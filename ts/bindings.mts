
import * as version from './version.mjs';
import { UInt5 } from './structs/CommonBase.mjs';

const imports: any = {};
imports.env = {};

var js_objs: Array<WeakRef<object>> = [];
var js_invoke: Function;
var getRandomValues: Function;

imports.wasi_snapshot_preview1 = {
	"fd_write": (fd: number, iovec_array_ptr: number, iovec_array_len: number) => {
		// This should generally only be used to print panic messages
		console.log("FD_WRITE to " + fd + " in " + iovec_array_len + " chunks.");
		const ptr_len_view = new Uint32Array(wasm.memory.buffer, iovec_array_ptr, iovec_array_len * 2);
		for (var i = 0; i < iovec_array_len; i++) {
			const bytes_view = new Uint8Array(wasm.memory.buffer, ptr_len_view[i*2], ptr_len_view[i*2+1]);
			console.log(String.fromCharCode(...bytes_view));
		}
		return 0;
	},
	"fd_close": (_fd: number) => {
		// This is not generally called, but may be referenced in debug builds
		console.log("wasi_snapshot_preview1:fd_close");
		return 58; // Not Supported
	},
	"fd_seek": (_fd: number, _offset: bigint, _whence: number, _new_offset: number) => {
		// This is not generally called, but may be referenced in debug builds
		console.log("wasi_snapshot_preview1:fd_seek");
		return 58; // Not Supported
	},
	"random_get": (buf_ptr: number, buf_len: number) => {
		const buf = new Uint8Array(wasm.memory.buffer, buf_ptr, buf_len);
		getRandomValues(buf);
		return 0;
	},
	"environ_sizes_get": (environ_var_count_ptr: number, environ_len_ptr: number) => {
		// This is called before fd_write to format + print panic messages
		console.log("wasi_snapshot_preview1:environ_sizes_get");
		const out_count_view = new Uint32Array(wasm.memory.buffer, environ_var_count_ptr, 1);
		out_count_view[0] = 0;
		const out_len_view = new Uint32Array(wasm.memory.buffer, environ_len_ptr, 1);
		out_len_view[0] = 0;
		return 0;
	},
	"environ_get": (environ_ptr: number, environ_buf_ptr: number) => {
		// This is called before fd_write to format + print panic messages
		console.log("wasi_snapshot_preview1:environ_get");
		return 58; // Note supported - we said there were 0 environment entries!
	},
	"proc_exit" : () => {
		console.log("wasi_snapshot_preview1:proc_exit");
	},
};

var wasm: any = null;
let isWasmInitialized: boolean = false;

async function finishInitializeWasm(wasmInstance: WebAssembly.Instance) {
	if (typeof crypto === "undefined") {
		var crypto_import = (await import('crypto')).webcrypto;
		getRandomValues = crypto_import.getRandomValues.bind(crypto_import);
	} else {
		getRandomValues = crypto.getRandomValues.bind(crypto);
	}

	wasm = wasmInstance.exports;
	if (!wasm.test_bigint_pass_deadbeef0badf00d(BigInt("0xdeadbeef0badf00d"))) {
		throw new Error("Currently need BigInt-as-u64 support, try ----experimental-wasm-bigint");
	}

	if (decodeString(wasm.TS_get_lib_version_string()) !== version.get_ldk_java_bindings_version())
		throw new Error("Compiled LDK library and LDK class failes do not match");
	// Fetching the LDK versions from C also checks that the header and binaries match
	const c_bindings_ver: number = wasm.TS_get_ldk_c_bindings_version();
	const ldk_ver: number = wasm.TS_get_ldk_version();
	if (c_bindings_ver == 0)
		throw new Error("LDK version did not match the header we built against");
	if (ldk_ver == 0)
		throw new Error("LDK C bindings version did not match the header we built against");
	const c_bindings_version: string = decodeString(c_bindings_ver)
	const ldk_version: string = decodeString(ldk_ver);
	console.log("Loaded LDK-Java Bindings with LDK " + ldk_version + " and LDK-C-Bindings " + c_bindings_version);

	isWasmInitialized = true;
}

/* @internal */
export async function initializeWasmFromUint8Array(wasmBinary: Uint8Array) {
	imports.env["js_invoke_function"] = js_invoke;
	const { instance: wasmInstance } = await WebAssembly.instantiate(wasmBinary, imports);
	await finishInitializeWasm(wasmInstance);
}

/* @internal */
export async function initializeWasmFetch(uri: string) {
	const stream = fetch(uri);
	imports.env["js_invoke_function"] = js_invoke;
	const { instance: wasmInstance } = await WebAssembly.instantiateStreaming(stream, imports);
	await finishInitializeWasm(wasmInstance);
}
// WASM CODEC

/* @internal */
export function uint5ArrToBytes(inputArray: Array<UInt5>): Uint8Array {
	const arr = new Uint8Array(inputArray.length);
	for (var i = 0; i < inputArray.length; i++) {
		arr[i] = inputArray[i].getVal();
	}
	return arr;
}

/* @internal */
export function encodeUint8Array (inputArray: Uint8Array): number {
	const cArrayPointer = wasm.TS_malloc(inputArray.length + 4);
	const arrayLengthView = new Uint32Array(wasm.memory.buffer, cArrayPointer, 1);
	arrayLengthView[0] = inputArray.length;
	const arrayMemoryView = new Uint8Array(wasm.memory.buffer, cArrayPointer + 4, inputArray.length);
	arrayMemoryView.set(inputArray);
	return cArrayPointer;
}
/* @internal */
export function encodeUint32Array (inputArray: Uint32Array|Array<number>): number {
	const cArrayPointer = wasm.TS_malloc((inputArray.length + 1) * 4);
	const arrayMemoryView = new Uint32Array(wasm.memory.buffer, cArrayPointer, inputArray.length);
	arrayMemoryView.set(inputArray, 1);
	arrayMemoryView[0] = inputArray.length;
	return cArrayPointer;
}
/* @internal */
export function encodeUint64Array (inputArray: BigUint64Array|Array<bigint>): number {
	const cArrayPointer = wasm.TS_malloc(inputArray.length * 8 + 1);
	const arrayLengthView = new Uint32Array(wasm.memory.buffer, cArrayPointer, 1);
	arrayLengthView[0] = inputArray.length;
	const arrayMemoryView = new BigUint64Array(wasm.memory.buffer, cArrayPointer + 4, inputArray.length);
	arrayMemoryView.set(inputArray);
	return cArrayPointer;
}

/* @internal */
export function check_arr_len(arr: Uint8Array, len: number): Uint8Array {
	if (arr.length != len) { throw new Error("Expected array of length " + len + "got " + arr.length); }
	return arr;
}

/* @internal */
export function getArrayLength(arrayPointer: number): number {
	const arraySizeViewer = new Uint32Array(wasm.memory.buffer, arrayPointer, 1);
	return arraySizeViewer[0];
}
/* @internal */
export function decodeUint8Array (arrayPointer: number, free = true): Uint8Array {
	const arraySize = getArrayLength(arrayPointer);
	const actualArrayViewer = new Uint8Array(wasm.memory.buffer, arrayPointer + 4, arraySize);
	// Clone the contents, TODO: In the future we should wrap the Viewer in a class that
	// will free the underlying memory when it becomes unreachable instead of copying here.
	// Note that doing so may have edge-case interactions with memory resizing (invalidating the buffer).
	const actualArray = actualArrayViewer.slice(0, arraySize);
	if (free) {
		wasm.TS_free(arrayPointer);
	}
	return actualArray;
}
const decodeUint32Array = (arrayPointer: number, free = true) => {
	const arraySize = getArrayLength(arrayPointer);
	const actualArrayViewer = new Uint32Array(
		wasm.memory.buffer, // value
		arrayPointer + 4, // offset (ignoring length bytes)
		arraySize // uint32 count
	);
	// Clone the contents, TODO: In the future we should wrap the Viewer in a class that
	// will free the underlying memory when it becomes unreachable instead of copying here.
	const actualArray = actualArrayViewer.slice(0, arraySize);
	if (free) {
		wasm.TS_free(arrayPointer);
	}
	return actualArray;
}


export function freeWasmMemory(pointer: number) { wasm.TS_free(pointer); }

/* @internal */
export function getU32ArrayElem(arrayPointer: number, idx: number): number {
	const actualArrayViewer = new Uint32Array(wasm.memory.buffer, arrayPointer + 4, idx + 1);
	return actualArrayViewer[idx];
}

/* @internal */
export function getU8ArrayElem(arrayPointer: number, idx: number): number {
	const actualArrayViewer = new Uint8Array(wasm.memory.buffer, arrayPointer + 4, idx + 1);
	return actualArrayViewer[idx];
}


/* @internal */
export function encodeString(str: string): number {
	const charArray = new TextEncoder().encode(str);
	return encodeUint8Array(charArray);
}

/* @internal */
export function decodeString(stringPointer: number, free = true): string {
	const arraySize = getArrayLength(stringPointer);
	const memoryView = new Uint8Array(wasm.memory.buffer, stringPointer + 4, arraySize);
	const result = new TextDecoder("utf-8").decode(memoryView);

	if (free) {
		wasm.TS_free(stringPointer);
	}

	return result;
}

/* @internal */ export function getRemainingAllocationCount(): number { return 0; }
/* @internal */ export function debugPrintRemainingAllocs() { }

/* @internal */
export enum AccessError {
	/**
	 * The requested chain is unknown.
	 */
	LDKAccessError_UnknownChain,
	/**
	 * The requested transaction doesn't exist or hasn't confirmed.
	 */
	LDKAccessError_UnknownTx,
	
}

/* @internal */
export enum COption_NoneZ {
	/**
	 * When we're in this state, this COption_NoneZ contains a
	 */
	LDKCOption_NoneZ_Some,
	/**
	 * When we're in this state, this COption_NoneZ contains nothing
	 */
	LDKCOption_NoneZ_None,
	
}

/* @internal */
export enum ChannelMonitorUpdateErr {
	/**
	 * Used to indicate a temporary failure (eg connection to a watchtower or remote backup of
	our state failed, but is expected to succeed at some point in the future).
	
	Such a failure will \"freeze\" a channel, preventing us from revoking old states or
	submitting new commitment transactions to the counterparty. Once the update(s) that failed
	have been successfully applied, a [`MonitorEvent::UpdateCompleted`] event should be returned
	via [`Watch::release_pending_monitor_events`] which will then restore the channel to an
	operational state.
	
	Note that a given ChannelManager will *never* re-generate a given ChannelMonitorUpdate. If
	you return a TemporaryFailure you must ensure that it is written to disk safely before
	writing out the latest ChannelManager state.
	
	Even when a channel has been \"frozen\" updates to the ChannelMonitor can continue to occur
	(eg if an inbound HTLC which we forwarded was claimed upstream resulting in us attempting
	to claim it on this channel) and those updates must be applied wherever they can be. At
	least one such updated ChannelMonitor must be persisted otherwise PermanentFailure should
	be returned to get things on-chain ASAP using only the in-memory copy. Obviously updates to
	the channel which would invalidate previous ChannelMonitors are not made when a channel has
	been \"frozen\".
	
	Note that even if updates made after TemporaryFailure succeed you must still provide a
	[`MonitorEvent::UpdateCompleted`] to ensure you have the latest monitor and re-enable
	normal channel operation. Note that this is normally generated through a call to
	[`ChainMonitor::channel_monitor_updated`].
	
	Note that the update being processed here will not be replayed for you when you return a
	[`MonitorEvent::UpdateCompleted`] event via [`Watch::release_pending_monitor_events`], so
	you must store the update itself on your own local disk prior to returning a
	TemporaryFailure. You may, of course, employ a journaling approach, storing only the
	ChannelMonitorUpdate on disk without updating the monitor itself, replaying the journal at
	reload-time.
	
	For deployments where a copy of ChannelMonitors and other local state are backed up in a
	remote location (with local copies persisted immediately), it is anticipated that all
	updates will return TemporaryFailure until the remote copies could be updated.
	
	[`ChainMonitor::channel_monitor_updated`]: chainmonitor::ChainMonitor::channel_monitor_updated
	 */
	LDKChannelMonitorUpdateErr_TemporaryFailure,
	/**
	 * Used to indicate no further channel monitor updates will be allowed (eg we've moved on to a
	different watchtower and cannot update with all watchtowers that were previously informed
	of this channel).
	
	At reception of this error, ChannelManager will force-close the channel and return at
	least a final ChannelMonitorUpdate::ChannelForceClosed which must be delivered to at
	least one ChannelMonitor copy. Revocation secret MUST NOT be released and offchain channel
	update must be rejected.
	
	This failure may also signal a failure to update the local persisted copy of one of
	the channel monitor instance.
	
	Note that even when you fail a holder commitment transaction update, you must store the
	update to ensure you can claim from it in case of a duplicate copy of this ChannelMonitor
	broadcasts it (e.g distributed channel-monitor deployment)
	
	In case of distributed watchtowers deployment, the new version must be written to disk, as
	state may have been stored but rejected due to a block forcing a commitment broadcast. This
	storage is used to claim outputs of rejected state confirmed onchain by another watchtower,
	lagging behind on block processing.
	 */
	LDKChannelMonitorUpdateErr_PermanentFailure,
	
}

/* @internal */
export enum ConfirmationTarget {
	/**
	 * We are happy with this transaction confirming slowly when feerate drops some.
	 */
	LDKConfirmationTarget_Background,
	/**
	 * We'd like this transaction to confirm without major delay, but 12-18 blocks is fine.
	 */
	LDKConfirmationTarget_Normal,
	/**
	 * We'd like this transaction to confirm in the next few blocks.
	 */
	LDKConfirmationTarget_HighPriority,
	
}

/* @internal */
export enum CreationError {
	/**
	 * The supplied description string was longer than 639 __bytes__ (see [`Description::new(...)`](./struct.Description.html#method.new))
	 */
	LDKCreationError_DescriptionTooLong,
	/**
	 * The specified route has too many hops and can't be encoded
	 */
	LDKCreationError_RouteTooLong,
	/**
	 * The Unix timestamp of the supplied date is less than zero or greater than 35-bits
	 */
	LDKCreationError_TimestampOutOfBounds,
	/**
	 * The supplied millisatoshi amount was greater than the total bitcoin supply.
	 */
	LDKCreationError_InvalidAmount,
	/**
	 * Route hints were required for this invoice and were missing. Applies to
	[phantom invoices].
	
	[phantom invoices]: crate::utils::create_phantom_invoice
	 */
	LDKCreationError_MissingRouteHints,
	
}

/* @internal */
export enum Currency {
	/**
	 * Bitcoin mainnet
	 */
	LDKCurrency_Bitcoin,
	/**
	 * Bitcoin testnet
	 */
	LDKCurrency_BitcoinTestnet,
	/**
	 * Bitcoin regtest
	 */
	LDKCurrency_Regtest,
	/**
	 * Bitcoin simnet
	 */
	LDKCurrency_Simnet,
	/**
	 * Bitcoin signet
	 */
	LDKCurrency_Signet,
	
}

/* @internal */
export enum Level {
	/**
	 * Designates extremely verbose information, including gossip-induced messages
	 */
	LDKLevel_Gossip,
	/**
	 * Designates very low priority, often extremely verbose, information
	 */
	LDKLevel_Trace,
	/**
	 * Designates lower priority information
	 */
	LDKLevel_Debug,
	/**
	 * Designates useful information
	 */
	LDKLevel_Info,
	/**
	 * Designates hazardous situations
	 */
	LDKLevel_Warn,
	/**
	 * Designates very serious errors
	 */
	LDKLevel_Error,
	
}

/* @internal */
export enum Network {
	/**
	 * The main Bitcoin blockchain.
	 */
	LDKNetwork_Bitcoin,
	/**
	 * The testnet3 blockchain.
	 */
	LDKNetwork_Testnet,
	/**
	 * A local test blockchain.
	 */
	LDKNetwork_Regtest,
	/**
	 * A blockchain on which blocks are signed instead of mined.
	 */
	LDKNetwork_Signet,
	
}

/* @internal */
export enum Recipient {
	/**
	 * The invoice should be signed with the local node secret key.
	 */
	LDKRecipient_Node,
	/**
	 * The invoice should be signed with the phantom node secret key. This secret key must be the
	same for all nodes participating in the [phantom node payment].
	
	[phantom node payment]: PhantomKeysManager
	 */
	LDKRecipient_PhantomNode,
	
}

/* @internal */
export enum Secp256k1Error {
	/**
	 * Signature failed verification
	 */
	LDKSecp256k1Error_IncorrectSignature,
	/**
	 * Badly sized message ("messages" are actually fixed-sized digests; see the MESSAGE_SIZE constant)
	 */
	LDKSecp256k1Error_InvalidMessage,
	/**
	 * Bad public key
	 */
	LDKSecp256k1Error_InvalidPublicKey,
	/**
	 * Bad signature
	 */
	LDKSecp256k1Error_InvalidSignature,
	/**
	 * Bad secret key
	 */
	LDKSecp256k1Error_InvalidSecretKey,
	/**
	 * Bad recovery id
	 */
	LDKSecp256k1Error_InvalidRecoveryId,
	/**
	 * Invalid tweak for add_assign or mul_assign
	 */
	LDKSecp256k1Error_InvalidTweak,
	/**
	 * tweak_add_check failed on an xonly public key
	 */
	LDKSecp256k1Error_TweakCheckFailed,
	/**
	 * Didn't pass enough memory to context creation with preallocated memory
	 */
	LDKSecp256k1Error_NotEnoughMemory,
	
}

/* @internal */
export enum SemanticError {
	/**
	 * The invoice is missing the mandatory payment hash
	 */
	LDKSemanticError_NoPaymentHash,
	/**
	 * The invoice has multiple payment hashes which isn't allowed
	 */
	LDKSemanticError_MultiplePaymentHashes,
	/**
	 * No description or description hash are part of the invoice
	 */
	LDKSemanticError_NoDescription,
	/**
	 * The invoice contains multiple descriptions and/or description hashes which isn't allowed
	 */
	LDKSemanticError_MultipleDescriptions,
	/**
	 * The invoice is missing the mandatory payment secret, which all modern lightning nodes
	should provide.
	 */
	LDKSemanticError_NoPaymentSecret,
	/**
	 * The invoice contains multiple payment secrets
	 */
	LDKSemanticError_MultiplePaymentSecrets,
	/**
	 * The invoice's features are invalid
	 */
	LDKSemanticError_InvalidFeatures,
	/**
	 * The recovery id doesn't fit the signature/pub key
	 */
	LDKSemanticError_InvalidRecoveryId,
	/**
	 * The invoice's signature is invalid
	 */
	LDKSemanticError_InvalidSignature,
	/**
	 * The invoice's amount was not a whole number of millisatoshis
	 */
	LDKSemanticError_ImpreciseAmount,
	
}

/* @internal */
export enum SiPrefix {
	/**
	 * 10^-3
	 */
	LDKSiPrefix_Milli,
	/**
	 * 10^-6
	 */
	LDKSiPrefix_Micro,
	/**
	 * 10^-9
	 */
	LDKSiPrefix_Nano,
	/**
	 * 10^-12
	 */
	LDKSiPrefix_Pico,
	
}
/* @internal */
export class LDKBech32Error {
	protected constructor() {}
}
/* @internal */
export function LDKBech32Error_ty_from_ptr(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKBech32Error_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKBech32Error_InvalidChar_get_invalid_char(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKBech32Error_InvalidChar_get_invalid_char(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKBech32Error_InvalidData_get_invalid_data(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKBech32Error_InvalidData_get_invalid_data(ptr);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z TxOut_get_script_pubkey (struct LDKTxOut* thing)
/* @internal */
export function TxOut_get_script_pubkey(thing: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxOut_get_script_pubkey(thing);
	return nativeResponseValue;
}
	// uint64_t TxOut_get_value (struct LDKTxOut* thing)
/* @internal */
export function TxOut_get_value(thing: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxOut_get_value(thing);
	return nativeResponseValue;
}
	// void CResult_NoneNoneZ_get_ok(LDKCResult_NoneNoneZ *NONNULL_PTR owner);
/* @internal */
export function CResult_NoneNoneZ_get_ok(owner: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneNoneZ_get_ok(owner);
	// debug statements here
}
	// void CResult_NoneNoneZ_get_err(LDKCResult_NoneNoneZ *NONNULL_PTR owner);
/* @internal */
export function CResult_NoneNoneZ_get_err(owner: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneNoneZ_get_err(owner);
	// debug statements here
}
	// struct LDKCounterpartyCommitmentSecrets CResult_CounterpartyCommitmentSecretsDecodeErrorZ_get_ok(LDKCResult_CounterpartyCommitmentSecretsDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_CounterpartyCommitmentSecretsDecodeErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CounterpartyCommitmentSecretsDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_CounterpartyCommitmentSecretsDecodeErrorZ_get_err(LDKCResult_CounterpartyCommitmentSecretsDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_CounterpartyCommitmentSecretsDecodeErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CounterpartyCommitmentSecretsDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKSecretKey CResult_SecretKeyErrorZ_get_ok(LDKCResult_SecretKeyErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_SecretKeyErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SecretKeyErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// enum LDKSecp256k1Error CResult_SecretKeyErrorZ_get_err(LDKCResult_SecretKeyErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_SecretKeyErrorZ_get_err(owner: number): Secp256k1Error {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SecretKeyErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKPublicKey CResult_PublicKeyErrorZ_get_ok(LDKCResult_PublicKeyErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_PublicKeyErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PublicKeyErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// enum LDKSecp256k1Error CResult_PublicKeyErrorZ_get_err(LDKCResult_PublicKeyErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_PublicKeyErrorZ_get_err(owner: number): Secp256k1Error {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PublicKeyErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKTxCreationKeys CResult_TxCreationKeysDecodeErrorZ_get_ok(LDKCResult_TxCreationKeysDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_TxCreationKeysDecodeErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxCreationKeysDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_TxCreationKeysDecodeErrorZ_get_err(LDKCResult_TxCreationKeysDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_TxCreationKeysDecodeErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxCreationKeysDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKChannelPublicKeys CResult_ChannelPublicKeysDecodeErrorZ_get_ok(LDKCResult_ChannelPublicKeysDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ChannelPublicKeysDecodeErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelPublicKeysDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_ChannelPublicKeysDecodeErrorZ_get_err(LDKCResult_ChannelPublicKeysDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ChannelPublicKeysDecodeErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelPublicKeysDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKTxCreationKeys CResult_TxCreationKeysErrorZ_get_ok(LDKCResult_TxCreationKeysErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_TxCreationKeysErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxCreationKeysErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// enum LDKSecp256k1Error CResult_TxCreationKeysErrorZ_get_err(LDKCResult_TxCreationKeysErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_TxCreationKeysErrorZ_get_err(owner: number): Secp256k1Error {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxCreationKeysErrorZ_get_err(owner);
	return nativeResponseValue;
}
/* @internal */
export class LDKCOption_u32Z {
	protected constructor() {}
}
/* @internal */
export function LDKCOption_u32Z_ty_from_ptr(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_u32Z_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKCOption_u32Z_Some_get_some(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_u32Z_Some_get_some(ptr);
	return nativeResponseValue;
}
	// struct LDKHTLCOutputInCommitment CResult_HTLCOutputInCommitmentDecodeErrorZ_get_ok(LDKCResult_HTLCOutputInCommitmentDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_HTLCOutputInCommitmentDecodeErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_HTLCOutputInCommitmentDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_HTLCOutputInCommitmentDecodeErrorZ_get_err(LDKCResult_HTLCOutputInCommitmentDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_HTLCOutputInCommitmentDecodeErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_HTLCOutputInCommitmentDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKCounterpartyChannelTransactionParameters CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_get_ok(LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_get_err(LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKChannelTransactionParameters CResult_ChannelTransactionParametersDecodeErrorZ_get_ok(LDKCResult_ChannelTransactionParametersDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ChannelTransactionParametersDecodeErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelTransactionParametersDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_ChannelTransactionParametersDecodeErrorZ_get_err(LDKCResult_ChannelTransactionParametersDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ChannelTransactionParametersDecodeErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelTransactionParametersDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKHolderCommitmentTransaction CResult_HolderCommitmentTransactionDecodeErrorZ_get_ok(LDKCResult_HolderCommitmentTransactionDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_HolderCommitmentTransactionDecodeErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_HolderCommitmentTransactionDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_HolderCommitmentTransactionDecodeErrorZ_get_err(LDKCResult_HolderCommitmentTransactionDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_HolderCommitmentTransactionDecodeErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_HolderCommitmentTransactionDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKBuiltCommitmentTransaction CResult_BuiltCommitmentTransactionDecodeErrorZ_get_ok(LDKCResult_BuiltCommitmentTransactionDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_BuiltCommitmentTransactionDecodeErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_BuiltCommitmentTransactionDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_BuiltCommitmentTransactionDecodeErrorZ_get_err(LDKCResult_BuiltCommitmentTransactionDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_BuiltCommitmentTransactionDecodeErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_BuiltCommitmentTransactionDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKTrustedClosingTransaction *CResult_TrustedClosingTransactionNoneZ_get_ok(LDKCResult_TrustedClosingTransactionNoneZ *NONNULL_PTR owner);
/* @internal */
export function CResult_TrustedClosingTransactionNoneZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TrustedClosingTransactionNoneZ_get_ok(owner);
	return nativeResponseValue;
}
	// void CResult_TrustedClosingTransactionNoneZ_get_err(LDKCResult_TrustedClosingTransactionNoneZ *NONNULL_PTR owner);
/* @internal */
export function CResult_TrustedClosingTransactionNoneZ_get_err(owner: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TrustedClosingTransactionNoneZ_get_err(owner);
	// debug statements here
}
	// struct LDKCommitmentTransaction CResult_CommitmentTransactionDecodeErrorZ_get_ok(LDKCResult_CommitmentTransactionDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_CommitmentTransactionDecodeErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CommitmentTransactionDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_CommitmentTransactionDecodeErrorZ_get_err(LDKCResult_CommitmentTransactionDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_CommitmentTransactionDecodeErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CommitmentTransactionDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKTrustedCommitmentTransaction *CResult_TrustedCommitmentTransactionNoneZ_get_ok(LDKCResult_TrustedCommitmentTransactionNoneZ *NONNULL_PTR owner);
/* @internal */
export function CResult_TrustedCommitmentTransactionNoneZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TrustedCommitmentTransactionNoneZ_get_ok(owner);
	return nativeResponseValue;
}
	// void CResult_TrustedCommitmentTransactionNoneZ_get_err(LDKCResult_TrustedCommitmentTransactionNoneZ *NONNULL_PTR owner);
/* @internal */
export function CResult_TrustedCommitmentTransactionNoneZ_get_err(owner: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TrustedCommitmentTransactionNoneZ_get_err(owner);
	// debug statements here
}
	// struct LDKCVec_SignatureZ CResult_CVec_SignatureZNoneZ_get_ok(LDKCResult_CVec_SignatureZNoneZ *NONNULL_PTR owner);
/* @internal */
export function CResult_CVec_SignatureZNoneZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CVec_SignatureZNoneZ_get_ok(owner);
	return nativeResponseValue;
}
	// void CResult_CVec_SignatureZNoneZ_get_err(LDKCResult_CVec_SignatureZNoneZ *NONNULL_PTR owner);
/* @internal */
export function CResult_CVec_SignatureZNoneZ_get_err(owner: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CVec_SignatureZNoneZ_get_err(owner);
	// debug statements here
}
	// struct LDKShutdownScript CResult_ShutdownScriptDecodeErrorZ_get_ok(LDKCResult_ShutdownScriptDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ShutdownScriptDecodeErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ShutdownScriptDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_ShutdownScriptDecodeErrorZ_get_err(LDKCResult_ShutdownScriptDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ShutdownScriptDecodeErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ShutdownScriptDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKShutdownScript CResult_ShutdownScriptInvalidShutdownScriptZ_get_ok(LDKCResult_ShutdownScriptInvalidShutdownScriptZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ShutdownScriptInvalidShutdownScriptZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ShutdownScriptInvalidShutdownScriptZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKInvalidShutdownScript CResult_ShutdownScriptInvalidShutdownScriptZ_get_err(LDKCResult_ShutdownScriptInvalidShutdownScriptZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ShutdownScriptInvalidShutdownScriptZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ShutdownScriptInvalidShutdownScriptZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKRouteHop CResult_RouteHopDecodeErrorZ_get_ok(LDKCResult_RouteHopDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_RouteHopDecodeErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteHopDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_RouteHopDecodeErrorZ_get_err(LDKCResult_RouteHopDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_RouteHopDecodeErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteHopDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKRoute CResult_RouteDecodeErrorZ_get_ok(LDKCResult_RouteDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_RouteDecodeErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_RouteDecodeErrorZ_get_err(LDKCResult_RouteDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_RouteDecodeErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKRouteParameters CResult_RouteParametersDecodeErrorZ_get_ok(LDKCResult_RouteParametersDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_RouteParametersDecodeErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteParametersDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_RouteParametersDecodeErrorZ_get_err(LDKCResult_RouteParametersDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_RouteParametersDecodeErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteParametersDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
/* @internal */
export class LDKCOption_u64Z {
	protected constructor() {}
}
/* @internal */
export function LDKCOption_u64Z_ty_from_ptr(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_u64Z_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKCOption_u64Z_Some_get_some(ptr: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_u64Z_Some_get_some(ptr);
	return nativeResponseValue;
}
	// struct LDKPaymentParameters CResult_PaymentParametersDecodeErrorZ_get_ok(LDKCResult_PaymentParametersDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_PaymentParametersDecodeErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentParametersDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_PaymentParametersDecodeErrorZ_get_err(LDKCResult_PaymentParametersDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_PaymentParametersDecodeErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentParametersDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKRouteHint CResult_RouteHintDecodeErrorZ_get_ok(LDKCResult_RouteHintDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_RouteHintDecodeErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteHintDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_RouteHintDecodeErrorZ_get_err(LDKCResult_RouteHintDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_RouteHintDecodeErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteHintDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKRouteHintHop CResult_RouteHintHopDecodeErrorZ_get_ok(LDKCResult_RouteHintHopDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_RouteHintHopDecodeErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteHintHopDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_RouteHintHopDecodeErrorZ_get_err(LDKCResult_RouteHintHopDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_RouteHintHopDecodeErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteHintHopDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKRoute CResult_RouteLightningErrorZ_get_ok(LDKCResult_RouteLightningErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_RouteLightningErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteLightningErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKLightningError CResult_RouteLightningErrorZ_get_err(LDKCResult_RouteLightningErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_RouteLightningErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteLightningErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKTxOut CResult_TxOutAccessErrorZ_get_ok(LDKCResult_TxOutAccessErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_TxOutAccessErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxOutAccessErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// enum LDKAccessError CResult_TxOutAccessErrorZ_get_err(LDKCResult_TxOutAccessErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_TxOutAccessErrorZ_get_err(owner: number): AccessError {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxOutAccessErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// uintptr_t C2Tuple_usizeTransactionZ_get_a(LDKC2Tuple_usizeTransactionZ *NONNULL_PTR owner);
/* @internal */
export function C2Tuple_usizeTransactionZ_get_a(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_usizeTransactionZ_get_a(owner);
	return nativeResponseValue;
}
	// struct LDKTransaction C2Tuple_usizeTransactionZ_get_b(LDKC2Tuple_usizeTransactionZ *NONNULL_PTR owner);
/* @internal */
export function C2Tuple_usizeTransactionZ_get_b(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_usizeTransactionZ_get_b(owner);
	return nativeResponseValue;
}
	// void CResult_NoneChannelMonitorUpdateErrZ_get_ok(LDKCResult_NoneChannelMonitorUpdateErrZ *NONNULL_PTR owner);
/* @internal */
export function CResult_NoneChannelMonitorUpdateErrZ_get_ok(owner: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneChannelMonitorUpdateErrZ_get_ok(owner);
	// debug statements here
}
	// enum LDKChannelMonitorUpdateErr CResult_NoneChannelMonitorUpdateErrZ_get_err(LDKCResult_NoneChannelMonitorUpdateErrZ *NONNULL_PTR owner);
/* @internal */
export function CResult_NoneChannelMonitorUpdateErrZ_get_err(owner: number): ChannelMonitorUpdateErr {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneChannelMonitorUpdateErrZ_get_err(owner);
	return nativeResponseValue;
}
/* @internal */
export class LDKMonitorEvent {
	protected constructor() {}
}
/* @internal */
export function LDKMonitorEvent_ty_from_ptr(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMonitorEvent_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMonitorEvent_HTLCEvent_get_htlc_event(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMonitorEvent_HTLCEvent_get_htlc_event(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMonitorEvent_CommitmentTxConfirmed_get_commitment_tx_confirmed(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMonitorEvent_CommitmentTxConfirmed_get_commitment_tx_confirmed(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMonitorEvent_UpdateCompleted_get_funding_txo(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMonitorEvent_UpdateCompleted_get_funding_txo(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMonitorEvent_UpdateCompleted_get_monitor_update_id(ptr: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMonitorEvent_UpdateCompleted_get_monitor_update_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMonitorEvent_UpdateFailed_get_update_failed(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMonitorEvent_UpdateFailed_get_update_failed(ptr);
	return nativeResponseValue;
}
/* @internal */
export class LDKCOption_C2Tuple_usizeTransactionZZ {
	protected constructor() {}
}
/* @internal */
export function LDKCOption_C2Tuple_usizeTransactionZZ_ty_from_ptr(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_C2Tuple_usizeTransactionZZ_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKCOption_C2Tuple_usizeTransactionZZ_Some_get_some(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_C2Tuple_usizeTransactionZZ_Some_get_some(ptr);
	return nativeResponseValue;
}
/* @internal */
export class LDKClosureReason {
	protected constructor() {}
}
/* @internal */
export function LDKClosureReason_ty_from_ptr(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKClosureReason_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKClosureReason_CounterpartyForceClosed_get_peer_msg(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKClosureReason_CounterpartyForceClosed_get_peer_msg(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKClosureReason_ProcessingError_get_err(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKClosureReason_ProcessingError_get_err(ptr);
	return nativeResponseValue;
}
/* @internal */
export class LDKCOption_ClosureReasonZ {
	protected constructor() {}
}
/* @internal */
export function LDKCOption_ClosureReasonZ_ty_from_ptr(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_ClosureReasonZ_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKCOption_ClosureReasonZ_Some_get_some(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_ClosureReasonZ_Some_get_some(ptr);
	return nativeResponseValue;
}
	// struct LDKCOption_ClosureReasonZ CResult_COption_ClosureReasonZDecodeErrorZ_get_ok(LDKCResult_COption_ClosureReasonZDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_COption_ClosureReasonZDecodeErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_ClosureReasonZDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_COption_ClosureReasonZDecodeErrorZ_get_err(LDKCResult_COption_ClosureReasonZDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_COption_ClosureReasonZDecodeErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_ClosureReasonZDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
/* @internal */
export class LDKNetworkUpdate {
	protected constructor() {}
}
/* @internal */
export function LDKNetworkUpdate_ty_from_ptr(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKNetworkUpdate_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKNetworkUpdate_ChannelUpdateMessage_get_msg(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKNetworkUpdate_ChannelUpdateMessage_get_msg(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKNetworkUpdate_ChannelClosed_get_short_channel_id(ptr: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKNetworkUpdate_ChannelClosed_get_short_channel_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKNetworkUpdate_ChannelClosed_get_is_permanent(ptr: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKNetworkUpdate_ChannelClosed_get_is_permanent(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKNetworkUpdate_NodeFailure_get_node_id(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKNetworkUpdate_NodeFailure_get_node_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKNetworkUpdate_NodeFailure_get_is_permanent(ptr: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKNetworkUpdate_NodeFailure_get_is_permanent(ptr);
	return nativeResponseValue;
}
/* @internal */
export class LDKCOption_NetworkUpdateZ {
	protected constructor() {}
}
/* @internal */
export function LDKCOption_NetworkUpdateZ_ty_from_ptr(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_NetworkUpdateZ_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKCOption_NetworkUpdateZ_Some_get_some(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_NetworkUpdateZ_Some_get_some(ptr);
	return nativeResponseValue;
}
/* @internal */
export class LDKSpendableOutputDescriptor {
	protected constructor() {}
}
/* @internal */
export function LDKSpendableOutputDescriptor_ty_from_ptr(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKSpendableOutputDescriptor_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKSpendableOutputDescriptor_StaticOutput_get_outpoint(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKSpendableOutputDescriptor_StaticOutput_get_outpoint(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKSpendableOutputDescriptor_StaticOutput_get_output(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKSpendableOutputDescriptor_StaticOutput_get_output(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKSpendableOutputDescriptor_DelayedPaymentOutput_get_delayed_payment_output(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKSpendableOutputDescriptor_DelayedPaymentOutput_get_delayed_payment_output(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKSpendableOutputDescriptor_StaticPaymentOutput_get_static_payment_output(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKSpendableOutputDescriptor_StaticPaymentOutput_get_static_payment_output(ptr);
	return nativeResponseValue;
}
/* @internal */
export class LDKPaymentPurpose {
	protected constructor() {}
}
/* @internal */
export function LDKPaymentPurpose_ty_from_ptr(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKPaymentPurpose_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKPaymentPurpose_InvoicePayment_get_payment_preimage(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKPaymentPurpose_InvoicePayment_get_payment_preimage(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKPaymentPurpose_InvoicePayment_get_payment_secret(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKPaymentPurpose_InvoicePayment_get_payment_secret(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKPaymentPurpose_SpontaneousPayment_get_spontaneous_payment(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKPaymentPurpose_SpontaneousPayment_get_spontaneous_payment(ptr);
	return nativeResponseValue;
}
/* @internal */
export class LDKEvent {
	protected constructor() {}
}
/* @internal */
export function LDKEvent_ty_from_ptr(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_FundingGenerationReady_get_temporary_channel_id(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_FundingGenerationReady_get_temporary_channel_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_FundingGenerationReady_get_channel_value_satoshis(ptr: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_FundingGenerationReady_get_channel_value_satoshis(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_FundingGenerationReady_get_output_script(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_FundingGenerationReady_get_output_script(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_FundingGenerationReady_get_user_channel_id(ptr: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_FundingGenerationReady_get_user_channel_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_PaymentReceived_get_payment_hash(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_PaymentReceived_get_payment_hash(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_PaymentReceived_get_amt(ptr: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_PaymentReceived_get_amt(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_PaymentReceived_get_purpose(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_PaymentReceived_get_purpose(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_PaymentSent_get_payment_id(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_PaymentSent_get_payment_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_PaymentSent_get_payment_preimage(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_PaymentSent_get_payment_preimage(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_PaymentSent_get_payment_hash(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_PaymentSent_get_payment_hash(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_PaymentSent_get_fee_paid_msat(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_PaymentSent_get_fee_paid_msat(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_PaymentPathFailed_get_payment_id(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_PaymentPathFailed_get_payment_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_PaymentPathFailed_get_payment_hash(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_PaymentPathFailed_get_payment_hash(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_PaymentPathFailed_get_rejected_by_dest(ptr: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_PaymentPathFailed_get_rejected_by_dest(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_PaymentPathFailed_get_network_update(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_PaymentPathFailed_get_network_update(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_PaymentPathFailed_get_all_paths_failed(ptr: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_PaymentPathFailed_get_all_paths_failed(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_PaymentPathFailed_get_path(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_PaymentPathFailed_get_path(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_PaymentPathFailed_get_short_channel_id(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_PaymentPathFailed_get_short_channel_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_PaymentPathFailed_get_retry(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_PaymentPathFailed_get_retry(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_PaymentFailed_get_payment_id(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_PaymentFailed_get_payment_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_PaymentFailed_get_payment_hash(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_PaymentFailed_get_payment_hash(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_PendingHTLCsForwardable_get_time_forwardable(ptr: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_PendingHTLCsForwardable_get_time_forwardable(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_SpendableOutputs_get_outputs(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_SpendableOutputs_get_outputs(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_PaymentForwarded_get_fee_earned_msat(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_PaymentForwarded_get_fee_earned_msat(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_PaymentForwarded_get_claim_from_onchain_tx(ptr: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_PaymentForwarded_get_claim_from_onchain_tx(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_ChannelClosed_get_channel_id(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_ChannelClosed_get_channel_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_ChannelClosed_get_user_channel_id(ptr: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_ChannelClosed_get_user_channel_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_ChannelClosed_get_reason(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_ChannelClosed_get_reason(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_DiscardFunding_get_channel_id(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_DiscardFunding_get_channel_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_DiscardFunding_get_transaction(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_DiscardFunding_get_transaction(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_PaymentPathSuccessful_get_payment_id(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_PaymentPathSuccessful_get_payment_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_PaymentPathSuccessful_get_payment_hash(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_PaymentPathSuccessful_get_payment_hash(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_PaymentPathSuccessful_get_path(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_PaymentPathSuccessful_get_path(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_OpenChannelRequest_get_temporary_channel_id(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_OpenChannelRequest_get_temporary_channel_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_OpenChannelRequest_get_counterparty_node_id(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_OpenChannelRequest_get_counterparty_node_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_OpenChannelRequest_get_funding_satoshis(ptr: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_OpenChannelRequest_get_funding_satoshis(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_OpenChannelRequest_get_push_msat(ptr: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_OpenChannelRequest_get_push_msat(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEvent_OpenChannelRequest_get_channel_type(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEvent_OpenChannelRequest_get_channel_type(ptr);
	return nativeResponseValue;
}
/* @internal */
export class LDKCOption_EventZ {
	protected constructor() {}
}
/* @internal */
export function LDKCOption_EventZ_ty_from_ptr(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_EventZ_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKCOption_EventZ_Some_get_some(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_EventZ_Some_get_some(ptr);
	return nativeResponseValue;
}
	// struct LDKCOption_EventZ CResult_COption_EventZDecodeErrorZ_get_ok(LDKCResult_COption_EventZDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_COption_EventZDecodeErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_EventZDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_COption_EventZDecodeErrorZ_get_err(LDKCResult_COption_EventZDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_COption_EventZDecodeErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_EventZDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
/* @internal */
export class LDKErrorAction {
	protected constructor() {}
}
/* @internal */
export function LDKErrorAction_ty_from_ptr(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKErrorAction_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKErrorAction_DisconnectPeer_get_msg(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKErrorAction_DisconnectPeer_get_msg(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKErrorAction_IgnoreAndLog_get_ignore_and_log(ptr: number): Level {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKErrorAction_IgnoreAndLog_get_ignore_and_log(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKErrorAction_SendErrorMessage_get_msg(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKErrorAction_SendErrorMessage_get_msg(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKErrorAction_SendWarningMessage_get_msg(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKErrorAction_SendWarningMessage_get_msg(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKErrorAction_SendWarningMessage_get_log_level(ptr: number): Level {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKErrorAction_SendWarningMessage_get_log_level(ptr);
	return nativeResponseValue;
}
/* @internal */
export class LDKMessageSendEvent {
	protected constructor() {}
}
/* @internal */
export function LDKMessageSendEvent_ty_from_ptr(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_SendAcceptChannel_get_node_id(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendAcceptChannel_get_node_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_SendAcceptChannel_get_msg(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendAcceptChannel_get_msg(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_SendOpenChannel_get_node_id(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendOpenChannel_get_node_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_SendOpenChannel_get_msg(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendOpenChannel_get_msg(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_SendFundingCreated_get_node_id(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendFundingCreated_get_node_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_SendFundingCreated_get_msg(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendFundingCreated_get_msg(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_SendFundingSigned_get_node_id(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendFundingSigned_get_node_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_SendFundingSigned_get_msg(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendFundingSigned_get_msg(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_SendFundingLocked_get_node_id(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendFundingLocked_get_node_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_SendFundingLocked_get_msg(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendFundingLocked_get_msg(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_SendAnnouncementSignatures_get_node_id(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendAnnouncementSignatures_get_node_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_SendAnnouncementSignatures_get_msg(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendAnnouncementSignatures_get_msg(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_UpdateHTLCs_get_node_id(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_UpdateHTLCs_get_node_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_UpdateHTLCs_get_updates(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_UpdateHTLCs_get_updates(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_SendRevokeAndACK_get_node_id(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendRevokeAndACK_get_node_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_SendRevokeAndACK_get_msg(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendRevokeAndACK_get_msg(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_SendClosingSigned_get_node_id(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendClosingSigned_get_node_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_SendClosingSigned_get_msg(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendClosingSigned_get_msg(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_SendShutdown_get_node_id(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendShutdown_get_node_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_SendShutdown_get_msg(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendShutdown_get_msg(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_SendChannelReestablish_get_node_id(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendChannelReestablish_get_node_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_SendChannelReestablish_get_msg(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendChannelReestablish_get_msg(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_BroadcastChannelAnnouncement_get_msg(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_BroadcastChannelAnnouncement_get_msg(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_BroadcastChannelAnnouncement_get_update_msg(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_BroadcastChannelAnnouncement_get_update_msg(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_BroadcastNodeAnnouncement_get_msg(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_BroadcastNodeAnnouncement_get_msg(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_BroadcastChannelUpdate_get_msg(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_BroadcastChannelUpdate_get_msg(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_SendChannelUpdate_get_node_id(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendChannelUpdate_get_node_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_SendChannelUpdate_get_msg(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendChannelUpdate_get_msg(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_HandleError_get_node_id(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_HandleError_get_node_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_HandleError_get_action(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_HandleError_get_action(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_SendChannelRangeQuery_get_node_id(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendChannelRangeQuery_get_node_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_SendChannelRangeQuery_get_msg(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendChannelRangeQuery_get_msg(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_SendShortIdsQuery_get_node_id(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendShortIdsQuery_get_node_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_SendShortIdsQuery_get_msg(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendShortIdsQuery_get_msg(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_SendReplyChannelRange_get_node_id(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendReplyChannelRange_get_node_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_SendReplyChannelRange_get_msg(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendReplyChannelRange_get_msg(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_SendGossipTimestampFilter_get_node_id(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendGossipTimestampFilter_get_node_id(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKMessageSendEvent_SendGossipTimestampFilter_get_msg(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKMessageSendEvent_SendGossipTimestampFilter_get_msg(ptr);
	return nativeResponseValue;
}
	// struct LDKFixedPenaltyScorer CResult_FixedPenaltyScorerDecodeErrorZ_get_ok(LDKCResult_FixedPenaltyScorerDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_FixedPenaltyScorerDecodeErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_FixedPenaltyScorerDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_FixedPenaltyScorerDecodeErrorZ_get_err(LDKCResult_FixedPenaltyScorerDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_FixedPenaltyScorerDecodeErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_FixedPenaltyScorerDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKScoringParameters CResult_ScoringParametersDecodeErrorZ_get_ok(LDKCResult_ScoringParametersDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ScoringParametersDecodeErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ScoringParametersDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_ScoringParametersDecodeErrorZ_get_err(LDKCResult_ScoringParametersDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ScoringParametersDecodeErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ScoringParametersDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKScorer *CResult_ScorerDecodeErrorZ_get_ok(LDKCResult_ScorerDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ScorerDecodeErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ScorerDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_ScorerDecodeErrorZ_get_err(LDKCResult_ScorerDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ScorerDecodeErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ScorerDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKProbabilisticScorer *CResult_ProbabilisticScorerDecodeErrorZ_get_ok(LDKCResult_ProbabilisticScorerDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ProbabilisticScorerDecodeErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ProbabilisticScorerDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_ProbabilisticScorerDecodeErrorZ_get_err(LDKCResult_ProbabilisticScorerDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ProbabilisticScorerDecodeErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ProbabilisticScorerDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKInitFeatures CResult_InitFeaturesDecodeErrorZ_get_ok(LDKCResult_InitFeaturesDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_InitFeaturesDecodeErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InitFeaturesDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_InitFeaturesDecodeErrorZ_get_err(LDKCResult_InitFeaturesDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_InitFeaturesDecodeErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InitFeaturesDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKChannelFeatures CResult_ChannelFeaturesDecodeErrorZ_get_ok(LDKCResult_ChannelFeaturesDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ChannelFeaturesDecodeErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelFeaturesDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_ChannelFeaturesDecodeErrorZ_get_err(LDKCResult_ChannelFeaturesDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ChannelFeaturesDecodeErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelFeaturesDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKNodeFeatures CResult_NodeFeaturesDecodeErrorZ_get_ok(LDKCResult_NodeFeaturesDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_NodeFeaturesDecodeErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NodeFeaturesDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_NodeFeaturesDecodeErrorZ_get_err(LDKCResult_NodeFeaturesDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_NodeFeaturesDecodeErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NodeFeaturesDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKInvoiceFeatures CResult_InvoiceFeaturesDecodeErrorZ_get_ok(LDKCResult_InvoiceFeaturesDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_InvoiceFeaturesDecodeErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InvoiceFeaturesDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_InvoiceFeaturesDecodeErrorZ_get_err(LDKCResult_InvoiceFeaturesDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_InvoiceFeaturesDecodeErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InvoiceFeaturesDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKChannelTypeFeatures CResult_ChannelTypeFeaturesDecodeErrorZ_get_ok(LDKCResult_ChannelTypeFeaturesDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ChannelTypeFeaturesDecodeErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelTypeFeaturesDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_ChannelTypeFeaturesDecodeErrorZ_get_err(LDKCResult_ChannelTypeFeaturesDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ChannelTypeFeaturesDecodeErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelTypeFeaturesDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKDelayedPaymentOutputDescriptor CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_get_ok(LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_get_err(LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKStaticPaymentOutputDescriptor CResult_StaticPaymentOutputDescriptorDecodeErrorZ_get_ok(LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_StaticPaymentOutputDescriptorDecodeErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_StaticPaymentOutputDescriptorDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_StaticPaymentOutputDescriptorDecodeErrorZ_get_err(LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_StaticPaymentOutputDescriptorDecodeErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_StaticPaymentOutputDescriptorDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKSpendableOutputDescriptor CResult_SpendableOutputDescriptorDecodeErrorZ_get_ok(LDKCResult_SpendableOutputDescriptorDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_SpendableOutputDescriptorDecodeErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SpendableOutputDescriptorDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_SpendableOutputDescriptorDecodeErrorZ_get_err(LDKCResult_SpendableOutputDescriptorDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_SpendableOutputDescriptorDecodeErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SpendableOutputDescriptorDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKSignature C2Tuple_SignatureCVec_SignatureZZ_get_a(LDKC2Tuple_SignatureCVec_SignatureZZ *NONNULL_PTR owner);
/* @internal */
export function C2Tuple_SignatureCVec_SignatureZZ_get_a(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_SignatureCVec_SignatureZZ_get_a(owner);
	return nativeResponseValue;
}
	// struct LDKCVec_SignatureZ C2Tuple_SignatureCVec_SignatureZZ_get_b(LDKC2Tuple_SignatureCVec_SignatureZZ *NONNULL_PTR owner);
/* @internal */
export function C2Tuple_SignatureCVec_SignatureZZ_get_b(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_SignatureCVec_SignatureZZ_get_b(owner);
	return nativeResponseValue;
}
	// struct LDKC2Tuple_SignatureCVec_SignatureZZ CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_get_ok(LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ *NONNULL_PTR owner);
/* @internal */
export function CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_get_ok(owner);
	return nativeResponseValue;
}
	// void CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_get_err(LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ *NONNULL_PTR owner);
/* @internal */
export function CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_get_err(owner: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_get_err(owner);
	// debug statements here
}
	// struct LDKSignature CResult_SignatureNoneZ_get_ok(LDKCResult_SignatureNoneZ *NONNULL_PTR owner);
/* @internal */
export function CResult_SignatureNoneZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SignatureNoneZ_get_ok(owner);
	return nativeResponseValue;
}
	// void CResult_SignatureNoneZ_get_err(LDKCResult_SignatureNoneZ *NONNULL_PTR owner);
/* @internal */
export function CResult_SignatureNoneZ_get_err(owner: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SignatureNoneZ_get_err(owner);
	// debug statements here
}
	// struct LDKSignature C2Tuple_SignatureSignatureZ_get_a(LDKC2Tuple_SignatureSignatureZ *NONNULL_PTR owner);
/* @internal */
export function C2Tuple_SignatureSignatureZ_get_a(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_SignatureSignatureZ_get_a(owner);
	return nativeResponseValue;
}
	// struct LDKSignature C2Tuple_SignatureSignatureZ_get_b(LDKC2Tuple_SignatureSignatureZ *NONNULL_PTR owner);
/* @internal */
export function C2Tuple_SignatureSignatureZ_get_b(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_SignatureSignatureZ_get_b(owner);
	return nativeResponseValue;
}
	// struct LDKC2Tuple_SignatureSignatureZ CResult_C2Tuple_SignatureSignatureZNoneZ_get_ok(LDKCResult_C2Tuple_SignatureSignatureZNoneZ *NONNULL_PTR owner);
/* @internal */
export function CResult_C2Tuple_SignatureSignatureZNoneZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_SignatureSignatureZNoneZ_get_ok(owner);
	return nativeResponseValue;
}
	// void CResult_C2Tuple_SignatureSignatureZNoneZ_get_err(LDKCResult_C2Tuple_SignatureSignatureZNoneZ *NONNULL_PTR owner);
/* @internal */
export function CResult_C2Tuple_SignatureSignatureZNoneZ_get_err(owner: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_SignatureSignatureZNoneZ_get_err(owner);
	// debug statements here
}
	// struct LDKSecretKey CResult_SecretKeyNoneZ_get_ok(LDKCResult_SecretKeyNoneZ *NONNULL_PTR owner);
/* @internal */
export function CResult_SecretKeyNoneZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SecretKeyNoneZ_get_ok(owner);
	return nativeResponseValue;
}
	// void CResult_SecretKeyNoneZ_get_err(LDKCResult_SecretKeyNoneZ *NONNULL_PTR owner);
/* @internal */
export function CResult_SecretKeyNoneZ_get_err(owner: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SecretKeyNoneZ_get_err(owner);
	// debug statements here
}
/* @internal */
export interface LDKBaseSign {
	get_per_commitment_point (idx: bigint): number;
	release_commitment_secret (idx: bigint): number;
	validate_holder_commitment (holder_tx: number, preimages: number): number;
	channel_keys_id (): number;
	sign_counterparty_commitment (commitment_tx: number, preimages: number): number;
	validate_counterparty_revocation (idx: bigint, secret: number): number;
	sign_holder_commitment_and_htlcs (commitment_tx: number): number;
	sign_justice_revoked_output (justice_tx: number, input: number, amount: bigint, per_commitment_key: number): number;
	sign_justice_revoked_htlc (justice_tx: number, input: number, amount: bigint, per_commitment_key: number, htlc: number): number;
	sign_counterparty_htlc_transaction (htlc_tx: number, input: number, amount: bigint, per_commitment_point: number, htlc: number): number;
	sign_closing_transaction (closing_tx: number): number;
	sign_channel_announcement (msg: number): number;
	ready_channel (channel_parameters: number): void;
}

/* @internal */
export function LDKBaseSign_new(impl: LDKBaseSign, pubkeys: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	var new_obj_idx = js_objs.length;
	for (var i = 0; i < js_objs.length; i++) {
		if (js_objs[i] == null || js_objs[i] == undefined) { new_obj_idx = i; break; }
	}
	js_objs[i] = new WeakRef(impl);
	return wasm.TS_LDKBaseSign_new(i);
}
	// LDKPublicKey BaseSign_get_per_commitment_point LDKBaseSign *NONNULL_PTR this_arg, uint64_t idx
/* @internal */
export function BaseSign_get_per_commitment_point(this_arg: number, idx: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BaseSign_get_per_commitment_point(this_arg, idx);
	return nativeResponseValue;
}
	// LDKThirtyTwoBytes BaseSign_release_commitment_secret LDKBaseSign *NONNULL_PTR this_arg, uint64_t idx
/* @internal */
export function BaseSign_release_commitment_secret(this_arg: number, idx: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BaseSign_release_commitment_secret(this_arg, idx);
	return nativeResponseValue;
}
	// LDKCResult_NoneNoneZ BaseSign_validate_holder_commitment LDKBaseSign *NONNULL_PTR this_arg, const struct LDKHolderCommitmentTransaction *NONNULL_PTR holder_tx, struct LDKCVec_PaymentPreimageZ preimages
/* @internal */
export function BaseSign_validate_holder_commitment(this_arg: number, holder_tx: number, preimages: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BaseSign_validate_holder_commitment(this_arg, holder_tx, preimages);
	return nativeResponseValue;
}
	// LDKThirtyTwoBytes BaseSign_channel_keys_id LDKBaseSign *NONNULL_PTR this_arg
/* @internal */
export function BaseSign_channel_keys_id(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BaseSign_channel_keys_id(this_arg);
	return nativeResponseValue;
}
	// LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ BaseSign_sign_counterparty_commitment LDKBaseSign *NONNULL_PTR this_arg, const struct LDKCommitmentTransaction *NONNULL_PTR commitment_tx, struct LDKCVec_PaymentPreimageZ preimages
/* @internal */
export function BaseSign_sign_counterparty_commitment(this_arg: number, commitment_tx: number, preimages: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BaseSign_sign_counterparty_commitment(this_arg, commitment_tx, preimages);
	return nativeResponseValue;
}
	// LDKCResult_NoneNoneZ BaseSign_validate_counterparty_revocation LDKBaseSign *NONNULL_PTR this_arg, uint64_t idx, const uint8_t (*secret)[32]
/* @internal */
export function BaseSign_validate_counterparty_revocation(this_arg: number, idx: bigint, secret: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BaseSign_validate_counterparty_revocation(this_arg, idx, secret);
	return nativeResponseValue;
}
	// LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ BaseSign_sign_holder_commitment_and_htlcs LDKBaseSign *NONNULL_PTR this_arg, const struct LDKHolderCommitmentTransaction *NONNULL_PTR commitment_tx
/* @internal */
export function BaseSign_sign_holder_commitment_and_htlcs(this_arg: number, commitment_tx: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BaseSign_sign_holder_commitment_and_htlcs(this_arg, commitment_tx);
	return nativeResponseValue;
}
	// LDKCResult_SignatureNoneZ BaseSign_sign_justice_revoked_output LDKBaseSign *NONNULL_PTR this_arg, struct LDKTransaction justice_tx, uintptr_t input, uint64_t amount, const uint8_t (*per_commitment_key)[32]
/* @internal */
export function BaseSign_sign_justice_revoked_output(this_arg: number, justice_tx: number, input: number, amount: bigint, per_commitment_key: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BaseSign_sign_justice_revoked_output(this_arg, justice_tx, input, amount, per_commitment_key);
	return nativeResponseValue;
}
	// LDKCResult_SignatureNoneZ BaseSign_sign_justice_revoked_htlc LDKBaseSign *NONNULL_PTR this_arg, struct LDKTransaction justice_tx, uintptr_t input, uint64_t amount, const uint8_t (*per_commitment_key)[32], const struct LDKHTLCOutputInCommitment *NONNULL_PTR htlc
/* @internal */
export function BaseSign_sign_justice_revoked_htlc(this_arg: number, justice_tx: number, input: number, amount: bigint, per_commitment_key: number, htlc: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BaseSign_sign_justice_revoked_htlc(this_arg, justice_tx, input, amount, per_commitment_key, htlc);
	return nativeResponseValue;
}
	// LDKCResult_SignatureNoneZ BaseSign_sign_counterparty_htlc_transaction LDKBaseSign *NONNULL_PTR this_arg, struct LDKTransaction htlc_tx, uintptr_t input, uint64_t amount, struct LDKPublicKey per_commitment_point, const struct LDKHTLCOutputInCommitment *NONNULL_PTR htlc
/* @internal */
export function BaseSign_sign_counterparty_htlc_transaction(this_arg: number, htlc_tx: number, input: number, amount: bigint, per_commitment_point: number, htlc: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BaseSign_sign_counterparty_htlc_transaction(this_arg, htlc_tx, input, amount, per_commitment_point, htlc);
	return nativeResponseValue;
}
	// LDKCResult_SignatureNoneZ BaseSign_sign_closing_transaction LDKBaseSign *NONNULL_PTR this_arg, const struct LDKClosingTransaction *NONNULL_PTR closing_tx
/* @internal */
export function BaseSign_sign_closing_transaction(this_arg: number, closing_tx: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BaseSign_sign_closing_transaction(this_arg, closing_tx);
	return nativeResponseValue;
}
	// LDKCResult_C2Tuple_SignatureSignatureZNoneZ BaseSign_sign_channel_announcement LDKBaseSign *NONNULL_PTR this_arg, const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR msg
/* @internal */
export function BaseSign_sign_channel_announcement(this_arg: number, msg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BaseSign_sign_channel_announcement(this_arg, msg);
	return nativeResponseValue;
}
	// void BaseSign_ready_channel LDKBaseSign *NONNULL_PTR this_arg, const struct LDKChannelTransactionParameters *NONNULL_PTR channel_parameters
/* @internal */
export function BaseSign_ready_channel(this_arg: number, channel_parameters: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BaseSign_ready_channel(this_arg, channel_parameters);
	// debug statements here
}
	// LDKChannelPublicKeys BaseSign_get_pubkeys LDKBaseSign *NONNULL_PTR this_arg
/* @internal */
export function BaseSign_get_pubkeys(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BaseSign_get_pubkeys(this_arg);
	return nativeResponseValue;
}
/* @internal */
export interface LDKSign {
	write (): number;
}

/* @internal */
export function LDKSign_new(impl: LDKSign, BaseSign: LDKBaseSign, pubkeys: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	var new_obj_idx = js_objs.length;
	for (var i = 0; i < js_objs.length; i++) {
		if (js_objs[i] == null || js_objs[i] == undefined) { new_obj_idx = i; break; }
	}
	js_objs[i] = new WeakRef(impl);
	return wasm.TS_LDKSign_new(i);
}
	// LDKCVec_u8Z Sign_write LDKSign *NONNULL_PTR this_arg
/* @internal */
export function Sign_write(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Sign_write(this_arg);
	return nativeResponseValue;
}
	// struct LDKSign CResult_SignDecodeErrorZ_get_ok(LDKCResult_SignDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_SignDecodeErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SignDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_SignDecodeErrorZ_get_err(LDKCResult_SignDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_SignDecodeErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SignDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKRecoverableSignature CResult_RecoverableSignatureNoneZ_get_ok(LDKCResult_RecoverableSignatureNoneZ *NONNULL_PTR owner);
/* @internal */
export function CResult_RecoverableSignatureNoneZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RecoverableSignatureNoneZ_get_ok(owner);
	return nativeResponseValue;
}
	// void CResult_RecoverableSignatureNoneZ_get_err(LDKCResult_RecoverableSignatureNoneZ *NONNULL_PTR owner);
/* @internal */
export function CResult_RecoverableSignatureNoneZ_get_err(owner: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RecoverableSignatureNoneZ_get_err(owner);
	// debug statements here
}
	// struct LDKCVec_CVec_u8ZZ CResult_CVec_CVec_u8ZZNoneZ_get_ok(LDKCResult_CVec_CVec_u8ZZNoneZ *NONNULL_PTR owner);
/* @internal */
export function CResult_CVec_CVec_u8ZZNoneZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CVec_CVec_u8ZZNoneZ_get_ok(owner);
	return nativeResponseValue;
}
	// void CResult_CVec_CVec_u8ZZNoneZ_get_err(LDKCResult_CVec_CVec_u8ZZNoneZ *NONNULL_PTR owner);
/* @internal */
export function CResult_CVec_CVec_u8ZZNoneZ_get_err(owner: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CVec_CVec_u8ZZNoneZ_get_err(owner);
	// debug statements here
}
	// struct LDKInMemorySigner CResult_InMemorySignerDecodeErrorZ_get_ok(LDKCResult_InMemorySignerDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_InMemorySignerDecodeErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InMemorySignerDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_InMemorySignerDecodeErrorZ_get_err(LDKCResult_InMemorySignerDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_InMemorySignerDecodeErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InMemorySignerDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKTransaction CResult_TransactionNoneZ_get_ok(LDKCResult_TransactionNoneZ *NONNULL_PTR owner);
/* @internal */
export function CResult_TransactionNoneZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TransactionNoneZ_get_ok(owner);
	return nativeResponseValue;
}
	// void CResult_TransactionNoneZ_get_err(LDKCResult_TransactionNoneZ *NONNULL_PTR owner);
/* @internal */
export function CResult_TransactionNoneZ_get_err(owner: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TransactionNoneZ_get_err(owner);
	// debug statements here
}
/* @internal */
export class LDKCOption_u16Z {
	protected constructor() {}
}
/* @internal */
export function LDKCOption_u16Z_ty_from_ptr(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_u16Z_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKCOption_u16Z_Some_get_some(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_u16Z_Some_get_some(ptr);
	return nativeResponseValue;
}
/* @internal */
export class LDKAPIError {
	protected constructor() {}
}
/* @internal */
export function LDKAPIError_ty_from_ptr(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKAPIError_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKAPIError_APIMisuseError_get_err(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKAPIError_APIMisuseError_get_err(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKAPIError_FeeRateTooHigh_get_err(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKAPIError_FeeRateTooHigh_get_err(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKAPIError_FeeRateTooHigh_get_feerate(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKAPIError_FeeRateTooHigh_get_feerate(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKAPIError_RouteError_get_err(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKAPIError_RouteError_get_err(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKAPIError_ChannelUnavailable_get_err(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKAPIError_ChannelUnavailable_get_err(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKAPIError_IncompatibleShutdownScript_get_script(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKAPIError_IncompatibleShutdownScript_get_script(ptr);
	return nativeResponseValue;
}
	// void CResult_NoneAPIErrorZ_get_ok(LDKCResult_NoneAPIErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_NoneAPIErrorZ_get_ok(owner: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneAPIErrorZ_get_ok(owner);
	// debug statements here
}
	// struct LDKAPIError CResult_NoneAPIErrorZ_get_err(LDKCResult_NoneAPIErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_NoneAPIErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneAPIErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKThirtyTwoBytes CResult__u832APIErrorZ_get_ok(LDKCResult__u832APIErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult__u832APIErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult__u832APIErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKAPIError CResult__u832APIErrorZ_get_err(LDKCResult__u832APIErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult__u832APIErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult__u832APIErrorZ_get_err(owner);
	return nativeResponseValue;
}
/* @internal */
export class LDKPaymentSendFailure {
	protected constructor() {}
}
/* @internal */
export function LDKPaymentSendFailure_ty_from_ptr(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKPaymentSendFailure_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKPaymentSendFailure_ParameterError_get_parameter_error(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKPaymentSendFailure_ParameterError_get_parameter_error(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKPaymentSendFailure_PathParameterError_get_path_parameter_error(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKPaymentSendFailure_PathParameterError_get_path_parameter_error(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKPaymentSendFailure_AllFailedRetrySafe_get_all_failed_retry_safe(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKPaymentSendFailure_AllFailedRetrySafe_get_all_failed_retry_safe(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKPaymentSendFailure_PartialFailure_get_results(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKPaymentSendFailure_PartialFailure_get_results(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKPaymentSendFailure_PartialFailure_get_failed_paths_retry(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKPaymentSendFailure_PartialFailure_get_failed_paths_retry(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKPaymentSendFailure_PartialFailure_get_payment_id(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKPaymentSendFailure_PartialFailure_get_payment_id(ptr);
	return nativeResponseValue;
}
	// struct LDKThirtyTwoBytes CResult_PaymentIdPaymentSendFailureZ_get_ok(LDKCResult_PaymentIdPaymentSendFailureZ *NONNULL_PTR owner);
/* @internal */
export function CResult_PaymentIdPaymentSendFailureZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentIdPaymentSendFailureZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKPaymentSendFailure CResult_PaymentIdPaymentSendFailureZ_get_err(LDKCResult_PaymentIdPaymentSendFailureZ *NONNULL_PTR owner);
/* @internal */
export function CResult_PaymentIdPaymentSendFailureZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentIdPaymentSendFailureZ_get_err(owner);
	return nativeResponseValue;
}
	// void CResult_NonePaymentSendFailureZ_get_ok(LDKCResult_NonePaymentSendFailureZ *NONNULL_PTR owner);
/* @internal */
export function CResult_NonePaymentSendFailureZ_get_ok(owner: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NonePaymentSendFailureZ_get_ok(owner);
	// debug statements here
}
	// struct LDKPaymentSendFailure CResult_NonePaymentSendFailureZ_get_err(LDKCResult_NonePaymentSendFailureZ *NONNULL_PTR owner);
/* @internal */
export function CResult_NonePaymentSendFailureZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NonePaymentSendFailureZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKThirtyTwoBytes C2Tuple_PaymentHashPaymentIdZ_get_a(LDKC2Tuple_PaymentHashPaymentIdZ *NONNULL_PTR owner);
/* @internal */
export function C2Tuple_PaymentHashPaymentIdZ_get_a(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_PaymentHashPaymentIdZ_get_a(owner);
	return nativeResponseValue;
}
	// struct LDKThirtyTwoBytes C2Tuple_PaymentHashPaymentIdZ_get_b(LDKC2Tuple_PaymentHashPaymentIdZ *NONNULL_PTR owner);
/* @internal */
export function C2Tuple_PaymentHashPaymentIdZ_get_b(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_PaymentHashPaymentIdZ_get_b(owner);
	return nativeResponseValue;
}
	// struct LDKC2Tuple_PaymentHashPaymentIdZ CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_get_ok(LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ *NONNULL_PTR owner);
/* @internal */
export function CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKPaymentSendFailure CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_get_err(LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ *NONNULL_PTR owner);
/* @internal */
export function CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_get_err(owner);
	return nativeResponseValue;
}
/* @internal */
export class LDKNetAddress {
	protected constructor() {}
}
/* @internal */
export function LDKNetAddress_ty_from_ptr(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKNetAddress_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKNetAddress_IPv4_get_addr(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKNetAddress_IPv4_get_addr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKNetAddress_IPv4_get_port(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKNetAddress_IPv4_get_port(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKNetAddress_IPv6_get_addr(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKNetAddress_IPv6_get_addr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKNetAddress_IPv6_get_port(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKNetAddress_IPv6_get_port(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKNetAddress_OnionV2_get_onion_v2(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKNetAddress_OnionV2_get_onion_v2(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKNetAddress_OnionV3_get_ed25519_pubkey(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKNetAddress_OnionV3_get_ed25519_pubkey(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKNetAddress_OnionV3_get_checksum(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKNetAddress_OnionV3_get_checksum(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKNetAddress_OnionV3_get_version(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKNetAddress_OnionV3_get_version(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKNetAddress_OnionV3_get_port(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKNetAddress_OnionV3_get_port(ptr);
	return nativeResponseValue;
}
	// struct LDKThirtyTwoBytes C2Tuple_PaymentHashPaymentSecretZ_get_a(LDKC2Tuple_PaymentHashPaymentSecretZ *NONNULL_PTR owner);
/* @internal */
export function C2Tuple_PaymentHashPaymentSecretZ_get_a(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_PaymentHashPaymentSecretZ_get_a(owner);
	return nativeResponseValue;
}
	// struct LDKThirtyTwoBytes C2Tuple_PaymentHashPaymentSecretZ_get_b(LDKC2Tuple_PaymentHashPaymentSecretZ *NONNULL_PTR owner);
/* @internal */
export function C2Tuple_PaymentHashPaymentSecretZ_get_b(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_PaymentHashPaymentSecretZ_get_b(owner);
	return nativeResponseValue;
}
	// struct LDKC2Tuple_PaymentHashPaymentSecretZ CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_get_ok(LDKCResult_C2Tuple_PaymentHashPaymentSecretZNoneZ *NONNULL_PTR owner);
/* @internal */
export function CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_get_ok(owner);
	return nativeResponseValue;
}
	// void CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_get_err(LDKCResult_C2Tuple_PaymentHashPaymentSecretZNoneZ *NONNULL_PTR owner);
/* @internal */
export function CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_get_err(owner: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_get_err(owner);
	// debug statements here
}
	// struct LDKC2Tuple_PaymentHashPaymentSecretZ CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_get_ok(LDKCResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKAPIError CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_get_err(LDKCResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKThirtyTwoBytes CResult_PaymentSecretNoneZ_get_ok(LDKCResult_PaymentSecretNoneZ *NONNULL_PTR owner);
/* @internal */
export function CResult_PaymentSecretNoneZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentSecretNoneZ_get_ok(owner);
	return nativeResponseValue;
}
	// void CResult_PaymentSecretNoneZ_get_err(LDKCResult_PaymentSecretNoneZ *NONNULL_PTR owner);
/* @internal */
export function CResult_PaymentSecretNoneZ_get_err(owner: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentSecretNoneZ_get_err(owner);
	// debug statements here
}
	// struct LDKThirtyTwoBytes CResult_PaymentSecretAPIErrorZ_get_ok(LDKCResult_PaymentSecretAPIErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_PaymentSecretAPIErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentSecretAPIErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKAPIError CResult_PaymentSecretAPIErrorZ_get_err(LDKCResult_PaymentSecretAPIErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_PaymentSecretAPIErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentSecretAPIErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKThirtyTwoBytes CResult_PaymentPreimageAPIErrorZ_get_ok(LDKCResult_PaymentPreimageAPIErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_PaymentPreimageAPIErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentPreimageAPIErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKAPIError CResult_PaymentPreimageAPIErrorZ_get_err(LDKCResult_PaymentPreimageAPIErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_PaymentPreimageAPIErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentPreimageAPIErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKCounterpartyForwardingInfo CResult_CounterpartyForwardingInfoDecodeErrorZ_get_ok(LDKCResult_CounterpartyForwardingInfoDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_CounterpartyForwardingInfoDecodeErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CounterpartyForwardingInfoDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_CounterpartyForwardingInfoDecodeErrorZ_get_err(LDKCResult_CounterpartyForwardingInfoDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_CounterpartyForwardingInfoDecodeErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CounterpartyForwardingInfoDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKChannelCounterparty CResult_ChannelCounterpartyDecodeErrorZ_get_ok(LDKCResult_ChannelCounterpartyDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ChannelCounterpartyDecodeErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelCounterpartyDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_ChannelCounterpartyDecodeErrorZ_get_err(LDKCResult_ChannelCounterpartyDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ChannelCounterpartyDecodeErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelCounterpartyDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKChannelDetails CResult_ChannelDetailsDecodeErrorZ_get_ok(LDKCResult_ChannelDetailsDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ChannelDetailsDecodeErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelDetailsDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_ChannelDetailsDecodeErrorZ_get_err(LDKCResult_ChannelDetailsDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ChannelDetailsDecodeErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelDetailsDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKPhantomRouteHints CResult_PhantomRouteHintsDecodeErrorZ_get_ok(LDKCResult_PhantomRouteHintsDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_PhantomRouteHintsDecodeErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PhantomRouteHintsDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_PhantomRouteHintsDecodeErrorZ_get_err(LDKCResult_PhantomRouteHintsDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_PhantomRouteHintsDecodeErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PhantomRouteHintsDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
/* @internal */
export interface LDKWatch {
	watch_channel (funding_txo: number, monitor: number): number;
	update_channel (funding_txo: number, update: number): number;
	release_pending_monitor_events (): number;
}

/* @internal */
export function LDKWatch_new(impl: LDKWatch): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	var new_obj_idx = js_objs.length;
	for (var i = 0; i < js_objs.length; i++) {
		if (js_objs[i] == null || js_objs[i] == undefined) { new_obj_idx = i; break; }
	}
	js_objs[i] = new WeakRef(impl);
	return wasm.TS_LDKWatch_new(i);
}
	// LDKCResult_NoneChannelMonitorUpdateErrZ Watch_watch_channel LDKWatch *NONNULL_PTR this_arg, struct LDKOutPoint funding_txo, struct LDKChannelMonitor monitor
/* @internal */
export function Watch_watch_channel(this_arg: number, funding_txo: number, monitor: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Watch_watch_channel(this_arg, funding_txo, monitor);
	return nativeResponseValue;
}
	// LDKCResult_NoneChannelMonitorUpdateErrZ Watch_update_channel LDKWatch *NONNULL_PTR this_arg, struct LDKOutPoint funding_txo, struct LDKChannelMonitorUpdate update
/* @internal */
export function Watch_update_channel(this_arg: number, funding_txo: number, update: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Watch_update_channel(this_arg, funding_txo, update);
	return nativeResponseValue;
}
	// LDKCVec_MonitorEventZ Watch_release_pending_monitor_events LDKWatch *NONNULL_PTR this_arg
/* @internal */
export function Watch_release_pending_monitor_events(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Watch_release_pending_monitor_events(this_arg);
	return nativeResponseValue;
}
/* @internal */
export interface LDKBroadcasterInterface {
	broadcast_transaction (tx: number): void;
}

/* @internal */
export function LDKBroadcasterInterface_new(impl: LDKBroadcasterInterface): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	var new_obj_idx = js_objs.length;
	for (var i = 0; i < js_objs.length; i++) {
		if (js_objs[i] == null || js_objs[i] == undefined) { new_obj_idx = i; break; }
	}
	js_objs[i] = new WeakRef(impl);
	return wasm.TS_LDKBroadcasterInterface_new(i);
}
	// void BroadcasterInterface_broadcast_transaction LDKBroadcasterInterface *NONNULL_PTR this_arg, struct LDKTransaction tx
/* @internal */
export function BroadcasterInterface_broadcast_transaction(this_arg: number, tx: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BroadcasterInterface_broadcast_transaction(this_arg, tx);
	// debug statements here
}
/* @internal */
export interface LDKKeysInterface {
	get_node_secret (recipient: Recipient): number;
	get_destination_script (): number;
	get_shutdown_scriptpubkey (): number;
	get_channel_signer (inbound: boolean, channel_value_satoshis: bigint): number;
	get_secure_random_bytes (): number;
	read_chan_signer (reader: number): number;
	sign_invoice (hrp_bytes: number, invoice_data: number, receipient: Recipient): number;
	get_inbound_payment_key_material (): number;
}

/* @internal */
export function LDKKeysInterface_new(impl: LDKKeysInterface): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	var new_obj_idx = js_objs.length;
	for (var i = 0; i < js_objs.length; i++) {
		if (js_objs[i] == null || js_objs[i] == undefined) { new_obj_idx = i; break; }
	}
	js_objs[i] = new WeakRef(impl);
	return wasm.TS_LDKKeysInterface_new(i);
}
	// LDKCResult_SecretKeyNoneZ KeysInterface_get_node_secret LDKKeysInterface *NONNULL_PTR this_arg, enum LDKRecipient recipient
/* @internal */
export function KeysInterface_get_node_secret(this_arg: number, recipient: Recipient): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_KeysInterface_get_node_secret(this_arg, recipient);
	return nativeResponseValue;
}
	// LDKCVec_u8Z KeysInterface_get_destination_script LDKKeysInterface *NONNULL_PTR this_arg
/* @internal */
export function KeysInterface_get_destination_script(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_KeysInterface_get_destination_script(this_arg);
	return nativeResponseValue;
}
	// LDKShutdownScript KeysInterface_get_shutdown_scriptpubkey LDKKeysInterface *NONNULL_PTR this_arg
/* @internal */
export function KeysInterface_get_shutdown_scriptpubkey(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_KeysInterface_get_shutdown_scriptpubkey(this_arg);
	return nativeResponseValue;
}
	// LDKSign KeysInterface_get_channel_signer LDKKeysInterface *NONNULL_PTR this_arg, bool inbound, uint64_t channel_value_satoshis
/* @internal */
export function KeysInterface_get_channel_signer(this_arg: number, inbound: boolean, channel_value_satoshis: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_KeysInterface_get_channel_signer(this_arg, inbound, channel_value_satoshis);
	return nativeResponseValue;
}
	// LDKThirtyTwoBytes KeysInterface_get_secure_random_bytes LDKKeysInterface *NONNULL_PTR this_arg
/* @internal */
export function KeysInterface_get_secure_random_bytes(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_KeysInterface_get_secure_random_bytes(this_arg);
	return nativeResponseValue;
}
	// LDKCResult_SignDecodeErrorZ KeysInterface_read_chan_signer LDKKeysInterface *NONNULL_PTR this_arg, struct LDKu8slice reader
/* @internal */
export function KeysInterface_read_chan_signer(this_arg: number, reader: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_KeysInterface_read_chan_signer(this_arg, reader);
	return nativeResponseValue;
}
	// LDKCResult_RecoverableSignatureNoneZ KeysInterface_sign_invoice LDKKeysInterface *NONNULL_PTR this_arg, struct LDKu8slice hrp_bytes, struct LDKCVec_u5Z invoice_data, enum LDKRecipient receipient
/* @internal */
export function KeysInterface_sign_invoice(this_arg: number, hrp_bytes: number, invoice_data: number, receipient: Recipient): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_KeysInterface_sign_invoice(this_arg, hrp_bytes, invoice_data, receipient);
	return nativeResponseValue;
}
	// LDKThirtyTwoBytes KeysInterface_get_inbound_payment_key_material LDKKeysInterface *NONNULL_PTR this_arg
/* @internal */
export function KeysInterface_get_inbound_payment_key_material(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_KeysInterface_get_inbound_payment_key_material(this_arg);
	return nativeResponseValue;
}
/* @internal */
export interface LDKFeeEstimator {
	get_est_sat_per_1000_weight (confirmation_target: ConfirmationTarget): number;
}

/* @internal */
export function LDKFeeEstimator_new(impl: LDKFeeEstimator): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	var new_obj_idx = js_objs.length;
	for (var i = 0; i < js_objs.length; i++) {
		if (js_objs[i] == null || js_objs[i] == undefined) { new_obj_idx = i; break; }
	}
	js_objs[i] = new WeakRef(impl);
	return wasm.TS_LDKFeeEstimator_new(i);
}
	// uint32_t FeeEstimator_get_est_sat_per_1000_weight LDKFeeEstimator *NONNULL_PTR this_arg, enum LDKConfirmationTarget confirmation_target
/* @internal */
export function FeeEstimator_get_est_sat_per_1000_weight(this_arg: number, confirmation_target: ConfirmationTarget): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_FeeEstimator_get_est_sat_per_1000_weight(this_arg, confirmation_target);
	return nativeResponseValue;
}
/* @internal */
export interface LDKLogger {
	log (record: number): void;
}

/* @internal */
export function LDKLogger_new(impl: LDKLogger): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	var new_obj_idx = js_objs.length;
	for (var i = 0; i < js_objs.length; i++) {
		if (js_objs[i] == null || js_objs[i] == undefined) { new_obj_idx = i; break; }
	}
	js_objs[i] = new WeakRef(impl);
	return wasm.TS_LDKLogger_new(i);
}
	// struct LDKThirtyTwoBytes C2Tuple_BlockHashChannelManagerZ_get_a(LDKC2Tuple_BlockHashChannelManagerZ *NONNULL_PTR owner);
/* @internal */
export function C2Tuple_BlockHashChannelManagerZ_get_a(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_BlockHashChannelManagerZ_get_a(owner);
	return nativeResponseValue;
}
	// struct LDKChannelManager *C2Tuple_BlockHashChannelManagerZ_get_b(LDKC2Tuple_BlockHashChannelManagerZ *NONNULL_PTR owner);
/* @internal */
export function C2Tuple_BlockHashChannelManagerZ_get_b(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_BlockHashChannelManagerZ_get_b(owner);
	return nativeResponseValue;
}
	// struct LDKC2Tuple_BlockHashChannelManagerZ *CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_get_ok(LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_get_err(LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKChannelConfig CResult_ChannelConfigDecodeErrorZ_get_ok(LDKCResult_ChannelConfigDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ChannelConfigDecodeErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelConfigDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_ChannelConfigDecodeErrorZ_get_err(LDKCResult_ChannelConfigDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ChannelConfigDecodeErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelConfigDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKOutPoint CResult_OutPointDecodeErrorZ_get_ok(LDKCResult_OutPointDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_OutPointDecodeErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_OutPointDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_OutPointDecodeErrorZ_get_err(LDKCResult_OutPointDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_OutPointDecodeErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_OutPointDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
/* @internal */
export interface LDKType {
	type_id (): number;
	debug_str (): number;
	write (): number;
}

/* @internal */
export function LDKType_new(impl: LDKType): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	var new_obj_idx = js_objs.length;
	for (var i = 0; i < js_objs.length; i++) {
		if (js_objs[i] == null || js_objs[i] == undefined) { new_obj_idx = i; break; }
	}
	js_objs[i] = new WeakRef(impl);
	return wasm.TS_LDKType_new(i);
}
	// uint16_t Type_type_id LDKType *NONNULL_PTR this_arg
/* @internal */
export function Type_type_id(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Type_type_id(this_arg);
	return nativeResponseValue;
}
	// LDKStr Type_debug_str LDKType *NONNULL_PTR this_arg
/* @internal */
export function Type_debug_str(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Type_debug_str(this_arg);
	return nativeResponseValue;
}
	// LDKCVec_u8Z Type_write LDKType *NONNULL_PTR this_arg
/* @internal */
export function Type_write(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Type_write(this_arg);
	return nativeResponseValue;
}
/* @internal */
export class LDKCOption_TypeZ {
	protected constructor() {}
}
/* @internal */
export function LDKCOption_TypeZ_ty_from_ptr(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_TypeZ_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKCOption_TypeZ_Some_get_some(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_TypeZ_Some_get_some(ptr);
	return nativeResponseValue;
}
	// struct LDKCOption_TypeZ CResult_COption_TypeZDecodeErrorZ_get_ok(LDKCResult_COption_TypeZDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_COption_TypeZDecodeErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_TypeZDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_COption_TypeZDecodeErrorZ_get_err(LDKCResult_COption_TypeZDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_COption_TypeZDecodeErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_TypeZDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
/* @internal */
export class LDKPaymentError {
	protected constructor() {}
}
/* @internal */
export function LDKPaymentError_ty_from_ptr(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKPaymentError_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKPaymentError_Invoice_get_invoice(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKPaymentError_Invoice_get_invoice(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKPaymentError_Routing_get_routing(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKPaymentError_Routing_get_routing(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKPaymentError_Sending_get_sending(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKPaymentError_Sending_get_sending(ptr);
	return nativeResponseValue;
}
	// struct LDKThirtyTwoBytes CResult_PaymentIdPaymentErrorZ_get_ok(LDKCResult_PaymentIdPaymentErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_PaymentIdPaymentErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentIdPaymentErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKPaymentError CResult_PaymentIdPaymentErrorZ_get_err(LDKCResult_PaymentIdPaymentErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_PaymentIdPaymentErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentIdPaymentErrorZ_get_err(owner);
	return nativeResponseValue;
}
/* @internal */
export class LDKParseError {
	protected constructor() {}
}
/* @internal */
export function LDKParseError_ty_from_ptr(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKParseError_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKParseError_Bech32Error_get_bech32_error(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKParseError_Bech32Error_get_bech32_error(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKParseError_ParseAmountError_get_parse_amount_error(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKParseError_ParseAmountError_get_parse_amount_error(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKParseError_MalformedSignature_get_malformed_signature(ptr: number): Secp256k1Error {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKParseError_MalformedSignature_get_malformed_signature(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKParseError_DescriptionDecodeError_get_description_decode_error(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKParseError_DescriptionDecodeError_get_description_decode_error(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKParseError_InvalidSliceLength_get_invalid_slice_length(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKParseError_InvalidSliceLength_get_invalid_slice_length(ptr);
	return nativeResponseValue;
}
	// enum LDKSiPrefix CResult_SiPrefixParseErrorZ_get_ok(LDKCResult_SiPrefixParseErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_SiPrefixParseErrorZ_get_ok(owner: number): SiPrefix {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SiPrefixParseErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKParseError CResult_SiPrefixParseErrorZ_get_err(LDKCResult_SiPrefixParseErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_SiPrefixParseErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SiPrefixParseErrorZ_get_err(owner);
	return nativeResponseValue;
}
/* @internal */
export class LDKParseOrSemanticError {
	protected constructor() {}
}
/* @internal */
export function LDKParseOrSemanticError_ty_from_ptr(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKParseOrSemanticError_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKParseOrSemanticError_ParseError_get_parse_error(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKParseOrSemanticError_ParseError_get_parse_error(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKParseOrSemanticError_SemanticError_get_semantic_error(ptr: number): SemanticError {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKParseOrSemanticError_SemanticError_get_semantic_error(ptr);
	return nativeResponseValue;
}
	// struct LDKInvoice CResult_InvoiceParseOrSemanticErrorZ_get_ok(LDKCResult_InvoiceParseOrSemanticErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_InvoiceParseOrSemanticErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InvoiceParseOrSemanticErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKParseOrSemanticError CResult_InvoiceParseOrSemanticErrorZ_get_err(LDKCResult_InvoiceParseOrSemanticErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_InvoiceParseOrSemanticErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InvoiceParseOrSemanticErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKSignedRawInvoice CResult_SignedRawInvoiceParseErrorZ_get_ok(LDKCResult_SignedRawInvoiceParseErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_SignedRawInvoiceParseErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SignedRawInvoiceParseErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKParseError CResult_SignedRawInvoiceParseErrorZ_get_err(LDKCResult_SignedRawInvoiceParseErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_SignedRawInvoiceParseErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SignedRawInvoiceParseErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKRawInvoice C3Tuple_RawInvoice_u832InvoiceSignatureZ_get_a(LDKC3Tuple_RawInvoice_u832InvoiceSignatureZ *NONNULL_PTR owner);
/* @internal */
export function C3Tuple_RawInvoice_u832InvoiceSignatureZ_get_a(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C3Tuple_RawInvoice_u832InvoiceSignatureZ_get_a(owner);
	return nativeResponseValue;
}
	// struct LDKThirtyTwoBytes C3Tuple_RawInvoice_u832InvoiceSignatureZ_get_b(LDKC3Tuple_RawInvoice_u832InvoiceSignatureZ *NONNULL_PTR owner);
/* @internal */
export function C3Tuple_RawInvoice_u832InvoiceSignatureZ_get_b(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C3Tuple_RawInvoice_u832InvoiceSignatureZ_get_b(owner);
	return nativeResponseValue;
}
	// struct LDKInvoiceSignature C3Tuple_RawInvoice_u832InvoiceSignatureZ_get_c(LDKC3Tuple_RawInvoice_u832InvoiceSignatureZ *NONNULL_PTR owner);
/* @internal */
export function C3Tuple_RawInvoice_u832InvoiceSignatureZ_get_c(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C3Tuple_RawInvoice_u832InvoiceSignatureZ_get_c(owner);
	return nativeResponseValue;
}
	// struct LDKPayeePubKey CResult_PayeePubKeyErrorZ_get_ok(LDKCResult_PayeePubKeyErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_PayeePubKeyErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PayeePubKeyErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// enum LDKSecp256k1Error CResult_PayeePubKeyErrorZ_get_err(LDKCResult_PayeePubKeyErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_PayeePubKeyErrorZ_get_err(owner: number): Secp256k1Error {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PayeePubKeyErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKPositiveTimestamp CResult_PositiveTimestampCreationErrorZ_get_ok(LDKCResult_PositiveTimestampCreationErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_PositiveTimestampCreationErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PositiveTimestampCreationErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// enum LDKCreationError CResult_PositiveTimestampCreationErrorZ_get_err(LDKCResult_PositiveTimestampCreationErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_PositiveTimestampCreationErrorZ_get_err(owner: number): CreationError {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PositiveTimestampCreationErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// void CResult_NoneSemanticErrorZ_get_ok(LDKCResult_NoneSemanticErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_NoneSemanticErrorZ_get_ok(owner: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneSemanticErrorZ_get_ok(owner);
	// debug statements here
}
	// enum LDKSemanticError CResult_NoneSemanticErrorZ_get_err(LDKCResult_NoneSemanticErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_NoneSemanticErrorZ_get_err(owner: number): SemanticError {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneSemanticErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKInvoice CResult_InvoiceSemanticErrorZ_get_ok(LDKCResult_InvoiceSemanticErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_InvoiceSemanticErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InvoiceSemanticErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// enum LDKSemanticError CResult_InvoiceSemanticErrorZ_get_err(LDKCResult_InvoiceSemanticErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_InvoiceSemanticErrorZ_get_err(owner: number): SemanticError {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InvoiceSemanticErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKDescription CResult_DescriptionCreationErrorZ_get_ok(LDKCResult_DescriptionCreationErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_DescriptionCreationErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_DescriptionCreationErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// enum LDKCreationError CResult_DescriptionCreationErrorZ_get_err(LDKCResult_DescriptionCreationErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_DescriptionCreationErrorZ_get_err(owner: number): CreationError {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_DescriptionCreationErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKPrivateRoute CResult_PrivateRouteCreationErrorZ_get_ok(LDKCResult_PrivateRouteCreationErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_PrivateRouteCreationErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PrivateRouteCreationErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// enum LDKCreationError CResult_PrivateRouteCreationErrorZ_get_err(LDKCResult_PrivateRouteCreationErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_PrivateRouteCreationErrorZ_get_err(owner: number): CreationError {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PrivateRouteCreationErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKStr CResult_StringErrorZ_get_ok(LDKCResult_StringErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_StringErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_StringErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// enum LDKSecp256k1Error CResult_StringErrorZ_get_err(LDKCResult_StringErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_StringErrorZ_get_err(owner: number): Secp256k1Error {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_StringErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKChannelMonitorUpdate CResult_ChannelMonitorUpdateDecodeErrorZ_get_ok(LDKCResult_ChannelMonitorUpdateDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ChannelMonitorUpdateDecodeErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelMonitorUpdateDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_ChannelMonitorUpdateDecodeErrorZ_get_err(LDKCResult_ChannelMonitorUpdateDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ChannelMonitorUpdateDecodeErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelMonitorUpdateDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
/* @internal */
export class LDKCOption_MonitorEventZ {
	protected constructor() {}
}
/* @internal */
export function LDKCOption_MonitorEventZ_ty_from_ptr(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_MonitorEventZ_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKCOption_MonitorEventZ_Some_get_some(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_MonitorEventZ_Some_get_some(ptr);
	return nativeResponseValue;
}
	// struct LDKCOption_MonitorEventZ CResult_COption_MonitorEventZDecodeErrorZ_get_ok(LDKCResult_COption_MonitorEventZDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_COption_MonitorEventZDecodeErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_MonitorEventZDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_COption_MonitorEventZDecodeErrorZ_get_err(LDKCResult_COption_MonitorEventZDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_COption_MonitorEventZDecodeErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_MonitorEventZDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKHTLCUpdate CResult_HTLCUpdateDecodeErrorZ_get_ok(LDKCResult_HTLCUpdateDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_HTLCUpdateDecodeErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_HTLCUpdateDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_HTLCUpdateDecodeErrorZ_get_err(LDKCResult_HTLCUpdateDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_HTLCUpdateDecodeErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_HTLCUpdateDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKOutPoint C2Tuple_OutPointScriptZ_get_a(LDKC2Tuple_OutPointScriptZ *NONNULL_PTR owner);
/* @internal */
export function C2Tuple_OutPointScriptZ_get_a(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_OutPointScriptZ_get_a(owner);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z C2Tuple_OutPointScriptZ_get_b(LDKC2Tuple_OutPointScriptZ *NONNULL_PTR owner);
/* @internal */
export function C2Tuple_OutPointScriptZ_get_b(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_OutPointScriptZ_get_b(owner);
	return nativeResponseValue;
}
	// uint32_t C2Tuple_u32ScriptZ_get_a(LDKC2Tuple_u32ScriptZ *NONNULL_PTR owner);
/* @internal */
export function C2Tuple_u32ScriptZ_get_a(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_u32ScriptZ_get_a(owner);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z C2Tuple_u32ScriptZ_get_b(LDKC2Tuple_u32ScriptZ *NONNULL_PTR owner);
/* @internal */
export function C2Tuple_u32ScriptZ_get_b(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_u32ScriptZ_get_b(owner);
	return nativeResponseValue;
}
	// struct LDKThirtyTwoBytes C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_get_a(LDKC2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ *NONNULL_PTR owner);
/* @internal */
export function C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_get_a(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_get_a(owner);
	return nativeResponseValue;
}
	// struct LDKCVec_C2Tuple_u32ScriptZZ C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_get_b(LDKC2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ *NONNULL_PTR owner);
/* @internal */
export function C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_get_b(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_get_b(owner);
	return nativeResponseValue;
}
	// uint32_t C2Tuple_u32TxOutZ_get_a(LDKC2Tuple_u32TxOutZ *NONNULL_PTR owner);
/* @internal */
export function C2Tuple_u32TxOutZ_get_a(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_u32TxOutZ_get_a(owner);
	return nativeResponseValue;
}
	// struct LDKTxOut C2Tuple_u32TxOutZ_get_b(LDKC2Tuple_u32TxOutZ *NONNULL_PTR owner);
/* @internal */
export function C2Tuple_u32TxOutZ_get_b(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_u32TxOutZ_get_b(owner);
	return nativeResponseValue;
}
	// struct LDKThirtyTwoBytes C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_get_a(LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ *NONNULL_PTR owner);
/* @internal */
export function C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_get_a(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_get_a(owner);
	return nativeResponseValue;
}
	// struct LDKCVec_C2Tuple_u32TxOutZZ C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_get_b(LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ *NONNULL_PTR owner);
/* @internal */
export function C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_get_b(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_get_b(owner);
	return nativeResponseValue;
}
/* @internal */
export class LDKBalance {
	protected constructor() {}
}
/* @internal */
export function LDKBalance_ty_from_ptr(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKBalance_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKBalance_ClaimableOnChannelClose_get_claimable_amount_satoshis(ptr: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKBalance_ClaimableOnChannelClose_get_claimable_amount_satoshis(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKBalance_ClaimableAwaitingConfirmations_get_claimable_amount_satoshis(ptr: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKBalance_ClaimableAwaitingConfirmations_get_claimable_amount_satoshis(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKBalance_ClaimableAwaitingConfirmations_get_confirmation_height(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKBalance_ClaimableAwaitingConfirmations_get_confirmation_height(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKBalance_ContentiousClaimable_get_claimable_amount_satoshis(ptr: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKBalance_ContentiousClaimable_get_claimable_amount_satoshis(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKBalance_ContentiousClaimable_get_timeout_height(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKBalance_ContentiousClaimable_get_timeout_height(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKBalance_MaybeClaimableHTLCAwaitingTimeout_get_claimable_amount_satoshis(ptr: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKBalance_MaybeClaimableHTLCAwaitingTimeout_get_claimable_amount_satoshis(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKBalance_MaybeClaimableHTLCAwaitingTimeout_get_claimable_height(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKBalance_MaybeClaimableHTLCAwaitingTimeout_get_claimable_height(ptr);
	return nativeResponseValue;
}
	// struct LDKThirtyTwoBytes C2Tuple_BlockHashChannelMonitorZ_get_a(LDKC2Tuple_BlockHashChannelMonitorZ *NONNULL_PTR owner);
/* @internal */
export function C2Tuple_BlockHashChannelMonitorZ_get_a(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_BlockHashChannelMonitorZ_get_a(owner);
	return nativeResponseValue;
}
	// struct LDKChannelMonitor C2Tuple_BlockHashChannelMonitorZ_get_b(LDKC2Tuple_BlockHashChannelMonitorZ *NONNULL_PTR owner);
/* @internal */
export function C2Tuple_BlockHashChannelMonitorZ_get_b(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_BlockHashChannelMonitorZ_get_b(owner);
	return nativeResponseValue;
}
	// struct LDKC2Tuple_BlockHashChannelMonitorZ CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_get_ok(LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_get_err(LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// void CResult_NoneLightningErrorZ_get_ok(LDKCResult_NoneLightningErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_NoneLightningErrorZ_get_ok(owner: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneLightningErrorZ_get_ok(owner);
	// debug statements here
}
	// struct LDKLightningError CResult_NoneLightningErrorZ_get_err(LDKCResult_NoneLightningErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_NoneLightningErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneLightningErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKPublicKey C2Tuple_PublicKeyTypeZ_get_a(LDKC2Tuple_PublicKeyTypeZ *NONNULL_PTR owner);
/* @internal */
export function C2Tuple_PublicKeyTypeZ_get_a(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_PublicKeyTypeZ_get_a(owner);
	return nativeResponseValue;
}
	// struct LDKType C2Tuple_PublicKeyTypeZ_get_b(LDKC2Tuple_PublicKeyTypeZ *NONNULL_PTR owner);
/* @internal */
export function C2Tuple_PublicKeyTypeZ_get_b(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_PublicKeyTypeZ_get_b(owner);
	return nativeResponseValue;
}
	// bool CResult_boolLightningErrorZ_get_ok(LDKCResult_boolLightningErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_boolLightningErrorZ_get_ok(owner: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_boolLightningErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKLightningError CResult_boolLightningErrorZ_get_err(LDKCResult_boolLightningErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_boolLightningErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_boolLightningErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKChannelAnnouncement C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_get_a(LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ *NONNULL_PTR owner);
/* @internal */
export function C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_get_a(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_get_a(owner);
	return nativeResponseValue;
}
	// struct LDKChannelUpdate C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_get_b(LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ *NONNULL_PTR owner);
/* @internal */
export function C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_get_b(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_get_b(owner);
	return nativeResponseValue;
}
	// struct LDKChannelUpdate C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_get_c(LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ *NONNULL_PTR owner);
/* @internal */
export function C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_get_c(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_get_c(owner);
	return nativeResponseValue;
}
/* @internal */
export class LDKCOption_NetAddressZ {
	protected constructor() {}
}
/* @internal */
export function LDKCOption_NetAddressZ_ty_from_ptr(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_NetAddressZ_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKCOption_NetAddressZ_Some_get_some(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_NetAddressZ_Some_get_some(ptr);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z CResult_CVec_u8ZPeerHandleErrorZ_get_ok(LDKCResult_CVec_u8ZPeerHandleErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_CVec_u8ZPeerHandleErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CVec_u8ZPeerHandleErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKPeerHandleError CResult_CVec_u8ZPeerHandleErrorZ_get_err(LDKCResult_CVec_u8ZPeerHandleErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_CVec_u8ZPeerHandleErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CVec_u8ZPeerHandleErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// void CResult_NonePeerHandleErrorZ_get_ok(LDKCResult_NonePeerHandleErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_NonePeerHandleErrorZ_get_ok(owner: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NonePeerHandleErrorZ_get_ok(owner);
	// debug statements here
}
	// struct LDKPeerHandleError CResult_NonePeerHandleErrorZ_get_err(LDKCResult_NonePeerHandleErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_NonePeerHandleErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NonePeerHandleErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// bool CResult_boolPeerHandleErrorZ_get_ok(LDKCResult_boolPeerHandleErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_boolPeerHandleErrorZ_get_ok(owner: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_boolPeerHandleErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKPeerHandleError CResult_boolPeerHandleErrorZ_get_err(LDKCResult_boolPeerHandleErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_boolPeerHandleErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_boolPeerHandleErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKNodeId CResult_NodeIdDecodeErrorZ_get_ok(LDKCResult_NodeIdDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_NodeIdDecodeErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NodeIdDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_NodeIdDecodeErrorZ_get_err(LDKCResult_NodeIdDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_NodeIdDecodeErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NodeIdDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKCOption_NetworkUpdateZ CResult_COption_NetworkUpdateZDecodeErrorZ_get_ok(LDKCResult_COption_NetworkUpdateZDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_COption_NetworkUpdateZDecodeErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_NetworkUpdateZDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_COption_NetworkUpdateZDecodeErrorZ_get_err(LDKCResult_COption_NetworkUpdateZDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_COption_NetworkUpdateZDecodeErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_NetworkUpdateZDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
/* @internal */
export interface LDKAccess {
	get_utxo (genesis_hash: number, short_channel_id: bigint): number;
}

/* @internal */
export function LDKAccess_new(impl: LDKAccess): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	var new_obj_idx = js_objs.length;
	for (var i = 0; i < js_objs.length; i++) {
		if (js_objs[i] == null || js_objs[i] == undefined) { new_obj_idx = i; break; }
	}
	js_objs[i] = new WeakRef(impl);
	return wasm.TS_LDKAccess_new(i);
}
	// LDKCResult_TxOutAccessErrorZ Access_get_utxo LDKAccess *NONNULL_PTR this_arg, const uint8_t (*genesis_hash)[32], uint64_t short_channel_id
/* @internal */
export function Access_get_utxo(this_arg: number, genesis_hash: number, short_channel_id: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Access_get_utxo(this_arg, genesis_hash, short_channel_id);
	return nativeResponseValue;
}
/* @internal */
export class LDKCOption_AccessZ {
	protected constructor() {}
}
/* @internal */
export function LDKCOption_AccessZ_ty_from_ptr(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_AccessZ_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKCOption_AccessZ_Some_get_some(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_AccessZ_Some_get_some(ptr);
	return nativeResponseValue;
}
	// struct LDKChannelUpdateInfo CResult_ChannelUpdateInfoDecodeErrorZ_get_ok(LDKCResult_ChannelUpdateInfoDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ChannelUpdateInfoDecodeErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelUpdateInfoDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_ChannelUpdateInfoDecodeErrorZ_get_err(LDKCResult_ChannelUpdateInfoDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ChannelUpdateInfoDecodeErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelUpdateInfoDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKChannelInfo CResult_ChannelInfoDecodeErrorZ_get_ok(LDKCResult_ChannelInfoDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ChannelInfoDecodeErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelInfoDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_ChannelInfoDecodeErrorZ_get_err(LDKCResult_ChannelInfoDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ChannelInfoDecodeErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelInfoDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKRoutingFees CResult_RoutingFeesDecodeErrorZ_get_ok(LDKCResult_RoutingFeesDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_RoutingFeesDecodeErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RoutingFeesDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_RoutingFeesDecodeErrorZ_get_err(LDKCResult_RoutingFeesDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_RoutingFeesDecodeErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RoutingFeesDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKNodeAnnouncementInfo CResult_NodeAnnouncementInfoDecodeErrorZ_get_ok(LDKCResult_NodeAnnouncementInfoDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_NodeAnnouncementInfoDecodeErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NodeAnnouncementInfoDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_NodeAnnouncementInfoDecodeErrorZ_get_err(LDKCResult_NodeAnnouncementInfoDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_NodeAnnouncementInfoDecodeErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NodeAnnouncementInfoDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKNodeInfo CResult_NodeInfoDecodeErrorZ_get_ok(LDKCResult_NodeInfoDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_NodeInfoDecodeErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NodeInfoDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_NodeInfoDecodeErrorZ_get_err(LDKCResult_NodeInfoDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_NodeInfoDecodeErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NodeInfoDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKNetworkGraph CResult_NetworkGraphDecodeErrorZ_get_ok(LDKCResult_NetworkGraphDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_NetworkGraphDecodeErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NetworkGraphDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_NetworkGraphDecodeErrorZ_get_err(LDKCResult_NetworkGraphDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_NetworkGraphDecodeErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NetworkGraphDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
/* @internal */
export class LDKCOption_CVec_NetAddressZZ {
	protected constructor() {}
}
/* @internal */
export function LDKCOption_CVec_NetAddressZZ_ty_from_ptr(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_CVec_NetAddressZZ_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKCOption_CVec_NetAddressZZ_Some_get_some(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_CVec_NetAddressZZ_Some_get_some(ptr);
	return nativeResponseValue;
}
	// struct LDKNetAddress CResult_NetAddressDecodeErrorZ_get_ok(LDKCResult_NetAddressDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_NetAddressDecodeErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NetAddressDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_NetAddressDecodeErrorZ_get_err(LDKCResult_NetAddressDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_NetAddressDecodeErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NetAddressDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKAcceptChannel CResult_AcceptChannelDecodeErrorZ_get_ok(LDKCResult_AcceptChannelDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_AcceptChannelDecodeErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_AcceptChannelDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_AcceptChannelDecodeErrorZ_get_err(LDKCResult_AcceptChannelDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_AcceptChannelDecodeErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_AcceptChannelDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKAnnouncementSignatures CResult_AnnouncementSignaturesDecodeErrorZ_get_ok(LDKCResult_AnnouncementSignaturesDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_AnnouncementSignaturesDecodeErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_AnnouncementSignaturesDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_AnnouncementSignaturesDecodeErrorZ_get_err(LDKCResult_AnnouncementSignaturesDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_AnnouncementSignaturesDecodeErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_AnnouncementSignaturesDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKChannelReestablish CResult_ChannelReestablishDecodeErrorZ_get_ok(LDKCResult_ChannelReestablishDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ChannelReestablishDecodeErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelReestablishDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_ChannelReestablishDecodeErrorZ_get_err(LDKCResult_ChannelReestablishDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ChannelReestablishDecodeErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelReestablishDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKClosingSigned CResult_ClosingSignedDecodeErrorZ_get_ok(LDKCResult_ClosingSignedDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ClosingSignedDecodeErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ClosingSignedDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_ClosingSignedDecodeErrorZ_get_err(LDKCResult_ClosingSignedDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ClosingSignedDecodeErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ClosingSignedDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKClosingSignedFeeRange CResult_ClosingSignedFeeRangeDecodeErrorZ_get_ok(LDKCResult_ClosingSignedFeeRangeDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ClosingSignedFeeRangeDecodeErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ClosingSignedFeeRangeDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_ClosingSignedFeeRangeDecodeErrorZ_get_err(LDKCResult_ClosingSignedFeeRangeDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ClosingSignedFeeRangeDecodeErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ClosingSignedFeeRangeDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKCommitmentSigned CResult_CommitmentSignedDecodeErrorZ_get_ok(LDKCResult_CommitmentSignedDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_CommitmentSignedDecodeErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CommitmentSignedDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_CommitmentSignedDecodeErrorZ_get_err(LDKCResult_CommitmentSignedDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_CommitmentSignedDecodeErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CommitmentSignedDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKFundingCreated CResult_FundingCreatedDecodeErrorZ_get_ok(LDKCResult_FundingCreatedDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_FundingCreatedDecodeErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_FundingCreatedDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_FundingCreatedDecodeErrorZ_get_err(LDKCResult_FundingCreatedDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_FundingCreatedDecodeErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_FundingCreatedDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKFundingSigned CResult_FundingSignedDecodeErrorZ_get_ok(LDKCResult_FundingSignedDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_FundingSignedDecodeErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_FundingSignedDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_FundingSignedDecodeErrorZ_get_err(LDKCResult_FundingSignedDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_FundingSignedDecodeErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_FundingSignedDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKFundingLocked CResult_FundingLockedDecodeErrorZ_get_ok(LDKCResult_FundingLockedDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_FundingLockedDecodeErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_FundingLockedDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_FundingLockedDecodeErrorZ_get_err(LDKCResult_FundingLockedDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_FundingLockedDecodeErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_FundingLockedDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKInit CResult_InitDecodeErrorZ_get_ok(LDKCResult_InitDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_InitDecodeErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InitDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_InitDecodeErrorZ_get_err(LDKCResult_InitDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_InitDecodeErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InitDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKOpenChannel CResult_OpenChannelDecodeErrorZ_get_ok(LDKCResult_OpenChannelDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_OpenChannelDecodeErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_OpenChannelDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_OpenChannelDecodeErrorZ_get_err(LDKCResult_OpenChannelDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_OpenChannelDecodeErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_OpenChannelDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKRevokeAndACK CResult_RevokeAndACKDecodeErrorZ_get_ok(LDKCResult_RevokeAndACKDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_RevokeAndACKDecodeErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RevokeAndACKDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_RevokeAndACKDecodeErrorZ_get_err(LDKCResult_RevokeAndACKDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_RevokeAndACKDecodeErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RevokeAndACKDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKShutdown CResult_ShutdownDecodeErrorZ_get_ok(LDKCResult_ShutdownDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ShutdownDecodeErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ShutdownDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_ShutdownDecodeErrorZ_get_err(LDKCResult_ShutdownDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ShutdownDecodeErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ShutdownDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKUpdateFailHTLC CResult_UpdateFailHTLCDecodeErrorZ_get_ok(LDKCResult_UpdateFailHTLCDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_UpdateFailHTLCDecodeErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UpdateFailHTLCDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_UpdateFailHTLCDecodeErrorZ_get_err(LDKCResult_UpdateFailHTLCDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_UpdateFailHTLCDecodeErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UpdateFailHTLCDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKUpdateFailMalformedHTLC CResult_UpdateFailMalformedHTLCDecodeErrorZ_get_ok(LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_UpdateFailMalformedHTLCDecodeErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UpdateFailMalformedHTLCDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_UpdateFailMalformedHTLCDecodeErrorZ_get_err(LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_UpdateFailMalformedHTLCDecodeErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UpdateFailMalformedHTLCDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKUpdateFee CResult_UpdateFeeDecodeErrorZ_get_ok(LDKCResult_UpdateFeeDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_UpdateFeeDecodeErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UpdateFeeDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_UpdateFeeDecodeErrorZ_get_err(LDKCResult_UpdateFeeDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_UpdateFeeDecodeErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UpdateFeeDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKUpdateFulfillHTLC CResult_UpdateFulfillHTLCDecodeErrorZ_get_ok(LDKCResult_UpdateFulfillHTLCDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_UpdateFulfillHTLCDecodeErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UpdateFulfillHTLCDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_UpdateFulfillHTLCDecodeErrorZ_get_err(LDKCResult_UpdateFulfillHTLCDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_UpdateFulfillHTLCDecodeErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UpdateFulfillHTLCDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKUpdateAddHTLC CResult_UpdateAddHTLCDecodeErrorZ_get_ok(LDKCResult_UpdateAddHTLCDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_UpdateAddHTLCDecodeErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UpdateAddHTLCDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_UpdateAddHTLCDecodeErrorZ_get_err(LDKCResult_UpdateAddHTLCDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_UpdateAddHTLCDecodeErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UpdateAddHTLCDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKPing CResult_PingDecodeErrorZ_get_ok(LDKCResult_PingDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_PingDecodeErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PingDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_PingDecodeErrorZ_get_err(LDKCResult_PingDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_PingDecodeErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PingDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKPong CResult_PongDecodeErrorZ_get_ok(LDKCResult_PongDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_PongDecodeErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PongDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_PongDecodeErrorZ_get_err(LDKCResult_PongDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_PongDecodeErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PongDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKUnsignedChannelAnnouncement CResult_UnsignedChannelAnnouncementDecodeErrorZ_get_ok(LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_UnsignedChannelAnnouncementDecodeErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UnsignedChannelAnnouncementDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_UnsignedChannelAnnouncementDecodeErrorZ_get_err(LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_UnsignedChannelAnnouncementDecodeErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UnsignedChannelAnnouncementDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKChannelAnnouncement CResult_ChannelAnnouncementDecodeErrorZ_get_ok(LDKCResult_ChannelAnnouncementDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ChannelAnnouncementDecodeErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelAnnouncementDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_ChannelAnnouncementDecodeErrorZ_get_err(LDKCResult_ChannelAnnouncementDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ChannelAnnouncementDecodeErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelAnnouncementDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKUnsignedChannelUpdate CResult_UnsignedChannelUpdateDecodeErrorZ_get_ok(LDKCResult_UnsignedChannelUpdateDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_UnsignedChannelUpdateDecodeErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UnsignedChannelUpdateDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_UnsignedChannelUpdateDecodeErrorZ_get_err(LDKCResult_UnsignedChannelUpdateDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_UnsignedChannelUpdateDecodeErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UnsignedChannelUpdateDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKChannelUpdate CResult_ChannelUpdateDecodeErrorZ_get_ok(LDKCResult_ChannelUpdateDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ChannelUpdateDecodeErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelUpdateDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_ChannelUpdateDecodeErrorZ_get_err(LDKCResult_ChannelUpdateDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ChannelUpdateDecodeErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelUpdateDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKErrorMessage CResult_ErrorMessageDecodeErrorZ_get_ok(LDKCResult_ErrorMessageDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ErrorMessageDecodeErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ErrorMessageDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_ErrorMessageDecodeErrorZ_get_err(LDKCResult_ErrorMessageDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ErrorMessageDecodeErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ErrorMessageDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKWarningMessage CResult_WarningMessageDecodeErrorZ_get_ok(LDKCResult_WarningMessageDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_WarningMessageDecodeErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_WarningMessageDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_WarningMessageDecodeErrorZ_get_err(LDKCResult_WarningMessageDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_WarningMessageDecodeErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_WarningMessageDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKUnsignedNodeAnnouncement CResult_UnsignedNodeAnnouncementDecodeErrorZ_get_ok(LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_UnsignedNodeAnnouncementDecodeErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UnsignedNodeAnnouncementDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_UnsignedNodeAnnouncementDecodeErrorZ_get_err(LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_UnsignedNodeAnnouncementDecodeErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UnsignedNodeAnnouncementDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKNodeAnnouncement CResult_NodeAnnouncementDecodeErrorZ_get_ok(LDKCResult_NodeAnnouncementDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_NodeAnnouncementDecodeErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NodeAnnouncementDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_NodeAnnouncementDecodeErrorZ_get_err(LDKCResult_NodeAnnouncementDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_NodeAnnouncementDecodeErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NodeAnnouncementDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKQueryShortChannelIds CResult_QueryShortChannelIdsDecodeErrorZ_get_ok(LDKCResult_QueryShortChannelIdsDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_QueryShortChannelIdsDecodeErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_QueryShortChannelIdsDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_QueryShortChannelIdsDecodeErrorZ_get_err(LDKCResult_QueryShortChannelIdsDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_QueryShortChannelIdsDecodeErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_QueryShortChannelIdsDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKReplyShortChannelIdsEnd CResult_ReplyShortChannelIdsEndDecodeErrorZ_get_ok(LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ReplyShortChannelIdsEndDecodeErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ReplyShortChannelIdsEndDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_ReplyShortChannelIdsEndDecodeErrorZ_get_err(LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ReplyShortChannelIdsEndDecodeErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ReplyShortChannelIdsEndDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKQueryChannelRange CResult_QueryChannelRangeDecodeErrorZ_get_ok(LDKCResult_QueryChannelRangeDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_QueryChannelRangeDecodeErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_QueryChannelRangeDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_QueryChannelRangeDecodeErrorZ_get_err(LDKCResult_QueryChannelRangeDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_QueryChannelRangeDecodeErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_QueryChannelRangeDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKReplyChannelRange CResult_ReplyChannelRangeDecodeErrorZ_get_ok(LDKCResult_ReplyChannelRangeDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ReplyChannelRangeDecodeErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ReplyChannelRangeDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_ReplyChannelRangeDecodeErrorZ_get_err(LDKCResult_ReplyChannelRangeDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_ReplyChannelRangeDecodeErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ReplyChannelRangeDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
	// struct LDKGossipTimestampFilter CResult_GossipTimestampFilterDecodeErrorZ_get_ok(LDKCResult_GossipTimestampFilterDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_GossipTimestampFilterDecodeErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_GossipTimestampFilterDecodeErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKDecodeError CResult_GossipTimestampFilterDecodeErrorZ_get_err(LDKCResult_GossipTimestampFilterDecodeErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_GossipTimestampFilterDecodeErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_GossipTimestampFilterDecodeErrorZ_get_err(owner);
	return nativeResponseValue;
}
/* @internal */
export class LDKSignOrCreationError {
	protected constructor() {}
}
/* @internal */
export function LDKSignOrCreationError_ty_from_ptr(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKSignOrCreationError_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKSignOrCreationError_CreationError_get_creation_error(ptr: number): CreationError {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKSignOrCreationError_CreationError_get_creation_error(ptr);
	return nativeResponseValue;
}
	// struct LDKInvoice CResult_InvoiceSignOrCreationErrorZ_get_ok(LDKCResult_InvoiceSignOrCreationErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_InvoiceSignOrCreationErrorZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InvoiceSignOrCreationErrorZ_get_ok(owner);
	return nativeResponseValue;
}
	// struct LDKSignOrCreationError CResult_InvoiceSignOrCreationErrorZ_get_err(LDKCResult_InvoiceSignOrCreationErrorZ *NONNULL_PTR owner);
/* @internal */
export function CResult_InvoiceSignOrCreationErrorZ_get_err(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InvoiceSignOrCreationErrorZ_get_err(owner);
	return nativeResponseValue;
}
/* @internal */
export interface LDKFilter {
	register_tx (txid: number, script_pubkey: number): void;
	register_output (output: number): number;
}

/* @internal */
export function LDKFilter_new(impl: LDKFilter): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	var new_obj_idx = js_objs.length;
	for (var i = 0; i < js_objs.length; i++) {
		if (js_objs[i] == null || js_objs[i] == undefined) { new_obj_idx = i; break; }
	}
	js_objs[i] = new WeakRef(impl);
	return wasm.TS_LDKFilter_new(i);
}
	// void Filter_register_tx LDKFilter *NONNULL_PTR this_arg, const uint8_t (*txid)[32], struct LDKu8slice script_pubkey
/* @internal */
export function Filter_register_tx(this_arg: number, txid: number, script_pubkey: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Filter_register_tx(this_arg, txid, script_pubkey);
	// debug statements here
}
	// LDKCOption_C2Tuple_usizeTransactionZZ Filter_register_output LDKFilter *NONNULL_PTR this_arg, struct LDKWatchedOutput output
/* @internal */
export function Filter_register_output(this_arg: number, output: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Filter_register_output(this_arg, output);
	return nativeResponseValue;
}
/* @internal */
export class LDKCOption_FilterZ {
	protected constructor() {}
}
/* @internal */
export function LDKCOption_FilterZ_ty_from_ptr(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_FilterZ_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKCOption_FilterZ_Some_get_some(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKCOption_FilterZ_Some_get_some(ptr);
	return nativeResponseValue;
}
	// struct LDKLockedChannelMonitor *CResult_LockedChannelMonitorNoneZ_get_ok(LDKCResult_LockedChannelMonitorNoneZ *NONNULL_PTR owner);
/* @internal */
export function CResult_LockedChannelMonitorNoneZ_get_ok(owner: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_LockedChannelMonitorNoneZ_get_ok(owner);
	return nativeResponseValue;
}
	// void CResult_LockedChannelMonitorNoneZ_get_err(LDKCResult_LockedChannelMonitorNoneZ *NONNULL_PTR owner);
/* @internal */
export function CResult_LockedChannelMonitorNoneZ_get_err(owner: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_LockedChannelMonitorNoneZ_get_err(owner);
	// debug statements here
}
/* @internal */
export interface LDKMessageSendEventsProvider {
	get_and_clear_pending_msg_events (): number;
}

/* @internal */
export function LDKMessageSendEventsProvider_new(impl: LDKMessageSendEventsProvider): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	var new_obj_idx = js_objs.length;
	for (var i = 0; i < js_objs.length; i++) {
		if (js_objs[i] == null || js_objs[i] == undefined) { new_obj_idx = i; break; }
	}
	js_objs[i] = new WeakRef(impl);
	return wasm.TS_LDKMessageSendEventsProvider_new(i);
}
	// LDKCVec_MessageSendEventZ MessageSendEventsProvider_get_and_clear_pending_msg_events LDKMessageSendEventsProvider *NONNULL_PTR this_arg
/* @internal */
export function MessageSendEventsProvider_get_and_clear_pending_msg_events(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MessageSendEventsProvider_get_and_clear_pending_msg_events(this_arg);
	return nativeResponseValue;
}
/* @internal */
export interface LDKEventHandler {
	handle_event (event: number): void;
}

/* @internal */
export function LDKEventHandler_new(impl: LDKEventHandler): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	var new_obj_idx = js_objs.length;
	for (var i = 0; i < js_objs.length; i++) {
		if (js_objs[i] == null || js_objs[i] == undefined) { new_obj_idx = i; break; }
	}
	js_objs[i] = new WeakRef(impl);
	return wasm.TS_LDKEventHandler_new(i);
}
	// void EventHandler_handle_event LDKEventHandler *NONNULL_PTR this_arg, const struct LDKEvent *NONNULL_PTR event
/* @internal */
export function EventHandler_handle_event(this_arg: number, event: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_EventHandler_handle_event(this_arg, event);
	// debug statements here
}
/* @internal */
export interface LDKEventsProvider {
	process_pending_events (handler: number): void;
}

/* @internal */
export function LDKEventsProvider_new(impl: LDKEventsProvider): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	var new_obj_idx = js_objs.length;
	for (var i = 0; i < js_objs.length; i++) {
		if (js_objs[i] == null || js_objs[i] == undefined) { new_obj_idx = i; break; }
	}
	js_objs[i] = new WeakRef(impl);
	return wasm.TS_LDKEventsProvider_new(i);
}
	// void EventsProvider_process_pending_events LDKEventsProvider *NONNULL_PTR this_arg, struct LDKEventHandler handler
/* @internal */
export function EventsProvider_process_pending_events(this_arg: number, handler: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_EventsProvider_process_pending_events(this_arg, handler);
	// debug statements here
}
/* @internal */
export interface LDKListen {
	block_connected (block: number, height: number): void;
	block_disconnected (header: number, height: number): void;
}

/* @internal */
export function LDKListen_new(impl: LDKListen): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	var new_obj_idx = js_objs.length;
	for (var i = 0; i < js_objs.length; i++) {
		if (js_objs[i] == null || js_objs[i] == undefined) { new_obj_idx = i; break; }
	}
	js_objs[i] = new WeakRef(impl);
	return wasm.TS_LDKListen_new(i);
}
	// void Listen_block_connected LDKListen *NONNULL_PTR this_arg, struct LDKu8slice block, uint32_t height
/* @internal */
export function Listen_block_connected(this_arg: number, block: number, height: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Listen_block_connected(this_arg, block, height);
	// debug statements here
}
	// void Listen_block_disconnected LDKListen *NONNULL_PTR this_arg, const uint8_t (*header)[80], uint32_t height
/* @internal */
export function Listen_block_disconnected(this_arg: number, header: number, height: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Listen_block_disconnected(this_arg, header, height);
	// debug statements here
}
/* @internal */
export interface LDKConfirm {
	transactions_confirmed (header: number, txdata: number, height: number): void;
	transaction_unconfirmed (txid: number): void;
	best_block_updated (header: number, height: number): void;
	get_relevant_txids (): number;
}

/* @internal */
export function LDKConfirm_new(impl: LDKConfirm): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	var new_obj_idx = js_objs.length;
	for (var i = 0; i < js_objs.length; i++) {
		if (js_objs[i] == null || js_objs[i] == undefined) { new_obj_idx = i; break; }
	}
	js_objs[i] = new WeakRef(impl);
	return wasm.TS_LDKConfirm_new(i);
}
	// void Confirm_transactions_confirmed LDKConfirm *NONNULL_PTR this_arg, const uint8_t (*header)[80], struct LDKCVec_C2Tuple_usizeTransactionZZ txdata, uint32_t height
/* @internal */
export function Confirm_transactions_confirmed(this_arg: number, header: number, txdata: number, height: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Confirm_transactions_confirmed(this_arg, header, txdata, height);
	// debug statements here
}
	// void Confirm_transaction_unconfirmed LDKConfirm *NONNULL_PTR this_arg, const uint8_t (*txid)[32]
/* @internal */
export function Confirm_transaction_unconfirmed(this_arg: number, txid: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Confirm_transaction_unconfirmed(this_arg, txid);
	// debug statements here
}
	// void Confirm_best_block_updated LDKConfirm *NONNULL_PTR this_arg, const uint8_t (*header)[80], uint32_t height
/* @internal */
export function Confirm_best_block_updated(this_arg: number, header: number, height: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Confirm_best_block_updated(this_arg, header, height);
	// debug statements here
}
	// LDKCVec_TxidZ Confirm_get_relevant_txids LDKConfirm *NONNULL_PTR this_arg
/* @internal */
export function Confirm_get_relevant_txids(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Confirm_get_relevant_txids(this_arg);
	return nativeResponseValue;
}
/* @internal */
export interface LDKPersist {
	persist_new_channel (channel_id: number, data: number, update_id: number): number;
	update_persisted_channel (channel_id: number, update: number, data: number, update_id: number): number;
}

/* @internal */
export function LDKPersist_new(impl: LDKPersist): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	var new_obj_idx = js_objs.length;
	for (var i = 0; i < js_objs.length; i++) {
		if (js_objs[i] == null || js_objs[i] == undefined) { new_obj_idx = i; break; }
	}
	js_objs[i] = new WeakRef(impl);
	return wasm.TS_LDKPersist_new(i);
}
	// LDKCResult_NoneChannelMonitorUpdateErrZ Persist_persist_new_channel LDKPersist *NONNULL_PTR this_arg, struct LDKOutPoint channel_id, const struct LDKChannelMonitor *NONNULL_PTR data, struct LDKMonitorUpdateId update_id
/* @internal */
export function Persist_persist_new_channel(this_arg: number, channel_id: number, data: number, update_id: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Persist_persist_new_channel(this_arg, channel_id, data, update_id);
	return nativeResponseValue;
}
	// LDKCResult_NoneChannelMonitorUpdateErrZ Persist_update_persisted_channel LDKPersist *NONNULL_PTR this_arg, struct LDKOutPoint channel_id, const struct LDKChannelMonitorUpdate *NONNULL_PTR update, const struct LDKChannelMonitor *NONNULL_PTR data, struct LDKMonitorUpdateId update_id
/* @internal */
export function Persist_update_persisted_channel(this_arg: number, channel_id: number, update: number, data: number, update_id: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Persist_update_persisted_channel(this_arg, channel_id, update, data, update_id);
	return nativeResponseValue;
}
/* @internal */
export interface LDKChannelMessageHandler {
	handle_open_channel (their_node_id: number, their_features: number, msg: number): void;
	handle_accept_channel (their_node_id: number, their_features: number, msg: number): void;
	handle_funding_created (their_node_id: number, msg: number): void;
	handle_funding_signed (their_node_id: number, msg: number): void;
	handle_funding_locked (their_node_id: number, msg: number): void;
	handle_shutdown (their_node_id: number, their_features: number, msg: number): void;
	handle_closing_signed (their_node_id: number, msg: number): void;
	handle_update_add_htlc (their_node_id: number, msg: number): void;
	handle_update_fulfill_htlc (their_node_id: number, msg: number): void;
	handle_update_fail_htlc (their_node_id: number, msg: number): void;
	handle_update_fail_malformed_htlc (their_node_id: number, msg: number): void;
	handle_commitment_signed (their_node_id: number, msg: number): void;
	handle_revoke_and_ack (their_node_id: number, msg: number): void;
	handle_update_fee (their_node_id: number, msg: number): void;
	handle_announcement_signatures (their_node_id: number, msg: number): void;
	peer_disconnected (their_node_id: number, no_connection_possible: boolean): void;
	peer_connected (their_node_id: number, msg: number): void;
	handle_channel_reestablish (their_node_id: number, msg: number): void;
	handle_channel_update (their_node_id: number, msg: number): void;
	handle_error (their_node_id: number, msg: number): void;
}

/* @internal */
export function LDKChannelMessageHandler_new(impl: LDKChannelMessageHandler, MessageSendEventsProvider: LDKMessageSendEventsProvider): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	var new_obj_idx = js_objs.length;
	for (var i = 0; i < js_objs.length; i++) {
		if (js_objs[i] == null || js_objs[i] == undefined) { new_obj_idx = i; break; }
	}
	js_objs[i] = new WeakRef(impl);
	return wasm.TS_LDKChannelMessageHandler_new(i);
}
	// void ChannelMessageHandler_handle_open_channel LDKChannelMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, struct LDKInitFeatures their_features, const struct LDKOpenChannel *NONNULL_PTR msg
/* @internal */
export function ChannelMessageHandler_handle_open_channel(this_arg: number, their_node_id: number, their_features: number, msg: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMessageHandler_handle_open_channel(this_arg, their_node_id, their_features, msg);
	// debug statements here
}
	// void ChannelMessageHandler_handle_accept_channel LDKChannelMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, struct LDKInitFeatures their_features, const struct LDKAcceptChannel *NONNULL_PTR msg
/* @internal */
export function ChannelMessageHandler_handle_accept_channel(this_arg: number, their_node_id: number, their_features: number, msg: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMessageHandler_handle_accept_channel(this_arg, their_node_id, their_features, msg);
	// debug statements here
}
	// void ChannelMessageHandler_handle_funding_created LDKChannelMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, const struct LDKFundingCreated *NONNULL_PTR msg
/* @internal */
export function ChannelMessageHandler_handle_funding_created(this_arg: number, their_node_id: number, msg: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMessageHandler_handle_funding_created(this_arg, their_node_id, msg);
	// debug statements here
}
	// void ChannelMessageHandler_handle_funding_signed LDKChannelMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, const struct LDKFundingSigned *NONNULL_PTR msg
/* @internal */
export function ChannelMessageHandler_handle_funding_signed(this_arg: number, their_node_id: number, msg: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMessageHandler_handle_funding_signed(this_arg, their_node_id, msg);
	// debug statements here
}
	// void ChannelMessageHandler_handle_funding_locked LDKChannelMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, const struct LDKFundingLocked *NONNULL_PTR msg
/* @internal */
export function ChannelMessageHandler_handle_funding_locked(this_arg: number, their_node_id: number, msg: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMessageHandler_handle_funding_locked(this_arg, their_node_id, msg);
	// debug statements here
}
	// void ChannelMessageHandler_handle_shutdown LDKChannelMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, const struct LDKInitFeatures *NONNULL_PTR their_features, const struct LDKShutdown *NONNULL_PTR msg
/* @internal */
export function ChannelMessageHandler_handle_shutdown(this_arg: number, their_node_id: number, their_features: number, msg: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMessageHandler_handle_shutdown(this_arg, their_node_id, their_features, msg);
	// debug statements here
}
	// void ChannelMessageHandler_handle_closing_signed LDKChannelMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, const struct LDKClosingSigned *NONNULL_PTR msg
/* @internal */
export function ChannelMessageHandler_handle_closing_signed(this_arg: number, their_node_id: number, msg: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMessageHandler_handle_closing_signed(this_arg, their_node_id, msg);
	// debug statements here
}
	// void ChannelMessageHandler_handle_update_add_htlc LDKChannelMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, const struct LDKUpdateAddHTLC *NONNULL_PTR msg
/* @internal */
export function ChannelMessageHandler_handle_update_add_htlc(this_arg: number, their_node_id: number, msg: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMessageHandler_handle_update_add_htlc(this_arg, their_node_id, msg);
	// debug statements here
}
	// void ChannelMessageHandler_handle_update_fulfill_htlc LDKChannelMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, const struct LDKUpdateFulfillHTLC *NONNULL_PTR msg
/* @internal */
export function ChannelMessageHandler_handle_update_fulfill_htlc(this_arg: number, their_node_id: number, msg: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMessageHandler_handle_update_fulfill_htlc(this_arg, their_node_id, msg);
	// debug statements here
}
	// void ChannelMessageHandler_handle_update_fail_htlc LDKChannelMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, const struct LDKUpdateFailHTLC *NONNULL_PTR msg
/* @internal */
export function ChannelMessageHandler_handle_update_fail_htlc(this_arg: number, their_node_id: number, msg: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMessageHandler_handle_update_fail_htlc(this_arg, their_node_id, msg);
	// debug statements here
}
	// void ChannelMessageHandler_handle_update_fail_malformed_htlc LDKChannelMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, const struct LDKUpdateFailMalformedHTLC *NONNULL_PTR msg
/* @internal */
export function ChannelMessageHandler_handle_update_fail_malformed_htlc(this_arg: number, their_node_id: number, msg: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMessageHandler_handle_update_fail_malformed_htlc(this_arg, their_node_id, msg);
	// debug statements here
}
	// void ChannelMessageHandler_handle_commitment_signed LDKChannelMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, const struct LDKCommitmentSigned *NONNULL_PTR msg
/* @internal */
export function ChannelMessageHandler_handle_commitment_signed(this_arg: number, their_node_id: number, msg: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMessageHandler_handle_commitment_signed(this_arg, their_node_id, msg);
	// debug statements here
}
	// void ChannelMessageHandler_handle_revoke_and_ack LDKChannelMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, const struct LDKRevokeAndACK *NONNULL_PTR msg
/* @internal */
export function ChannelMessageHandler_handle_revoke_and_ack(this_arg: number, their_node_id: number, msg: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMessageHandler_handle_revoke_and_ack(this_arg, their_node_id, msg);
	// debug statements here
}
	// void ChannelMessageHandler_handle_update_fee LDKChannelMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, const struct LDKUpdateFee *NONNULL_PTR msg
/* @internal */
export function ChannelMessageHandler_handle_update_fee(this_arg: number, their_node_id: number, msg: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMessageHandler_handle_update_fee(this_arg, their_node_id, msg);
	// debug statements here
}
	// void ChannelMessageHandler_handle_announcement_signatures LDKChannelMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, const struct LDKAnnouncementSignatures *NONNULL_PTR msg
/* @internal */
export function ChannelMessageHandler_handle_announcement_signatures(this_arg: number, their_node_id: number, msg: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMessageHandler_handle_announcement_signatures(this_arg, their_node_id, msg);
	// debug statements here
}
	// void ChannelMessageHandler_peer_disconnected LDKChannelMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, bool no_connection_possible
/* @internal */
export function ChannelMessageHandler_peer_disconnected(this_arg: number, their_node_id: number, no_connection_possible: boolean): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMessageHandler_peer_disconnected(this_arg, their_node_id, no_connection_possible);
	// debug statements here
}
	// void ChannelMessageHandler_peer_connected LDKChannelMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, const struct LDKInit *NONNULL_PTR msg
/* @internal */
export function ChannelMessageHandler_peer_connected(this_arg: number, their_node_id: number, msg: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMessageHandler_peer_connected(this_arg, their_node_id, msg);
	// debug statements here
}
	// void ChannelMessageHandler_handle_channel_reestablish LDKChannelMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, const struct LDKChannelReestablish *NONNULL_PTR msg
/* @internal */
export function ChannelMessageHandler_handle_channel_reestablish(this_arg: number, their_node_id: number, msg: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMessageHandler_handle_channel_reestablish(this_arg, their_node_id, msg);
	// debug statements here
}
	// void ChannelMessageHandler_handle_channel_update LDKChannelMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, const struct LDKChannelUpdate *NONNULL_PTR msg
/* @internal */
export function ChannelMessageHandler_handle_channel_update(this_arg: number, their_node_id: number, msg: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMessageHandler_handle_channel_update(this_arg, their_node_id, msg);
	// debug statements here
}
	// void ChannelMessageHandler_handle_error LDKChannelMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, const struct LDKErrorMessage *NONNULL_PTR msg
/* @internal */
export function ChannelMessageHandler_handle_error(this_arg: number, their_node_id: number, msg: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMessageHandler_handle_error(this_arg, their_node_id, msg);
	// debug statements here
}
/* @internal */
export interface LDKRoutingMessageHandler {
	handle_node_announcement (msg: number): number;
	handle_channel_announcement (msg: number): number;
	handle_channel_update (msg: number): number;
	get_next_channel_announcements (starting_point: bigint, batch_amount: number): number;
	get_next_node_announcements (starting_point: number, batch_amount: number): number;
	peer_connected (their_node_id: number, init: number): void;
	handle_reply_channel_range (their_node_id: number, msg: number): number;
	handle_reply_short_channel_ids_end (their_node_id: number, msg: number): number;
	handle_query_channel_range (their_node_id: number, msg: number): number;
	handle_query_short_channel_ids (their_node_id: number, msg: number): number;
}

/* @internal */
export function LDKRoutingMessageHandler_new(impl: LDKRoutingMessageHandler, MessageSendEventsProvider: LDKMessageSendEventsProvider): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	var new_obj_idx = js_objs.length;
	for (var i = 0; i < js_objs.length; i++) {
		if (js_objs[i] == null || js_objs[i] == undefined) { new_obj_idx = i; break; }
	}
	js_objs[i] = new WeakRef(impl);
	return wasm.TS_LDKRoutingMessageHandler_new(i);
}
	// LDKCResult_boolLightningErrorZ RoutingMessageHandler_handle_node_announcement LDKRoutingMessageHandler *NONNULL_PTR this_arg, const struct LDKNodeAnnouncement *NONNULL_PTR msg
/* @internal */
export function RoutingMessageHandler_handle_node_announcement(this_arg: number, msg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RoutingMessageHandler_handle_node_announcement(this_arg, msg);
	return nativeResponseValue;
}
	// LDKCResult_boolLightningErrorZ RoutingMessageHandler_handle_channel_announcement LDKRoutingMessageHandler *NONNULL_PTR this_arg, const struct LDKChannelAnnouncement *NONNULL_PTR msg
/* @internal */
export function RoutingMessageHandler_handle_channel_announcement(this_arg: number, msg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RoutingMessageHandler_handle_channel_announcement(this_arg, msg);
	return nativeResponseValue;
}
	// LDKCResult_boolLightningErrorZ RoutingMessageHandler_handle_channel_update LDKRoutingMessageHandler *NONNULL_PTR this_arg, const struct LDKChannelUpdate *NONNULL_PTR msg
/* @internal */
export function RoutingMessageHandler_handle_channel_update(this_arg: number, msg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RoutingMessageHandler_handle_channel_update(this_arg, msg);
	return nativeResponseValue;
}
	// LDKCVec_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ RoutingMessageHandler_get_next_channel_announcements LDKRoutingMessageHandler *NONNULL_PTR this_arg, uint64_t starting_point, uint8_t batch_amount
/* @internal */
export function RoutingMessageHandler_get_next_channel_announcements(this_arg: number, starting_point: bigint, batch_amount: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RoutingMessageHandler_get_next_channel_announcements(this_arg, starting_point, batch_amount);
	return nativeResponseValue;
}
	// LDKCVec_NodeAnnouncementZ RoutingMessageHandler_get_next_node_announcements LDKRoutingMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey starting_point, uint8_t batch_amount
/* @internal */
export function RoutingMessageHandler_get_next_node_announcements(this_arg: number, starting_point: number, batch_amount: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RoutingMessageHandler_get_next_node_announcements(this_arg, starting_point, batch_amount);
	return nativeResponseValue;
}
	// void RoutingMessageHandler_peer_connected LDKRoutingMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, const struct LDKInit *NONNULL_PTR init
/* @internal */
export function RoutingMessageHandler_peer_connected(this_arg: number, their_node_id: number, init: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RoutingMessageHandler_peer_connected(this_arg, their_node_id, init);
	// debug statements here
}
	// LDKCResult_NoneLightningErrorZ RoutingMessageHandler_handle_reply_channel_range LDKRoutingMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, struct LDKReplyChannelRange msg
/* @internal */
export function RoutingMessageHandler_handle_reply_channel_range(this_arg: number, their_node_id: number, msg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RoutingMessageHandler_handle_reply_channel_range(this_arg, their_node_id, msg);
	return nativeResponseValue;
}
	// LDKCResult_NoneLightningErrorZ RoutingMessageHandler_handle_reply_short_channel_ids_end LDKRoutingMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, struct LDKReplyShortChannelIdsEnd msg
/* @internal */
export function RoutingMessageHandler_handle_reply_short_channel_ids_end(this_arg: number, their_node_id: number, msg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RoutingMessageHandler_handle_reply_short_channel_ids_end(this_arg, their_node_id, msg);
	return nativeResponseValue;
}
	// LDKCResult_NoneLightningErrorZ RoutingMessageHandler_handle_query_channel_range LDKRoutingMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, struct LDKQueryChannelRange msg
/* @internal */
export function RoutingMessageHandler_handle_query_channel_range(this_arg: number, their_node_id: number, msg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RoutingMessageHandler_handle_query_channel_range(this_arg, their_node_id, msg);
	return nativeResponseValue;
}
	// LDKCResult_NoneLightningErrorZ RoutingMessageHandler_handle_query_short_channel_ids LDKRoutingMessageHandler *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, struct LDKQueryShortChannelIds msg
/* @internal */
export function RoutingMessageHandler_handle_query_short_channel_ids(this_arg: number, their_node_id: number, msg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RoutingMessageHandler_handle_query_short_channel_ids(this_arg, their_node_id, msg);
	return nativeResponseValue;
}
/* @internal */
export interface LDKCustomMessageReader {
	read (message_type: number, buffer: number): number;
}

/* @internal */
export function LDKCustomMessageReader_new(impl: LDKCustomMessageReader): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	var new_obj_idx = js_objs.length;
	for (var i = 0; i < js_objs.length; i++) {
		if (js_objs[i] == null || js_objs[i] == undefined) { new_obj_idx = i; break; }
	}
	js_objs[i] = new WeakRef(impl);
	return wasm.TS_LDKCustomMessageReader_new(i);
}
	// LDKCResult_COption_TypeZDecodeErrorZ CustomMessageReader_read LDKCustomMessageReader *NONNULL_PTR this_arg, uint16_t message_type, struct LDKu8slice buffer
/* @internal */
export function CustomMessageReader_read(this_arg: number, message_type: number, buffer: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CustomMessageReader_read(this_arg, message_type, buffer);
	return nativeResponseValue;
}
/* @internal */
export interface LDKCustomMessageHandler {
	handle_custom_message (msg: number, sender_node_id: number): number;
	get_and_clear_pending_msg (): number;
}

/* @internal */
export function LDKCustomMessageHandler_new(impl: LDKCustomMessageHandler, CustomMessageReader: LDKCustomMessageReader): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	var new_obj_idx = js_objs.length;
	for (var i = 0; i < js_objs.length; i++) {
		if (js_objs[i] == null || js_objs[i] == undefined) { new_obj_idx = i; break; }
	}
	js_objs[i] = new WeakRef(impl);
	return wasm.TS_LDKCustomMessageHandler_new(i);
}
	// LDKCResult_NoneLightningErrorZ CustomMessageHandler_handle_custom_message LDKCustomMessageHandler *NONNULL_PTR this_arg, struct LDKType msg, struct LDKPublicKey sender_node_id
/* @internal */
export function CustomMessageHandler_handle_custom_message(this_arg: number, msg: number, sender_node_id: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CustomMessageHandler_handle_custom_message(this_arg, msg, sender_node_id);
	return nativeResponseValue;
}
	// LDKCVec_C2Tuple_PublicKeyTypeZZ CustomMessageHandler_get_and_clear_pending_msg LDKCustomMessageHandler *NONNULL_PTR this_arg
/* @internal */
export function CustomMessageHandler_get_and_clear_pending_msg(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CustomMessageHandler_get_and_clear_pending_msg(this_arg);
	return nativeResponseValue;
}
/* @internal */
export interface LDKSocketDescriptor {
	send_data (data: number, resume_read: boolean): number;
	disconnect_socket (): void;
	eq (other_arg: number): boolean;
	hash (): bigint;
}

/* @internal */
export function LDKSocketDescriptor_new(impl: LDKSocketDescriptor): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	var new_obj_idx = js_objs.length;
	for (var i = 0; i < js_objs.length; i++) {
		if (js_objs[i] == null || js_objs[i] == undefined) { new_obj_idx = i; break; }
	}
	js_objs[i] = new WeakRef(impl);
	return wasm.TS_LDKSocketDescriptor_new(i);
}
	// uintptr_t SocketDescriptor_send_data LDKSocketDescriptor *NONNULL_PTR this_arg, struct LDKu8slice data, bool resume_read
/* @internal */
export function SocketDescriptor_send_data(this_arg: number, data: number, resume_read: boolean): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SocketDescriptor_send_data(this_arg, data, resume_read);
	return nativeResponseValue;
}
	// void SocketDescriptor_disconnect_socket LDKSocketDescriptor *NONNULL_PTR this_arg
/* @internal */
export function SocketDescriptor_disconnect_socket(this_arg: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SocketDescriptor_disconnect_socket(this_arg);
	// debug statements here
}
	// uint64_t SocketDescriptor_hash LDKSocketDescriptor *NONNULL_PTR this_arg
/* @internal */
export function SocketDescriptor_hash(this_arg: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SocketDescriptor_hash(this_arg);
	return nativeResponseValue;
}
/* @internal */
export class LDKEffectiveCapacity {
	protected constructor() {}
}
/* @internal */
export function LDKEffectiveCapacity_ty_from_ptr(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEffectiveCapacity_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEffectiveCapacity_ExactLiquidity_get_liquidity_msat(ptr: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEffectiveCapacity_ExactLiquidity_get_liquidity_msat(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEffectiveCapacity_MaximumHTLC_get_amount_msat(ptr: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEffectiveCapacity_MaximumHTLC_get_amount_msat(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKEffectiveCapacity_Total_get_capacity_msat(ptr: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKEffectiveCapacity_Total_get_capacity_msat(ptr);
	return nativeResponseValue;
}
/* @internal */
export interface LDKScore {
	channel_penalty_msat (short_channel_id: bigint, send_amt_msat: bigint, capacity_msat: bigint, source: number, target: number): bigint;
	payment_path_failed (path: number, short_channel_id: bigint): void;
	payment_path_successful (path: number): void;
	write (): number;
}

/* @internal */
export function LDKScore_new(impl: LDKScore): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	var new_obj_idx = js_objs.length;
	for (var i = 0; i < js_objs.length; i++) {
		if (js_objs[i] == null || js_objs[i] == undefined) { new_obj_idx = i; break; }
	}
	js_objs[i] = new WeakRef(impl);
	return wasm.TS_LDKScore_new(i);
}
	// uint64_t Score_channel_penalty_msat LDKScore *NONNULL_PTR this_arg, uint64_t short_channel_id, uint64_t send_amt_msat, uint64_t capacity_msat, const struct LDKNodeId *NONNULL_PTR source, const struct LDKNodeId *NONNULL_PTR target
/* @internal */
export function Score_channel_penalty_msat(this_arg: number, short_channel_id: bigint, send_amt_msat: bigint, capacity_msat: bigint, source: number, target: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Score_channel_penalty_msat(this_arg, short_channel_id, send_amt_msat, capacity_msat, source, target);
	return nativeResponseValue;
}
	// void Score_payment_path_failed LDKScore *NONNULL_PTR this_arg, struct LDKCVec_RouteHopZ path, uint64_t short_channel_id
/* @internal */
export function Score_payment_path_failed(this_arg: number, path: number, short_channel_id: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Score_payment_path_failed(this_arg, path, short_channel_id);
	// debug statements here
}
	// void Score_payment_path_successful LDKScore *NONNULL_PTR this_arg, struct LDKCVec_RouteHopZ path
/* @internal */
export function Score_payment_path_successful(this_arg: number, path: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Score_payment_path_successful(this_arg, path);
	// debug statements here
}
	// LDKCVec_u8Z Score_write LDKScore *NONNULL_PTR this_arg
/* @internal */
export function Score_write(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Score_write(this_arg);
	return nativeResponseValue;
}
/* @internal */
export interface LDKLockableScore {
	lock (): number;
}

/* @internal */
export function LDKLockableScore_new(impl: LDKLockableScore): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	var new_obj_idx = js_objs.length;
	for (var i = 0; i < js_objs.length; i++) {
		if (js_objs[i] == null || js_objs[i] == undefined) { new_obj_idx = i; break; }
	}
	js_objs[i] = new WeakRef(impl);
	return wasm.TS_LDKLockableScore_new(i);
}
	// LDKScore LockableScore_lock LDKLockableScore *NONNULL_PTR this_arg
/* @internal */
export function LockableScore_lock(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LockableScore_lock(this_arg);
	return nativeResponseValue;
}
/* @internal */
export class LDKFallback {
	protected constructor() {}
}
/* @internal */
export function LDKFallback_ty_from_ptr(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKFallback_ty_from_ptr(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKFallback_SegWitProgram_get_version(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKFallback_SegWitProgram_get_version(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKFallback_SegWitProgram_get_program(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKFallback_SegWitProgram_get_program(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKFallback_PubKeyHash_get_pub_key_hash(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKFallback_PubKeyHash_get_pub_key_hash(ptr);
	return nativeResponseValue;
}
/* @internal */
export function LDKFallback_ScriptHash_get_script_hash(ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LDKFallback_ScriptHash_get_script_hash(ptr);
	return nativeResponseValue;
}
/* @internal */
export interface LDKPayer {
	node_id (): number;
	first_hops (): number;
	send_payment (route: number, payment_hash: number, payment_secret: number): number;
	send_spontaneous_payment (route: number, payment_preimage: number): number;
	retry_payment (route: number, payment_id: number): number;
	abandon_payment (payment_id: number): void;
}

/* @internal */
export function LDKPayer_new(impl: LDKPayer): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	var new_obj_idx = js_objs.length;
	for (var i = 0; i < js_objs.length; i++) {
		if (js_objs[i] == null || js_objs[i] == undefined) { new_obj_idx = i; break; }
	}
	js_objs[i] = new WeakRef(impl);
	return wasm.TS_LDKPayer_new(i);
}
	// LDKPublicKey Payer_node_id LDKPayer *NONNULL_PTR this_arg
/* @internal */
export function Payer_node_id(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Payer_node_id(this_arg);
	return nativeResponseValue;
}
	// LDKCVec_ChannelDetailsZ Payer_first_hops LDKPayer *NONNULL_PTR this_arg
/* @internal */
export function Payer_first_hops(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Payer_first_hops(this_arg);
	return nativeResponseValue;
}
	// LDKCResult_PaymentIdPaymentSendFailureZ Payer_send_payment LDKPayer *NONNULL_PTR this_arg, const struct LDKRoute *NONNULL_PTR route, struct LDKThirtyTwoBytes payment_hash, struct LDKThirtyTwoBytes payment_secret
/* @internal */
export function Payer_send_payment(this_arg: number, route: number, payment_hash: number, payment_secret: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Payer_send_payment(this_arg, route, payment_hash, payment_secret);
	return nativeResponseValue;
}
	// LDKCResult_PaymentIdPaymentSendFailureZ Payer_send_spontaneous_payment LDKPayer *NONNULL_PTR this_arg, const struct LDKRoute *NONNULL_PTR route, struct LDKThirtyTwoBytes payment_preimage
/* @internal */
export function Payer_send_spontaneous_payment(this_arg: number, route: number, payment_preimage: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Payer_send_spontaneous_payment(this_arg, route, payment_preimage);
	return nativeResponseValue;
}
	// LDKCResult_NonePaymentSendFailureZ Payer_retry_payment LDKPayer *NONNULL_PTR this_arg, const struct LDKRoute *NONNULL_PTR route, struct LDKThirtyTwoBytes payment_id
/* @internal */
export function Payer_retry_payment(this_arg: number, route: number, payment_id: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Payer_retry_payment(this_arg, route, payment_id);
	return nativeResponseValue;
}
	// void Payer_abandon_payment LDKPayer *NONNULL_PTR this_arg, struct LDKThirtyTwoBytes payment_id
/* @internal */
export function Payer_abandon_payment(this_arg: number, payment_id: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Payer_abandon_payment(this_arg, payment_id);
	// debug statements here
}
/* @internal */
export interface LDKRouter {
	find_route (payer: number, route_params: number, payment_hash: number, first_hops: number, scorer: number): number;
}

/* @internal */
export function LDKRouter_new(impl: LDKRouter): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	var new_obj_idx = js_objs.length;
	for (var i = 0; i < js_objs.length; i++) {
		if (js_objs[i] == null || js_objs[i] == undefined) { new_obj_idx = i; break; }
	}
	js_objs[i] = new WeakRef(impl);
	return wasm.TS_LDKRouter_new(i);
}
	// LDKCResult_RouteLightningErrorZ Router_find_route LDKRouter *NONNULL_PTR this_arg, struct LDKPublicKey payer, const struct LDKRouteParameters *NONNULL_PTR route_params, const uint8_t (*payment_hash)[32], struct LDKCVec_ChannelDetailsZ *first_hops, const struct LDKScore *NONNULL_PTR scorer
/* @internal */
export function Router_find_route(this_arg: number, payer: number, route_params: number, payment_hash: number, first_hops: number, scorer: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Router_find_route(this_arg, payer, route_params, payment_hash, first_hops, scorer);
	return nativeResponseValue;
}
	// struct LDKStr _ldk_get_compiled_version(void);
/* @internal */
export function _ldk_get_compiled_version(): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS__ldk_get_compiled_version();
	return nativeResponseValue;
}
	// struct LDKStr _ldk_c_bindings_get_compiled_version(void);
/* @internal */
export function _ldk_c_bindings_get_compiled_version(): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS__ldk_c_bindings_get_compiled_version();
	return nativeResponseValue;
}
	// uintptr_t Bech32Error_clone_ptr(LDKBech32Error *NONNULL_PTR arg);
/* @internal */
export function Bech32Error_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bech32Error_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKBech32Error Bech32Error_clone(const struct LDKBech32Error *NONNULL_PTR orig);
/* @internal */
export function Bech32Error_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bech32Error_clone(orig);
	return nativeResponseValue;
}
	// void Bech32Error_free(struct LDKBech32Error o);
/* @internal */
export function Bech32Error_free(o: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Bech32Error_free(o);
	// debug statements here
}
	// void Transaction_free(struct LDKTransaction _res);
/* @internal */
export function Transaction_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Transaction_free(_res);
	// debug statements here
}
	// struct LDKTxOut TxOut_new(struct LDKCVec_u8Z script_pubkey, uint64_t value);
/* @internal */
export function TxOut_new(script_pubkey: number, value: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxOut_new(script_pubkey, value);
	return nativeResponseValue;
}
	// void TxOut_free(struct LDKTxOut _res);
/* @internal */
export function TxOut_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxOut_free(_res);
	// debug statements here
}
	// uintptr_t TxOut_clone_ptr(LDKTxOut *NONNULL_PTR arg);
/* @internal */
export function TxOut_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxOut_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKTxOut TxOut_clone(const struct LDKTxOut *NONNULL_PTR orig);
/* @internal */
export function TxOut_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxOut_clone(orig);
	return nativeResponseValue;
}
	// void Str_free(struct LDKStr _res);
/* @internal */
export function Str_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Str_free(_res);
	// debug statements here
}
	// struct LDKCResult_NoneNoneZ CResult_NoneNoneZ_ok(void);
/* @internal */
export function CResult_NoneNoneZ_ok(): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneNoneZ_ok();
	return nativeResponseValue;
}
	// struct LDKCResult_NoneNoneZ CResult_NoneNoneZ_err(void);
/* @internal */
export function CResult_NoneNoneZ_err(): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneNoneZ_err();
	return nativeResponseValue;
}
	// bool CResult_NoneNoneZ_is_ok(const struct LDKCResult_NoneNoneZ *NONNULL_PTR o);
/* @internal */
export function CResult_NoneNoneZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneNoneZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_NoneNoneZ_free(struct LDKCResult_NoneNoneZ _res);
/* @internal */
export function CResult_NoneNoneZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneNoneZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_NoneNoneZ_clone_ptr(LDKCResult_NoneNoneZ *NONNULL_PTR arg);
/* @internal */
export function CResult_NoneNoneZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneNoneZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_NoneNoneZ CResult_NoneNoneZ_clone(const struct LDKCResult_NoneNoneZ *NONNULL_PTR orig);
/* @internal */
export function CResult_NoneNoneZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneNoneZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_CounterpartyCommitmentSecretsDecodeErrorZ CResult_CounterpartyCommitmentSecretsDecodeErrorZ_ok(struct LDKCounterpartyCommitmentSecrets o);
/* @internal */
export function CResult_CounterpartyCommitmentSecretsDecodeErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CounterpartyCommitmentSecretsDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_CounterpartyCommitmentSecretsDecodeErrorZ CResult_CounterpartyCommitmentSecretsDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_CounterpartyCommitmentSecretsDecodeErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CounterpartyCommitmentSecretsDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_CounterpartyCommitmentSecretsDecodeErrorZ_is_ok(const struct LDKCResult_CounterpartyCommitmentSecretsDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_CounterpartyCommitmentSecretsDecodeErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CounterpartyCommitmentSecretsDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_CounterpartyCommitmentSecretsDecodeErrorZ_free(struct LDKCResult_CounterpartyCommitmentSecretsDecodeErrorZ _res);
/* @internal */
export function CResult_CounterpartyCommitmentSecretsDecodeErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CounterpartyCommitmentSecretsDecodeErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_CounterpartyCommitmentSecretsDecodeErrorZ_clone_ptr(LDKCResult_CounterpartyCommitmentSecretsDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_CounterpartyCommitmentSecretsDecodeErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CounterpartyCommitmentSecretsDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_CounterpartyCommitmentSecretsDecodeErrorZ CResult_CounterpartyCommitmentSecretsDecodeErrorZ_clone(const struct LDKCResult_CounterpartyCommitmentSecretsDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_CounterpartyCommitmentSecretsDecodeErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CounterpartyCommitmentSecretsDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_SecretKeyErrorZ CResult_SecretKeyErrorZ_ok(struct LDKSecretKey o);
/* @internal */
export function CResult_SecretKeyErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SecretKeyErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_SecretKeyErrorZ CResult_SecretKeyErrorZ_err(enum LDKSecp256k1Error e);
/* @internal */
export function CResult_SecretKeyErrorZ_err(e: Secp256k1Error): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SecretKeyErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_SecretKeyErrorZ_is_ok(const struct LDKCResult_SecretKeyErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_SecretKeyErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SecretKeyErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_SecretKeyErrorZ_free(struct LDKCResult_SecretKeyErrorZ _res);
/* @internal */
export function CResult_SecretKeyErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SecretKeyErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_SecretKeyErrorZ_clone_ptr(LDKCResult_SecretKeyErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_SecretKeyErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SecretKeyErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_SecretKeyErrorZ CResult_SecretKeyErrorZ_clone(const struct LDKCResult_SecretKeyErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_SecretKeyErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SecretKeyErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_PublicKeyErrorZ CResult_PublicKeyErrorZ_ok(struct LDKPublicKey o);
/* @internal */
export function CResult_PublicKeyErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PublicKeyErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_PublicKeyErrorZ CResult_PublicKeyErrorZ_err(enum LDKSecp256k1Error e);
/* @internal */
export function CResult_PublicKeyErrorZ_err(e: Secp256k1Error): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PublicKeyErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_PublicKeyErrorZ_is_ok(const struct LDKCResult_PublicKeyErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_PublicKeyErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PublicKeyErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_PublicKeyErrorZ_free(struct LDKCResult_PublicKeyErrorZ _res);
/* @internal */
export function CResult_PublicKeyErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PublicKeyErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_PublicKeyErrorZ_clone_ptr(LDKCResult_PublicKeyErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_PublicKeyErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PublicKeyErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_PublicKeyErrorZ CResult_PublicKeyErrorZ_clone(const struct LDKCResult_PublicKeyErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_PublicKeyErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PublicKeyErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_TxCreationKeysDecodeErrorZ CResult_TxCreationKeysDecodeErrorZ_ok(struct LDKTxCreationKeys o);
/* @internal */
export function CResult_TxCreationKeysDecodeErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxCreationKeysDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_TxCreationKeysDecodeErrorZ CResult_TxCreationKeysDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_TxCreationKeysDecodeErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxCreationKeysDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_TxCreationKeysDecodeErrorZ_is_ok(const struct LDKCResult_TxCreationKeysDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_TxCreationKeysDecodeErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxCreationKeysDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_TxCreationKeysDecodeErrorZ_free(struct LDKCResult_TxCreationKeysDecodeErrorZ _res);
/* @internal */
export function CResult_TxCreationKeysDecodeErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxCreationKeysDecodeErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_TxCreationKeysDecodeErrorZ_clone_ptr(LDKCResult_TxCreationKeysDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_TxCreationKeysDecodeErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxCreationKeysDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_TxCreationKeysDecodeErrorZ CResult_TxCreationKeysDecodeErrorZ_clone(const struct LDKCResult_TxCreationKeysDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_TxCreationKeysDecodeErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxCreationKeysDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelPublicKeysDecodeErrorZ CResult_ChannelPublicKeysDecodeErrorZ_ok(struct LDKChannelPublicKeys o);
/* @internal */
export function CResult_ChannelPublicKeysDecodeErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelPublicKeysDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelPublicKeysDecodeErrorZ CResult_ChannelPublicKeysDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_ChannelPublicKeysDecodeErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelPublicKeysDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_ChannelPublicKeysDecodeErrorZ_is_ok(const struct LDKCResult_ChannelPublicKeysDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_ChannelPublicKeysDecodeErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelPublicKeysDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_ChannelPublicKeysDecodeErrorZ_free(struct LDKCResult_ChannelPublicKeysDecodeErrorZ _res);
/* @internal */
export function CResult_ChannelPublicKeysDecodeErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelPublicKeysDecodeErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_ChannelPublicKeysDecodeErrorZ_clone_ptr(LDKCResult_ChannelPublicKeysDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_ChannelPublicKeysDecodeErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelPublicKeysDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelPublicKeysDecodeErrorZ CResult_ChannelPublicKeysDecodeErrorZ_clone(const struct LDKCResult_ChannelPublicKeysDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_ChannelPublicKeysDecodeErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelPublicKeysDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_TxCreationKeysErrorZ CResult_TxCreationKeysErrorZ_ok(struct LDKTxCreationKeys o);
/* @internal */
export function CResult_TxCreationKeysErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxCreationKeysErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_TxCreationKeysErrorZ CResult_TxCreationKeysErrorZ_err(enum LDKSecp256k1Error e);
/* @internal */
export function CResult_TxCreationKeysErrorZ_err(e: Secp256k1Error): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxCreationKeysErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_TxCreationKeysErrorZ_is_ok(const struct LDKCResult_TxCreationKeysErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_TxCreationKeysErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxCreationKeysErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_TxCreationKeysErrorZ_free(struct LDKCResult_TxCreationKeysErrorZ _res);
/* @internal */
export function CResult_TxCreationKeysErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxCreationKeysErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_TxCreationKeysErrorZ_clone_ptr(LDKCResult_TxCreationKeysErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_TxCreationKeysErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxCreationKeysErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_TxCreationKeysErrorZ CResult_TxCreationKeysErrorZ_clone(const struct LDKCResult_TxCreationKeysErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_TxCreationKeysErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxCreationKeysErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCOption_u32Z COption_u32Z_some(uint32_t o);
/* @internal */
export function COption_u32Z_some(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_u32Z_some(o);
	return nativeResponseValue;
}
	// struct LDKCOption_u32Z COption_u32Z_none(void);
/* @internal */
export function COption_u32Z_none(): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_u32Z_none();
	return nativeResponseValue;
}
	// void COption_u32Z_free(struct LDKCOption_u32Z _res);
/* @internal */
export function COption_u32Z_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_u32Z_free(_res);
	// debug statements here
}
	// uintptr_t COption_u32Z_clone_ptr(LDKCOption_u32Z *NONNULL_PTR arg);
/* @internal */
export function COption_u32Z_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_u32Z_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCOption_u32Z COption_u32Z_clone(const struct LDKCOption_u32Z *NONNULL_PTR orig);
/* @internal */
export function COption_u32Z_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_u32Z_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_HTLCOutputInCommitmentDecodeErrorZ CResult_HTLCOutputInCommitmentDecodeErrorZ_ok(struct LDKHTLCOutputInCommitment o);
/* @internal */
export function CResult_HTLCOutputInCommitmentDecodeErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_HTLCOutputInCommitmentDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_HTLCOutputInCommitmentDecodeErrorZ CResult_HTLCOutputInCommitmentDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_HTLCOutputInCommitmentDecodeErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_HTLCOutputInCommitmentDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_HTLCOutputInCommitmentDecodeErrorZ_is_ok(const struct LDKCResult_HTLCOutputInCommitmentDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_HTLCOutputInCommitmentDecodeErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_HTLCOutputInCommitmentDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_HTLCOutputInCommitmentDecodeErrorZ_free(struct LDKCResult_HTLCOutputInCommitmentDecodeErrorZ _res);
/* @internal */
export function CResult_HTLCOutputInCommitmentDecodeErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_HTLCOutputInCommitmentDecodeErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_HTLCOutputInCommitmentDecodeErrorZ_clone_ptr(LDKCResult_HTLCOutputInCommitmentDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_HTLCOutputInCommitmentDecodeErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_HTLCOutputInCommitmentDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_HTLCOutputInCommitmentDecodeErrorZ CResult_HTLCOutputInCommitmentDecodeErrorZ_clone(const struct LDKCResult_HTLCOutputInCommitmentDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_HTLCOutputInCommitmentDecodeErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_HTLCOutputInCommitmentDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// enum LDKCOption_NoneZ COption_NoneZ_some(void);
/* @internal */
export function COption_NoneZ_some(): COption_NoneZ {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_NoneZ_some();
	return nativeResponseValue;
}
	// enum LDKCOption_NoneZ COption_NoneZ_none(void);
/* @internal */
export function COption_NoneZ_none(): COption_NoneZ {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_NoneZ_none();
	return nativeResponseValue;
}
	// void COption_NoneZ_free(enum LDKCOption_NoneZ _res);
/* @internal */
export function COption_NoneZ_free(_res: COption_NoneZ): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_NoneZ_free(_res);
	// debug statements here
}
	// struct LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_ok(struct LDKCounterpartyChannelTransactionParameters o);
/* @internal */
export function CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_is_ok(const struct LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_free(struct LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ _res);
/* @internal */
export function CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_clone_ptr(LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_clone(const struct LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelTransactionParametersDecodeErrorZ CResult_ChannelTransactionParametersDecodeErrorZ_ok(struct LDKChannelTransactionParameters o);
/* @internal */
export function CResult_ChannelTransactionParametersDecodeErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelTransactionParametersDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelTransactionParametersDecodeErrorZ CResult_ChannelTransactionParametersDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_ChannelTransactionParametersDecodeErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelTransactionParametersDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_ChannelTransactionParametersDecodeErrorZ_is_ok(const struct LDKCResult_ChannelTransactionParametersDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_ChannelTransactionParametersDecodeErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelTransactionParametersDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_ChannelTransactionParametersDecodeErrorZ_free(struct LDKCResult_ChannelTransactionParametersDecodeErrorZ _res);
/* @internal */
export function CResult_ChannelTransactionParametersDecodeErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelTransactionParametersDecodeErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_ChannelTransactionParametersDecodeErrorZ_clone_ptr(LDKCResult_ChannelTransactionParametersDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_ChannelTransactionParametersDecodeErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelTransactionParametersDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelTransactionParametersDecodeErrorZ CResult_ChannelTransactionParametersDecodeErrorZ_clone(const struct LDKCResult_ChannelTransactionParametersDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_ChannelTransactionParametersDecodeErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelTransactionParametersDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// void CVec_SignatureZ_free(struct LDKCVec_SignatureZ _res);
/* @internal */
export function CVec_SignatureZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CVec_SignatureZ_free(_res);
	// debug statements here
}
	// struct LDKCResult_HolderCommitmentTransactionDecodeErrorZ CResult_HolderCommitmentTransactionDecodeErrorZ_ok(struct LDKHolderCommitmentTransaction o);
/* @internal */
export function CResult_HolderCommitmentTransactionDecodeErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_HolderCommitmentTransactionDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_HolderCommitmentTransactionDecodeErrorZ CResult_HolderCommitmentTransactionDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_HolderCommitmentTransactionDecodeErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_HolderCommitmentTransactionDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_HolderCommitmentTransactionDecodeErrorZ_is_ok(const struct LDKCResult_HolderCommitmentTransactionDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_HolderCommitmentTransactionDecodeErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_HolderCommitmentTransactionDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_HolderCommitmentTransactionDecodeErrorZ_free(struct LDKCResult_HolderCommitmentTransactionDecodeErrorZ _res);
/* @internal */
export function CResult_HolderCommitmentTransactionDecodeErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_HolderCommitmentTransactionDecodeErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_HolderCommitmentTransactionDecodeErrorZ_clone_ptr(LDKCResult_HolderCommitmentTransactionDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_HolderCommitmentTransactionDecodeErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_HolderCommitmentTransactionDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_HolderCommitmentTransactionDecodeErrorZ CResult_HolderCommitmentTransactionDecodeErrorZ_clone(const struct LDKCResult_HolderCommitmentTransactionDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_HolderCommitmentTransactionDecodeErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_HolderCommitmentTransactionDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_BuiltCommitmentTransactionDecodeErrorZ CResult_BuiltCommitmentTransactionDecodeErrorZ_ok(struct LDKBuiltCommitmentTransaction o);
/* @internal */
export function CResult_BuiltCommitmentTransactionDecodeErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_BuiltCommitmentTransactionDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_BuiltCommitmentTransactionDecodeErrorZ CResult_BuiltCommitmentTransactionDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_BuiltCommitmentTransactionDecodeErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_BuiltCommitmentTransactionDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_BuiltCommitmentTransactionDecodeErrorZ_is_ok(const struct LDKCResult_BuiltCommitmentTransactionDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_BuiltCommitmentTransactionDecodeErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_BuiltCommitmentTransactionDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_BuiltCommitmentTransactionDecodeErrorZ_free(struct LDKCResult_BuiltCommitmentTransactionDecodeErrorZ _res);
/* @internal */
export function CResult_BuiltCommitmentTransactionDecodeErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_BuiltCommitmentTransactionDecodeErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_BuiltCommitmentTransactionDecodeErrorZ_clone_ptr(LDKCResult_BuiltCommitmentTransactionDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_BuiltCommitmentTransactionDecodeErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_BuiltCommitmentTransactionDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_BuiltCommitmentTransactionDecodeErrorZ CResult_BuiltCommitmentTransactionDecodeErrorZ_clone(const struct LDKCResult_BuiltCommitmentTransactionDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_BuiltCommitmentTransactionDecodeErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_BuiltCommitmentTransactionDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_TrustedClosingTransactionNoneZ CResult_TrustedClosingTransactionNoneZ_ok(struct LDKTrustedClosingTransaction o);
/* @internal */
export function CResult_TrustedClosingTransactionNoneZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TrustedClosingTransactionNoneZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_TrustedClosingTransactionNoneZ CResult_TrustedClosingTransactionNoneZ_err(void);
/* @internal */
export function CResult_TrustedClosingTransactionNoneZ_err(): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TrustedClosingTransactionNoneZ_err();
	return nativeResponseValue;
}
	// bool CResult_TrustedClosingTransactionNoneZ_is_ok(const struct LDKCResult_TrustedClosingTransactionNoneZ *NONNULL_PTR o);
/* @internal */
export function CResult_TrustedClosingTransactionNoneZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TrustedClosingTransactionNoneZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_TrustedClosingTransactionNoneZ_free(struct LDKCResult_TrustedClosingTransactionNoneZ _res);
/* @internal */
export function CResult_TrustedClosingTransactionNoneZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TrustedClosingTransactionNoneZ_free(_res);
	// debug statements here
}
	// struct LDKCResult_CommitmentTransactionDecodeErrorZ CResult_CommitmentTransactionDecodeErrorZ_ok(struct LDKCommitmentTransaction o);
/* @internal */
export function CResult_CommitmentTransactionDecodeErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CommitmentTransactionDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_CommitmentTransactionDecodeErrorZ CResult_CommitmentTransactionDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_CommitmentTransactionDecodeErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CommitmentTransactionDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_CommitmentTransactionDecodeErrorZ_is_ok(const struct LDKCResult_CommitmentTransactionDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_CommitmentTransactionDecodeErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CommitmentTransactionDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_CommitmentTransactionDecodeErrorZ_free(struct LDKCResult_CommitmentTransactionDecodeErrorZ _res);
/* @internal */
export function CResult_CommitmentTransactionDecodeErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CommitmentTransactionDecodeErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_CommitmentTransactionDecodeErrorZ_clone_ptr(LDKCResult_CommitmentTransactionDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_CommitmentTransactionDecodeErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CommitmentTransactionDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_CommitmentTransactionDecodeErrorZ CResult_CommitmentTransactionDecodeErrorZ_clone(const struct LDKCResult_CommitmentTransactionDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_CommitmentTransactionDecodeErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CommitmentTransactionDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_TrustedCommitmentTransactionNoneZ CResult_TrustedCommitmentTransactionNoneZ_ok(struct LDKTrustedCommitmentTransaction o);
/* @internal */
export function CResult_TrustedCommitmentTransactionNoneZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TrustedCommitmentTransactionNoneZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_TrustedCommitmentTransactionNoneZ CResult_TrustedCommitmentTransactionNoneZ_err(void);
/* @internal */
export function CResult_TrustedCommitmentTransactionNoneZ_err(): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TrustedCommitmentTransactionNoneZ_err();
	return nativeResponseValue;
}
	// bool CResult_TrustedCommitmentTransactionNoneZ_is_ok(const struct LDKCResult_TrustedCommitmentTransactionNoneZ *NONNULL_PTR o);
/* @internal */
export function CResult_TrustedCommitmentTransactionNoneZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TrustedCommitmentTransactionNoneZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_TrustedCommitmentTransactionNoneZ_free(struct LDKCResult_TrustedCommitmentTransactionNoneZ _res);
/* @internal */
export function CResult_TrustedCommitmentTransactionNoneZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TrustedCommitmentTransactionNoneZ_free(_res);
	// debug statements here
}
	// struct LDKCResult_CVec_SignatureZNoneZ CResult_CVec_SignatureZNoneZ_ok(struct LDKCVec_SignatureZ o);
/* @internal */
export function CResult_CVec_SignatureZNoneZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CVec_SignatureZNoneZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_CVec_SignatureZNoneZ CResult_CVec_SignatureZNoneZ_err(void);
/* @internal */
export function CResult_CVec_SignatureZNoneZ_err(): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CVec_SignatureZNoneZ_err();
	return nativeResponseValue;
}
	// bool CResult_CVec_SignatureZNoneZ_is_ok(const struct LDKCResult_CVec_SignatureZNoneZ *NONNULL_PTR o);
/* @internal */
export function CResult_CVec_SignatureZNoneZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CVec_SignatureZNoneZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_CVec_SignatureZNoneZ_free(struct LDKCResult_CVec_SignatureZNoneZ _res);
/* @internal */
export function CResult_CVec_SignatureZNoneZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CVec_SignatureZNoneZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_CVec_SignatureZNoneZ_clone_ptr(LDKCResult_CVec_SignatureZNoneZ *NONNULL_PTR arg);
/* @internal */
export function CResult_CVec_SignatureZNoneZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CVec_SignatureZNoneZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_CVec_SignatureZNoneZ CResult_CVec_SignatureZNoneZ_clone(const struct LDKCResult_CVec_SignatureZNoneZ *NONNULL_PTR orig);
/* @internal */
export function CResult_CVec_SignatureZNoneZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CVec_SignatureZNoneZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_ShutdownScriptDecodeErrorZ CResult_ShutdownScriptDecodeErrorZ_ok(struct LDKShutdownScript o);
/* @internal */
export function CResult_ShutdownScriptDecodeErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ShutdownScriptDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_ShutdownScriptDecodeErrorZ CResult_ShutdownScriptDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_ShutdownScriptDecodeErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ShutdownScriptDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_ShutdownScriptDecodeErrorZ_is_ok(const struct LDKCResult_ShutdownScriptDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_ShutdownScriptDecodeErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ShutdownScriptDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_ShutdownScriptDecodeErrorZ_free(struct LDKCResult_ShutdownScriptDecodeErrorZ _res);
/* @internal */
export function CResult_ShutdownScriptDecodeErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ShutdownScriptDecodeErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_ShutdownScriptDecodeErrorZ_clone_ptr(LDKCResult_ShutdownScriptDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_ShutdownScriptDecodeErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ShutdownScriptDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_ShutdownScriptDecodeErrorZ CResult_ShutdownScriptDecodeErrorZ_clone(const struct LDKCResult_ShutdownScriptDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_ShutdownScriptDecodeErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ShutdownScriptDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_ShutdownScriptInvalidShutdownScriptZ CResult_ShutdownScriptInvalidShutdownScriptZ_ok(struct LDKShutdownScript o);
/* @internal */
export function CResult_ShutdownScriptInvalidShutdownScriptZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ShutdownScriptInvalidShutdownScriptZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_ShutdownScriptInvalidShutdownScriptZ CResult_ShutdownScriptInvalidShutdownScriptZ_err(struct LDKInvalidShutdownScript e);
/* @internal */
export function CResult_ShutdownScriptInvalidShutdownScriptZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ShutdownScriptInvalidShutdownScriptZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_ShutdownScriptInvalidShutdownScriptZ_is_ok(const struct LDKCResult_ShutdownScriptInvalidShutdownScriptZ *NONNULL_PTR o);
/* @internal */
export function CResult_ShutdownScriptInvalidShutdownScriptZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ShutdownScriptInvalidShutdownScriptZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_ShutdownScriptInvalidShutdownScriptZ_free(struct LDKCResult_ShutdownScriptInvalidShutdownScriptZ _res);
/* @internal */
export function CResult_ShutdownScriptInvalidShutdownScriptZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ShutdownScriptInvalidShutdownScriptZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_ShutdownScriptInvalidShutdownScriptZ_clone_ptr(LDKCResult_ShutdownScriptInvalidShutdownScriptZ *NONNULL_PTR arg);
/* @internal */
export function CResult_ShutdownScriptInvalidShutdownScriptZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ShutdownScriptInvalidShutdownScriptZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_ShutdownScriptInvalidShutdownScriptZ CResult_ShutdownScriptInvalidShutdownScriptZ_clone(const struct LDKCResult_ShutdownScriptInvalidShutdownScriptZ *NONNULL_PTR orig);
/* @internal */
export function CResult_ShutdownScriptInvalidShutdownScriptZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ShutdownScriptInvalidShutdownScriptZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_RouteHopDecodeErrorZ CResult_RouteHopDecodeErrorZ_ok(struct LDKRouteHop o);
/* @internal */
export function CResult_RouteHopDecodeErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteHopDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_RouteHopDecodeErrorZ CResult_RouteHopDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_RouteHopDecodeErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteHopDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_RouteHopDecodeErrorZ_is_ok(const struct LDKCResult_RouteHopDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_RouteHopDecodeErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteHopDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_RouteHopDecodeErrorZ_free(struct LDKCResult_RouteHopDecodeErrorZ _res);
/* @internal */
export function CResult_RouteHopDecodeErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteHopDecodeErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_RouteHopDecodeErrorZ_clone_ptr(LDKCResult_RouteHopDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_RouteHopDecodeErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteHopDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_RouteHopDecodeErrorZ CResult_RouteHopDecodeErrorZ_clone(const struct LDKCResult_RouteHopDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_RouteHopDecodeErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteHopDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// void CVec_RouteHopZ_free(struct LDKCVec_RouteHopZ _res);
/* @internal */
export function CVec_RouteHopZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CVec_RouteHopZ_free(_res);
	// debug statements here
}
	// void CVec_CVec_RouteHopZZ_free(struct LDKCVec_CVec_RouteHopZZ _res);
/* @internal */
export function CVec_CVec_RouteHopZZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CVec_CVec_RouteHopZZ_free(_res);
	// debug statements here
}
	// struct LDKCResult_RouteDecodeErrorZ CResult_RouteDecodeErrorZ_ok(struct LDKRoute o);
/* @internal */
export function CResult_RouteDecodeErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_RouteDecodeErrorZ CResult_RouteDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_RouteDecodeErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_RouteDecodeErrorZ_is_ok(const struct LDKCResult_RouteDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_RouteDecodeErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_RouteDecodeErrorZ_free(struct LDKCResult_RouteDecodeErrorZ _res);
/* @internal */
export function CResult_RouteDecodeErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteDecodeErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_RouteDecodeErrorZ_clone_ptr(LDKCResult_RouteDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_RouteDecodeErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_RouteDecodeErrorZ CResult_RouteDecodeErrorZ_clone(const struct LDKCResult_RouteDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_RouteDecodeErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_RouteParametersDecodeErrorZ CResult_RouteParametersDecodeErrorZ_ok(struct LDKRouteParameters o);
/* @internal */
export function CResult_RouteParametersDecodeErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteParametersDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_RouteParametersDecodeErrorZ CResult_RouteParametersDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_RouteParametersDecodeErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteParametersDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_RouteParametersDecodeErrorZ_is_ok(const struct LDKCResult_RouteParametersDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_RouteParametersDecodeErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteParametersDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_RouteParametersDecodeErrorZ_free(struct LDKCResult_RouteParametersDecodeErrorZ _res);
/* @internal */
export function CResult_RouteParametersDecodeErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteParametersDecodeErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_RouteParametersDecodeErrorZ_clone_ptr(LDKCResult_RouteParametersDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_RouteParametersDecodeErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteParametersDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_RouteParametersDecodeErrorZ CResult_RouteParametersDecodeErrorZ_clone(const struct LDKCResult_RouteParametersDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_RouteParametersDecodeErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteParametersDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// void CVec_RouteHintZ_free(struct LDKCVec_RouteHintZ _res);
/* @internal */
export function CVec_RouteHintZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CVec_RouteHintZ_free(_res);
	// debug statements here
}
	// struct LDKCOption_u64Z COption_u64Z_some(uint64_t o);
/* @internal */
export function COption_u64Z_some(o: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_u64Z_some(o);
	return nativeResponseValue;
}
	// struct LDKCOption_u64Z COption_u64Z_none(void);
/* @internal */
export function COption_u64Z_none(): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_u64Z_none();
	return nativeResponseValue;
}
	// void COption_u64Z_free(struct LDKCOption_u64Z _res);
/* @internal */
export function COption_u64Z_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_u64Z_free(_res);
	// debug statements here
}
	// uintptr_t COption_u64Z_clone_ptr(LDKCOption_u64Z *NONNULL_PTR arg);
/* @internal */
export function COption_u64Z_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_u64Z_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCOption_u64Z COption_u64Z_clone(const struct LDKCOption_u64Z *NONNULL_PTR orig);
/* @internal */
export function COption_u64Z_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_u64Z_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_PaymentParametersDecodeErrorZ CResult_PaymentParametersDecodeErrorZ_ok(struct LDKPaymentParameters o);
/* @internal */
export function CResult_PaymentParametersDecodeErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentParametersDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_PaymentParametersDecodeErrorZ CResult_PaymentParametersDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_PaymentParametersDecodeErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentParametersDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_PaymentParametersDecodeErrorZ_is_ok(const struct LDKCResult_PaymentParametersDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_PaymentParametersDecodeErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentParametersDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_PaymentParametersDecodeErrorZ_free(struct LDKCResult_PaymentParametersDecodeErrorZ _res);
/* @internal */
export function CResult_PaymentParametersDecodeErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentParametersDecodeErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_PaymentParametersDecodeErrorZ_clone_ptr(LDKCResult_PaymentParametersDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_PaymentParametersDecodeErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentParametersDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_PaymentParametersDecodeErrorZ CResult_PaymentParametersDecodeErrorZ_clone(const struct LDKCResult_PaymentParametersDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_PaymentParametersDecodeErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentParametersDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// void CVec_RouteHintHopZ_free(struct LDKCVec_RouteHintHopZ _res);
/* @internal */
export function CVec_RouteHintHopZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CVec_RouteHintHopZ_free(_res);
	// debug statements here
}
	// struct LDKCResult_RouteHintDecodeErrorZ CResult_RouteHintDecodeErrorZ_ok(struct LDKRouteHint o);
/* @internal */
export function CResult_RouteHintDecodeErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteHintDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_RouteHintDecodeErrorZ CResult_RouteHintDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_RouteHintDecodeErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteHintDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_RouteHintDecodeErrorZ_is_ok(const struct LDKCResult_RouteHintDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_RouteHintDecodeErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteHintDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_RouteHintDecodeErrorZ_free(struct LDKCResult_RouteHintDecodeErrorZ _res);
/* @internal */
export function CResult_RouteHintDecodeErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteHintDecodeErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_RouteHintDecodeErrorZ_clone_ptr(LDKCResult_RouteHintDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_RouteHintDecodeErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteHintDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_RouteHintDecodeErrorZ CResult_RouteHintDecodeErrorZ_clone(const struct LDKCResult_RouteHintDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_RouteHintDecodeErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteHintDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_RouteHintHopDecodeErrorZ CResult_RouteHintHopDecodeErrorZ_ok(struct LDKRouteHintHop o);
/* @internal */
export function CResult_RouteHintHopDecodeErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteHintHopDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_RouteHintHopDecodeErrorZ CResult_RouteHintHopDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_RouteHintHopDecodeErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteHintHopDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_RouteHintHopDecodeErrorZ_is_ok(const struct LDKCResult_RouteHintHopDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_RouteHintHopDecodeErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteHintHopDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_RouteHintHopDecodeErrorZ_free(struct LDKCResult_RouteHintHopDecodeErrorZ _res);
/* @internal */
export function CResult_RouteHintHopDecodeErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteHintHopDecodeErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_RouteHintHopDecodeErrorZ_clone_ptr(LDKCResult_RouteHintHopDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_RouteHintHopDecodeErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteHintHopDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_RouteHintHopDecodeErrorZ CResult_RouteHintHopDecodeErrorZ_clone(const struct LDKCResult_RouteHintHopDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_RouteHintHopDecodeErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteHintHopDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// void CVec_ChannelDetailsZ_free(struct LDKCVec_ChannelDetailsZ _res);
/* @internal */
export function CVec_ChannelDetailsZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CVec_ChannelDetailsZ_free(_res);
	// debug statements here
}
	// struct LDKCResult_RouteLightningErrorZ CResult_RouteLightningErrorZ_ok(struct LDKRoute o);
/* @internal */
export function CResult_RouteLightningErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteLightningErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_RouteLightningErrorZ CResult_RouteLightningErrorZ_err(struct LDKLightningError e);
/* @internal */
export function CResult_RouteLightningErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteLightningErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_RouteLightningErrorZ_is_ok(const struct LDKCResult_RouteLightningErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_RouteLightningErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteLightningErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_RouteLightningErrorZ_free(struct LDKCResult_RouteLightningErrorZ _res);
/* @internal */
export function CResult_RouteLightningErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteLightningErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_RouteLightningErrorZ_clone_ptr(LDKCResult_RouteLightningErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_RouteLightningErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteLightningErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_RouteLightningErrorZ CResult_RouteLightningErrorZ_clone(const struct LDKCResult_RouteLightningErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_RouteLightningErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RouteLightningErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_TxOutAccessErrorZ CResult_TxOutAccessErrorZ_ok(struct LDKTxOut o);
/* @internal */
export function CResult_TxOutAccessErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxOutAccessErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_TxOutAccessErrorZ CResult_TxOutAccessErrorZ_err(enum LDKAccessError e);
/* @internal */
export function CResult_TxOutAccessErrorZ_err(e: AccessError): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxOutAccessErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_TxOutAccessErrorZ_is_ok(const struct LDKCResult_TxOutAccessErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_TxOutAccessErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxOutAccessErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_TxOutAccessErrorZ_free(struct LDKCResult_TxOutAccessErrorZ _res);
/* @internal */
export function CResult_TxOutAccessErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxOutAccessErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_TxOutAccessErrorZ_clone_ptr(LDKCResult_TxOutAccessErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_TxOutAccessErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxOutAccessErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_TxOutAccessErrorZ CResult_TxOutAccessErrorZ_clone(const struct LDKCResult_TxOutAccessErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_TxOutAccessErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TxOutAccessErrorZ_clone(orig);
	return nativeResponseValue;
}
	// uintptr_t C2Tuple_usizeTransactionZ_clone_ptr(LDKC2Tuple_usizeTransactionZ *NONNULL_PTR arg);
/* @internal */
export function C2Tuple_usizeTransactionZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_usizeTransactionZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKC2Tuple_usizeTransactionZ C2Tuple_usizeTransactionZ_clone(const struct LDKC2Tuple_usizeTransactionZ *NONNULL_PTR orig);
/* @internal */
export function C2Tuple_usizeTransactionZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_usizeTransactionZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKC2Tuple_usizeTransactionZ C2Tuple_usizeTransactionZ_new(uintptr_t a, struct LDKTransaction b);
/* @internal */
export function C2Tuple_usizeTransactionZ_new(a: number, b: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_usizeTransactionZ_new(a, b);
	return nativeResponseValue;
}
	// void C2Tuple_usizeTransactionZ_free(struct LDKC2Tuple_usizeTransactionZ _res);
/* @internal */
export function C2Tuple_usizeTransactionZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_usizeTransactionZ_free(_res);
	// debug statements here
}
	// void CVec_C2Tuple_usizeTransactionZZ_free(struct LDKCVec_C2Tuple_usizeTransactionZZ _res);
/* @internal */
export function CVec_C2Tuple_usizeTransactionZZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CVec_C2Tuple_usizeTransactionZZ_free(_res);
	// debug statements here
}
	// void CVec_TxidZ_free(struct LDKCVec_TxidZ _res);
/* @internal */
export function CVec_TxidZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CVec_TxidZ_free(_res);
	// debug statements here
}
	// struct LDKCResult_NoneChannelMonitorUpdateErrZ CResult_NoneChannelMonitorUpdateErrZ_ok(void);
/* @internal */
export function CResult_NoneChannelMonitorUpdateErrZ_ok(): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneChannelMonitorUpdateErrZ_ok();
	return nativeResponseValue;
}
	// struct LDKCResult_NoneChannelMonitorUpdateErrZ CResult_NoneChannelMonitorUpdateErrZ_err(enum LDKChannelMonitorUpdateErr e);
/* @internal */
export function CResult_NoneChannelMonitorUpdateErrZ_err(e: ChannelMonitorUpdateErr): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneChannelMonitorUpdateErrZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_NoneChannelMonitorUpdateErrZ_is_ok(const struct LDKCResult_NoneChannelMonitorUpdateErrZ *NONNULL_PTR o);
/* @internal */
export function CResult_NoneChannelMonitorUpdateErrZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneChannelMonitorUpdateErrZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_NoneChannelMonitorUpdateErrZ_free(struct LDKCResult_NoneChannelMonitorUpdateErrZ _res);
/* @internal */
export function CResult_NoneChannelMonitorUpdateErrZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneChannelMonitorUpdateErrZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_NoneChannelMonitorUpdateErrZ_clone_ptr(LDKCResult_NoneChannelMonitorUpdateErrZ *NONNULL_PTR arg);
/* @internal */
export function CResult_NoneChannelMonitorUpdateErrZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneChannelMonitorUpdateErrZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_NoneChannelMonitorUpdateErrZ CResult_NoneChannelMonitorUpdateErrZ_clone(const struct LDKCResult_NoneChannelMonitorUpdateErrZ *NONNULL_PTR orig);
/* @internal */
export function CResult_NoneChannelMonitorUpdateErrZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneChannelMonitorUpdateErrZ_clone(orig);
	return nativeResponseValue;
}
	// void CVec_MonitorEventZ_free(struct LDKCVec_MonitorEventZ _res);
/* @internal */
export function CVec_MonitorEventZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CVec_MonitorEventZ_free(_res);
	// debug statements here
}
	// struct LDKCOption_C2Tuple_usizeTransactionZZ COption_C2Tuple_usizeTransactionZZ_some(struct LDKC2Tuple_usizeTransactionZ o);
/* @internal */
export function COption_C2Tuple_usizeTransactionZZ_some(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_C2Tuple_usizeTransactionZZ_some(o);
	return nativeResponseValue;
}
	// struct LDKCOption_C2Tuple_usizeTransactionZZ COption_C2Tuple_usizeTransactionZZ_none(void);
/* @internal */
export function COption_C2Tuple_usizeTransactionZZ_none(): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_C2Tuple_usizeTransactionZZ_none();
	return nativeResponseValue;
}
	// void COption_C2Tuple_usizeTransactionZZ_free(struct LDKCOption_C2Tuple_usizeTransactionZZ _res);
/* @internal */
export function COption_C2Tuple_usizeTransactionZZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_C2Tuple_usizeTransactionZZ_free(_res);
	// debug statements here
}
	// uintptr_t COption_C2Tuple_usizeTransactionZZ_clone_ptr(LDKCOption_C2Tuple_usizeTransactionZZ *NONNULL_PTR arg);
/* @internal */
export function COption_C2Tuple_usizeTransactionZZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_C2Tuple_usizeTransactionZZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCOption_C2Tuple_usizeTransactionZZ COption_C2Tuple_usizeTransactionZZ_clone(const struct LDKCOption_C2Tuple_usizeTransactionZZ *NONNULL_PTR orig);
/* @internal */
export function COption_C2Tuple_usizeTransactionZZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_C2Tuple_usizeTransactionZZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCOption_ClosureReasonZ COption_ClosureReasonZ_some(struct LDKClosureReason o);
/* @internal */
export function COption_ClosureReasonZ_some(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_ClosureReasonZ_some(o);
	return nativeResponseValue;
}
	// struct LDKCOption_ClosureReasonZ COption_ClosureReasonZ_none(void);
/* @internal */
export function COption_ClosureReasonZ_none(): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_ClosureReasonZ_none();
	return nativeResponseValue;
}
	// void COption_ClosureReasonZ_free(struct LDKCOption_ClosureReasonZ _res);
/* @internal */
export function COption_ClosureReasonZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_ClosureReasonZ_free(_res);
	// debug statements here
}
	// uintptr_t COption_ClosureReasonZ_clone_ptr(LDKCOption_ClosureReasonZ *NONNULL_PTR arg);
/* @internal */
export function COption_ClosureReasonZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_ClosureReasonZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCOption_ClosureReasonZ COption_ClosureReasonZ_clone(const struct LDKCOption_ClosureReasonZ *NONNULL_PTR orig);
/* @internal */
export function COption_ClosureReasonZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_ClosureReasonZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_COption_ClosureReasonZDecodeErrorZ CResult_COption_ClosureReasonZDecodeErrorZ_ok(struct LDKCOption_ClosureReasonZ o);
/* @internal */
export function CResult_COption_ClosureReasonZDecodeErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_ClosureReasonZDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_COption_ClosureReasonZDecodeErrorZ CResult_COption_ClosureReasonZDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_COption_ClosureReasonZDecodeErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_ClosureReasonZDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_COption_ClosureReasonZDecodeErrorZ_is_ok(const struct LDKCResult_COption_ClosureReasonZDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_COption_ClosureReasonZDecodeErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_ClosureReasonZDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_COption_ClosureReasonZDecodeErrorZ_free(struct LDKCResult_COption_ClosureReasonZDecodeErrorZ _res);
/* @internal */
export function CResult_COption_ClosureReasonZDecodeErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_ClosureReasonZDecodeErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_COption_ClosureReasonZDecodeErrorZ_clone_ptr(LDKCResult_COption_ClosureReasonZDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_COption_ClosureReasonZDecodeErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_ClosureReasonZDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_COption_ClosureReasonZDecodeErrorZ CResult_COption_ClosureReasonZDecodeErrorZ_clone(const struct LDKCResult_COption_ClosureReasonZDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_COption_ClosureReasonZDecodeErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_ClosureReasonZDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCOption_NetworkUpdateZ COption_NetworkUpdateZ_some(struct LDKNetworkUpdate o);
/* @internal */
export function COption_NetworkUpdateZ_some(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_NetworkUpdateZ_some(o);
	return nativeResponseValue;
}
	// struct LDKCOption_NetworkUpdateZ COption_NetworkUpdateZ_none(void);
/* @internal */
export function COption_NetworkUpdateZ_none(): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_NetworkUpdateZ_none();
	return nativeResponseValue;
}
	// void COption_NetworkUpdateZ_free(struct LDKCOption_NetworkUpdateZ _res);
/* @internal */
export function COption_NetworkUpdateZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_NetworkUpdateZ_free(_res);
	// debug statements here
}
	// uintptr_t COption_NetworkUpdateZ_clone_ptr(LDKCOption_NetworkUpdateZ *NONNULL_PTR arg);
/* @internal */
export function COption_NetworkUpdateZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_NetworkUpdateZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCOption_NetworkUpdateZ COption_NetworkUpdateZ_clone(const struct LDKCOption_NetworkUpdateZ *NONNULL_PTR orig);
/* @internal */
export function COption_NetworkUpdateZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_NetworkUpdateZ_clone(orig);
	return nativeResponseValue;
}
	// void CVec_SpendableOutputDescriptorZ_free(struct LDKCVec_SpendableOutputDescriptorZ _res);
/* @internal */
export function CVec_SpendableOutputDescriptorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CVec_SpendableOutputDescriptorZ_free(_res);
	// debug statements here
}
	// struct LDKCOption_EventZ COption_EventZ_some(struct LDKEvent o);
/* @internal */
export function COption_EventZ_some(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_EventZ_some(o);
	return nativeResponseValue;
}
	// struct LDKCOption_EventZ COption_EventZ_none(void);
/* @internal */
export function COption_EventZ_none(): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_EventZ_none();
	return nativeResponseValue;
}
	// void COption_EventZ_free(struct LDKCOption_EventZ _res);
/* @internal */
export function COption_EventZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_EventZ_free(_res);
	// debug statements here
}
	// uintptr_t COption_EventZ_clone_ptr(LDKCOption_EventZ *NONNULL_PTR arg);
/* @internal */
export function COption_EventZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_EventZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCOption_EventZ COption_EventZ_clone(const struct LDKCOption_EventZ *NONNULL_PTR orig);
/* @internal */
export function COption_EventZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_EventZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_COption_EventZDecodeErrorZ CResult_COption_EventZDecodeErrorZ_ok(struct LDKCOption_EventZ o);
/* @internal */
export function CResult_COption_EventZDecodeErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_EventZDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_COption_EventZDecodeErrorZ CResult_COption_EventZDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_COption_EventZDecodeErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_EventZDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_COption_EventZDecodeErrorZ_is_ok(const struct LDKCResult_COption_EventZDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_COption_EventZDecodeErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_EventZDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_COption_EventZDecodeErrorZ_free(struct LDKCResult_COption_EventZDecodeErrorZ _res);
/* @internal */
export function CResult_COption_EventZDecodeErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_EventZDecodeErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_COption_EventZDecodeErrorZ_clone_ptr(LDKCResult_COption_EventZDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_COption_EventZDecodeErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_EventZDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_COption_EventZDecodeErrorZ CResult_COption_EventZDecodeErrorZ_clone(const struct LDKCResult_COption_EventZDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_COption_EventZDecodeErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_EventZDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// void CVec_MessageSendEventZ_free(struct LDKCVec_MessageSendEventZ _res);
/* @internal */
export function CVec_MessageSendEventZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CVec_MessageSendEventZ_free(_res);
	// debug statements here
}
	// struct LDKCResult_FixedPenaltyScorerDecodeErrorZ CResult_FixedPenaltyScorerDecodeErrorZ_ok(struct LDKFixedPenaltyScorer o);
/* @internal */
export function CResult_FixedPenaltyScorerDecodeErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_FixedPenaltyScorerDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_FixedPenaltyScorerDecodeErrorZ CResult_FixedPenaltyScorerDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_FixedPenaltyScorerDecodeErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_FixedPenaltyScorerDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_FixedPenaltyScorerDecodeErrorZ_is_ok(const struct LDKCResult_FixedPenaltyScorerDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_FixedPenaltyScorerDecodeErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_FixedPenaltyScorerDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_FixedPenaltyScorerDecodeErrorZ_free(struct LDKCResult_FixedPenaltyScorerDecodeErrorZ _res);
/* @internal */
export function CResult_FixedPenaltyScorerDecodeErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_FixedPenaltyScorerDecodeErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_FixedPenaltyScorerDecodeErrorZ_clone_ptr(LDKCResult_FixedPenaltyScorerDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_FixedPenaltyScorerDecodeErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_FixedPenaltyScorerDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_FixedPenaltyScorerDecodeErrorZ CResult_FixedPenaltyScorerDecodeErrorZ_clone(const struct LDKCResult_FixedPenaltyScorerDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_FixedPenaltyScorerDecodeErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_FixedPenaltyScorerDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_ScoringParametersDecodeErrorZ CResult_ScoringParametersDecodeErrorZ_ok(struct LDKScoringParameters o);
/* @internal */
export function CResult_ScoringParametersDecodeErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ScoringParametersDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_ScoringParametersDecodeErrorZ CResult_ScoringParametersDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_ScoringParametersDecodeErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ScoringParametersDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_ScoringParametersDecodeErrorZ_is_ok(const struct LDKCResult_ScoringParametersDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_ScoringParametersDecodeErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ScoringParametersDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_ScoringParametersDecodeErrorZ_free(struct LDKCResult_ScoringParametersDecodeErrorZ _res);
/* @internal */
export function CResult_ScoringParametersDecodeErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ScoringParametersDecodeErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_ScoringParametersDecodeErrorZ_clone_ptr(LDKCResult_ScoringParametersDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_ScoringParametersDecodeErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ScoringParametersDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_ScoringParametersDecodeErrorZ CResult_ScoringParametersDecodeErrorZ_clone(const struct LDKCResult_ScoringParametersDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_ScoringParametersDecodeErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ScoringParametersDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_ScorerDecodeErrorZ CResult_ScorerDecodeErrorZ_ok(struct LDKScorer o);
/* @internal */
export function CResult_ScorerDecodeErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ScorerDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_ScorerDecodeErrorZ CResult_ScorerDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_ScorerDecodeErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ScorerDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_ScorerDecodeErrorZ_is_ok(const struct LDKCResult_ScorerDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_ScorerDecodeErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ScorerDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_ScorerDecodeErrorZ_free(struct LDKCResult_ScorerDecodeErrorZ _res);
/* @internal */
export function CResult_ScorerDecodeErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ScorerDecodeErrorZ_free(_res);
	// debug statements here
}
	// struct LDKCResult_ProbabilisticScorerDecodeErrorZ CResult_ProbabilisticScorerDecodeErrorZ_ok(struct LDKProbabilisticScorer o);
/* @internal */
export function CResult_ProbabilisticScorerDecodeErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ProbabilisticScorerDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_ProbabilisticScorerDecodeErrorZ CResult_ProbabilisticScorerDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_ProbabilisticScorerDecodeErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ProbabilisticScorerDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_ProbabilisticScorerDecodeErrorZ_is_ok(const struct LDKCResult_ProbabilisticScorerDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_ProbabilisticScorerDecodeErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ProbabilisticScorerDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_ProbabilisticScorerDecodeErrorZ_free(struct LDKCResult_ProbabilisticScorerDecodeErrorZ _res);
/* @internal */
export function CResult_ProbabilisticScorerDecodeErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ProbabilisticScorerDecodeErrorZ_free(_res);
	// debug statements here
}
	// struct LDKCResult_InitFeaturesDecodeErrorZ CResult_InitFeaturesDecodeErrorZ_ok(struct LDKInitFeatures o);
/* @internal */
export function CResult_InitFeaturesDecodeErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InitFeaturesDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_InitFeaturesDecodeErrorZ CResult_InitFeaturesDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_InitFeaturesDecodeErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InitFeaturesDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_InitFeaturesDecodeErrorZ_is_ok(const struct LDKCResult_InitFeaturesDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_InitFeaturesDecodeErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InitFeaturesDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_InitFeaturesDecodeErrorZ_free(struct LDKCResult_InitFeaturesDecodeErrorZ _res);
/* @internal */
export function CResult_InitFeaturesDecodeErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InitFeaturesDecodeErrorZ_free(_res);
	// debug statements here
}
	// struct LDKCResult_ChannelFeaturesDecodeErrorZ CResult_ChannelFeaturesDecodeErrorZ_ok(struct LDKChannelFeatures o);
/* @internal */
export function CResult_ChannelFeaturesDecodeErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelFeaturesDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelFeaturesDecodeErrorZ CResult_ChannelFeaturesDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_ChannelFeaturesDecodeErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelFeaturesDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_ChannelFeaturesDecodeErrorZ_is_ok(const struct LDKCResult_ChannelFeaturesDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_ChannelFeaturesDecodeErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelFeaturesDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_ChannelFeaturesDecodeErrorZ_free(struct LDKCResult_ChannelFeaturesDecodeErrorZ _res);
/* @internal */
export function CResult_ChannelFeaturesDecodeErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelFeaturesDecodeErrorZ_free(_res);
	// debug statements here
}
	// struct LDKCResult_NodeFeaturesDecodeErrorZ CResult_NodeFeaturesDecodeErrorZ_ok(struct LDKNodeFeatures o);
/* @internal */
export function CResult_NodeFeaturesDecodeErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NodeFeaturesDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_NodeFeaturesDecodeErrorZ CResult_NodeFeaturesDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_NodeFeaturesDecodeErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NodeFeaturesDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_NodeFeaturesDecodeErrorZ_is_ok(const struct LDKCResult_NodeFeaturesDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_NodeFeaturesDecodeErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NodeFeaturesDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_NodeFeaturesDecodeErrorZ_free(struct LDKCResult_NodeFeaturesDecodeErrorZ _res);
/* @internal */
export function CResult_NodeFeaturesDecodeErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NodeFeaturesDecodeErrorZ_free(_res);
	// debug statements here
}
	// struct LDKCResult_InvoiceFeaturesDecodeErrorZ CResult_InvoiceFeaturesDecodeErrorZ_ok(struct LDKInvoiceFeatures o);
/* @internal */
export function CResult_InvoiceFeaturesDecodeErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InvoiceFeaturesDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_InvoiceFeaturesDecodeErrorZ CResult_InvoiceFeaturesDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_InvoiceFeaturesDecodeErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InvoiceFeaturesDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_InvoiceFeaturesDecodeErrorZ_is_ok(const struct LDKCResult_InvoiceFeaturesDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_InvoiceFeaturesDecodeErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InvoiceFeaturesDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_InvoiceFeaturesDecodeErrorZ_free(struct LDKCResult_InvoiceFeaturesDecodeErrorZ _res);
/* @internal */
export function CResult_InvoiceFeaturesDecodeErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InvoiceFeaturesDecodeErrorZ_free(_res);
	// debug statements here
}
	// struct LDKCResult_ChannelTypeFeaturesDecodeErrorZ CResult_ChannelTypeFeaturesDecodeErrorZ_ok(struct LDKChannelTypeFeatures o);
/* @internal */
export function CResult_ChannelTypeFeaturesDecodeErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelTypeFeaturesDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelTypeFeaturesDecodeErrorZ CResult_ChannelTypeFeaturesDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_ChannelTypeFeaturesDecodeErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelTypeFeaturesDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_ChannelTypeFeaturesDecodeErrorZ_is_ok(const struct LDKCResult_ChannelTypeFeaturesDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_ChannelTypeFeaturesDecodeErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelTypeFeaturesDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_ChannelTypeFeaturesDecodeErrorZ_free(struct LDKCResult_ChannelTypeFeaturesDecodeErrorZ _res);
/* @internal */
export function CResult_ChannelTypeFeaturesDecodeErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelTypeFeaturesDecodeErrorZ_free(_res);
	// debug statements here
}
	// struct LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_ok(struct LDKDelayedPaymentOutputDescriptor o);
/* @internal */
export function CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_is_ok(const struct LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_free(struct LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ _res);
/* @internal */
export function CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_clone_ptr(LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_clone(const struct LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ CResult_StaticPaymentOutputDescriptorDecodeErrorZ_ok(struct LDKStaticPaymentOutputDescriptor o);
/* @internal */
export function CResult_StaticPaymentOutputDescriptorDecodeErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_StaticPaymentOutputDescriptorDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ CResult_StaticPaymentOutputDescriptorDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_StaticPaymentOutputDescriptorDecodeErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_StaticPaymentOutputDescriptorDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_StaticPaymentOutputDescriptorDecodeErrorZ_is_ok(const struct LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_StaticPaymentOutputDescriptorDecodeErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_StaticPaymentOutputDescriptorDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_StaticPaymentOutputDescriptorDecodeErrorZ_free(struct LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ _res);
/* @internal */
export function CResult_StaticPaymentOutputDescriptorDecodeErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_StaticPaymentOutputDescriptorDecodeErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_StaticPaymentOutputDescriptorDecodeErrorZ_clone_ptr(LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_StaticPaymentOutputDescriptorDecodeErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_StaticPaymentOutputDescriptorDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ CResult_StaticPaymentOutputDescriptorDecodeErrorZ_clone(const struct LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_StaticPaymentOutputDescriptorDecodeErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_StaticPaymentOutputDescriptorDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_SpendableOutputDescriptorDecodeErrorZ CResult_SpendableOutputDescriptorDecodeErrorZ_ok(struct LDKSpendableOutputDescriptor o);
/* @internal */
export function CResult_SpendableOutputDescriptorDecodeErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SpendableOutputDescriptorDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_SpendableOutputDescriptorDecodeErrorZ CResult_SpendableOutputDescriptorDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_SpendableOutputDescriptorDecodeErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SpendableOutputDescriptorDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_SpendableOutputDescriptorDecodeErrorZ_is_ok(const struct LDKCResult_SpendableOutputDescriptorDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_SpendableOutputDescriptorDecodeErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SpendableOutputDescriptorDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_SpendableOutputDescriptorDecodeErrorZ_free(struct LDKCResult_SpendableOutputDescriptorDecodeErrorZ _res);
/* @internal */
export function CResult_SpendableOutputDescriptorDecodeErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SpendableOutputDescriptorDecodeErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_SpendableOutputDescriptorDecodeErrorZ_clone_ptr(LDKCResult_SpendableOutputDescriptorDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_SpendableOutputDescriptorDecodeErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SpendableOutputDescriptorDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_SpendableOutputDescriptorDecodeErrorZ CResult_SpendableOutputDescriptorDecodeErrorZ_clone(const struct LDKCResult_SpendableOutputDescriptorDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_SpendableOutputDescriptorDecodeErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SpendableOutputDescriptorDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// void CVec_PaymentPreimageZ_free(struct LDKCVec_PaymentPreimageZ _res);
/* @internal */
export function CVec_PaymentPreimageZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CVec_PaymentPreimageZ_free(_res);
	// debug statements here
}
	// uintptr_t C2Tuple_SignatureCVec_SignatureZZ_clone_ptr(LDKC2Tuple_SignatureCVec_SignatureZZ *NONNULL_PTR arg);
/* @internal */
export function C2Tuple_SignatureCVec_SignatureZZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_SignatureCVec_SignatureZZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKC2Tuple_SignatureCVec_SignatureZZ C2Tuple_SignatureCVec_SignatureZZ_clone(const struct LDKC2Tuple_SignatureCVec_SignatureZZ *NONNULL_PTR orig);
/* @internal */
export function C2Tuple_SignatureCVec_SignatureZZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_SignatureCVec_SignatureZZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKC2Tuple_SignatureCVec_SignatureZZ C2Tuple_SignatureCVec_SignatureZZ_new(struct LDKSignature a, struct LDKCVec_SignatureZ b);
/* @internal */
export function C2Tuple_SignatureCVec_SignatureZZ_new(a: number, b: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_SignatureCVec_SignatureZZ_new(a, b);
	return nativeResponseValue;
}
	// void C2Tuple_SignatureCVec_SignatureZZ_free(struct LDKC2Tuple_SignatureCVec_SignatureZZ _res);
/* @internal */
export function C2Tuple_SignatureCVec_SignatureZZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_SignatureCVec_SignatureZZ_free(_res);
	// debug statements here
}
	// struct LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_ok(struct LDKC2Tuple_SignatureCVec_SignatureZZ o);
/* @internal */
export function CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_err(void);
/* @internal */
export function CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_err(): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_err();
	return nativeResponseValue;
}
	// bool CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_is_ok(const struct LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ *NONNULL_PTR o);
/* @internal */
export function CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_free(struct LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ _res);
/* @internal */
export function CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_clone_ptr(LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ *NONNULL_PTR arg);
/* @internal */
export function CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_clone(const struct LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ *NONNULL_PTR orig);
/* @internal */
export function CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_SignatureNoneZ CResult_SignatureNoneZ_ok(struct LDKSignature o);
/* @internal */
export function CResult_SignatureNoneZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SignatureNoneZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_SignatureNoneZ CResult_SignatureNoneZ_err(void);
/* @internal */
export function CResult_SignatureNoneZ_err(): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SignatureNoneZ_err();
	return nativeResponseValue;
}
	// bool CResult_SignatureNoneZ_is_ok(const struct LDKCResult_SignatureNoneZ *NONNULL_PTR o);
/* @internal */
export function CResult_SignatureNoneZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SignatureNoneZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_SignatureNoneZ_free(struct LDKCResult_SignatureNoneZ _res);
/* @internal */
export function CResult_SignatureNoneZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SignatureNoneZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_SignatureNoneZ_clone_ptr(LDKCResult_SignatureNoneZ *NONNULL_PTR arg);
/* @internal */
export function CResult_SignatureNoneZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SignatureNoneZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_SignatureNoneZ CResult_SignatureNoneZ_clone(const struct LDKCResult_SignatureNoneZ *NONNULL_PTR orig);
/* @internal */
export function CResult_SignatureNoneZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SignatureNoneZ_clone(orig);
	return nativeResponseValue;
}
	// uintptr_t C2Tuple_SignatureSignatureZ_clone_ptr(LDKC2Tuple_SignatureSignatureZ *NONNULL_PTR arg);
/* @internal */
export function C2Tuple_SignatureSignatureZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_SignatureSignatureZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKC2Tuple_SignatureSignatureZ C2Tuple_SignatureSignatureZ_clone(const struct LDKC2Tuple_SignatureSignatureZ *NONNULL_PTR orig);
/* @internal */
export function C2Tuple_SignatureSignatureZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_SignatureSignatureZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKC2Tuple_SignatureSignatureZ C2Tuple_SignatureSignatureZ_new(struct LDKSignature a, struct LDKSignature b);
/* @internal */
export function C2Tuple_SignatureSignatureZ_new(a: number, b: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_SignatureSignatureZ_new(a, b);
	return nativeResponseValue;
}
	// void C2Tuple_SignatureSignatureZ_free(struct LDKC2Tuple_SignatureSignatureZ _res);
/* @internal */
export function C2Tuple_SignatureSignatureZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_SignatureSignatureZ_free(_res);
	// debug statements here
}
	// struct LDKCResult_C2Tuple_SignatureSignatureZNoneZ CResult_C2Tuple_SignatureSignatureZNoneZ_ok(struct LDKC2Tuple_SignatureSignatureZ o);
/* @internal */
export function CResult_C2Tuple_SignatureSignatureZNoneZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_SignatureSignatureZNoneZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_C2Tuple_SignatureSignatureZNoneZ CResult_C2Tuple_SignatureSignatureZNoneZ_err(void);
/* @internal */
export function CResult_C2Tuple_SignatureSignatureZNoneZ_err(): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_SignatureSignatureZNoneZ_err();
	return nativeResponseValue;
}
	// bool CResult_C2Tuple_SignatureSignatureZNoneZ_is_ok(const struct LDKCResult_C2Tuple_SignatureSignatureZNoneZ *NONNULL_PTR o);
/* @internal */
export function CResult_C2Tuple_SignatureSignatureZNoneZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_SignatureSignatureZNoneZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_C2Tuple_SignatureSignatureZNoneZ_free(struct LDKCResult_C2Tuple_SignatureSignatureZNoneZ _res);
/* @internal */
export function CResult_C2Tuple_SignatureSignatureZNoneZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_SignatureSignatureZNoneZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_C2Tuple_SignatureSignatureZNoneZ_clone_ptr(LDKCResult_C2Tuple_SignatureSignatureZNoneZ *NONNULL_PTR arg);
/* @internal */
export function CResult_C2Tuple_SignatureSignatureZNoneZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_SignatureSignatureZNoneZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_C2Tuple_SignatureSignatureZNoneZ CResult_C2Tuple_SignatureSignatureZNoneZ_clone(const struct LDKCResult_C2Tuple_SignatureSignatureZNoneZ *NONNULL_PTR orig);
/* @internal */
export function CResult_C2Tuple_SignatureSignatureZNoneZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_SignatureSignatureZNoneZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_SecretKeyNoneZ CResult_SecretKeyNoneZ_ok(struct LDKSecretKey o);
/* @internal */
export function CResult_SecretKeyNoneZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SecretKeyNoneZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_SecretKeyNoneZ CResult_SecretKeyNoneZ_err(void);
/* @internal */
export function CResult_SecretKeyNoneZ_err(): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SecretKeyNoneZ_err();
	return nativeResponseValue;
}
	// bool CResult_SecretKeyNoneZ_is_ok(const struct LDKCResult_SecretKeyNoneZ *NONNULL_PTR o);
/* @internal */
export function CResult_SecretKeyNoneZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SecretKeyNoneZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_SecretKeyNoneZ_free(struct LDKCResult_SecretKeyNoneZ _res);
/* @internal */
export function CResult_SecretKeyNoneZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SecretKeyNoneZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_SecretKeyNoneZ_clone_ptr(LDKCResult_SecretKeyNoneZ *NONNULL_PTR arg);
/* @internal */
export function CResult_SecretKeyNoneZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SecretKeyNoneZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_SecretKeyNoneZ CResult_SecretKeyNoneZ_clone(const struct LDKCResult_SecretKeyNoneZ *NONNULL_PTR orig);
/* @internal */
export function CResult_SecretKeyNoneZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SecretKeyNoneZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_SignDecodeErrorZ CResult_SignDecodeErrorZ_ok(struct LDKSign o);
/* @internal */
export function CResult_SignDecodeErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SignDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_SignDecodeErrorZ CResult_SignDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_SignDecodeErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SignDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_SignDecodeErrorZ_is_ok(const struct LDKCResult_SignDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_SignDecodeErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SignDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_SignDecodeErrorZ_free(struct LDKCResult_SignDecodeErrorZ _res);
/* @internal */
export function CResult_SignDecodeErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SignDecodeErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_SignDecodeErrorZ_clone_ptr(LDKCResult_SignDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_SignDecodeErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SignDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_SignDecodeErrorZ CResult_SignDecodeErrorZ_clone(const struct LDKCResult_SignDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_SignDecodeErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SignDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// void CVec_u5Z_free(struct LDKCVec_u5Z _res);
/* @internal */
export function CVec_u5Z_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CVec_u5Z_free(_res);
	// debug statements here
}
	// struct LDKCResult_RecoverableSignatureNoneZ CResult_RecoverableSignatureNoneZ_ok(struct LDKRecoverableSignature o);
/* @internal */
export function CResult_RecoverableSignatureNoneZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RecoverableSignatureNoneZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_RecoverableSignatureNoneZ CResult_RecoverableSignatureNoneZ_err(void);
/* @internal */
export function CResult_RecoverableSignatureNoneZ_err(): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RecoverableSignatureNoneZ_err();
	return nativeResponseValue;
}
	// bool CResult_RecoverableSignatureNoneZ_is_ok(const struct LDKCResult_RecoverableSignatureNoneZ *NONNULL_PTR o);
/* @internal */
export function CResult_RecoverableSignatureNoneZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RecoverableSignatureNoneZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_RecoverableSignatureNoneZ_free(struct LDKCResult_RecoverableSignatureNoneZ _res);
/* @internal */
export function CResult_RecoverableSignatureNoneZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RecoverableSignatureNoneZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_RecoverableSignatureNoneZ_clone_ptr(LDKCResult_RecoverableSignatureNoneZ *NONNULL_PTR arg);
/* @internal */
export function CResult_RecoverableSignatureNoneZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RecoverableSignatureNoneZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_RecoverableSignatureNoneZ CResult_RecoverableSignatureNoneZ_clone(const struct LDKCResult_RecoverableSignatureNoneZ *NONNULL_PTR orig);
/* @internal */
export function CResult_RecoverableSignatureNoneZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RecoverableSignatureNoneZ_clone(orig);
	return nativeResponseValue;
}
	// void CVec_u8Z_free(struct LDKCVec_u8Z _res);
/* @internal */
export function CVec_u8Z_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CVec_u8Z_free(_res);
	// debug statements here
}
	// void CVec_CVec_u8ZZ_free(struct LDKCVec_CVec_u8ZZ _res);
/* @internal */
export function CVec_CVec_u8ZZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CVec_CVec_u8ZZ_free(_res);
	// debug statements here
}
	// struct LDKCResult_CVec_CVec_u8ZZNoneZ CResult_CVec_CVec_u8ZZNoneZ_ok(struct LDKCVec_CVec_u8ZZ o);
/* @internal */
export function CResult_CVec_CVec_u8ZZNoneZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CVec_CVec_u8ZZNoneZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_CVec_CVec_u8ZZNoneZ CResult_CVec_CVec_u8ZZNoneZ_err(void);
/* @internal */
export function CResult_CVec_CVec_u8ZZNoneZ_err(): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CVec_CVec_u8ZZNoneZ_err();
	return nativeResponseValue;
}
	// bool CResult_CVec_CVec_u8ZZNoneZ_is_ok(const struct LDKCResult_CVec_CVec_u8ZZNoneZ *NONNULL_PTR o);
/* @internal */
export function CResult_CVec_CVec_u8ZZNoneZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CVec_CVec_u8ZZNoneZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_CVec_CVec_u8ZZNoneZ_free(struct LDKCResult_CVec_CVec_u8ZZNoneZ _res);
/* @internal */
export function CResult_CVec_CVec_u8ZZNoneZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CVec_CVec_u8ZZNoneZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_CVec_CVec_u8ZZNoneZ_clone_ptr(LDKCResult_CVec_CVec_u8ZZNoneZ *NONNULL_PTR arg);
/* @internal */
export function CResult_CVec_CVec_u8ZZNoneZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CVec_CVec_u8ZZNoneZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_CVec_CVec_u8ZZNoneZ CResult_CVec_CVec_u8ZZNoneZ_clone(const struct LDKCResult_CVec_CVec_u8ZZNoneZ *NONNULL_PTR orig);
/* @internal */
export function CResult_CVec_CVec_u8ZZNoneZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CVec_CVec_u8ZZNoneZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_InMemorySignerDecodeErrorZ CResult_InMemorySignerDecodeErrorZ_ok(struct LDKInMemorySigner o);
/* @internal */
export function CResult_InMemorySignerDecodeErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InMemorySignerDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_InMemorySignerDecodeErrorZ CResult_InMemorySignerDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_InMemorySignerDecodeErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InMemorySignerDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_InMemorySignerDecodeErrorZ_is_ok(const struct LDKCResult_InMemorySignerDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_InMemorySignerDecodeErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InMemorySignerDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_InMemorySignerDecodeErrorZ_free(struct LDKCResult_InMemorySignerDecodeErrorZ _res);
/* @internal */
export function CResult_InMemorySignerDecodeErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InMemorySignerDecodeErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_InMemorySignerDecodeErrorZ_clone_ptr(LDKCResult_InMemorySignerDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_InMemorySignerDecodeErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InMemorySignerDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_InMemorySignerDecodeErrorZ CResult_InMemorySignerDecodeErrorZ_clone(const struct LDKCResult_InMemorySignerDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_InMemorySignerDecodeErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InMemorySignerDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// void CVec_TxOutZ_free(struct LDKCVec_TxOutZ _res);
/* @internal */
export function CVec_TxOutZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CVec_TxOutZ_free(_res);
	// debug statements here
}
	// struct LDKCResult_TransactionNoneZ CResult_TransactionNoneZ_ok(struct LDKTransaction o);
/* @internal */
export function CResult_TransactionNoneZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TransactionNoneZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_TransactionNoneZ CResult_TransactionNoneZ_err(void);
/* @internal */
export function CResult_TransactionNoneZ_err(): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TransactionNoneZ_err();
	return nativeResponseValue;
}
	// bool CResult_TransactionNoneZ_is_ok(const struct LDKCResult_TransactionNoneZ *NONNULL_PTR o);
/* @internal */
export function CResult_TransactionNoneZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TransactionNoneZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_TransactionNoneZ_free(struct LDKCResult_TransactionNoneZ _res);
/* @internal */
export function CResult_TransactionNoneZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TransactionNoneZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_TransactionNoneZ_clone_ptr(LDKCResult_TransactionNoneZ *NONNULL_PTR arg);
/* @internal */
export function CResult_TransactionNoneZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TransactionNoneZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_TransactionNoneZ CResult_TransactionNoneZ_clone(const struct LDKCResult_TransactionNoneZ *NONNULL_PTR orig);
/* @internal */
export function CResult_TransactionNoneZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_TransactionNoneZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCOption_u16Z COption_u16Z_some(uint16_t o);
/* @internal */
export function COption_u16Z_some(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_u16Z_some(o);
	return nativeResponseValue;
}
	// struct LDKCOption_u16Z COption_u16Z_none(void);
/* @internal */
export function COption_u16Z_none(): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_u16Z_none();
	return nativeResponseValue;
}
	// void COption_u16Z_free(struct LDKCOption_u16Z _res);
/* @internal */
export function COption_u16Z_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_u16Z_free(_res);
	// debug statements here
}
	// uintptr_t COption_u16Z_clone_ptr(LDKCOption_u16Z *NONNULL_PTR arg);
/* @internal */
export function COption_u16Z_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_u16Z_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCOption_u16Z COption_u16Z_clone(const struct LDKCOption_u16Z *NONNULL_PTR orig);
/* @internal */
export function COption_u16Z_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_u16Z_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_NoneAPIErrorZ CResult_NoneAPIErrorZ_ok(void);
/* @internal */
export function CResult_NoneAPIErrorZ_ok(): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneAPIErrorZ_ok();
	return nativeResponseValue;
}
	// struct LDKCResult_NoneAPIErrorZ CResult_NoneAPIErrorZ_err(struct LDKAPIError e);
/* @internal */
export function CResult_NoneAPIErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneAPIErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_NoneAPIErrorZ_is_ok(const struct LDKCResult_NoneAPIErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_NoneAPIErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneAPIErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_NoneAPIErrorZ_free(struct LDKCResult_NoneAPIErrorZ _res);
/* @internal */
export function CResult_NoneAPIErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneAPIErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_NoneAPIErrorZ_clone_ptr(LDKCResult_NoneAPIErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_NoneAPIErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneAPIErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_NoneAPIErrorZ CResult_NoneAPIErrorZ_clone(const struct LDKCResult_NoneAPIErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_NoneAPIErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneAPIErrorZ_clone(orig);
	return nativeResponseValue;
}
	// void CVec_CResult_NoneAPIErrorZZ_free(struct LDKCVec_CResult_NoneAPIErrorZZ _res);
/* @internal */
export function CVec_CResult_NoneAPIErrorZZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CVec_CResult_NoneAPIErrorZZ_free(_res);
	// debug statements here
}
	// void CVec_APIErrorZ_free(struct LDKCVec_APIErrorZ _res);
/* @internal */
export function CVec_APIErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CVec_APIErrorZ_free(_res);
	// debug statements here
}
	// struct LDKCResult__u832APIErrorZ CResult__u832APIErrorZ_ok(struct LDKThirtyTwoBytes o);
/* @internal */
export function CResult__u832APIErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult__u832APIErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult__u832APIErrorZ CResult__u832APIErrorZ_err(struct LDKAPIError e);
/* @internal */
export function CResult__u832APIErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult__u832APIErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult__u832APIErrorZ_is_ok(const struct LDKCResult__u832APIErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult__u832APIErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult__u832APIErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult__u832APIErrorZ_free(struct LDKCResult__u832APIErrorZ _res);
/* @internal */
export function CResult__u832APIErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult__u832APIErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult__u832APIErrorZ_clone_ptr(LDKCResult__u832APIErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult__u832APIErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult__u832APIErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult__u832APIErrorZ CResult__u832APIErrorZ_clone(const struct LDKCResult__u832APIErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult__u832APIErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult__u832APIErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_PaymentIdPaymentSendFailureZ CResult_PaymentIdPaymentSendFailureZ_ok(struct LDKThirtyTwoBytes o);
/* @internal */
export function CResult_PaymentIdPaymentSendFailureZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentIdPaymentSendFailureZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_PaymentIdPaymentSendFailureZ CResult_PaymentIdPaymentSendFailureZ_err(struct LDKPaymentSendFailure e);
/* @internal */
export function CResult_PaymentIdPaymentSendFailureZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentIdPaymentSendFailureZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_PaymentIdPaymentSendFailureZ_is_ok(const struct LDKCResult_PaymentIdPaymentSendFailureZ *NONNULL_PTR o);
/* @internal */
export function CResult_PaymentIdPaymentSendFailureZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentIdPaymentSendFailureZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_PaymentIdPaymentSendFailureZ_free(struct LDKCResult_PaymentIdPaymentSendFailureZ _res);
/* @internal */
export function CResult_PaymentIdPaymentSendFailureZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentIdPaymentSendFailureZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_PaymentIdPaymentSendFailureZ_clone_ptr(LDKCResult_PaymentIdPaymentSendFailureZ *NONNULL_PTR arg);
/* @internal */
export function CResult_PaymentIdPaymentSendFailureZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentIdPaymentSendFailureZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_PaymentIdPaymentSendFailureZ CResult_PaymentIdPaymentSendFailureZ_clone(const struct LDKCResult_PaymentIdPaymentSendFailureZ *NONNULL_PTR orig);
/* @internal */
export function CResult_PaymentIdPaymentSendFailureZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentIdPaymentSendFailureZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_NonePaymentSendFailureZ CResult_NonePaymentSendFailureZ_ok(void);
/* @internal */
export function CResult_NonePaymentSendFailureZ_ok(): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NonePaymentSendFailureZ_ok();
	return nativeResponseValue;
}
	// struct LDKCResult_NonePaymentSendFailureZ CResult_NonePaymentSendFailureZ_err(struct LDKPaymentSendFailure e);
/* @internal */
export function CResult_NonePaymentSendFailureZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NonePaymentSendFailureZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_NonePaymentSendFailureZ_is_ok(const struct LDKCResult_NonePaymentSendFailureZ *NONNULL_PTR o);
/* @internal */
export function CResult_NonePaymentSendFailureZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NonePaymentSendFailureZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_NonePaymentSendFailureZ_free(struct LDKCResult_NonePaymentSendFailureZ _res);
/* @internal */
export function CResult_NonePaymentSendFailureZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NonePaymentSendFailureZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_NonePaymentSendFailureZ_clone_ptr(LDKCResult_NonePaymentSendFailureZ *NONNULL_PTR arg);
/* @internal */
export function CResult_NonePaymentSendFailureZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NonePaymentSendFailureZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_NonePaymentSendFailureZ CResult_NonePaymentSendFailureZ_clone(const struct LDKCResult_NonePaymentSendFailureZ *NONNULL_PTR orig);
/* @internal */
export function CResult_NonePaymentSendFailureZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NonePaymentSendFailureZ_clone(orig);
	return nativeResponseValue;
}
	// uintptr_t C2Tuple_PaymentHashPaymentIdZ_clone_ptr(LDKC2Tuple_PaymentHashPaymentIdZ *NONNULL_PTR arg);
/* @internal */
export function C2Tuple_PaymentHashPaymentIdZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_PaymentHashPaymentIdZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKC2Tuple_PaymentHashPaymentIdZ C2Tuple_PaymentHashPaymentIdZ_clone(const struct LDKC2Tuple_PaymentHashPaymentIdZ *NONNULL_PTR orig);
/* @internal */
export function C2Tuple_PaymentHashPaymentIdZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_PaymentHashPaymentIdZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKC2Tuple_PaymentHashPaymentIdZ C2Tuple_PaymentHashPaymentIdZ_new(struct LDKThirtyTwoBytes a, struct LDKThirtyTwoBytes b);
/* @internal */
export function C2Tuple_PaymentHashPaymentIdZ_new(a: number, b: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_PaymentHashPaymentIdZ_new(a, b);
	return nativeResponseValue;
}
	// void C2Tuple_PaymentHashPaymentIdZ_free(struct LDKC2Tuple_PaymentHashPaymentIdZ _res);
/* @internal */
export function C2Tuple_PaymentHashPaymentIdZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_PaymentHashPaymentIdZ_free(_res);
	// debug statements here
}
	// struct LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_ok(struct LDKC2Tuple_PaymentHashPaymentIdZ o);
/* @internal */
export function CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_err(struct LDKPaymentSendFailure e);
/* @internal */
export function CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_is_ok(const struct LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ *NONNULL_PTR o);
/* @internal */
export function CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_free(struct LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ _res);
/* @internal */
export function CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_clone_ptr(LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ *NONNULL_PTR arg);
/* @internal */
export function CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_clone(const struct LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ *NONNULL_PTR orig);
/* @internal */
export function CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_clone(orig);
	return nativeResponseValue;
}
	// void CVec_NetAddressZ_free(struct LDKCVec_NetAddressZ _res);
/* @internal */
export function CVec_NetAddressZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CVec_NetAddressZ_free(_res);
	// debug statements here
}
	// uintptr_t C2Tuple_PaymentHashPaymentSecretZ_clone_ptr(LDKC2Tuple_PaymentHashPaymentSecretZ *NONNULL_PTR arg);
/* @internal */
export function C2Tuple_PaymentHashPaymentSecretZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_PaymentHashPaymentSecretZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKC2Tuple_PaymentHashPaymentSecretZ C2Tuple_PaymentHashPaymentSecretZ_clone(const struct LDKC2Tuple_PaymentHashPaymentSecretZ *NONNULL_PTR orig);
/* @internal */
export function C2Tuple_PaymentHashPaymentSecretZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_PaymentHashPaymentSecretZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKC2Tuple_PaymentHashPaymentSecretZ C2Tuple_PaymentHashPaymentSecretZ_new(struct LDKThirtyTwoBytes a, struct LDKThirtyTwoBytes b);
/* @internal */
export function C2Tuple_PaymentHashPaymentSecretZ_new(a: number, b: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_PaymentHashPaymentSecretZ_new(a, b);
	return nativeResponseValue;
}
	// void C2Tuple_PaymentHashPaymentSecretZ_free(struct LDKC2Tuple_PaymentHashPaymentSecretZ _res);
/* @internal */
export function C2Tuple_PaymentHashPaymentSecretZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_PaymentHashPaymentSecretZ_free(_res);
	// debug statements here
}
	// struct LDKCResult_C2Tuple_PaymentHashPaymentSecretZNoneZ CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_ok(struct LDKC2Tuple_PaymentHashPaymentSecretZ o);
/* @internal */
export function CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_C2Tuple_PaymentHashPaymentSecretZNoneZ CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_err(void);
/* @internal */
export function CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_err(): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_err();
	return nativeResponseValue;
}
	// bool CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_is_ok(const struct LDKCResult_C2Tuple_PaymentHashPaymentSecretZNoneZ *NONNULL_PTR o);
/* @internal */
export function CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_free(struct LDKCResult_C2Tuple_PaymentHashPaymentSecretZNoneZ _res);
/* @internal */
export function CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_clone_ptr(LDKCResult_C2Tuple_PaymentHashPaymentSecretZNoneZ *NONNULL_PTR arg);
/* @internal */
export function CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_C2Tuple_PaymentHashPaymentSecretZNoneZ CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_clone(const struct LDKCResult_C2Tuple_PaymentHashPaymentSecretZNoneZ *NONNULL_PTR orig);
/* @internal */
export function CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_PaymentHashPaymentSecretZNoneZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_ok(struct LDKC2Tuple_PaymentHashPaymentSecretZ o);
/* @internal */
export function CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_err(struct LDKAPIError e);
/* @internal */
export function CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_is_ok(const struct LDKCResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_free(struct LDKCResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ _res);
/* @internal */
export function CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_clone_ptr(LDKCResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_clone(const struct LDKCResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_PaymentSecretNoneZ CResult_PaymentSecretNoneZ_ok(struct LDKThirtyTwoBytes o);
/* @internal */
export function CResult_PaymentSecretNoneZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentSecretNoneZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_PaymentSecretNoneZ CResult_PaymentSecretNoneZ_err(void);
/* @internal */
export function CResult_PaymentSecretNoneZ_err(): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentSecretNoneZ_err();
	return nativeResponseValue;
}
	// bool CResult_PaymentSecretNoneZ_is_ok(const struct LDKCResult_PaymentSecretNoneZ *NONNULL_PTR o);
/* @internal */
export function CResult_PaymentSecretNoneZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentSecretNoneZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_PaymentSecretNoneZ_free(struct LDKCResult_PaymentSecretNoneZ _res);
/* @internal */
export function CResult_PaymentSecretNoneZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentSecretNoneZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_PaymentSecretNoneZ_clone_ptr(LDKCResult_PaymentSecretNoneZ *NONNULL_PTR arg);
/* @internal */
export function CResult_PaymentSecretNoneZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentSecretNoneZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_PaymentSecretNoneZ CResult_PaymentSecretNoneZ_clone(const struct LDKCResult_PaymentSecretNoneZ *NONNULL_PTR orig);
/* @internal */
export function CResult_PaymentSecretNoneZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentSecretNoneZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_PaymentSecretAPIErrorZ CResult_PaymentSecretAPIErrorZ_ok(struct LDKThirtyTwoBytes o);
/* @internal */
export function CResult_PaymentSecretAPIErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentSecretAPIErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_PaymentSecretAPIErrorZ CResult_PaymentSecretAPIErrorZ_err(struct LDKAPIError e);
/* @internal */
export function CResult_PaymentSecretAPIErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentSecretAPIErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_PaymentSecretAPIErrorZ_is_ok(const struct LDKCResult_PaymentSecretAPIErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_PaymentSecretAPIErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentSecretAPIErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_PaymentSecretAPIErrorZ_free(struct LDKCResult_PaymentSecretAPIErrorZ _res);
/* @internal */
export function CResult_PaymentSecretAPIErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentSecretAPIErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_PaymentSecretAPIErrorZ_clone_ptr(LDKCResult_PaymentSecretAPIErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_PaymentSecretAPIErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentSecretAPIErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_PaymentSecretAPIErrorZ CResult_PaymentSecretAPIErrorZ_clone(const struct LDKCResult_PaymentSecretAPIErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_PaymentSecretAPIErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentSecretAPIErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_PaymentPreimageAPIErrorZ CResult_PaymentPreimageAPIErrorZ_ok(struct LDKThirtyTwoBytes o);
/* @internal */
export function CResult_PaymentPreimageAPIErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentPreimageAPIErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_PaymentPreimageAPIErrorZ CResult_PaymentPreimageAPIErrorZ_err(struct LDKAPIError e);
/* @internal */
export function CResult_PaymentPreimageAPIErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentPreimageAPIErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_PaymentPreimageAPIErrorZ_is_ok(const struct LDKCResult_PaymentPreimageAPIErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_PaymentPreimageAPIErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentPreimageAPIErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_PaymentPreimageAPIErrorZ_free(struct LDKCResult_PaymentPreimageAPIErrorZ _res);
/* @internal */
export function CResult_PaymentPreimageAPIErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentPreimageAPIErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_PaymentPreimageAPIErrorZ_clone_ptr(LDKCResult_PaymentPreimageAPIErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_PaymentPreimageAPIErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentPreimageAPIErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_PaymentPreimageAPIErrorZ CResult_PaymentPreimageAPIErrorZ_clone(const struct LDKCResult_PaymentPreimageAPIErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_PaymentPreimageAPIErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentPreimageAPIErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_CounterpartyForwardingInfoDecodeErrorZ CResult_CounterpartyForwardingInfoDecodeErrorZ_ok(struct LDKCounterpartyForwardingInfo o);
/* @internal */
export function CResult_CounterpartyForwardingInfoDecodeErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CounterpartyForwardingInfoDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_CounterpartyForwardingInfoDecodeErrorZ CResult_CounterpartyForwardingInfoDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_CounterpartyForwardingInfoDecodeErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CounterpartyForwardingInfoDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_CounterpartyForwardingInfoDecodeErrorZ_is_ok(const struct LDKCResult_CounterpartyForwardingInfoDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_CounterpartyForwardingInfoDecodeErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CounterpartyForwardingInfoDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_CounterpartyForwardingInfoDecodeErrorZ_free(struct LDKCResult_CounterpartyForwardingInfoDecodeErrorZ _res);
/* @internal */
export function CResult_CounterpartyForwardingInfoDecodeErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CounterpartyForwardingInfoDecodeErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_CounterpartyForwardingInfoDecodeErrorZ_clone_ptr(LDKCResult_CounterpartyForwardingInfoDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_CounterpartyForwardingInfoDecodeErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CounterpartyForwardingInfoDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_CounterpartyForwardingInfoDecodeErrorZ CResult_CounterpartyForwardingInfoDecodeErrorZ_clone(const struct LDKCResult_CounterpartyForwardingInfoDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_CounterpartyForwardingInfoDecodeErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CounterpartyForwardingInfoDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelCounterpartyDecodeErrorZ CResult_ChannelCounterpartyDecodeErrorZ_ok(struct LDKChannelCounterparty o);
/* @internal */
export function CResult_ChannelCounterpartyDecodeErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelCounterpartyDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelCounterpartyDecodeErrorZ CResult_ChannelCounterpartyDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_ChannelCounterpartyDecodeErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelCounterpartyDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_ChannelCounterpartyDecodeErrorZ_is_ok(const struct LDKCResult_ChannelCounterpartyDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_ChannelCounterpartyDecodeErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelCounterpartyDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_ChannelCounterpartyDecodeErrorZ_free(struct LDKCResult_ChannelCounterpartyDecodeErrorZ _res);
/* @internal */
export function CResult_ChannelCounterpartyDecodeErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelCounterpartyDecodeErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_ChannelCounterpartyDecodeErrorZ_clone_ptr(LDKCResult_ChannelCounterpartyDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_ChannelCounterpartyDecodeErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelCounterpartyDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelCounterpartyDecodeErrorZ CResult_ChannelCounterpartyDecodeErrorZ_clone(const struct LDKCResult_ChannelCounterpartyDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_ChannelCounterpartyDecodeErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelCounterpartyDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelDetailsDecodeErrorZ CResult_ChannelDetailsDecodeErrorZ_ok(struct LDKChannelDetails o);
/* @internal */
export function CResult_ChannelDetailsDecodeErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelDetailsDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelDetailsDecodeErrorZ CResult_ChannelDetailsDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_ChannelDetailsDecodeErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelDetailsDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_ChannelDetailsDecodeErrorZ_is_ok(const struct LDKCResult_ChannelDetailsDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_ChannelDetailsDecodeErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelDetailsDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_ChannelDetailsDecodeErrorZ_free(struct LDKCResult_ChannelDetailsDecodeErrorZ _res);
/* @internal */
export function CResult_ChannelDetailsDecodeErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelDetailsDecodeErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_ChannelDetailsDecodeErrorZ_clone_ptr(LDKCResult_ChannelDetailsDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_ChannelDetailsDecodeErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelDetailsDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelDetailsDecodeErrorZ CResult_ChannelDetailsDecodeErrorZ_clone(const struct LDKCResult_ChannelDetailsDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_ChannelDetailsDecodeErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelDetailsDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_PhantomRouteHintsDecodeErrorZ CResult_PhantomRouteHintsDecodeErrorZ_ok(struct LDKPhantomRouteHints o);
/* @internal */
export function CResult_PhantomRouteHintsDecodeErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PhantomRouteHintsDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_PhantomRouteHintsDecodeErrorZ CResult_PhantomRouteHintsDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_PhantomRouteHintsDecodeErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PhantomRouteHintsDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_PhantomRouteHintsDecodeErrorZ_is_ok(const struct LDKCResult_PhantomRouteHintsDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_PhantomRouteHintsDecodeErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PhantomRouteHintsDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_PhantomRouteHintsDecodeErrorZ_free(struct LDKCResult_PhantomRouteHintsDecodeErrorZ _res);
/* @internal */
export function CResult_PhantomRouteHintsDecodeErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PhantomRouteHintsDecodeErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_PhantomRouteHintsDecodeErrorZ_clone_ptr(LDKCResult_PhantomRouteHintsDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_PhantomRouteHintsDecodeErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PhantomRouteHintsDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_PhantomRouteHintsDecodeErrorZ CResult_PhantomRouteHintsDecodeErrorZ_clone(const struct LDKCResult_PhantomRouteHintsDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_PhantomRouteHintsDecodeErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PhantomRouteHintsDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// void CVec_ChannelMonitorZ_free(struct LDKCVec_ChannelMonitorZ _res);
/* @internal */
export function CVec_ChannelMonitorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CVec_ChannelMonitorZ_free(_res);
	// debug statements here
}
	// struct LDKC2Tuple_BlockHashChannelManagerZ C2Tuple_BlockHashChannelManagerZ_new(struct LDKThirtyTwoBytes a, struct LDKChannelManager b);
/* @internal */
export function C2Tuple_BlockHashChannelManagerZ_new(a: number, b: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_BlockHashChannelManagerZ_new(a, b);
	return nativeResponseValue;
}
	// void C2Tuple_BlockHashChannelManagerZ_free(struct LDKC2Tuple_BlockHashChannelManagerZ _res);
/* @internal */
export function C2Tuple_BlockHashChannelManagerZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_BlockHashChannelManagerZ_free(_res);
	// debug statements here
}
	// struct LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_ok(struct LDKC2Tuple_BlockHashChannelManagerZ o);
/* @internal */
export function CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_is_ok(const struct LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_free(struct LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ _res);
/* @internal */
export function CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_free(_res);
	// debug statements here
}
	// struct LDKCResult_ChannelConfigDecodeErrorZ CResult_ChannelConfigDecodeErrorZ_ok(struct LDKChannelConfig o);
/* @internal */
export function CResult_ChannelConfigDecodeErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelConfigDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelConfigDecodeErrorZ CResult_ChannelConfigDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_ChannelConfigDecodeErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelConfigDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_ChannelConfigDecodeErrorZ_is_ok(const struct LDKCResult_ChannelConfigDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_ChannelConfigDecodeErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelConfigDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_ChannelConfigDecodeErrorZ_free(struct LDKCResult_ChannelConfigDecodeErrorZ _res);
/* @internal */
export function CResult_ChannelConfigDecodeErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelConfigDecodeErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_ChannelConfigDecodeErrorZ_clone_ptr(LDKCResult_ChannelConfigDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_ChannelConfigDecodeErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelConfigDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelConfigDecodeErrorZ CResult_ChannelConfigDecodeErrorZ_clone(const struct LDKCResult_ChannelConfigDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_ChannelConfigDecodeErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelConfigDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_OutPointDecodeErrorZ CResult_OutPointDecodeErrorZ_ok(struct LDKOutPoint o);
/* @internal */
export function CResult_OutPointDecodeErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_OutPointDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_OutPointDecodeErrorZ CResult_OutPointDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_OutPointDecodeErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_OutPointDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_OutPointDecodeErrorZ_is_ok(const struct LDKCResult_OutPointDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_OutPointDecodeErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_OutPointDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_OutPointDecodeErrorZ_free(struct LDKCResult_OutPointDecodeErrorZ _res);
/* @internal */
export function CResult_OutPointDecodeErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_OutPointDecodeErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_OutPointDecodeErrorZ_clone_ptr(LDKCResult_OutPointDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_OutPointDecodeErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_OutPointDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_OutPointDecodeErrorZ CResult_OutPointDecodeErrorZ_clone(const struct LDKCResult_OutPointDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_OutPointDecodeErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_OutPointDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCOption_TypeZ COption_TypeZ_some(struct LDKType o);
/* @internal */
export function COption_TypeZ_some(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_TypeZ_some(o);
	return nativeResponseValue;
}
	// struct LDKCOption_TypeZ COption_TypeZ_none(void);
/* @internal */
export function COption_TypeZ_none(): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_TypeZ_none();
	return nativeResponseValue;
}
	// void COption_TypeZ_free(struct LDKCOption_TypeZ _res);
/* @internal */
export function COption_TypeZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_TypeZ_free(_res);
	// debug statements here
}
	// uintptr_t COption_TypeZ_clone_ptr(LDKCOption_TypeZ *NONNULL_PTR arg);
/* @internal */
export function COption_TypeZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_TypeZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCOption_TypeZ COption_TypeZ_clone(const struct LDKCOption_TypeZ *NONNULL_PTR orig);
/* @internal */
export function COption_TypeZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_TypeZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_COption_TypeZDecodeErrorZ CResult_COption_TypeZDecodeErrorZ_ok(struct LDKCOption_TypeZ o);
/* @internal */
export function CResult_COption_TypeZDecodeErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_TypeZDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_COption_TypeZDecodeErrorZ CResult_COption_TypeZDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_COption_TypeZDecodeErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_TypeZDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_COption_TypeZDecodeErrorZ_is_ok(const struct LDKCResult_COption_TypeZDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_COption_TypeZDecodeErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_TypeZDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_COption_TypeZDecodeErrorZ_free(struct LDKCResult_COption_TypeZDecodeErrorZ _res);
/* @internal */
export function CResult_COption_TypeZDecodeErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_TypeZDecodeErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_COption_TypeZDecodeErrorZ_clone_ptr(LDKCResult_COption_TypeZDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_COption_TypeZDecodeErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_TypeZDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_COption_TypeZDecodeErrorZ CResult_COption_TypeZDecodeErrorZ_clone(const struct LDKCResult_COption_TypeZDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_COption_TypeZDecodeErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_TypeZDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_PaymentIdPaymentErrorZ CResult_PaymentIdPaymentErrorZ_ok(struct LDKThirtyTwoBytes o);
/* @internal */
export function CResult_PaymentIdPaymentErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentIdPaymentErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_PaymentIdPaymentErrorZ CResult_PaymentIdPaymentErrorZ_err(struct LDKPaymentError e);
/* @internal */
export function CResult_PaymentIdPaymentErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentIdPaymentErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_PaymentIdPaymentErrorZ_is_ok(const struct LDKCResult_PaymentIdPaymentErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_PaymentIdPaymentErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentIdPaymentErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_PaymentIdPaymentErrorZ_free(struct LDKCResult_PaymentIdPaymentErrorZ _res);
/* @internal */
export function CResult_PaymentIdPaymentErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentIdPaymentErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_PaymentIdPaymentErrorZ_clone_ptr(LDKCResult_PaymentIdPaymentErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_PaymentIdPaymentErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentIdPaymentErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_PaymentIdPaymentErrorZ CResult_PaymentIdPaymentErrorZ_clone(const struct LDKCResult_PaymentIdPaymentErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_PaymentIdPaymentErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PaymentIdPaymentErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_SiPrefixParseErrorZ CResult_SiPrefixParseErrorZ_ok(enum LDKSiPrefix o);
/* @internal */
export function CResult_SiPrefixParseErrorZ_ok(o: SiPrefix): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SiPrefixParseErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_SiPrefixParseErrorZ CResult_SiPrefixParseErrorZ_err(struct LDKParseError e);
/* @internal */
export function CResult_SiPrefixParseErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SiPrefixParseErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_SiPrefixParseErrorZ_is_ok(const struct LDKCResult_SiPrefixParseErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_SiPrefixParseErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SiPrefixParseErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_SiPrefixParseErrorZ_free(struct LDKCResult_SiPrefixParseErrorZ _res);
/* @internal */
export function CResult_SiPrefixParseErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SiPrefixParseErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_SiPrefixParseErrorZ_clone_ptr(LDKCResult_SiPrefixParseErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_SiPrefixParseErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SiPrefixParseErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_SiPrefixParseErrorZ CResult_SiPrefixParseErrorZ_clone(const struct LDKCResult_SiPrefixParseErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_SiPrefixParseErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SiPrefixParseErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_InvoiceParseOrSemanticErrorZ CResult_InvoiceParseOrSemanticErrorZ_ok(struct LDKInvoice o);
/* @internal */
export function CResult_InvoiceParseOrSemanticErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InvoiceParseOrSemanticErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_InvoiceParseOrSemanticErrorZ CResult_InvoiceParseOrSemanticErrorZ_err(struct LDKParseOrSemanticError e);
/* @internal */
export function CResult_InvoiceParseOrSemanticErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InvoiceParseOrSemanticErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_InvoiceParseOrSemanticErrorZ_is_ok(const struct LDKCResult_InvoiceParseOrSemanticErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_InvoiceParseOrSemanticErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InvoiceParseOrSemanticErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_InvoiceParseOrSemanticErrorZ_free(struct LDKCResult_InvoiceParseOrSemanticErrorZ _res);
/* @internal */
export function CResult_InvoiceParseOrSemanticErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InvoiceParseOrSemanticErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_InvoiceParseOrSemanticErrorZ_clone_ptr(LDKCResult_InvoiceParseOrSemanticErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_InvoiceParseOrSemanticErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InvoiceParseOrSemanticErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_InvoiceParseOrSemanticErrorZ CResult_InvoiceParseOrSemanticErrorZ_clone(const struct LDKCResult_InvoiceParseOrSemanticErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_InvoiceParseOrSemanticErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InvoiceParseOrSemanticErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_SignedRawInvoiceParseErrorZ CResult_SignedRawInvoiceParseErrorZ_ok(struct LDKSignedRawInvoice o);
/* @internal */
export function CResult_SignedRawInvoiceParseErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SignedRawInvoiceParseErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_SignedRawInvoiceParseErrorZ CResult_SignedRawInvoiceParseErrorZ_err(struct LDKParseError e);
/* @internal */
export function CResult_SignedRawInvoiceParseErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SignedRawInvoiceParseErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_SignedRawInvoiceParseErrorZ_is_ok(const struct LDKCResult_SignedRawInvoiceParseErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_SignedRawInvoiceParseErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SignedRawInvoiceParseErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_SignedRawInvoiceParseErrorZ_free(struct LDKCResult_SignedRawInvoiceParseErrorZ _res);
/* @internal */
export function CResult_SignedRawInvoiceParseErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SignedRawInvoiceParseErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_SignedRawInvoiceParseErrorZ_clone_ptr(LDKCResult_SignedRawInvoiceParseErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_SignedRawInvoiceParseErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SignedRawInvoiceParseErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_SignedRawInvoiceParseErrorZ CResult_SignedRawInvoiceParseErrorZ_clone(const struct LDKCResult_SignedRawInvoiceParseErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_SignedRawInvoiceParseErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_SignedRawInvoiceParseErrorZ_clone(orig);
	return nativeResponseValue;
}
	// uintptr_t C3Tuple_RawInvoice_u832InvoiceSignatureZ_clone_ptr(LDKC3Tuple_RawInvoice_u832InvoiceSignatureZ *NONNULL_PTR arg);
/* @internal */
export function C3Tuple_RawInvoice_u832InvoiceSignatureZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C3Tuple_RawInvoice_u832InvoiceSignatureZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKC3Tuple_RawInvoice_u832InvoiceSignatureZ C3Tuple_RawInvoice_u832InvoiceSignatureZ_clone(const struct LDKC3Tuple_RawInvoice_u832InvoiceSignatureZ *NONNULL_PTR orig);
/* @internal */
export function C3Tuple_RawInvoice_u832InvoiceSignatureZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C3Tuple_RawInvoice_u832InvoiceSignatureZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKC3Tuple_RawInvoice_u832InvoiceSignatureZ C3Tuple_RawInvoice_u832InvoiceSignatureZ_new(struct LDKRawInvoice a, struct LDKThirtyTwoBytes b, struct LDKInvoiceSignature c);
/* @internal */
export function C3Tuple_RawInvoice_u832InvoiceSignatureZ_new(a: number, b: number, c: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C3Tuple_RawInvoice_u832InvoiceSignatureZ_new(a, b, c);
	return nativeResponseValue;
}
	// void C3Tuple_RawInvoice_u832InvoiceSignatureZ_free(struct LDKC3Tuple_RawInvoice_u832InvoiceSignatureZ _res);
/* @internal */
export function C3Tuple_RawInvoice_u832InvoiceSignatureZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C3Tuple_RawInvoice_u832InvoiceSignatureZ_free(_res);
	// debug statements here
}
	// struct LDKCResult_PayeePubKeyErrorZ CResult_PayeePubKeyErrorZ_ok(struct LDKPayeePubKey o);
/* @internal */
export function CResult_PayeePubKeyErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PayeePubKeyErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_PayeePubKeyErrorZ CResult_PayeePubKeyErrorZ_err(enum LDKSecp256k1Error e);
/* @internal */
export function CResult_PayeePubKeyErrorZ_err(e: Secp256k1Error): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PayeePubKeyErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_PayeePubKeyErrorZ_is_ok(const struct LDKCResult_PayeePubKeyErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_PayeePubKeyErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PayeePubKeyErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_PayeePubKeyErrorZ_free(struct LDKCResult_PayeePubKeyErrorZ _res);
/* @internal */
export function CResult_PayeePubKeyErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PayeePubKeyErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_PayeePubKeyErrorZ_clone_ptr(LDKCResult_PayeePubKeyErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_PayeePubKeyErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PayeePubKeyErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_PayeePubKeyErrorZ CResult_PayeePubKeyErrorZ_clone(const struct LDKCResult_PayeePubKeyErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_PayeePubKeyErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PayeePubKeyErrorZ_clone(orig);
	return nativeResponseValue;
}
	// void CVec_PrivateRouteZ_free(struct LDKCVec_PrivateRouteZ _res);
/* @internal */
export function CVec_PrivateRouteZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CVec_PrivateRouteZ_free(_res);
	// debug statements here
}
	// struct LDKCResult_PositiveTimestampCreationErrorZ CResult_PositiveTimestampCreationErrorZ_ok(struct LDKPositiveTimestamp o);
/* @internal */
export function CResult_PositiveTimestampCreationErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PositiveTimestampCreationErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_PositiveTimestampCreationErrorZ CResult_PositiveTimestampCreationErrorZ_err(enum LDKCreationError e);
/* @internal */
export function CResult_PositiveTimestampCreationErrorZ_err(e: CreationError): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PositiveTimestampCreationErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_PositiveTimestampCreationErrorZ_is_ok(const struct LDKCResult_PositiveTimestampCreationErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_PositiveTimestampCreationErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PositiveTimestampCreationErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_PositiveTimestampCreationErrorZ_free(struct LDKCResult_PositiveTimestampCreationErrorZ _res);
/* @internal */
export function CResult_PositiveTimestampCreationErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PositiveTimestampCreationErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_PositiveTimestampCreationErrorZ_clone_ptr(LDKCResult_PositiveTimestampCreationErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_PositiveTimestampCreationErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PositiveTimestampCreationErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_PositiveTimestampCreationErrorZ CResult_PositiveTimestampCreationErrorZ_clone(const struct LDKCResult_PositiveTimestampCreationErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_PositiveTimestampCreationErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PositiveTimestampCreationErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_NoneSemanticErrorZ CResult_NoneSemanticErrorZ_ok(void);
/* @internal */
export function CResult_NoneSemanticErrorZ_ok(): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneSemanticErrorZ_ok();
	return nativeResponseValue;
}
	// struct LDKCResult_NoneSemanticErrorZ CResult_NoneSemanticErrorZ_err(enum LDKSemanticError e);
/* @internal */
export function CResult_NoneSemanticErrorZ_err(e: SemanticError): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneSemanticErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_NoneSemanticErrorZ_is_ok(const struct LDKCResult_NoneSemanticErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_NoneSemanticErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneSemanticErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_NoneSemanticErrorZ_free(struct LDKCResult_NoneSemanticErrorZ _res);
/* @internal */
export function CResult_NoneSemanticErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneSemanticErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_NoneSemanticErrorZ_clone_ptr(LDKCResult_NoneSemanticErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_NoneSemanticErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneSemanticErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_NoneSemanticErrorZ CResult_NoneSemanticErrorZ_clone(const struct LDKCResult_NoneSemanticErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_NoneSemanticErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneSemanticErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_InvoiceSemanticErrorZ CResult_InvoiceSemanticErrorZ_ok(struct LDKInvoice o);
/* @internal */
export function CResult_InvoiceSemanticErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InvoiceSemanticErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_InvoiceSemanticErrorZ CResult_InvoiceSemanticErrorZ_err(enum LDKSemanticError e);
/* @internal */
export function CResult_InvoiceSemanticErrorZ_err(e: SemanticError): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InvoiceSemanticErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_InvoiceSemanticErrorZ_is_ok(const struct LDKCResult_InvoiceSemanticErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_InvoiceSemanticErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InvoiceSemanticErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_InvoiceSemanticErrorZ_free(struct LDKCResult_InvoiceSemanticErrorZ _res);
/* @internal */
export function CResult_InvoiceSemanticErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InvoiceSemanticErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_InvoiceSemanticErrorZ_clone_ptr(LDKCResult_InvoiceSemanticErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_InvoiceSemanticErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InvoiceSemanticErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_InvoiceSemanticErrorZ CResult_InvoiceSemanticErrorZ_clone(const struct LDKCResult_InvoiceSemanticErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_InvoiceSemanticErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InvoiceSemanticErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_DescriptionCreationErrorZ CResult_DescriptionCreationErrorZ_ok(struct LDKDescription o);
/* @internal */
export function CResult_DescriptionCreationErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_DescriptionCreationErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_DescriptionCreationErrorZ CResult_DescriptionCreationErrorZ_err(enum LDKCreationError e);
/* @internal */
export function CResult_DescriptionCreationErrorZ_err(e: CreationError): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_DescriptionCreationErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_DescriptionCreationErrorZ_is_ok(const struct LDKCResult_DescriptionCreationErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_DescriptionCreationErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_DescriptionCreationErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_DescriptionCreationErrorZ_free(struct LDKCResult_DescriptionCreationErrorZ _res);
/* @internal */
export function CResult_DescriptionCreationErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_DescriptionCreationErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_DescriptionCreationErrorZ_clone_ptr(LDKCResult_DescriptionCreationErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_DescriptionCreationErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_DescriptionCreationErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_DescriptionCreationErrorZ CResult_DescriptionCreationErrorZ_clone(const struct LDKCResult_DescriptionCreationErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_DescriptionCreationErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_DescriptionCreationErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_PrivateRouteCreationErrorZ CResult_PrivateRouteCreationErrorZ_ok(struct LDKPrivateRoute o);
/* @internal */
export function CResult_PrivateRouteCreationErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PrivateRouteCreationErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_PrivateRouteCreationErrorZ CResult_PrivateRouteCreationErrorZ_err(enum LDKCreationError e);
/* @internal */
export function CResult_PrivateRouteCreationErrorZ_err(e: CreationError): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PrivateRouteCreationErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_PrivateRouteCreationErrorZ_is_ok(const struct LDKCResult_PrivateRouteCreationErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_PrivateRouteCreationErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PrivateRouteCreationErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_PrivateRouteCreationErrorZ_free(struct LDKCResult_PrivateRouteCreationErrorZ _res);
/* @internal */
export function CResult_PrivateRouteCreationErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PrivateRouteCreationErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_PrivateRouteCreationErrorZ_clone_ptr(LDKCResult_PrivateRouteCreationErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_PrivateRouteCreationErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PrivateRouteCreationErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_PrivateRouteCreationErrorZ CResult_PrivateRouteCreationErrorZ_clone(const struct LDKCResult_PrivateRouteCreationErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_PrivateRouteCreationErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PrivateRouteCreationErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_StringErrorZ CResult_StringErrorZ_ok(struct LDKStr o);
/* @internal */
export function CResult_StringErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_StringErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_StringErrorZ CResult_StringErrorZ_err(enum LDKSecp256k1Error e);
/* @internal */
export function CResult_StringErrorZ_err(e: Secp256k1Error): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_StringErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_StringErrorZ_is_ok(const struct LDKCResult_StringErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_StringErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_StringErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_StringErrorZ_free(struct LDKCResult_StringErrorZ _res);
/* @internal */
export function CResult_StringErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_StringErrorZ_free(_res);
	// debug statements here
}
	// struct LDKCResult_ChannelMonitorUpdateDecodeErrorZ CResult_ChannelMonitorUpdateDecodeErrorZ_ok(struct LDKChannelMonitorUpdate o);
/* @internal */
export function CResult_ChannelMonitorUpdateDecodeErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelMonitorUpdateDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelMonitorUpdateDecodeErrorZ CResult_ChannelMonitorUpdateDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_ChannelMonitorUpdateDecodeErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelMonitorUpdateDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_ChannelMonitorUpdateDecodeErrorZ_is_ok(const struct LDKCResult_ChannelMonitorUpdateDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_ChannelMonitorUpdateDecodeErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelMonitorUpdateDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_ChannelMonitorUpdateDecodeErrorZ_free(struct LDKCResult_ChannelMonitorUpdateDecodeErrorZ _res);
/* @internal */
export function CResult_ChannelMonitorUpdateDecodeErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelMonitorUpdateDecodeErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_ChannelMonitorUpdateDecodeErrorZ_clone_ptr(LDKCResult_ChannelMonitorUpdateDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_ChannelMonitorUpdateDecodeErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelMonitorUpdateDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelMonitorUpdateDecodeErrorZ CResult_ChannelMonitorUpdateDecodeErrorZ_clone(const struct LDKCResult_ChannelMonitorUpdateDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_ChannelMonitorUpdateDecodeErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelMonitorUpdateDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCOption_MonitorEventZ COption_MonitorEventZ_some(struct LDKMonitorEvent o);
/* @internal */
export function COption_MonitorEventZ_some(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_MonitorEventZ_some(o);
	return nativeResponseValue;
}
	// struct LDKCOption_MonitorEventZ COption_MonitorEventZ_none(void);
/* @internal */
export function COption_MonitorEventZ_none(): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_MonitorEventZ_none();
	return nativeResponseValue;
}
	// void COption_MonitorEventZ_free(struct LDKCOption_MonitorEventZ _res);
/* @internal */
export function COption_MonitorEventZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_MonitorEventZ_free(_res);
	// debug statements here
}
	// uintptr_t COption_MonitorEventZ_clone_ptr(LDKCOption_MonitorEventZ *NONNULL_PTR arg);
/* @internal */
export function COption_MonitorEventZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_MonitorEventZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCOption_MonitorEventZ COption_MonitorEventZ_clone(const struct LDKCOption_MonitorEventZ *NONNULL_PTR orig);
/* @internal */
export function COption_MonitorEventZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_MonitorEventZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_COption_MonitorEventZDecodeErrorZ CResult_COption_MonitorEventZDecodeErrorZ_ok(struct LDKCOption_MonitorEventZ o);
/* @internal */
export function CResult_COption_MonitorEventZDecodeErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_MonitorEventZDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_COption_MonitorEventZDecodeErrorZ CResult_COption_MonitorEventZDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_COption_MonitorEventZDecodeErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_MonitorEventZDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_COption_MonitorEventZDecodeErrorZ_is_ok(const struct LDKCResult_COption_MonitorEventZDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_COption_MonitorEventZDecodeErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_MonitorEventZDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_COption_MonitorEventZDecodeErrorZ_free(struct LDKCResult_COption_MonitorEventZDecodeErrorZ _res);
/* @internal */
export function CResult_COption_MonitorEventZDecodeErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_MonitorEventZDecodeErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_COption_MonitorEventZDecodeErrorZ_clone_ptr(LDKCResult_COption_MonitorEventZDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_COption_MonitorEventZDecodeErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_MonitorEventZDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_COption_MonitorEventZDecodeErrorZ CResult_COption_MonitorEventZDecodeErrorZ_clone(const struct LDKCResult_COption_MonitorEventZDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_COption_MonitorEventZDecodeErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_MonitorEventZDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_HTLCUpdateDecodeErrorZ CResult_HTLCUpdateDecodeErrorZ_ok(struct LDKHTLCUpdate o);
/* @internal */
export function CResult_HTLCUpdateDecodeErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_HTLCUpdateDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_HTLCUpdateDecodeErrorZ CResult_HTLCUpdateDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_HTLCUpdateDecodeErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_HTLCUpdateDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_HTLCUpdateDecodeErrorZ_is_ok(const struct LDKCResult_HTLCUpdateDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_HTLCUpdateDecodeErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_HTLCUpdateDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_HTLCUpdateDecodeErrorZ_free(struct LDKCResult_HTLCUpdateDecodeErrorZ _res);
/* @internal */
export function CResult_HTLCUpdateDecodeErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_HTLCUpdateDecodeErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_HTLCUpdateDecodeErrorZ_clone_ptr(LDKCResult_HTLCUpdateDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_HTLCUpdateDecodeErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_HTLCUpdateDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_HTLCUpdateDecodeErrorZ CResult_HTLCUpdateDecodeErrorZ_clone(const struct LDKCResult_HTLCUpdateDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_HTLCUpdateDecodeErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_HTLCUpdateDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// uintptr_t C2Tuple_OutPointScriptZ_clone_ptr(LDKC2Tuple_OutPointScriptZ *NONNULL_PTR arg);
/* @internal */
export function C2Tuple_OutPointScriptZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_OutPointScriptZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKC2Tuple_OutPointScriptZ C2Tuple_OutPointScriptZ_clone(const struct LDKC2Tuple_OutPointScriptZ *NONNULL_PTR orig);
/* @internal */
export function C2Tuple_OutPointScriptZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_OutPointScriptZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKC2Tuple_OutPointScriptZ C2Tuple_OutPointScriptZ_new(struct LDKOutPoint a, struct LDKCVec_u8Z b);
/* @internal */
export function C2Tuple_OutPointScriptZ_new(a: number, b: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_OutPointScriptZ_new(a, b);
	return nativeResponseValue;
}
	// void C2Tuple_OutPointScriptZ_free(struct LDKC2Tuple_OutPointScriptZ _res);
/* @internal */
export function C2Tuple_OutPointScriptZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_OutPointScriptZ_free(_res);
	// debug statements here
}
	// uintptr_t C2Tuple_u32ScriptZ_clone_ptr(LDKC2Tuple_u32ScriptZ *NONNULL_PTR arg);
/* @internal */
export function C2Tuple_u32ScriptZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_u32ScriptZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKC2Tuple_u32ScriptZ C2Tuple_u32ScriptZ_clone(const struct LDKC2Tuple_u32ScriptZ *NONNULL_PTR orig);
/* @internal */
export function C2Tuple_u32ScriptZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_u32ScriptZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKC2Tuple_u32ScriptZ C2Tuple_u32ScriptZ_new(uint32_t a, struct LDKCVec_u8Z b);
/* @internal */
export function C2Tuple_u32ScriptZ_new(a: number, b: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_u32ScriptZ_new(a, b);
	return nativeResponseValue;
}
	// void C2Tuple_u32ScriptZ_free(struct LDKC2Tuple_u32ScriptZ _res);
/* @internal */
export function C2Tuple_u32ScriptZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_u32ScriptZ_free(_res);
	// debug statements here
}
	// void CVec_C2Tuple_u32ScriptZZ_free(struct LDKCVec_C2Tuple_u32ScriptZZ _res);
/* @internal */
export function CVec_C2Tuple_u32ScriptZZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CVec_C2Tuple_u32ScriptZZ_free(_res);
	// debug statements here
}
	// uintptr_t C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_clone_ptr(LDKC2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ *NONNULL_PTR arg);
/* @internal */
export function C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKC2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_clone(const struct LDKC2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ *NONNULL_PTR orig);
/* @internal */
export function C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKC2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_new(struct LDKThirtyTwoBytes a, struct LDKCVec_C2Tuple_u32ScriptZZ b);
/* @internal */
export function C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_new(a: number, b: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_new(a, b);
	return nativeResponseValue;
}
	// void C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_free(struct LDKC2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ _res);
/* @internal */
export function C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_free(_res);
	// debug statements here
}
	// void CVec_C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZZ_free(struct LDKCVec_C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZZ _res);
/* @internal */
export function CVec_C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CVec_C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZZ_free(_res);
	// debug statements here
}
	// void CVec_EventZ_free(struct LDKCVec_EventZ _res);
/* @internal */
export function CVec_EventZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CVec_EventZ_free(_res);
	// debug statements here
}
	// void CVec_TransactionZ_free(struct LDKCVec_TransactionZ _res);
/* @internal */
export function CVec_TransactionZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CVec_TransactionZ_free(_res);
	// debug statements here
}
	// uintptr_t C2Tuple_u32TxOutZ_clone_ptr(LDKC2Tuple_u32TxOutZ *NONNULL_PTR arg);
/* @internal */
export function C2Tuple_u32TxOutZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_u32TxOutZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKC2Tuple_u32TxOutZ C2Tuple_u32TxOutZ_clone(const struct LDKC2Tuple_u32TxOutZ *NONNULL_PTR orig);
/* @internal */
export function C2Tuple_u32TxOutZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_u32TxOutZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKC2Tuple_u32TxOutZ C2Tuple_u32TxOutZ_new(uint32_t a, struct LDKTxOut b);
/* @internal */
export function C2Tuple_u32TxOutZ_new(a: number, b: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_u32TxOutZ_new(a, b);
	return nativeResponseValue;
}
	// void C2Tuple_u32TxOutZ_free(struct LDKC2Tuple_u32TxOutZ _res);
/* @internal */
export function C2Tuple_u32TxOutZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_u32TxOutZ_free(_res);
	// debug statements here
}
	// void CVec_C2Tuple_u32TxOutZZ_free(struct LDKCVec_C2Tuple_u32TxOutZZ _res);
/* @internal */
export function CVec_C2Tuple_u32TxOutZZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CVec_C2Tuple_u32TxOutZZ_free(_res);
	// debug statements here
}
	// uintptr_t C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_clone_ptr(LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ *NONNULL_PTR arg);
/* @internal */
export function C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_clone(const struct LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ *NONNULL_PTR orig);
/* @internal */
export function C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_new(struct LDKThirtyTwoBytes a, struct LDKCVec_C2Tuple_u32TxOutZZ b);
/* @internal */
export function C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_new(a: number, b: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_new(a, b);
	return nativeResponseValue;
}
	// void C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_free(struct LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ _res);
/* @internal */
export function C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_free(_res);
	// debug statements here
}
	// void CVec_C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZZ_free(struct LDKCVec_C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZZ _res);
/* @internal */
export function CVec_C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CVec_C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZZ_free(_res);
	// debug statements here
}
	// void CVec_BalanceZ_free(struct LDKCVec_BalanceZ _res);
/* @internal */
export function CVec_BalanceZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CVec_BalanceZ_free(_res);
	// debug statements here
}
	// uintptr_t C2Tuple_BlockHashChannelMonitorZ_clone_ptr(LDKC2Tuple_BlockHashChannelMonitorZ *NONNULL_PTR arg);
/* @internal */
export function C2Tuple_BlockHashChannelMonitorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_BlockHashChannelMonitorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKC2Tuple_BlockHashChannelMonitorZ C2Tuple_BlockHashChannelMonitorZ_clone(const struct LDKC2Tuple_BlockHashChannelMonitorZ *NONNULL_PTR orig);
/* @internal */
export function C2Tuple_BlockHashChannelMonitorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_BlockHashChannelMonitorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKC2Tuple_BlockHashChannelMonitorZ C2Tuple_BlockHashChannelMonitorZ_new(struct LDKThirtyTwoBytes a, struct LDKChannelMonitor b);
/* @internal */
export function C2Tuple_BlockHashChannelMonitorZ_new(a: number, b: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_BlockHashChannelMonitorZ_new(a, b);
	return nativeResponseValue;
}
	// void C2Tuple_BlockHashChannelMonitorZ_free(struct LDKC2Tuple_BlockHashChannelMonitorZ _res);
/* @internal */
export function C2Tuple_BlockHashChannelMonitorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_BlockHashChannelMonitorZ_free(_res);
	// debug statements here
}
	// struct LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_ok(struct LDKC2Tuple_BlockHashChannelMonitorZ o);
/* @internal */
export function CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_is_ok(const struct LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_free(struct LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ _res);
/* @internal */
export function CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_clone_ptr(LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_clone(const struct LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_NoneLightningErrorZ CResult_NoneLightningErrorZ_ok(void);
/* @internal */
export function CResult_NoneLightningErrorZ_ok(): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneLightningErrorZ_ok();
	return nativeResponseValue;
}
	// struct LDKCResult_NoneLightningErrorZ CResult_NoneLightningErrorZ_err(struct LDKLightningError e);
/* @internal */
export function CResult_NoneLightningErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneLightningErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_NoneLightningErrorZ_is_ok(const struct LDKCResult_NoneLightningErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_NoneLightningErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneLightningErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_NoneLightningErrorZ_free(struct LDKCResult_NoneLightningErrorZ _res);
/* @internal */
export function CResult_NoneLightningErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneLightningErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_NoneLightningErrorZ_clone_ptr(LDKCResult_NoneLightningErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_NoneLightningErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneLightningErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_NoneLightningErrorZ CResult_NoneLightningErrorZ_clone(const struct LDKCResult_NoneLightningErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_NoneLightningErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NoneLightningErrorZ_clone(orig);
	return nativeResponseValue;
}
	// uintptr_t C2Tuple_PublicKeyTypeZ_clone_ptr(LDKC2Tuple_PublicKeyTypeZ *NONNULL_PTR arg);
/* @internal */
export function C2Tuple_PublicKeyTypeZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_PublicKeyTypeZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKC2Tuple_PublicKeyTypeZ C2Tuple_PublicKeyTypeZ_clone(const struct LDKC2Tuple_PublicKeyTypeZ *NONNULL_PTR orig);
/* @internal */
export function C2Tuple_PublicKeyTypeZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_PublicKeyTypeZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKC2Tuple_PublicKeyTypeZ C2Tuple_PublicKeyTypeZ_new(struct LDKPublicKey a, struct LDKType b);
/* @internal */
export function C2Tuple_PublicKeyTypeZ_new(a: number, b: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_PublicKeyTypeZ_new(a, b);
	return nativeResponseValue;
}
	// void C2Tuple_PublicKeyTypeZ_free(struct LDKC2Tuple_PublicKeyTypeZ _res);
/* @internal */
export function C2Tuple_PublicKeyTypeZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_PublicKeyTypeZ_free(_res);
	// debug statements here
}
	// void CVec_C2Tuple_PublicKeyTypeZZ_free(struct LDKCVec_C2Tuple_PublicKeyTypeZZ _res);
/* @internal */
export function CVec_C2Tuple_PublicKeyTypeZZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CVec_C2Tuple_PublicKeyTypeZZ_free(_res);
	// debug statements here
}
	// struct LDKCResult_boolLightningErrorZ CResult_boolLightningErrorZ_ok(bool o);
/* @internal */
export function CResult_boolLightningErrorZ_ok(o: boolean): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_boolLightningErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_boolLightningErrorZ CResult_boolLightningErrorZ_err(struct LDKLightningError e);
/* @internal */
export function CResult_boolLightningErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_boolLightningErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_boolLightningErrorZ_is_ok(const struct LDKCResult_boolLightningErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_boolLightningErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_boolLightningErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_boolLightningErrorZ_free(struct LDKCResult_boolLightningErrorZ _res);
/* @internal */
export function CResult_boolLightningErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_boolLightningErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_boolLightningErrorZ_clone_ptr(LDKCResult_boolLightningErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_boolLightningErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_boolLightningErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_boolLightningErrorZ CResult_boolLightningErrorZ_clone(const struct LDKCResult_boolLightningErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_boolLightningErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_boolLightningErrorZ_clone(orig);
	return nativeResponseValue;
}
	// uintptr_t C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_clone_ptr(LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ *NONNULL_PTR arg);
/* @internal */
export function C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_clone(const struct LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ *NONNULL_PTR orig);
/* @internal */
export function C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_new(struct LDKChannelAnnouncement a, struct LDKChannelUpdate b, struct LDKChannelUpdate c);
/* @internal */
export function C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_new(a: number, b: number, c: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_new(a, b, c);
	return nativeResponseValue;
}
	// void C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_free(struct LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ _res);
/* @internal */
export function C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_free(_res);
	// debug statements here
}
	// void CVec_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ_free(struct LDKCVec_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ _res);
/* @internal */
export function CVec_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CVec_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ_free(_res);
	// debug statements here
}
	// void CVec_NodeAnnouncementZ_free(struct LDKCVec_NodeAnnouncementZ _res);
/* @internal */
export function CVec_NodeAnnouncementZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CVec_NodeAnnouncementZ_free(_res);
	// debug statements here
}
	// void CVec_PublicKeyZ_free(struct LDKCVec_PublicKeyZ _res);
/* @internal */
export function CVec_PublicKeyZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CVec_PublicKeyZ_free(_res);
	// debug statements here
}
	// struct LDKCOption_NetAddressZ COption_NetAddressZ_some(struct LDKNetAddress o);
/* @internal */
export function COption_NetAddressZ_some(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_NetAddressZ_some(o);
	return nativeResponseValue;
}
	// struct LDKCOption_NetAddressZ COption_NetAddressZ_none(void);
/* @internal */
export function COption_NetAddressZ_none(): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_NetAddressZ_none();
	return nativeResponseValue;
}
	// void COption_NetAddressZ_free(struct LDKCOption_NetAddressZ _res);
/* @internal */
export function COption_NetAddressZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_NetAddressZ_free(_res);
	// debug statements here
}
	// uintptr_t COption_NetAddressZ_clone_ptr(LDKCOption_NetAddressZ *NONNULL_PTR arg);
/* @internal */
export function COption_NetAddressZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_NetAddressZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCOption_NetAddressZ COption_NetAddressZ_clone(const struct LDKCOption_NetAddressZ *NONNULL_PTR orig);
/* @internal */
export function COption_NetAddressZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_NetAddressZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_CVec_u8ZPeerHandleErrorZ CResult_CVec_u8ZPeerHandleErrorZ_ok(struct LDKCVec_u8Z o);
/* @internal */
export function CResult_CVec_u8ZPeerHandleErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CVec_u8ZPeerHandleErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_CVec_u8ZPeerHandleErrorZ CResult_CVec_u8ZPeerHandleErrorZ_err(struct LDKPeerHandleError e);
/* @internal */
export function CResult_CVec_u8ZPeerHandleErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CVec_u8ZPeerHandleErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_CVec_u8ZPeerHandleErrorZ_is_ok(const struct LDKCResult_CVec_u8ZPeerHandleErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_CVec_u8ZPeerHandleErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CVec_u8ZPeerHandleErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_CVec_u8ZPeerHandleErrorZ_free(struct LDKCResult_CVec_u8ZPeerHandleErrorZ _res);
/* @internal */
export function CResult_CVec_u8ZPeerHandleErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CVec_u8ZPeerHandleErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_CVec_u8ZPeerHandleErrorZ_clone_ptr(LDKCResult_CVec_u8ZPeerHandleErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_CVec_u8ZPeerHandleErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CVec_u8ZPeerHandleErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_CVec_u8ZPeerHandleErrorZ CResult_CVec_u8ZPeerHandleErrorZ_clone(const struct LDKCResult_CVec_u8ZPeerHandleErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_CVec_u8ZPeerHandleErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CVec_u8ZPeerHandleErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_NonePeerHandleErrorZ CResult_NonePeerHandleErrorZ_ok(void);
/* @internal */
export function CResult_NonePeerHandleErrorZ_ok(): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NonePeerHandleErrorZ_ok();
	return nativeResponseValue;
}
	// struct LDKCResult_NonePeerHandleErrorZ CResult_NonePeerHandleErrorZ_err(struct LDKPeerHandleError e);
/* @internal */
export function CResult_NonePeerHandleErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NonePeerHandleErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_NonePeerHandleErrorZ_is_ok(const struct LDKCResult_NonePeerHandleErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_NonePeerHandleErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NonePeerHandleErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_NonePeerHandleErrorZ_free(struct LDKCResult_NonePeerHandleErrorZ _res);
/* @internal */
export function CResult_NonePeerHandleErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NonePeerHandleErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_NonePeerHandleErrorZ_clone_ptr(LDKCResult_NonePeerHandleErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_NonePeerHandleErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NonePeerHandleErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_NonePeerHandleErrorZ CResult_NonePeerHandleErrorZ_clone(const struct LDKCResult_NonePeerHandleErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_NonePeerHandleErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NonePeerHandleErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_boolPeerHandleErrorZ CResult_boolPeerHandleErrorZ_ok(bool o);
/* @internal */
export function CResult_boolPeerHandleErrorZ_ok(o: boolean): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_boolPeerHandleErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_boolPeerHandleErrorZ CResult_boolPeerHandleErrorZ_err(struct LDKPeerHandleError e);
/* @internal */
export function CResult_boolPeerHandleErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_boolPeerHandleErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_boolPeerHandleErrorZ_is_ok(const struct LDKCResult_boolPeerHandleErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_boolPeerHandleErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_boolPeerHandleErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_boolPeerHandleErrorZ_free(struct LDKCResult_boolPeerHandleErrorZ _res);
/* @internal */
export function CResult_boolPeerHandleErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_boolPeerHandleErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_boolPeerHandleErrorZ_clone_ptr(LDKCResult_boolPeerHandleErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_boolPeerHandleErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_boolPeerHandleErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_boolPeerHandleErrorZ CResult_boolPeerHandleErrorZ_clone(const struct LDKCResult_boolPeerHandleErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_boolPeerHandleErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_boolPeerHandleErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_NodeIdDecodeErrorZ CResult_NodeIdDecodeErrorZ_ok(struct LDKNodeId o);
/* @internal */
export function CResult_NodeIdDecodeErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NodeIdDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_NodeIdDecodeErrorZ CResult_NodeIdDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_NodeIdDecodeErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NodeIdDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_NodeIdDecodeErrorZ_is_ok(const struct LDKCResult_NodeIdDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_NodeIdDecodeErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NodeIdDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_NodeIdDecodeErrorZ_free(struct LDKCResult_NodeIdDecodeErrorZ _res);
/* @internal */
export function CResult_NodeIdDecodeErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NodeIdDecodeErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_NodeIdDecodeErrorZ_clone_ptr(LDKCResult_NodeIdDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_NodeIdDecodeErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NodeIdDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_NodeIdDecodeErrorZ CResult_NodeIdDecodeErrorZ_clone(const struct LDKCResult_NodeIdDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_NodeIdDecodeErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NodeIdDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_COption_NetworkUpdateZDecodeErrorZ CResult_COption_NetworkUpdateZDecodeErrorZ_ok(struct LDKCOption_NetworkUpdateZ o);
/* @internal */
export function CResult_COption_NetworkUpdateZDecodeErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_NetworkUpdateZDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_COption_NetworkUpdateZDecodeErrorZ CResult_COption_NetworkUpdateZDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_COption_NetworkUpdateZDecodeErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_NetworkUpdateZDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_COption_NetworkUpdateZDecodeErrorZ_is_ok(const struct LDKCResult_COption_NetworkUpdateZDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_COption_NetworkUpdateZDecodeErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_NetworkUpdateZDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_COption_NetworkUpdateZDecodeErrorZ_free(struct LDKCResult_COption_NetworkUpdateZDecodeErrorZ _res);
/* @internal */
export function CResult_COption_NetworkUpdateZDecodeErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_NetworkUpdateZDecodeErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_COption_NetworkUpdateZDecodeErrorZ_clone_ptr(LDKCResult_COption_NetworkUpdateZDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_COption_NetworkUpdateZDecodeErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_NetworkUpdateZDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_COption_NetworkUpdateZDecodeErrorZ CResult_COption_NetworkUpdateZDecodeErrorZ_clone(const struct LDKCResult_COption_NetworkUpdateZDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_COption_NetworkUpdateZDecodeErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_COption_NetworkUpdateZDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCOption_AccessZ COption_AccessZ_some(struct LDKAccess o);
/* @internal */
export function COption_AccessZ_some(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_AccessZ_some(o);
	return nativeResponseValue;
}
	// struct LDKCOption_AccessZ COption_AccessZ_none(void);
/* @internal */
export function COption_AccessZ_none(): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_AccessZ_none();
	return nativeResponseValue;
}
	// void COption_AccessZ_free(struct LDKCOption_AccessZ _res);
/* @internal */
export function COption_AccessZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_AccessZ_free(_res);
	// debug statements here
}
	// struct LDKCResult_ChannelUpdateInfoDecodeErrorZ CResult_ChannelUpdateInfoDecodeErrorZ_ok(struct LDKChannelUpdateInfo o);
/* @internal */
export function CResult_ChannelUpdateInfoDecodeErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelUpdateInfoDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelUpdateInfoDecodeErrorZ CResult_ChannelUpdateInfoDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_ChannelUpdateInfoDecodeErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelUpdateInfoDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_ChannelUpdateInfoDecodeErrorZ_is_ok(const struct LDKCResult_ChannelUpdateInfoDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_ChannelUpdateInfoDecodeErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelUpdateInfoDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_ChannelUpdateInfoDecodeErrorZ_free(struct LDKCResult_ChannelUpdateInfoDecodeErrorZ _res);
/* @internal */
export function CResult_ChannelUpdateInfoDecodeErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelUpdateInfoDecodeErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_ChannelUpdateInfoDecodeErrorZ_clone_ptr(LDKCResult_ChannelUpdateInfoDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_ChannelUpdateInfoDecodeErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelUpdateInfoDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelUpdateInfoDecodeErrorZ CResult_ChannelUpdateInfoDecodeErrorZ_clone(const struct LDKCResult_ChannelUpdateInfoDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_ChannelUpdateInfoDecodeErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelUpdateInfoDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelInfoDecodeErrorZ CResult_ChannelInfoDecodeErrorZ_ok(struct LDKChannelInfo o);
/* @internal */
export function CResult_ChannelInfoDecodeErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelInfoDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelInfoDecodeErrorZ CResult_ChannelInfoDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_ChannelInfoDecodeErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelInfoDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_ChannelInfoDecodeErrorZ_is_ok(const struct LDKCResult_ChannelInfoDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_ChannelInfoDecodeErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelInfoDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_ChannelInfoDecodeErrorZ_free(struct LDKCResult_ChannelInfoDecodeErrorZ _res);
/* @internal */
export function CResult_ChannelInfoDecodeErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelInfoDecodeErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_ChannelInfoDecodeErrorZ_clone_ptr(LDKCResult_ChannelInfoDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_ChannelInfoDecodeErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelInfoDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelInfoDecodeErrorZ CResult_ChannelInfoDecodeErrorZ_clone(const struct LDKCResult_ChannelInfoDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_ChannelInfoDecodeErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelInfoDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_RoutingFeesDecodeErrorZ CResult_RoutingFeesDecodeErrorZ_ok(struct LDKRoutingFees o);
/* @internal */
export function CResult_RoutingFeesDecodeErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RoutingFeesDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_RoutingFeesDecodeErrorZ CResult_RoutingFeesDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_RoutingFeesDecodeErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RoutingFeesDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_RoutingFeesDecodeErrorZ_is_ok(const struct LDKCResult_RoutingFeesDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_RoutingFeesDecodeErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RoutingFeesDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_RoutingFeesDecodeErrorZ_free(struct LDKCResult_RoutingFeesDecodeErrorZ _res);
/* @internal */
export function CResult_RoutingFeesDecodeErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RoutingFeesDecodeErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_RoutingFeesDecodeErrorZ_clone_ptr(LDKCResult_RoutingFeesDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_RoutingFeesDecodeErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RoutingFeesDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_RoutingFeesDecodeErrorZ CResult_RoutingFeesDecodeErrorZ_clone(const struct LDKCResult_RoutingFeesDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_RoutingFeesDecodeErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RoutingFeesDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_NodeAnnouncementInfoDecodeErrorZ CResult_NodeAnnouncementInfoDecodeErrorZ_ok(struct LDKNodeAnnouncementInfo o);
/* @internal */
export function CResult_NodeAnnouncementInfoDecodeErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NodeAnnouncementInfoDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_NodeAnnouncementInfoDecodeErrorZ CResult_NodeAnnouncementInfoDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_NodeAnnouncementInfoDecodeErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NodeAnnouncementInfoDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_NodeAnnouncementInfoDecodeErrorZ_is_ok(const struct LDKCResult_NodeAnnouncementInfoDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_NodeAnnouncementInfoDecodeErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NodeAnnouncementInfoDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_NodeAnnouncementInfoDecodeErrorZ_free(struct LDKCResult_NodeAnnouncementInfoDecodeErrorZ _res);
/* @internal */
export function CResult_NodeAnnouncementInfoDecodeErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NodeAnnouncementInfoDecodeErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_NodeAnnouncementInfoDecodeErrorZ_clone_ptr(LDKCResult_NodeAnnouncementInfoDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_NodeAnnouncementInfoDecodeErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NodeAnnouncementInfoDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_NodeAnnouncementInfoDecodeErrorZ CResult_NodeAnnouncementInfoDecodeErrorZ_clone(const struct LDKCResult_NodeAnnouncementInfoDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_NodeAnnouncementInfoDecodeErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NodeAnnouncementInfoDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// void CVec_u64Z_free(struct LDKCVec_u64Z _res);
/* @internal */
export function CVec_u64Z_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CVec_u64Z_free(_res);
	// debug statements here
}
	// struct LDKCResult_NodeInfoDecodeErrorZ CResult_NodeInfoDecodeErrorZ_ok(struct LDKNodeInfo o);
/* @internal */
export function CResult_NodeInfoDecodeErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NodeInfoDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_NodeInfoDecodeErrorZ CResult_NodeInfoDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_NodeInfoDecodeErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NodeInfoDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_NodeInfoDecodeErrorZ_is_ok(const struct LDKCResult_NodeInfoDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_NodeInfoDecodeErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NodeInfoDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_NodeInfoDecodeErrorZ_free(struct LDKCResult_NodeInfoDecodeErrorZ _res);
/* @internal */
export function CResult_NodeInfoDecodeErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NodeInfoDecodeErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_NodeInfoDecodeErrorZ_clone_ptr(LDKCResult_NodeInfoDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_NodeInfoDecodeErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NodeInfoDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_NodeInfoDecodeErrorZ CResult_NodeInfoDecodeErrorZ_clone(const struct LDKCResult_NodeInfoDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_NodeInfoDecodeErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NodeInfoDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_NetworkGraphDecodeErrorZ CResult_NetworkGraphDecodeErrorZ_ok(struct LDKNetworkGraph o);
/* @internal */
export function CResult_NetworkGraphDecodeErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NetworkGraphDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_NetworkGraphDecodeErrorZ CResult_NetworkGraphDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_NetworkGraphDecodeErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NetworkGraphDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_NetworkGraphDecodeErrorZ_is_ok(const struct LDKCResult_NetworkGraphDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_NetworkGraphDecodeErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NetworkGraphDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_NetworkGraphDecodeErrorZ_free(struct LDKCResult_NetworkGraphDecodeErrorZ _res);
/* @internal */
export function CResult_NetworkGraphDecodeErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NetworkGraphDecodeErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_NetworkGraphDecodeErrorZ_clone_ptr(LDKCResult_NetworkGraphDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_NetworkGraphDecodeErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NetworkGraphDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_NetworkGraphDecodeErrorZ CResult_NetworkGraphDecodeErrorZ_clone(const struct LDKCResult_NetworkGraphDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_NetworkGraphDecodeErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NetworkGraphDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCOption_CVec_NetAddressZZ COption_CVec_NetAddressZZ_some(struct LDKCVec_NetAddressZ o);
/* @internal */
export function COption_CVec_NetAddressZZ_some(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_CVec_NetAddressZZ_some(o);
	return nativeResponseValue;
}
	// struct LDKCOption_CVec_NetAddressZZ COption_CVec_NetAddressZZ_none(void);
/* @internal */
export function COption_CVec_NetAddressZZ_none(): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_CVec_NetAddressZZ_none();
	return nativeResponseValue;
}
	// void COption_CVec_NetAddressZZ_free(struct LDKCOption_CVec_NetAddressZZ _res);
/* @internal */
export function COption_CVec_NetAddressZZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_CVec_NetAddressZZ_free(_res);
	// debug statements here
}
	// uintptr_t COption_CVec_NetAddressZZ_clone_ptr(LDKCOption_CVec_NetAddressZZ *NONNULL_PTR arg);
/* @internal */
export function COption_CVec_NetAddressZZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_CVec_NetAddressZZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCOption_CVec_NetAddressZZ COption_CVec_NetAddressZZ_clone(const struct LDKCOption_CVec_NetAddressZZ *NONNULL_PTR orig);
/* @internal */
export function COption_CVec_NetAddressZZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_CVec_NetAddressZZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_NetAddressDecodeErrorZ CResult_NetAddressDecodeErrorZ_ok(struct LDKNetAddress o);
/* @internal */
export function CResult_NetAddressDecodeErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NetAddressDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_NetAddressDecodeErrorZ CResult_NetAddressDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_NetAddressDecodeErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NetAddressDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_NetAddressDecodeErrorZ_is_ok(const struct LDKCResult_NetAddressDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_NetAddressDecodeErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NetAddressDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_NetAddressDecodeErrorZ_free(struct LDKCResult_NetAddressDecodeErrorZ _res);
/* @internal */
export function CResult_NetAddressDecodeErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NetAddressDecodeErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_NetAddressDecodeErrorZ_clone_ptr(LDKCResult_NetAddressDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_NetAddressDecodeErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NetAddressDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_NetAddressDecodeErrorZ CResult_NetAddressDecodeErrorZ_clone(const struct LDKCResult_NetAddressDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_NetAddressDecodeErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NetAddressDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// void CVec_UpdateAddHTLCZ_free(struct LDKCVec_UpdateAddHTLCZ _res);
/* @internal */
export function CVec_UpdateAddHTLCZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CVec_UpdateAddHTLCZ_free(_res);
	// debug statements here
}
	// void CVec_UpdateFulfillHTLCZ_free(struct LDKCVec_UpdateFulfillHTLCZ _res);
/* @internal */
export function CVec_UpdateFulfillHTLCZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CVec_UpdateFulfillHTLCZ_free(_res);
	// debug statements here
}
	// void CVec_UpdateFailHTLCZ_free(struct LDKCVec_UpdateFailHTLCZ _res);
/* @internal */
export function CVec_UpdateFailHTLCZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CVec_UpdateFailHTLCZ_free(_res);
	// debug statements here
}
	// void CVec_UpdateFailMalformedHTLCZ_free(struct LDKCVec_UpdateFailMalformedHTLCZ _res);
/* @internal */
export function CVec_UpdateFailMalformedHTLCZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CVec_UpdateFailMalformedHTLCZ_free(_res);
	// debug statements here
}
	// struct LDKCResult_AcceptChannelDecodeErrorZ CResult_AcceptChannelDecodeErrorZ_ok(struct LDKAcceptChannel o);
/* @internal */
export function CResult_AcceptChannelDecodeErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_AcceptChannelDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_AcceptChannelDecodeErrorZ CResult_AcceptChannelDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_AcceptChannelDecodeErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_AcceptChannelDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_AcceptChannelDecodeErrorZ_is_ok(const struct LDKCResult_AcceptChannelDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_AcceptChannelDecodeErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_AcceptChannelDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_AcceptChannelDecodeErrorZ_free(struct LDKCResult_AcceptChannelDecodeErrorZ _res);
/* @internal */
export function CResult_AcceptChannelDecodeErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_AcceptChannelDecodeErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_AcceptChannelDecodeErrorZ_clone_ptr(LDKCResult_AcceptChannelDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_AcceptChannelDecodeErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_AcceptChannelDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_AcceptChannelDecodeErrorZ CResult_AcceptChannelDecodeErrorZ_clone(const struct LDKCResult_AcceptChannelDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_AcceptChannelDecodeErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_AcceptChannelDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_AnnouncementSignaturesDecodeErrorZ CResult_AnnouncementSignaturesDecodeErrorZ_ok(struct LDKAnnouncementSignatures o);
/* @internal */
export function CResult_AnnouncementSignaturesDecodeErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_AnnouncementSignaturesDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_AnnouncementSignaturesDecodeErrorZ CResult_AnnouncementSignaturesDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_AnnouncementSignaturesDecodeErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_AnnouncementSignaturesDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_AnnouncementSignaturesDecodeErrorZ_is_ok(const struct LDKCResult_AnnouncementSignaturesDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_AnnouncementSignaturesDecodeErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_AnnouncementSignaturesDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_AnnouncementSignaturesDecodeErrorZ_free(struct LDKCResult_AnnouncementSignaturesDecodeErrorZ _res);
/* @internal */
export function CResult_AnnouncementSignaturesDecodeErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_AnnouncementSignaturesDecodeErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_AnnouncementSignaturesDecodeErrorZ_clone_ptr(LDKCResult_AnnouncementSignaturesDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_AnnouncementSignaturesDecodeErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_AnnouncementSignaturesDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_AnnouncementSignaturesDecodeErrorZ CResult_AnnouncementSignaturesDecodeErrorZ_clone(const struct LDKCResult_AnnouncementSignaturesDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_AnnouncementSignaturesDecodeErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_AnnouncementSignaturesDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelReestablishDecodeErrorZ CResult_ChannelReestablishDecodeErrorZ_ok(struct LDKChannelReestablish o);
/* @internal */
export function CResult_ChannelReestablishDecodeErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelReestablishDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelReestablishDecodeErrorZ CResult_ChannelReestablishDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_ChannelReestablishDecodeErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelReestablishDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_ChannelReestablishDecodeErrorZ_is_ok(const struct LDKCResult_ChannelReestablishDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_ChannelReestablishDecodeErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelReestablishDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_ChannelReestablishDecodeErrorZ_free(struct LDKCResult_ChannelReestablishDecodeErrorZ _res);
/* @internal */
export function CResult_ChannelReestablishDecodeErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelReestablishDecodeErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_ChannelReestablishDecodeErrorZ_clone_ptr(LDKCResult_ChannelReestablishDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_ChannelReestablishDecodeErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelReestablishDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelReestablishDecodeErrorZ CResult_ChannelReestablishDecodeErrorZ_clone(const struct LDKCResult_ChannelReestablishDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_ChannelReestablishDecodeErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelReestablishDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_ClosingSignedDecodeErrorZ CResult_ClosingSignedDecodeErrorZ_ok(struct LDKClosingSigned o);
/* @internal */
export function CResult_ClosingSignedDecodeErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ClosingSignedDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_ClosingSignedDecodeErrorZ CResult_ClosingSignedDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_ClosingSignedDecodeErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ClosingSignedDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_ClosingSignedDecodeErrorZ_is_ok(const struct LDKCResult_ClosingSignedDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_ClosingSignedDecodeErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ClosingSignedDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_ClosingSignedDecodeErrorZ_free(struct LDKCResult_ClosingSignedDecodeErrorZ _res);
/* @internal */
export function CResult_ClosingSignedDecodeErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ClosingSignedDecodeErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_ClosingSignedDecodeErrorZ_clone_ptr(LDKCResult_ClosingSignedDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_ClosingSignedDecodeErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ClosingSignedDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_ClosingSignedDecodeErrorZ CResult_ClosingSignedDecodeErrorZ_clone(const struct LDKCResult_ClosingSignedDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_ClosingSignedDecodeErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ClosingSignedDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_ClosingSignedFeeRangeDecodeErrorZ CResult_ClosingSignedFeeRangeDecodeErrorZ_ok(struct LDKClosingSignedFeeRange o);
/* @internal */
export function CResult_ClosingSignedFeeRangeDecodeErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ClosingSignedFeeRangeDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_ClosingSignedFeeRangeDecodeErrorZ CResult_ClosingSignedFeeRangeDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_ClosingSignedFeeRangeDecodeErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ClosingSignedFeeRangeDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_ClosingSignedFeeRangeDecodeErrorZ_is_ok(const struct LDKCResult_ClosingSignedFeeRangeDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_ClosingSignedFeeRangeDecodeErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ClosingSignedFeeRangeDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_ClosingSignedFeeRangeDecodeErrorZ_free(struct LDKCResult_ClosingSignedFeeRangeDecodeErrorZ _res);
/* @internal */
export function CResult_ClosingSignedFeeRangeDecodeErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ClosingSignedFeeRangeDecodeErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_ClosingSignedFeeRangeDecodeErrorZ_clone_ptr(LDKCResult_ClosingSignedFeeRangeDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_ClosingSignedFeeRangeDecodeErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ClosingSignedFeeRangeDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_ClosingSignedFeeRangeDecodeErrorZ CResult_ClosingSignedFeeRangeDecodeErrorZ_clone(const struct LDKCResult_ClosingSignedFeeRangeDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_ClosingSignedFeeRangeDecodeErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ClosingSignedFeeRangeDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_CommitmentSignedDecodeErrorZ CResult_CommitmentSignedDecodeErrorZ_ok(struct LDKCommitmentSigned o);
/* @internal */
export function CResult_CommitmentSignedDecodeErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CommitmentSignedDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_CommitmentSignedDecodeErrorZ CResult_CommitmentSignedDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_CommitmentSignedDecodeErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CommitmentSignedDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_CommitmentSignedDecodeErrorZ_is_ok(const struct LDKCResult_CommitmentSignedDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_CommitmentSignedDecodeErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CommitmentSignedDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_CommitmentSignedDecodeErrorZ_free(struct LDKCResult_CommitmentSignedDecodeErrorZ _res);
/* @internal */
export function CResult_CommitmentSignedDecodeErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CommitmentSignedDecodeErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_CommitmentSignedDecodeErrorZ_clone_ptr(LDKCResult_CommitmentSignedDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_CommitmentSignedDecodeErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CommitmentSignedDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_CommitmentSignedDecodeErrorZ CResult_CommitmentSignedDecodeErrorZ_clone(const struct LDKCResult_CommitmentSignedDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_CommitmentSignedDecodeErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_CommitmentSignedDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_FundingCreatedDecodeErrorZ CResult_FundingCreatedDecodeErrorZ_ok(struct LDKFundingCreated o);
/* @internal */
export function CResult_FundingCreatedDecodeErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_FundingCreatedDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_FundingCreatedDecodeErrorZ CResult_FundingCreatedDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_FundingCreatedDecodeErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_FundingCreatedDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_FundingCreatedDecodeErrorZ_is_ok(const struct LDKCResult_FundingCreatedDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_FundingCreatedDecodeErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_FundingCreatedDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_FundingCreatedDecodeErrorZ_free(struct LDKCResult_FundingCreatedDecodeErrorZ _res);
/* @internal */
export function CResult_FundingCreatedDecodeErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_FundingCreatedDecodeErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_FundingCreatedDecodeErrorZ_clone_ptr(LDKCResult_FundingCreatedDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_FundingCreatedDecodeErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_FundingCreatedDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_FundingCreatedDecodeErrorZ CResult_FundingCreatedDecodeErrorZ_clone(const struct LDKCResult_FundingCreatedDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_FundingCreatedDecodeErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_FundingCreatedDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_FundingSignedDecodeErrorZ CResult_FundingSignedDecodeErrorZ_ok(struct LDKFundingSigned o);
/* @internal */
export function CResult_FundingSignedDecodeErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_FundingSignedDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_FundingSignedDecodeErrorZ CResult_FundingSignedDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_FundingSignedDecodeErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_FundingSignedDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_FundingSignedDecodeErrorZ_is_ok(const struct LDKCResult_FundingSignedDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_FundingSignedDecodeErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_FundingSignedDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_FundingSignedDecodeErrorZ_free(struct LDKCResult_FundingSignedDecodeErrorZ _res);
/* @internal */
export function CResult_FundingSignedDecodeErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_FundingSignedDecodeErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_FundingSignedDecodeErrorZ_clone_ptr(LDKCResult_FundingSignedDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_FundingSignedDecodeErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_FundingSignedDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_FundingSignedDecodeErrorZ CResult_FundingSignedDecodeErrorZ_clone(const struct LDKCResult_FundingSignedDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_FundingSignedDecodeErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_FundingSignedDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_FundingLockedDecodeErrorZ CResult_FundingLockedDecodeErrorZ_ok(struct LDKFundingLocked o);
/* @internal */
export function CResult_FundingLockedDecodeErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_FundingLockedDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_FundingLockedDecodeErrorZ CResult_FundingLockedDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_FundingLockedDecodeErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_FundingLockedDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_FundingLockedDecodeErrorZ_is_ok(const struct LDKCResult_FundingLockedDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_FundingLockedDecodeErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_FundingLockedDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_FundingLockedDecodeErrorZ_free(struct LDKCResult_FundingLockedDecodeErrorZ _res);
/* @internal */
export function CResult_FundingLockedDecodeErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_FundingLockedDecodeErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_FundingLockedDecodeErrorZ_clone_ptr(LDKCResult_FundingLockedDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_FundingLockedDecodeErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_FundingLockedDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_FundingLockedDecodeErrorZ CResult_FundingLockedDecodeErrorZ_clone(const struct LDKCResult_FundingLockedDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_FundingLockedDecodeErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_FundingLockedDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_InitDecodeErrorZ CResult_InitDecodeErrorZ_ok(struct LDKInit o);
/* @internal */
export function CResult_InitDecodeErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InitDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_InitDecodeErrorZ CResult_InitDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_InitDecodeErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InitDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_InitDecodeErrorZ_is_ok(const struct LDKCResult_InitDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_InitDecodeErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InitDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_InitDecodeErrorZ_free(struct LDKCResult_InitDecodeErrorZ _res);
/* @internal */
export function CResult_InitDecodeErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InitDecodeErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_InitDecodeErrorZ_clone_ptr(LDKCResult_InitDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_InitDecodeErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InitDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_InitDecodeErrorZ CResult_InitDecodeErrorZ_clone(const struct LDKCResult_InitDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_InitDecodeErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InitDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_OpenChannelDecodeErrorZ CResult_OpenChannelDecodeErrorZ_ok(struct LDKOpenChannel o);
/* @internal */
export function CResult_OpenChannelDecodeErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_OpenChannelDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_OpenChannelDecodeErrorZ CResult_OpenChannelDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_OpenChannelDecodeErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_OpenChannelDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_OpenChannelDecodeErrorZ_is_ok(const struct LDKCResult_OpenChannelDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_OpenChannelDecodeErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_OpenChannelDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_OpenChannelDecodeErrorZ_free(struct LDKCResult_OpenChannelDecodeErrorZ _res);
/* @internal */
export function CResult_OpenChannelDecodeErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_OpenChannelDecodeErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_OpenChannelDecodeErrorZ_clone_ptr(LDKCResult_OpenChannelDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_OpenChannelDecodeErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_OpenChannelDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_OpenChannelDecodeErrorZ CResult_OpenChannelDecodeErrorZ_clone(const struct LDKCResult_OpenChannelDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_OpenChannelDecodeErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_OpenChannelDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_RevokeAndACKDecodeErrorZ CResult_RevokeAndACKDecodeErrorZ_ok(struct LDKRevokeAndACK o);
/* @internal */
export function CResult_RevokeAndACKDecodeErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RevokeAndACKDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_RevokeAndACKDecodeErrorZ CResult_RevokeAndACKDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_RevokeAndACKDecodeErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RevokeAndACKDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_RevokeAndACKDecodeErrorZ_is_ok(const struct LDKCResult_RevokeAndACKDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_RevokeAndACKDecodeErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RevokeAndACKDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_RevokeAndACKDecodeErrorZ_free(struct LDKCResult_RevokeAndACKDecodeErrorZ _res);
/* @internal */
export function CResult_RevokeAndACKDecodeErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RevokeAndACKDecodeErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_RevokeAndACKDecodeErrorZ_clone_ptr(LDKCResult_RevokeAndACKDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_RevokeAndACKDecodeErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RevokeAndACKDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_RevokeAndACKDecodeErrorZ CResult_RevokeAndACKDecodeErrorZ_clone(const struct LDKCResult_RevokeAndACKDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_RevokeAndACKDecodeErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_RevokeAndACKDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_ShutdownDecodeErrorZ CResult_ShutdownDecodeErrorZ_ok(struct LDKShutdown o);
/* @internal */
export function CResult_ShutdownDecodeErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ShutdownDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_ShutdownDecodeErrorZ CResult_ShutdownDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_ShutdownDecodeErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ShutdownDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_ShutdownDecodeErrorZ_is_ok(const struct LDKCResult_ShutdownDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_ShutdownDecodeErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ShutdownDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_ShutdownDecodeErrorZ_free(struct LDKCResult_ShutdownDecodeErrorZ _res);
/* @internal */
export function CResult_ShutdownDecodeErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ShutdownDecodeErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_ShutdownDecodeErrorZ_clone_ptr(LDKCResult_ShutdownDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_ShutdownDecodeErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ShutdownDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_ShutdownDecodeErrorZ CResult_ShutdownDecodeErrorZ_clone(const struct LDKCResult_ShutdownDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_ShutdownDecodeErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ShutdownDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_UpdateFailHTLCDecodeErrorZ CResult_UpdateFailHTLCDecodeErrorZ_ok(struct LDKUpdateFailHTLC o);
/* @internal */
export function CResult_UpdateFailHTLCDecodeErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UpdateFailHTLCDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_UpdateFailHTLCDecodeErrorZ CResult_UpdateFailHTLCDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_UpdateFailHTLCDecodeErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UpdateFailHTLCDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_UpdateFailHTLCDecodeErrorZ_is_ok(const struct LDKCResult_UpdateFailHTLCDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_UpdateFailHTLCDecodeErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UpdateFailHTLCDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_UpdateFailHTLCDecodeErrorZ_free(struct LDKCResult_UpdateFailHTLCDecodeErrorZ _res);
/* @internal */
export function CResult_UpdateFailHTLCDecodeErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UpdateFailHTLCDecodeErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_UpdateFailHTLCDecodeErrorZ_clone_ptr(LDKCResult_UpdateFailHTLCDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_UpdateFailHTLCDecodeErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UpdateFailHTLCDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_UpdateFailHTLCDecodeErrorZ CResult_UpdateFailHTLCDecodeErrorZ_clone(const struct LDKCResult_UpdateFailHTLCDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_UpdateFailHTLCDecodeErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UpdateFailHTLCDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ CResult_UpdateFailMalformedHTLCDecodeErrorZ_ok(struct LDKUpdateFailMalformedHTLC o);
/* @internal */
export function CResult_UpdateFailMalformedHTLCDecodeErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UpdateFailMalformedHTLCDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ CResult_UpdateFailMalformedHTLCDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_UpdateFailMalformedHTLCDecodeErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UpdateFailMalformedHTLCDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_UpdateFailMalformedHTLCDecodeErrorZ_is_ok(const struct LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_UpdateFailMalformedHTLCDecodeErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UpdateFailMalformedHTLCDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_UpdateFailMalformedHTLCDecodeErrorZ_free(struct LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ _res);
/* @internal */
export function CResult_UpdateFailMalformedHTLCDecodeErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UpdateFailMalformedHTLCDecodeErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_UpdateFailMalformedHTLCDecodeErrorZ_clone_ptr(LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_UpdateFailMalformedHTLCDecodeErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UpdateFailMalformedHTLCDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ CResult_UpdateFailMalformedHTLCDecodeErrorZ_clone(const struct LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_UpdateFailMalformedHTLCDecodeErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UpdateFailMalformedHTLCDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_UpdateFeeDecodeErrorZ CResult_UpdateFeeDecodeErrorZ_ok(struct LDKUpdateFee o);
/* @internal */
export function CResult_UpdateFeeDecodeErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UpdateFeeDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_UpdateFeeDecodeErrorZ CResult_UpdateFeeDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_UpdateFeeDecodeErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UpdateFeeDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_UpdateFeeDecodeErrorZ_is_ok(const struct LDKCResult_UpdateFeeDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_UpdateFeeDecodeErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UpdateFeeDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_UpdateFeeDecodeErrorZ_free(struct LDKCResult_UpdateFeeDecodeErrorZ _res);
/* @internal */
export function CResult_UpdateFeeDecodeErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UpdateFeeDecodeErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_UpdateFeeDecodeErrorZ_clone_ptr(LDKCResult_UpdateFeeDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_UpdateFeeDecodeErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UpdateFeeDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_UpdateFeeDecodeErrorZ CResult_UpdateFeeDecodeErrorZ_clone(const struct LDKCResult_UpdateFeeDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_UpdateFeeDecodeErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UpdateFeeDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_UpdateFulfillHTLCDecodeErrorZ CResult_UpdateFulfillHTLCDecodeErrorZ_ok(struct LDKUpdateFulfillHTLC o);
/* @internal */
export function CResult_UpdateFulfillHTLCDecodeErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UpdateFulfillHTLCDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_UpdateFulfillHTLCDecodeErrorZ CResult_UpdateFulfillHTLCDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_UpdateFulfillHTLCDecodeErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UpdateFulfillHTLCDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_UpdateFulfillHTLCDecodeErrorZ_is_ok(const struct LDKCResult_UpdateFulfillHTLCDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_UpdateFulfillHTLCDecodeErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UpdateFulfillHTLCDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_UpdateFulfillHTLCDecodeErrorZ_free(struct LDKCResult_UpdateFulfillHTLCDecodeErrorZ _res);
/* @internal */
export function CResult_UpdateFulfillHTLCDecodeErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UpdateFulfillHTLCDecodeErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_UpdateFulfillHTLCDecodeErrorZ_clone_ptr(LDKCResult_UpdateFulfillHTLCDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_UpdateFulfillHTLCDecodeErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UpdateFulfillHTLCDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_UpdateFulfillHTLCDecodeErrorZ CResult_UpdateFulfillHTLCDecodeErrorZ_clone(const struct LDKCResult_UpdateFulfillHTLCDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_UpdateFulfillHTLCDecodeErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UpdateFulfillHTLCDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_UpdateAddHTLCDecodeErrorZ CResult_UpdateAddHTLCDecodeErrorZ_ok(struct LDKUpdateAddHTLC o);
/* @internal */
export function CResult_UpdateAddHTLCDecodeErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UpdateAddHTLCDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_UpdateAddHTLCDecodeErrorZ CResult_UpdateAddHTLCDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_UpdateAddHTLCDecodeErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UpdateAddHTLCDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_UpdateAddHTLCDecodeErrorZ_is_ok(const struct LDKCResult_UpdateAddHTLCDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_UpdateAddHTLCDecodeErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UpdateAddHTLCDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_UpdateAddHTLCDecodeErrorZ_free(struct LDKCResult_UpdateAddHTLCDecodeErrorZ _res);
/* @internal */
export function CResult_UpdateAddHTLCDecodeErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UpdateAddHTLCDecodeErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_UpdateAddHTLCDecodeErrorZ_clone_ptr(LDKCResult_UpdateAddHTLCDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_UpdateAddHTLCDecodeErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UpdateAddHTLCDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_UpdateAddHTLCDecodeErrorZ CResult_UpdateAddHTLCDecodeErrorZ_clone(const struct LDKCResult_UpdateAddHTLCDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_UpdateAddHTLCDecodeErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UpdateAddHTLCDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_PingDecodeErrorZ CResult_PingDecodeErrorZ_ok(struct LDKPing o);
/* @internal */
export function CResult_PingDecodeErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PingDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_PingDecodeErrorZ CResult_PingDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_PingDecodeErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PingDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_PingDecodeErrorZ_is_ok(const struct LDKCResult_PingDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_PingDecodeErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PingDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_PingDecodeErrorZ_free(struct LDKCResult_PingDecodeErrorZ _res);
/* @internal */
export function CResult_PingDecodeErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PingDecodeErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_PingDecodeErrorZ_clone_ptr(LDKCResult_PingDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_PingDecodeErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PingDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_PingDecodeErrorZ CResult_PingDecodeErrorZ_clone(const struct LDKCResult_PingDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_PingDecodeErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PingDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_PongDecodeErrorZ CResult_PongDecodeErrorZ_ok(struct LDKPong o);
/* @internal */
export function CResult_PongDecodeErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PongDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_PongDecodeErrorZ CResult_PongDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_PongDecodeErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PongDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_PongDecodeErrorZ_is_ok(const struct LDKCResult_PongDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_PongDecodeErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PongDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_PongDecodeErrorZ_free(struct LDKCResult_PongDecodeErrorZ _res);
/* @internal */
export function CResult_PongDecodeErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PongDecodeErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_PongDecodeErrorZ_clone_ptr(LDKCResult_PongDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_PongDecodeErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PongDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_PongDecodeErrorZ CResult_PongDecodeErrorZ_clone(const struct LDKCResult_PongDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_PongDecodeErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_PongDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ CResult_UnsignedChannelAnnouncementDecodeErrorZ_ok(struct LDKUnsignedChannelAnnouncement o);
/* @internal */
export function CResult_UnsignedChannelAnnouncementDecodeErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UnsignedChannelAnnouncementDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ CResult_UnsignedChannelAnnouncementDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_UnsignedChannelAnnouncementDecodeErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UnsignedChannelAnnouncementDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_UnsignedChannelAnnouncementDecodeErrorZ_is_ok(const struct LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_UnsignedChannelAnnouncementDecodeErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UnsignedChannelAnnouncementDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_UnsignedChannelAnnouncementDecodeErrorZ_free(struct LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ _res);
/* @internal */
export function CResult_UnsignedChannelAnnouncementDecodeErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UnsignedChannelAnnouncementDecodeErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_UnsignedChannelAnnouncementDecodeErrorZ_clone_ptr(LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_UnsignedChannelAnnouncementDecodeErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UnsignedChannelAnnouncementDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ CResult_UnsignedChannelAnnouncementDecodeErrorZ_clone(const struct LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_UnsignedChannelAnnouncementDecodeErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UnsignedChannelAnnouncementDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelAnnouncementDecodeErrorZ CResult_ChannelAnnouncementDecodeErrorZ_ok(struct LDKChannelAnnouncement o);
/* @internal */
export function CResult_ChannelAnnouncementDecodeErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelAnnouncementDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelAnnouncementDecodeErrorZ CResult_ChannelAnnouncementDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_ChannelAnnouncementDecodeErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelAnnouncementDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_ChannelAnnouncementDecodeErrorZ_is_ok(const struct LDKCResult_ChannelAnnouncementDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_ChannelAnnouncementDecodeErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelAnnouncementDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_ChannelAnnouncementDecodeErrorZ_free(struct LDKCResult_ChannelAnnouncementDecodeErrorZ _res);
/* @internal */
export function CResult_ChannelAnnouncementDecodeErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelAnnouncementDecodeErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_ChannelAnnouncementDecodeErrorZ_clone_ptr(LDKCResult_ChannelAnnouncementDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_ChannelAnnouncementDecodeErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelAnnouncementDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelAnnouncementDecodeErrorZ CResult_ChannelAnnouncementDecodeErrorZ_clone(const struct LDKCResult_ChannelAnnouncementDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_ChannelAnnouncementDecodeErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelAnnouncementDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_UnsignedChannelUpdateDecodeErrorZ CResult_UnsignedChannelUpdateDecodeErrorZ_ok(struct LDKUnsignedChannelUpdate o);
/* @internal */
export function CResult_UnsignedChannelUpdateDecodeErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UnsignedChannelUpdateDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_UnsignedChannelUpdateDecodeErrorZ CResult_UnsignedChannelUpdateDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_UnsignedChannelUpdateDecodeErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UnsignedChannelUpdateDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_UnsignedChannelUpdateDecodeErrorZ_is_ok(const struct LDKCResult_UnsignedChannelUpdateDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_UnsignedChannelUpdateDecodeErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UnsignedChannelUpdateDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_UnsignedChannelUpdateDecodeErrorZ_free(struct LDKCResult_UnsignedChannelUpdateDecodeErrorZ _res);
/* @internal */
export function CResult_UnsignedChannelUpdateDecodeErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UnsignedChannelUpdateDecodeErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_UnsignedChannelUpdateDecodeErrorZ_clone_ptr(LDKCResult_UnsignedChannelUpdateDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_UnsignedChannelUpdateDecodeErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UnsignedChannelUpdateDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_UnsignedChannelUpdateDecodeErrorZ CResult_UnsignedChannelUpdateDecodeErrorZ_clone(const struct LDKCResult_UnsignedChannelUpdateDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_UnsignedChannelUpdateDecodeErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UnsignedChannelUpdateDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelUpdateDecodeErrorZ CResult_ChannelUpdateDecodeErrorZ_ok(struct LDKChannelUpdate o);
/* @internal */
export function CResult_ChannelUpdateDecodeErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelUpdateDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelUpdateDecodeErrorZ CResult_ChannelUpdateDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_ChannelUpdateDecodeErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelUpdateDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_ChannelUpdateDecodeErrorZ_is_ok(const struct LDKCResult_ChannelUpdateDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_ChannelUpdateDecodeErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelUpdateDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_ChannelUpdateDecodeErrorZ_free(struct LDKCResult_ChannelUpdateDecodeErrorZ _res);
/* @internal */
export function CResult_ChannelUpdateDecodeErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelUpdateDecodeErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_ChannelUpdateDecodeErrorZ_clone_ptr(LDKCResult_ChannelUpdateDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_ChannelUpdateDecodeErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelUpdateDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelUpdateDecodeErrorZ CResult_ChannelUpdateDecodeErrorZ_clone(const struct LDKCResult_ChannelUpdateDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_ChannelUpdateDecodeErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ChannelUpdateDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_ErrorMessageDecodeErrorZ CResult_ErrorMessageDecodeErrorZ_ok(struct LDKErrorMessage o);
/* @internal */
export function CResult_ErrorMessageDecodeErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ErrorMessageDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_ErrorMessageDecodeErrorZ CResult_ErrorMessageDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_ErrorMessageDecodeErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ErrorMessageDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_ErrorMessageDecodeErrorZ_is_ok(const struct LDKCResult_ErrorMessageDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_ErrorMessageDecodeErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ErrorMessageDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_ErrorMessageDecodeErrorZ_free(struct LDKCResult_ErrorMessageDecodeErrorZ _res);
/* @internal */
export function CResult_ErrorMessageDecodeErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ErrorMessageDecodeErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_ErrorMessageDecodeErrorZ_clone_ptr(LDKCResult_ErrorMessageDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_ErrorMessageDecodeErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ErrorMessageDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_ErrorMessageDecodeErrorZ CResult_ErrorMessageDecodeErrorZ_clone(const struct LDKCResult_ErrorMessageDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_ErrorMessageDecodeErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ErrorMessageDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_WarningMessageDecodeErrorZ CResult_WarningMessageDecodeErrorZ_ok(struct LDKWarningMessage o);
/* @internal */
export function CResult_WarningMessageDecodeErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_WarningMessageDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_WarningMessageDecodeErrorZ CResult_WarningMessageDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_WarningMessageDecodeErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_WarningMessageDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_WarningMessageDecodeErrorZ_is_ok(const struct LDKCResult_WarningMessageDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_WarningMessageDecodeErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_WarningMessageDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_WarningMessageDecodeErrorZ_free(struct LDKCResult_WarningMessageDecodeErrorZ _res);
/* @internal */
export function CResult_WarningMessageDecodeErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_WarningMessageDecodeErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_WarningMessageDecodeErrorZ_clone_ptr(LDKCResult_WarningMessageDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_WarningMessageDecodeErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_WarningMessageDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_WarningMessageDecodeErrorZ CResult_WarningMessageDecodeErrorZ_clone(const struct LDKCResult_WarningMessageDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_WarningMessageDecodeErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_WarningMessageDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ CResult_UnsignedNodeAnnouncementDecodeErrorZ_ok(struct LDKUnsignedNodeAnnouncement o);
/* @internal */
export function CResult_UnsignedNodeAnnouncementDecodeErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UnsignedNodeAnnouncementDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ CResult_UnsignedNodeAnnouncementDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_UnsignedNodeAnnouncementDecodeErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UnsignedNodeAnnouncementDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_UnsignedNodeAnnouncementDecodeErrorZ_is_ok(const struct LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_UnsignedNodeAnnouncementDecodeErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UnsignedNodeAnnouncementDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_UnsignedNodeAnnouncementDecodeErrorZ_free(struct LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ _res);
/* @internal */
export function CResult_UnsignedNodeAnnouncementDecodeErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UnsignedNodeAnnouncementDecodeErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_UnsignedNodeAnnouncementDecodeErrorZ_clone_ptr(LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_UnsignedNodeAnnouncementDecodeErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UnsignedNodeAnnouncementDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ CResult_UnsignedNodeAnnouncementDecodeErrorZ_clone(const struct LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_UnsignedNodeAnnouncementDecodeErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_UnsignedNodeAnnouncementDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_NodeAnnouncementDecodeErrorZ CResult_NodeAnnouncementDecodeErrorZ_ok(struct LDKNodeAnnouncement o);
/* @internal */
export function CResult_NodeAnnouncementDecodeErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NodeAnnouncementDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_NodeAnnouncementDecodeErrorZ CResult_NodeAnnouncementDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_NodeAnnouncementDecodeErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NodeAnnouncementDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_NodeAnnouncementDecodeErrorZ_is_ok(const struct LDKCResult_NodeAnnouncementDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_NodeAnnouncementDecodeErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NodeAnnouncementDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_NodeAnnouncementDecodeErrorZ_free(struct LDKCResult_NodeAnnouncementDecodeErrorZ _res);
/* @internal */
export function CResult_NodeAnnouncementDecodeErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NodeAnnouncementDecodeErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_NodeAnnouncementDecodeErrorZ_clone_ptr(LDKCResult_NodeAnnouncementDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_NodeAnnouncementDecodeErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NodeAnnouncementDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_NodeAnnouncementDecodeErrorZ CResult_NodeAnnouncementDecodeErrorZ_clone(const struct LDKCResult_NodeAnnouncementDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_NodeAnnouncementDecodeErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_NodeAnnouncementDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_QueryShortChannelIdsDecodeErrorZ CResult_QueryShortChannelIdsDecodeErrorZ_ok(struct LDKQueryShortChannelIds o);
/* @internal */
export function CResult_QueryShortChannelIdsDecodeErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_QueryShortChannelIdsDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_QueryShortChannelIdsDecodeErrorZ CResult_QueryShortChannelIdsDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_QueryShortChannelIdsDecodeErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_QueryShortChannelIdsDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_QueryShortChannelIdsDecodeErrorZ_is_ok(const struct LDKCResult_QueryShortChannelIdsDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_QueryShortChannelIdsDecodeErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_QueryShortChannelIdsDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_QueryShortChannelIdsDecodeErrorZ_free(struct LDKCResult_QueryShortChannelIdsDecodeErrorZ _res);
/* @internal */
export function CResult_QueryShortChannelIdsDecodeErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_QueryShortChannelIdsDecodeErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_QueryShortChannelIdsDecodeErrorZ_clone_ptr(LDKCResult_QueryShortChannelIdsDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_QueryShortChannelIdsDecodeErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_QueryShortChannelIdsDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_QueryShortChannelIdsDecodeErrorZ CResult_QueryShortChannelIdsDecodeErrorZ_clone(const struct LDKCResult_QueryShortChannelIdsDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_QueryShortChannelIdsDecodeErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_QueryShortChannelIdsDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ CResult_ReplyShortChannelIdsEndDecodeErrorZ_ok(struct LDKReplyShortChannelIdsEnd o);
/* @internal */
export function CResult_ReplyShortChannelIdsEndDecodeErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ReplyShortChannelIdsEndDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ CResult_ReplyShortChannelIdsEndDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_ReplyShortChannelIdsEndDecodeErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ReplyShortChannelIdsEndDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_ReplyShortChannelIdsEndDecodeErrorZ_is_ok(const struct LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_ReplyShortChannelIdsEndDecodeErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ReplyShortChannelIdsEndDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_ReplyShortChannelIdsEndDecodeErrorZ_free(struct LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ _res);
/* @internal */
export function CResult_ReplyShortChannelIdsEndDecodeErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ReplyShortChannelIdsEndDecodeErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_ReplyShortChannelIdsEndDecodeErrorZ_clone_ptr(LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_ReplyShortChannelIdsEndDecodeErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ReplyShortChannelIdsEndDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ CResult_ReplyShortChannelIdsEndDecodeErrorZ_clone(const struct LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_ReplyShortChannelIdsEndDecodeErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ReplyShortChannelIdsEndDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_QueryChannelRangeDecodeErrorZ CResult_QueryChannelRangeDecodeErrorZ_ok(struct LDKQueryChannelRange o);
/* @internal */
export function CResult_QueryChannelRangeDecodeErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_QueryChannelRangeDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_QueryChannelRangeDecodeErrorZ CResult_QueryChannelRangeDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_QueryChannelRangeDecodeErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_QueryChannelRangeDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_QueryChannelRangeDecodeErrorZ_is_ok(const struct LDKCResult_QueryChannelRangeDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_QueryChannelRangeDecodeErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_QueryChannelRangeDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_QueryChannelRangeDecodeErrorZ_free(struct LDKCResult_QueryChannelRangeDecodeErrorZ _res);
/* @internal */
export function CResult_QueryChannelRangeDecodeErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_QueryChannelRangeDecodeErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_QueryChannelRangeDecodeErrorZ_clone_ptr(LDKCResult_QueryChannelRangeDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_QueryChannelRangeDecodeErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_QueryChannelRangeDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_QueryChannelRangeDecodeErrorZ CResult_QueryChannelRangeDecodeErrorZ_clone(const struct LDKCResult_QueryChannelRangeDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_QueryChannelRangeDecodeErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_QueryChannelRangeDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_ReplyChannelRangeDecodeErrorZ CResult_ReplyChannelRangeDecodeErrorZ_ok(struct LDKReplyChannelRange o);
/* @internal */
export function CResult_ReplyChannelRangeDecodeErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ReplyChannelRangeDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_ReplyChannelRangeDecodeErrorZ CResult_ReplyChannelRangeDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_ReplyChannelRangeDecodeErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ReplyChannelRangeDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_ReplyChannelRangeDecodeErrorZ_is_ok(const struct LDKCResult_ReplyChannelRangeDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_ReplyChannelRangeDecodeErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ReplyChannelRangeDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_ReplyChannelRangeDecodeErrorZ_free(struct LDKCResult_ReplyChannelRangeDecodeErrorZ _res);
/* @internal */
export function CResult_ReplyChannelRangeDecodeErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ReplyChannelRangeDecodeErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_ReplyChannelRangeDecodeErrorZ_clone_ptr(LDKCResult_ReplyChannelRangeDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_ReplyChannelRangeDecodeErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ReplyChannelRangeDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_ReplyChannelRangeDecodeErrorZ CResult_ReplyChannelRangeDecodeErrorZ_clone(const struct LDKCResult_ReplyChannelRangeDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_ReplyChannelRangeDecodeErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_ReplyChannelRangeDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_GossipTimestampFilterDecodeErrorZ CResult_GossipTimestampFilterDecodeErrorZ_ok(struct LDKGossipTimestampFilter o);
/* @internal */
export function CResult_GossipTimestampFilterDecodeErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_GossipTimestampFilterDecodeErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_GossipTimestampFilterDecodeErrorZ CResult_GossipTimestampFilterDecodeErrorZ_err(struct LDKDecodeError e);
/* @internal */
export function CResult_GossipTimestampFilterDecodeErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_GossipTimestampFilterDecodeErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_GossipTimestampFilterDecodeErrorZ_is_ok(const struct LDKCResult_GossipTimestampFilterDecodeErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_GossipTimestampFilterDecodeErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_GossipTimestampFilterDecodeErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_GossipTimestampFilterDecodeErrorZ_free(struct LDKCResult_GossipTimestampFilterDecodeErrorZ _res);
/* @internal */
export function CResult_GossipTimestampFilterDecodeErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_GossipTimestampFilterDecodeErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_GossipTimestampFilterDecodeErrorZ_clone_ptr(LDKCResult_GossipTimestampFilterDecodeErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_GossipTimestampFilterDecodeErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_GossipTimestampFilterDecodeErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_GossipTimestampFilterDecodeErrorZ CResult_GossipTimestampFilterDecodeErrorZ_clone(const struct LDKCResult_GossipTimestampFilterDecodeErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_GossipTimestampFilterDecodeErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_GossipTimestampFilterDecodeErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCResult_InvoiceSignOrCreationErrorZ CResult_InvoiceSignOrCreationErrorZ_ok(struct LDKInvoice o);
/* @internal */
export function CResult_InvoiceSignOrCreationErrorZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InvoiceSignOrCreationErrorZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_InvoiceSignOrCreationErrorZ CResult_InvoiceSignOrCreationErrorZ_err(struct LDKSignOrCreationError e);
/* @internal */
export function CResult_InvoiceSignOrCreationErrorZ_err(e: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InvoiceSignOrCreationErrorZ_err(e);
	return nativeResponseValue;
}
	// bool CResult_InvoiceSignOrCreationErrorZ_is_ok(const struct LDKCResult_InvoiceSignOrCreationErrorZ *NONNULL_PTR o);
/* @internal */
export function CResult_InvoiceSignOrCreationErrorZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InvoiceSignOrCreationErrorZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_InvoiceSignOrCreationErrorZ_free(struct LDKCResult_InvoiceSignOrCreationErrorZ _res);
/* @internal */
export function CResult_InvoiceSignOrCreationErrorZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InvoiceSignOrCreationErrorZ_free(_res);
	// debug statements here
}
	// uintptr_t CResult_InvoiceSignOrCreationErrorZ_clone_ptr(LDKCResult_InvoiceSignOrCreationErrorZ *NONNULL_PTR arg);
/* @internal */
export function CResult_InvoiceSignOrCreationErrorZ_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InvoiceSignOrCreationErrorZ_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCResult_InvoiceSignOrCreationErrorZ CResult_InvoiceSignOrCreationErrorZ_clone(const struct LDKCResult_InvoiceSignOrCreationErrorZ *NONNULL_PTR orig);
/* @internal */
export function CResult_InvoiceSignOrCreationErrorZ_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_InvoiceSignOrCreationErrorZ_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCOption_FilterZ COption_FilterZ_some(struct LDKFilter o);
/* @internal */
export function COption_FilterZ_some(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_FilterZ_some(o);
	return nativeResponseValue;
}
	// struct LDKCOption_FilterZ COption_FilterZ_none(void);
/* @internal */
export function COption_FilterZ_none(): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_FilterZ_none();
	return nativeResponseValue;
}
	// void COption_FilterZ_free(struct LDKCOption_FilterZ _res);
/* @internal */
export function COption_FilterZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_COption_FilterZ_free(_res);
	// debug statements here
}
	// struct LDKCResult_LockedChannelMonitorNoneZ CResult_LockedChannelMonitorNoneZ_ok(struct LDKLockedChannelMonitor o);
/* @internal */
export function CResult_LockedChannelMonitorNoneZ_ok(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_LockedChannelMonitorNoneZ_ok(o);
	return nativeResponseValue;
}
	// struct LDKCResult_LockedChannelMonitorNoneZ CResult_LockedChannelMonitorNoneZ_err(void);
/* @internal */
export function CResult_LockedChannelMonitorNoneZ_err(): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_LockedChannelMonitorNoneZ_err();
	return nativeResponseValue;
}
	// bool CResult_LockedChannelMonitorNoneZ_is_ok(const struct LDKCResult_LockedChannelMonitorNoneZ *NONNULL_PTR o);
/* @internal */
export function CResult_LockedChannelMonitorNoneZ_is_ok(o: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_LockedChannelMonitorNoneZ_is_ok(o);
	return nativeResponseValue;
}
	// void CResult_LockedChannelMonitorNoneZ_free(struct LDKCResult_LockedChannelMonitorNoneZ _res);
/* @internal */
export function CResult_LockedChannelMonitorNoneZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CResult_LockedChannelMonitorNoneZ_free(_res);
	// debug statements here
}
	// void CVec_OutPointZ_free(struct LDKCVec_OutPointZ _res);
/* @internal */
export function CVec_OutPointZ_free(_res: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CVec_OutPointZ_free(_res);
	// debug statements here
}
	// void PaymentPurpose_free(struct LDKPaymentPurpose this_ptr);
/* @internal */
export function PaymentPurpose_free(this_ptr: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentPurpose_free(this_ptr);
	// debug statements here
}
	// uintptr_t PaymentPurpose_clone_ptr(LDKPaymentPurpose *NONNULL_PTR arg);
/* @internal */
export function PaymentPurpose_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentPurpose_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKPaymentPurpose PaymentPurpose_clone(const struct LDKPaymentPurpose *NONNULL_PTR orig);
/* @internal */
export function PaymentPurpose_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentPurpose_clone(orig);
	return nativeResponseValue;
}
	// struct LDKPaymentPurpose PaymentPurpose_invoice_payment(struct LDKThirtyTwoBytes payment_preimage, struct LDKThirtyTwoBytes payment_secret);
/* @internal */
export function PaymentPurpose_invoice_payment(payment_preimage: number, payment_secret: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentPurpose_invoice_payment(payment_preimage, payment_secret);
	return nativeResponseValue;
}
	// struct LDKPaymentPurpose PaymentPurpose_spontaneous_payment(struct LDKThirtyTwoBytes a);
/* @internal */
export function PaymentPurpose_spontaneous_payment(a: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentPurpose_spontaneous_payment(a);
	return nativeResponseValue;
}
	// void ClosureReason_free(struct LDKClosureReason this_ptr);
/* @internal */
export function ClosureReason_free(this_ptr: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosureReason_free(this_ptr);
	// debug statements here
}
	// uintptr_t ClosureReason_clone_ptr(LDKClosureReason *NONNULL_PTR arg);
/* @internal */
export function ClosureReason_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosureReason_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKClosureReason ClosureReason_clone(const struct LDKClosureReason *NONNULL_PTR orig);
/* @internal */
export function ClosureReason_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosureReason_clone(orig);
	return nativeResponseValue;
}
	// struct LDKClosureReason ClosureReason_counterparty_force_closed(struct LDKStr peer_msg);
/* @internal */
export function ClosureReason_counterparty_force_closed(peer_msg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosureReason_counterparty_force_closed(peer_msg);
	return nativeResponseValue;
}
	// struct LDKClosureReason ClosureReason_holder_force_closed(void);
/* @internal */
export function ClosureReason_holder_force_closed(): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosureReason_holder_force_closed();
	return nativeResponseValue;
}
	// struct LDKClosureReason ClosureReason_cooperative_closure(void);
/* @internal */
export function ClosureReason_cooperative_closure(): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosureReason_cooperative_closure();
	return nativeResponseValue;
}
	// struct LDKClosureReason ClosureReason_commitment_tx_confirmed(void);
/* @internal */
export function ClosureReason_commitment_tx_confirmed(): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosureReason_commitment_tx_confirmed();
	return nativeResponseValue;
}
	// struct LDKClosureReason ClosureReason_funding_timed_out(void);
/* @internal */
export function ClosureReason_funding_timed_out(): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosureReason_funding_timed_out();
	return nativeResponseValue;
}
	// struct LDKClosureReason ClosureReason_processing_error(struct LDKStr err);
/* @internal */
export function ClosureReason_processing_error(err: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosureReason_processing_error(err);
	return nativeResponseValue;
}
	// struct LDKClosureReason ClosureReason_disconnected_peer(void);
/* @internal */
export function ClosureReason_disconnected_peer(): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosureReason_disconnected_peer();
	return nativeResponseValue;
}
	// struct LDKClosureReason ClosureReason_outdated_channel_manager(void);
/* @internal */
export function ClosureReason_outdated_channel_manager(): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosureReason_outdated_channel_manager();
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z ClosureReason_write(const struct LDKClosureReason *NONNULL_PTR obj);
/* @internal */
export function ClosureReason_write(obj: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosureReason_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_COption_ClosureReasonZDecodeErrorZ ClosureReason_read(struct LDKu8slice ser);
/* @internal */
export function ClosureReason_read(ser: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosureReason_read(ser);
	return nativeResponseValue;
}
	// void Event_free(struct LDKEvent this_ptr);
/* @internal */
export function Event_free(this_ptr: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Event_free(this_ptr);
	// debug statements here
}
	// uintptr_t Event_clone_ptr(LDKEvent *NONNULL_PTR arg);
/* @internal */
export function Event_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Event_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKEvent Event_clone(const struct LDKEvent *NONNULL_PTR orig);
/* @internal */
export function Event_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Event_clone(orig);
	return nativeResponseValue;
}
	// struct LDKEvent Event_funding_generation_ready(struct LDKThirtyTwoBytes temporary_channel_id, uint64_t channel_value_satoshis, struct LDKCVec_u8Z output_script, uint64_t user_channel_id);
/* @internal */
export function Event_funding_generation_ready(temporary_channel_id: number, channel_value_satoshis: bigint, output_script: number, user_channel_id: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Event_funding_generation_ready(temporary_channel_id, channel_value_satoshis, output_script, user_channel_id);
	return nativeResponseValue;
}
	// struct LDKEvent Event_payment_received(struct LDKThirtyTwoBytes payment_hash, uint64_t amt, struct LDKPaymentPurpose purpose);
/* @internal */
export function Event_payment_received(payment_hash: number, amt: bigint, purpose: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Event_payment_received(payment_hash, amt, purpose);
	return nativeResponseValue;
}
	// struct LDKEvent Event_payment_sent(struct LDKThirtyTwoBytes payment_id, struct LDKThirtyTwoBytes payment_preimage, struct LDKThirtyTwoBytes payment_hash, struct LDKCOption_u64Z fee_paid_msat);
/* @internal */
export function Event_payment_sent(payment_id: number, payment_preimage: number, payment_hash: number, fee_paid_msat: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Event_payment_sent(payment_id, payment_preimage, payment_hash, fee_paid_msat);
	return nativeResponseValue;
}
	// struct LDKEvent Event_payment_path_failed(struct LDKThirtyTwoBytes payment_id, struct LDKThirtyTwoBytes payment_hash, bool rejected_by_dest, struct LDKCOption_NetworkUpdateZ network_update, bool all_paths_failed, struct LDKCVec_RouteHopZ path, struct LDKCOption_u64Z short_channel_id, struct LDKRouteParameters retry);
/* @internal */
export function Event_payment_path_failed(payment_id: number, payment_hash: number, rejected_by_dest: boolean, network_update: number, all_paths_failed: boolean, path: number, short_channel_id: number, retry: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Event_payment_path_failed(payment_id, payment_hash, rejected_by_dest, network_update, all_paths_failed, path, short_channel_id, retry);
	return nativeResponseValue;
}
	// struct LDKEvent Event_payment_failed(struct LDKThirtyTwoBytes payment_id, struct LDKThirtyTwoBytes payment_hash);
/* @internal */
export function Event_payment_failed(payment_id: number, payment_hash: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Event_payment_failed(payment_id, payment_hash);
	return nativeResponseValue;
}
	// struct LDKEvent Event_pending_htlcs_forwardable(uint64_t time_forwardable);
/* @internal */
export function Event_pending_htlcs_forwardable(time_forwardable: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Event_pending_htlcs_forwardable(time_forwardable);
	return nativeResponseValue;
}
	// struct LDKEvent Event_spendable_outputs(struct LDKCVec_SpendableOutputDescriptorZ outputs);
/* @internal */
export function Event_spendable_outputs(outputs: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Event_spendable_outputs(outputs);
	return nativeResponseValue;
}
	// struct LDKEvent Event_payment_forwarded(struct LDKCOption_u64Z fee_earned_msat, bool claim_from_onchain_tx);
/* @internal */
export function Event_payment_forwarded(fee_earned_msat: number, claim_from_onchain_tx: boolean): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Event_payment_forwarded(fee_earned_msat, claim_from_onchain_tx);
	return nativeResponseValue;
}
	// struct LDKEvent Event_channel_closed(struct LDKThirtyTwoBytes channel_id, uint64_t user_channel_id, struct LDKClosureReason reason);
/* @internal */
export function Event_channel_closed(channel_id: number, user_channel_id: bigint, reason: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Event_channel_closed(channel_id, user_channel_id, reason);
	return nativeResponseValue;
}
	// struct LDKEvent Event_discard_funding(struct LDKThirtyTwoBytes channel_id, struct LDKTransaction transaction);
/* @internal */
export function Event_discard_funding(channel_id: number, transaction: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Event_discard_funding(channel_id, transaction);
	return nativeResponseValue;
}
	// struct LDKEvent Event_payment_path_successful(struct LDKThirtyTwoBytes payment_id, struct LDKThirtyTwoBytes payment_hash, struct LDKCVec_RouteHopZ path);
/* @internal */
export function Event_payment_path_successful(payment_id: number, payment_hash: number, path: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Event_payment_path_successful(payment_id, payment_hash, path);
	return nativeResponseValue;
}
	// struct LDKEvent Event_open_channel_request(struct LDKThirtyTwoBytes temporary_channel_id, struct LDKPublicKey counterparty_node_id, uint64_t funding_satoshis, uint64_t push_msat, struct LDKChannelTypeFeatures channel_type);
/* @internal */
export function Event_open_channel_request(temporary_channel_id: number, counterparty_node_id: number, funding_satoshis: bigint, push_msat: bigint, channel_type: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Event_open_channel_request(temporary_channel_id, counterparty_node_id, funding_satoshis, push_msat, channel_type);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z Event_write(const struct LDKEvent *NONNULL_PTR obj);
/* @internal */
export function Event_write(obj: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Event_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_COption_EventZDecodeErrorZ Event_read(struct LDKu8slice ser);
/* @internal */
export function Event_read(ser: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Event_read(ser);
	return nativeResponseValue;
}
	// void MessageSendEvent_free(struct LDKMessageSendEvent this_ptr);
/* @internal */
export function MessageSendEvent_free(this_ptr: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MessageSendEvent_free(this_ptr);
	// debug statements here
}
	// uintptr_t MessageSendEvent_clone_ptr(LDKMessageSendEvent *NONNULL_PTR arg);
/* @internal */
export function MessageSendEvent_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MessageSendEvent_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKMessageSendEvent MessageSendEvent_clone(const struct LDKMessageSendEvent *NONNULL_PTR orig);
/* @internal */
export function MessageSendEvent_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MessageSendEvent_clone(orig);
	return nativeResponseValue;
}
	// struct LDKMessageSendEvent MessageSendEvent_send_accept_channel(struct LDKPublicKey node_id, struct LDKAcceptChannel msg);
/* @internal */
export function MessageSendEvent_send_accept_channel(node_id: number, msg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MessageSendEvent_send_accept_channel(node_id, msg);
	return nativeResponseValue;
}
	// struct LDKMessageSendEvent MessageSendEvent_send_open_channel(struct LDKPublicKey node_id, struct LDKOpenChannel msg);
/* @internal */
export function MessageSendEvent_send_open_channel(node_id: number, msg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MessageSendEvent_send_open_channel(node_id, msg);
	return nativeResponseValue;
}
	// struct LDKMessageSendEvent MessageSendEvent_send_funding_created(struct LDKPublicKey node_id, struct LDKFundingCreated msg);
/* @internal */
export function MessageSendEvent_send_funding_created(node_id: number, msg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MessageSendEvent_send_funding_created(node_id, msg);
	return nativeResponseValue;
}
	// struct LDKMessageSendEvent MessageSendEvent_send_funding_signed(struct LDKPublicKey node_id, struct LDKFundingSigned msg);
/* @internal */
export function MessageSendEvent_send_funding_signed(node_id: number, msg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MessageSendEvent_send_funding_signed(node_id, msg);
	return nativeResponseValue;
}
	// struct LDKMessageSendEvent MessageSendEvent_send_funding_locked(struct LDKPublicKey node_id, struct LDKFundingLocked msg);
/* @internal */
export function MessageSendEvent_send_funding_locked(node_id: number, msg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MessageSendEvent_send_funding_locked(node_id, msg);
	return nativeResponseValue;
}
	// struct LDKMessageSendEvent MessageSendEvent_send_announcement_signatures(struct LDKPublicKey node_id, struct LDKAnnouncementSignatures msg);
/* @internal */
export function MessageSendEvent_send_announcement_signatures(node_id: number, msg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MessageSendEvent_send_announcement_signatures(node_id, msg);
	return nativeResponseValue;
}
	// struct LDKMessageSendEvent MessageSendEvent_update_htlcs(struct LDKPublicKey node_id, struct LDKCommitmentUpdate updates);
/* @internal */
export function MessageSendEvent_update_htlcs(node_id: number, updates: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MessageSendEvent_update_htlcs(node_id, updates);
	return nativeResponseValue;
}
	// struct LDKMessageSendEvent MessageSendEvent_send_revoke_and_ack(struct LDKPublicKey node_id, struct LDKRevokeAndACK msg);
/* @internal */
export function MessageSendEvent_send_revoke_and_ack(node_id: number, msg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MessageSendEvent_send_revoke_and_ack(node_id, msg);
	return nativeResponseValue;
}
	// struct LDKMessageSendEvent MessageSendEvent_send_closing_signed(struct LDKPublicKey node_id, struct LDKClosingSigned msg);
/* @internal */
export function MessageSendEvent_send_closing_signed(node_id: number, msg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MessageSendEvent_send_closing_signed(node_id, msg);
	return nativeResponseValue;
}
	// struct LDKMessageSendEvent MessageSendEvent_send_shutdown(struct LDKPublicKey node_id, struct LDKShutdown msg);
/* @internal */
export function MessageSendEvent_send_shutdown(node_id: number, msg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MessageSendEvent_send_shutdown(node_id, msg);
	return nativeResponseValue;
}
	// struct LDKMessageSendEvent MessageSendEvent_send_channel_reestablish(struct LDKPublicKey node_id, struct LDKChannelReestablish msg);
/* @internal */
export function MessageSendEvent_send_channel_reestablish(node_id: number, msg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MessageSendEvent_send_channel_reestablish(node_id, msg);
	return nativeResponseValue;
}
	// struct LDKMessageSendEvent MessageSendEvent_broadcast_channel_announcement(struct LDKChannelAnnouncement msg, struct LDKChannelUpdate update_msg);
/* @internal */
export function MessageSendEvent_broadcast_channel_announcement(msg: number, update_msg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MessageSendEvent_broadcast_channel_announcement(msg, update_msg);
	return nativeResponseValue;
}
	// struct LDKMessageSendEvent MessageSendEvent_broadcast_node_announcement(struct LDKNodeAnnouncement msg);
/* @internal */
export function MessageSendEvent_broadcast_node_announcement(msg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MessageSendEvent_broadcast_node_announcement(msg);
	return nativeResponseValue;
}
	// struct LDKMessageSendEvent MessageSendEvent_broadcast_channel_update(struct LDKChannelUpdate msg);
/* @internal */
export function MessageSendEvent_broadcast_channel_update(msg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MessageSendEvent_broadcast_channel_update(msg);
	return nativeResponseValue;
}
	// struct LDKMessageSendEvent MessageSendEvent_send_channel_update(struct LDKPublicKey node_id, struct LDKChannelUpdate msg);
/* @internal */
export function MessageSendEvent_send_channel_update(node_id: number, msg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MessageSendEvent_send_channel_update(node_id, msg);
	return nativeResponseValue;
}
	// struct LDKMessageSendEvent MessageSendEvent_handle_error(struct LDKPublicKey node_id, struct LDKErrorAction action);
/* @internal */
export function MessageSendEvent_handle_error(node_id: number, action: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MessageSendEvent_handle_error(node_id, action);
	return nativeResponseValue;
}
	// struct LDKMessageSendEvent MessageSendEvent_send_channel_range_query(struct LDKPublicKey node_id, struct LDKQueryChannelRange msg);
/* @internal */
export function MessageSendEvent_send_channel_range_query(node_id: number, msg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MessageSendEvent_send_channel_range_query(node_id, msg);
	return nativeResponseValue;
}
	// struct LDKMessageSendEvent MessageSendEvent_send_short_ids_query(struct LDKPublicKey node_id, struct LDKQueryShortChannelIds msg);
/* @internal */
export function MessageSendEvent_send_short_ids_query(node_id: number, msg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MessageSendEvent_send_short_ids_query(node_id, msg);
	return nativeResponseValue;
}
	// struct LDKMessageSendEvent MessageSendEvent_send_reply_channel_range(struct LDKPublicKey node_id, struct LDKReplyChannelRange msg);
/* @internal */
export function MessageSendEvent_send_reply_channel_range(node_id: number, msg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MessageSendEvent_send_reply_channel_range(node_id, msg);
	return nativeResponseValue;
}
	// struct LDKMessageSendEvent MessageSendEvent_send_gossip_timestamp_filter(struct LDKPublicKey node_id, struct LDKGossipTimestampFilter msg);
/* @internal */
export function MessageSendEvent_send_gossip_timestamp_filter(node_id: number, msg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MessageSendEvent_send_gossip_timestamp_filter(node_id, msg);
	return nativeResponseValue;
}
	// void MessageSendEventsProvider_free(struct LDKMessageSendEventsProvider this_ptr);
/* @internal */
export function MessageSendEventsProvider_free(this_ptr: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MessageSendEventsProvider_free(this_ptr);
	// debug statements here
}
	// void EventsProvider_free(struct LDKEventsProvider this_ptr);
/* @internal */
export function EventsProvider_free(this_ptr: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_EventsProvider_free(this_ptr);
	// debug statements here
}
	// void EventHandler_free(struct LDKEventHandler this_ptr);
/* @internal */
export function EventHandler_free(this_ptr: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_EventHandler_free(this_ptr);
	// debug statements here
}
	// void APIError_free(struct LDKAPIError this_ptr);
/* @internal */
export function APIError_free(this_ptr: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_APIError_free(this_ptr);
	// debug statements here
}
	// uintptr_t APIError_clone_ptr(LDKAPIError *NONNULL_PTR arg);
/* @internal */
export function APIError_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_APIError_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKAPIError APIError_clone(const struct LDKAPIError *NONNULL_PTR orig);
/* @internal */
export function APIError_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_APIError_clone(orig);
	return nativeResponseValue;
}
	// struct LDKAPIError APIError_apimisuse_error(struct LDKStr err);
/* @internal */
export function APIError_apimisuse_error(err: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_APIError_apimisuse_error(err);
	return nativeResponseValue;
}
	// struct LDKAPIError APIError_fee_rate_too_high(struct LDKStr err, uint32_t feerate);
/* @internal */
export function APIError_fee_rate_too_high(err: number, feerate: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_APIError_fee_rate_too_high(err, feerate);
	return nativeResponseValue;
}
	// struct LDKAPIError APIError_route_error(struct LDKStr err);
/* @internal */
export function APIError_route_error(err: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_APIError_route_error(err);
	return nativeResponseValue;
}
	// struct LDKAPIError APIError_channel_unavailable(struct LDKStr err);
/* @internal */
export function APIError_channel_unavailable(err: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_APIError_channel_unavailable(err);
	return nativeResponseValue;
}
	// struct LDKAPIError APIError_monitor_update_failed(void);
/* @internal */
export function APIError_monitor_update_failed(): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_APIError_monitor_update_failed();
	return nativeResponseValue;
}
	// struct LDKAPIError APIError_incompatible_shutdown_script(struct LDKShutdownScript script);
/* @internal */
export function APIError_incompatible_shutdown_script(script: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_APIError_incompatible_shutdown_script(script);
	return nativeResponseValue;
}
	// struct LDKCResult_StringErrorZ sign(struct LDKu8slice msg, const uint8_t (*sk)[32]);
/* @internal */
export function sign(msg: number, sk: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_sign(msg, sk);
	return nativeResponseValue;
}
	// struct LDKCResult_PublicKeyErrorZ recover_pk(struct LDKu8slice msg, struct LDKStr sig);
/* @internal */
export function recover_pk(msg: number, sig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_recover_pk(msg, sig);
	return nativeResponseValue;
}
	// bool verify(struct LDKu8slice msg, struct LDKStr sig, struct LDKPublicKey pk);
/* @internal */
export function verify(msg: number, sig: number, pk: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_verify(msg, sig, pk);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z construct_invoice_preimage(struct LDKu8slice hrp_bytes, struct LDKCVec_u5Z data_without_signature);
/* @internal */
export function construct_invoice_preimage(hrp_bytes: number, data_without_signature: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_construct_invoice_preimage(hrp_bytes, data_without_signature);
	return nativeResponseValue;
}
	// enum LDKLevel Level_clone(const enum LDKLevel *NONNULL_PTR orig);
/* @internal */
export function Level_clone(orig: number): Level {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Level_clone(orig);
	return nativeResponseValue;
}
	// enum LDKLevel Level_gossip(void);
/* @internal */
export function Level_gossip(): Level {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Level_gossip();
	return nativeResponseValue;
}
	// enum LDKLevel Level_trace(void);
/* @internal */
export function Level_trace(): Level {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Level_trace();
	return nativeResponseValue;
}
	// enum LDKLevel Level_debug(void);
/* @internal */
export function Level_debug(): Level {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Level_debug();
	return nativeResponseValue;
}
	// enum LDKLevel Level_info(void);
/* @internal */
export function Level_info(): Level {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Level_info();
	return nativeResponseValue;
}
	// enum LDKLevel Level_warn(void);
/* @internal */
export function Level_warn(): Level {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Level_warn();
	return nativeResponseValue;
}
	// enum LDKLevel Level_error(void);
/* @internal */
export function Level_error(): Level {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Level_error();
	return nativeResponseValue;
}
	// bool Level_eq(const enum LDKLevel *NONNULL_PTR a, const enum LDKLevel *NONNULL_PTR b);
/* @internal */
export function Level_eq(a: number, b: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Level_eq(a, b);
	return nativeResponseValue;
}
	// uint64_t Level_hash(const enum LDKLevel *NONNULL_PTR o);
/* @internal */
export function Level_hash(o: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Level_hash(o);
	return nativeResponseValue;
}
	// MUST_USE_RES enum LDKLevel Level_max(void);
/* @internal */
export function Level_max(): Level {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Level_max();
	return nativeResponseValue;
}
	// void Record_free(struct LDKRecord this_obj);
/* @internal */
export function Record_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Record_free(this_obj);
	// debug statements here
}
	// enum LDKLevel Record_get_level(const struct LDKRecord *NONNULL_PTR this_ptr);
/* @internal */
export function Record_get_level(this_ptr: number): Level {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Record_get_level(this_ptr);
	return nativeResponseValue;
}
	// void Record_set_level(struct LDKRecord *NONNULL_PTR this_ptr, enum LDKLevel val);
/* @internal */
export function Record_set_level(this_ptr: number, val: Level): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Record_set_level(this_ptr, val);
	// debug statements here
}
	// struct LDKStr Record_get_args(const struct LDKRecord *NONNULL_PTR this_ptr);
/* @internal */
export function Record_get_args(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Record_get_args(this_ptr);
	return nativeResponseValue;
}
	// void Record_set_args(struct LDKRecord *NONNULL_PTR this_ptr, struct LDKStr val);
/* @internal */
export function Record_set_args(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Record_set_args(this_ptr, val);
	// debug statements here
}
	// struct LDKStr Record_get_module_path(const struct LDKRecord *NONNULL_PTR this_ptr);
/* @internal */
export function Record_get_module_path(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Record_get_module_path(this_ptr);
	return nativeResponseValue;
}
	// void Record_set_module_path(struct LDKRecord *NONNULL_PTR this_ptr, struct LDKStr val);
/* @internal */
export function Record_set_module_path(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Record_set_module_path(this_ptr, val);
	// debug statements here
}
	// struct LDKStr Record_get_file(const struct LDKRecord *NONNULL_PTR this_ptr);
/* @internal */
export function Record_get_file(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Record_get_file(this_ptr);
	return nativeResponseValue;
}
	// void Record_set_file(struct LDKRecord *NONNULL_PTR this_ptr, struct LDKStr val);
/* @internal */
export function Record_set_file(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Record_set_file(this_ptr, val);
	// debug statements here
}
	// uint32_t Record_get_line(const struct LDKRecord *NONNULL_PTR this_ptr);
/* @internal */
export function Record_get_line(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Record_get_line(this_ptr);
	return nativeResponseValue;
}
	// void Record_set_line(struct LDKRecord *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */
export function Record_set_line(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Record_set_line(this_ptr, val);
	// debug statements here
}
	// uintptr_t Record_clone_ptr(LDKRecord *NONNULL_PTR arg);
/* @internal */
export function Record_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Record_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKRecord Record_clone(const struct LDKRecord *NONNULL_PTR orig);
/* @internal */
export function Record_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Record_clone(orig);
	return nativeResponseValue;
}
	// void Logger_free(struct LDKLogger this_ptr);
/* @internal */
export function Logger_free(this_ptr: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Logger_free(this_ptr);
	// debug statements here
}
	// void ChannelHandshakeConfig_free(struct LDKChannelHandshakeConfig this_obj);
/* @internal */
export function ChannelHandshakeConfig_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelHandshakeConfig_free(this_obj);
	// debug statements here
}
	// uint32_t ChannelHandshakeConfig_get_minimum_depth(const struct LDKChannelHandshakeConfig *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelHandshakeConfig_get_minimum_depth(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelHandshakeConfig_get_minimum_depth(this_ptr);
	return nativeResponseValue;
}
	// void ChannelHandshakeConfig_set_minimum_depth(struct LDKChannelHandshakeConfig *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */
export function ChannelHandshakeConfig_set_minimum_depth(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelHandshakeConfig_set_minimum_depth(this_ptr, val);
	// debug statements here
}
	// uint16_t ChannelHandshakeConfig_get_our_to_self_delay(const struct LDKChannelHandshakeConfig *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelHandshakeConfig_get_our_to_self_delay(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelHandshakeConfig_get_our_to_self_delay(this_ptr);
	return nativeResponseValue;
}
	// void ChannelHandshakeConfig_set_our_to_self_delay(struct LDKChannelHandshakeConfig *NONNULL_PTR this_ptr, uint16_t val);
/* @internal */
export function ChannelHandshakeConfig_set_our_to_self_delay(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelHandshakeConfig_set_our_to_self_delay(this_ptr, val);
	// debug statements here
}
	// uint64_t ChannelHandshakeConfig_get_our_htlc_minimum_msat(const struct LDKChannelHandshakeConfig *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelHandshakeConfig_get_our_htlc_minimum_msat(this_ptr: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelHandshakeConfig_get_our_htlc_minimum_msat(this_ptr);
	return nativeResponseValue;
}
	// void ChannelHandshakeConfig_set_our_htlc_minimum_msat(struct LDKChannelHandshakeConfig *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function ChannelHandshakeConfig_set_our_htlc_minimum_msat(this_ptr: number, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelHandshakeConfig_set_our_htlc_minimum_msat(this_ptr, val);
	// debug statements here
}
	// bool ChannelHandshakeConfig_get_negotiate_scid_privacy(const struct LDKChannelHandshakeConfig *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelHandshakeConfig_get_negotiate_scid_privacy(this_ptr: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelHandshakeConfig_get_negotiate_scid_privacy(this_ptr);
	return nativeResponseValue;
}
	// void ChannelHandshakeConfig_set_negotiate_scid_privacy(struct LDKChannelHandshakeConfig *NONNULL_PTR this_ptr, bool val);
/* @internal */
export function ChannelHandshakeConfig_set_negotiate_scid_privacy(this_ptr: number, val: boolean): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelHandshakeConfig_set_negotiate_scid_privacy(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKChannelHandshakeConfig ChannelHandshakeConfig_new(uint32_t minimum_depth_arg, uint16_t our_to_self_delay_arg, uint64_t our_htlc_minimum_msat_arg, bool negotiate_scid_privacy_arg);
/* @internal */
export function ChannelHandshakeConfig_new(minimum_depth_arg: number, our_to_self_delay_arg: number, our_htlc_minimum_msat_arg: bigint, negotiate_scid_privacy_arg: boolean): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelHandshakeConfig_new(minimum_depth_arg, our_to_self_delay_arg, our_htlc_minimum_msat_arg, negotiate_scid_privacy_arg);
	return nativeResponseValue;
}
	// uintptr_t ChannelHandshakeConfig_clone_ptr(LDKChannelHandshakeConfig *NONNULL_PTR arg);
/* @internal */
export function ChannelHandshakeConfig_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelHandshakeConfig_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKChannelHandshakeConfig ChannelHandshakeConfig_clone(const struct LDKChannelHandshakeConfig *NONNULL_PTR orig);
/* @internal */
export function ChannelHandshakeConfig_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelHandshakeConfig_clone(orig);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKChannelHandshakeConfig ChannelHandshakeConfig_default(void);
/* @internal */
export function ChannelHandshakeConfig_default(): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelHandshakeConfig_default();
	return nativeResponseValue;
}
	// void ChannelHandshakeLimits_free(struct LDKChannelHandshakeLimits this_obj);
/* @internal */
export function ChannelHandshakeLimits_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelHandshakeLimits_free(this_obj);
	// debug statements here
}
	// uint64_t ChannelHandshakeLimits_get_min_funding_satoshis(const struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelHandshakeLimits_get_min_funding_satoshis(this_ptr: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelHandshakeLimits_get_min_funding_satoshis(this_ptr);
	return nativeResponseValue;
}
	// void ChannelHandshakeLimits_set_min_funding_satoshis(struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function ChannelHandshakeLimits_set_min_funding_satoshis(this_ptr: number, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelHandshakeLimits_set_min_funding_satoshis(this_ptr, val);
	// debug statements here
}
	// uint64_t ChannelHandshakeLimits_get_max_htlc_minimum_msat(const struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelHandshakeLimits_get_max_htlc_minimum_msat(this_ptr: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelHandshakeLimits_get_max_htlc_minimum_msat(this_ptr);
	return nativeResponseValue;
}
	// void ChannelHandshakeLimits_set_max_htlc_minimum_msat(struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function ChannelHandshakeLimits_set_max_htlc_minimum_msat(this_ptr: number, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelHandshakeLimits_set_max_htlc_minimum_msat(this_ptr, val);
	// debug statements here
}
	// uint64_t ChannelHandshakeLimits_get_min_max_htlc_value_in_flight_msat(const struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelHandshakeLimits_get_min_max_htlc_value_in_flight_msat(this_ptr: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelHandshakeLimits_get_min_max_htlc_value_in_flight_msat(this_ptr);
	return nativeResponseValue;
}
	// void ChannelHandshakeLimits_set_min_max_htlc_value_in_flight_msat(struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function ChannelHandshakeLimits_set_min_max_htlc_value_in_flight_msat(this_ptr: number, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelHandshakeLimits_set_min_max_htlc_value_in_flight_msat(this_ptr, val);
	// debug statements here
}
	// uint64_t ChannelHandshakeLimits_get_max_channel_reserve_satoshis(const struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelHandshakeLimits_get_max_channel_reserve_satoshis(this_ptr: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelHandshakeLimits_get_max_channel_reserve_satoshis(this_ptr);
	return nativeResponseValue;
}
	// void ChannelHandshakeLimits_set_max_channel_reserve_satoshis(struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function ChannelHandshakeLimits_set_max_channel_reserve_satoshis(this_ptr: number, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelHandshakeLimits_set_max_channel_reserve_satoshis(this_ptr, val);
	// debug statements here
}
	// uint16_t ChannelHandshakeLimits_get_min_max_accepted_htlcs(const struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelHandshakeLimits_get_min_max_accepted_htlcs(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelHandshakeLimits_get_min_max_accepted_htlcs(this_ptr);
	return nativeResponseValue;
}
	// void ChannelHandshakeLimits_set_min_max_accepted_htlcs(struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr, uint16_t val);
/* @internal */
export function ChannelHandshakeLimits_set_min_max_accepted_htlcs(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelHandshakeLimits_set_min_max_accepted_htlcs(this_ptr, val);
	// debug statements here
}
	// uint32_t ChannelHandshakeLimits_get_max_minimum_depth(const struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelHandshakeLimits_get_max_minimum_depth(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelHandshakeLimits_get_max_minimum_depth(this_ptr);
	return nativeResponseValue;
}
	// void ChannelHandshakeLimits_set_max_minimum_depth(struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */
export function ChannelHandshakeLimits_set_max_minimum_depth(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelHandshakeLimits_set_max_minimum_depth(this_ptr, val);
	// debug statements here
}
	// bool ChannelHandshakeLimits_get_force_announced_channel_preference(const struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelHandshakeLimits_get_force_announced_channel_preference(this_ptr: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelHandshakeLimits_get_force_announced_channel_preference(this_ptr);
	return nativeResponseValue;
}
	// void ChannelHandshakeLimits_set_force_announced_channel_preference(struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr, bool val);
/* @internal */
export function ChannelHandshakeLimits_set_force_announced_channel_preference(this_ptr: number, val: boolean): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelHandshakeLimits_set_force_announced_channel_preference(this_ptr, val);
	// debug statements here
}
	// uint16_t ChannelHandshakeLimits_get_their_to_self_delay(const struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelHandshakeLimits_get_their_to_self_delay(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelHandshakeLimits_get_their_to_self_delay(this_ptr);
	return nativeResponseValue;
}
	// void ChannelHandshakeLimits_set_their_to_self_delay(struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr, uint16_t val);
/* @internal */
export function ChannelHandshakeLimits_set_their_to_self_delay(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelHandshakeLimits_set_their_to_self_delay(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKChannelHandshakeLimits ChannelHandshakeLimits_new(uint64_t min_funding_satoshis_arg, uint64_t max_htlc_minimum_msat_arg, uint64_t min_max_htlc_value_in_flight_msat_arg, uint64_t max_channel_reserve_satoshis_arg, uint16_t min_max_accepted_htlcs_arg, uint32_t max_minimum_depth_arg, bool force_announced_channel_preference_arg, uint16_t their_to_self_delay_arg);
/* @internal */
export function ChannelHandshakeLimits_new(min_funding_satoshis_arg: bigint, max_htlc_minimum_msat_arg: bigint, min_max_htlc_value_in_flight_msat_arg: bigint, max_channel_reserve_satoshis_arg: bigint, min_max_accepted_htlcs_arg: number, max_minimum_depth_arg: number, force_announced_channel_preference_arg: boolean, their_to_self_delay_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelHandshakeLimits_new(min_funding_satoshis_arg, max_htlc_minimum_msat_arg, min_max_htlc_value_in_flight_msat_arg, max_channel_reserve_satoshis_arg, min_max_accepted_htlcs_arg, max_minimum_depth_arg, force_announced_channel_preference_arg, their_to_self_delay_arg);
	return nativeResponseValue;
}
	// uintptr_t ChannelHandshakeLimits_clone_ptr(LDKChannelHandshakeLimits *NONNULL_PTR arg);
/* @internal */
export function ChannelHandshakeLimits_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelHandshakeLimits_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKChannelHandshakeLimits ChannelHandshakeLimits_clone(const struct LDKChannelHandshakeLimits *NONNULL_PTR orig);
/* @internal */
export function ChannelHandshakeLimits_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelHandshakeLimits_clone(orig);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKChannelHandshakeLimits ChannelHandshakeLimits_default(void);
/* @internal */
export function ChannelHandshakeLimits_default(): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelHandshakeLimits_default();
	return nativeResponseValue;
}
	// void ChannelConfig_free(struct LDKChannelConfig this_obj);
/* @internal */
export function ChannelConfig_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelConfig_free(this_obj);
	// debug statements here
}
	// uint32_t ChannelConfig_get_forwarding_fee_proportional_millionths(const struct LDKChannelConfig *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelConfig_get_forwarding_fee_proportional_millionths(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelConfig_get_forwarding_fee_proportional_millionths(this_ptr);
	return nativeResponseValue;
}
	// void ChannelConfig_set_forwarding_fee_proportional_millionths(struct LDKChannelConfig *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */
export function ChannelConfig_set_forwarding_fee_proportional_millionths(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelConfig_set_forwarding_fee_proportional_millionths(this_ptr, val);
	// debug statements here
}
	// uint32_t ChannelConfig_get_forwarding_fee_base_msat(const struct LDKChannelConfig *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelConfig_get_forwarding_fee_base_msat(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelConfig_get_forwarding_fee_base_msat(this_ptr);
	return nativeResponseValue;
}
	// void ChannelConfig_set_forwarding_fee_base_msat(struct LDKChannelConfig *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */
export function ChannelConfig_set_forwarding_fee_base_msat(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelConfig_set_forwarding_fee_base_msat(this_ptr, val);
	// debug statements here
}
	// uint16_t ChannelConfig_get_cltv_expiry_delta(const struct LDKChannelConfig *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelConfig_get_cltv_expiry_delta(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelConfig_get_cltv_expiry_delta(this_ptr);
	return nativeResponseValue;
}
	// void ChannelConfig_set_cltv_expiry_delta(struct LDKChannelConfig *NONNULL_PTR this_ptr, uint16_t val);
/* @internal */
export function ChannelConfig_set_cltv_expiry_delta(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelConfig_set_cltv_expiry_delta(this_ptr, val);
	// debug statements here
}
	// bool ChannelConfig_get_announced_channel(const struct LDKChannelConfig *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelConfig_get_announced_channel(this_ptr: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelConfig_get_announced_channel(this_ptr);
	return nativeResponseValue;
}
	// void ChannelConfig_set_announced_channel(struct LDKChannelConfig *NONNULL_PTR this_ptr, bool val);
/* @internal */
export function ChannelConfig_set_announced_channel(this_ptr: number, val: boolean): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelConfig_set_announced_channel(this_ptr, val);
	// debug statements here
}
	// bool ChannelConfig_get_commit_upfront_shutdown_pubkey(const struct LDKChannelConfig *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelConfig_get_commit_upfront_shutdown_pubkey(this_ptr: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelConfig_get_commit_upfront_shutdown_pubkey(this_ptr);
	return nativeResponseValue;
}
	// void ChannelConfig_set_commit_upfront_shutdown_pubkey(struct LDKChannelConfig *NONNULL_PTR this_ptr, bool val);
/* @internal */
export function ChannelConfig_set_commit_upfront_shutdown_pubkey(this_ptr: number, val: boolean): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelConfig_set_commit_upfront_shutdown_pubkey(this_ptr, val);
	// debug statements here
}
	// uint64_t ChannelConfig_get_max_dust_htlc_exposure_msat(const struct LDKChannelConfig *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelConfig_get_max_dust_htlc_exposure_msat(this_ptr: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelConfig_get_max_dust_htlc_exposure_msat(this_ptr);
	return nativeResponseValue;
}
	// void ChannelConfig_set_max_dust_htlc_exposure_msat(struct LDKChannelConfig *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function ChannelConfig_set_max_dust_htlc_exposure_msat(this_ptr: number, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelConfig_set_max_dust_htlc_exposure_msat(this_ptr, val);
	// debug statements here
}
	// uint64_t ChannelConfig_get_force_close_avoidance_max_fee_satoshis(const struct LDKChannelConfig *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelConfig_get_force_close_avoidance_max_fee_satoshis(this_ptr: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelConfig_get_force_close_avoidance_max_fee_satoshis(this_ptr);
	return nativeResponseValue;
}
	// void ChannelConfig_set_force_close_avoidance_max_fee_satoshis(struct LDKChannelConfig *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function ChannelConfig_set_force_close_avoidance_max_fee_satoshis(this_ptr: number, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelConfig_set_force_close_avoidance_max_fee_satoshis(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKChannelConfig ChannelConfig_new(uint32_t forwarding_fee_proportional_millionths_arg, uint32_t forwarding_fee_base_msat_arg, uint16_t cltv_expiry_delta_arg, bool announced_channel_arg, bool commit_upfront_shutdown_pubkey_arg, uint64_t max_dust_htlc_exposure_msat_arg, uint64_t force_close_avoidance_max_fee_satoshis_arg);
/* @internal */
export function ChannelConfig_new(forwarding_fee_proportional_millionths_arg: number, forwarding_fee_base_msat_arg: number, cltv_expiry_delta_arg: number, announced_channel_arg: boolean, commit_upfront_shutdown_pubkey_arg: boolean, max_dust_htlc_exposure_msat_arg: bigint, force_close_avoidance_max_fee_satoshis_arg: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelConfig_new(forwarding_fee_proportional_millionths_arg, forwarding_fee_base_msat_arg, cltv_expiry_delta_arg, announced_channel_arg, commit_upfront_shutdown_pubkey_arg, max_dust_htlc_exposure_msat_arg, force_close_avoidance_max_fee_satoshis_arg);
	return nativeResponseValue;
}
	// uintptr_t ChannelConfig_clone_ptr(LDKChannelConfig *NONNULL_PTR arg);
/* @internal */
export function ChannelConfig_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelConfig_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKChannelConfig ChannelConfig_clone(const struct LDKChannelConfig *NONNULL_PTR orig);
/* @internal */
export function ChannelConfig_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelConfig_clone(orig);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKChannelConfig ChannelConfig_default(void);
/* @internal */
export function ChannelConfig_default(): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelConfig_default();
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z ChannelConfig_write(const struct LDKChannelConfig *NONNULL_PTR obj);
/* @internal */
export function ChannelConfig_write(obj: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelConfig_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelConfigDecodeErrorZ ChannelConfig_read(struct LDKu8slice ser);
/* @internal */
export function ChannelConfig_read(ser: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelConfig_read(ser);
	return nativeResponseValue;
}
	// void UserConfig_free(struct LDKUserConfig this_obj);
/* @internal */
export function UserConfig_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UserConfig_free(this_obj);
	// debug statements here
}
	// struct LDKChannelHandshakeConfig UserConfig_get_own_channel_config(const struct LDKUserConfig *NONNULL_PTR this_ptr);
/* @internal */
export function UserConfig_get_own_channel_config(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UserConfig_get_own_channel_config(this_ptr);
	return nativeResponseValue;
}
	// void UserConfig_set_own_channel_config(struct LDKUserConfig *NONNULL_PTR this_ptr, struct LDKChannelHandshakeConfig val);
/* @internal */
export function UserConfig_set_own_channel_config(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UserConfig_set_own_channel_config(this_ptr, val);
	// debug statements here
}
	// struct LDKChannelHandshakeLimits UserConfig_get_peer_channel_config_limits(const struct LDKUserConfig *NONNULL_PTR this_ptr);
/* @internal */
export function UserConfig_get_peer_channel_config_limits(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UserConfig_get_peer_channel_config_limits(this_ptr);
	return nativeResponseValue;
}
	// void UserConfig_set_peer_channel_config_limits(struct LDKUserConfig *NONNULL_PTR this_ptr, struct LDKChannelHandshakeLimits val);
/* @internal */
export function UserConfig_set_peer_channel_config_limits(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UserConfig_set_peer_channel_config_limits(this_ptr, val);
	// debug statements here
}
	// struct LDKChannelConfig UserConfig_get_channel_options(const struct LDKUserConfig *NONNULL_PTR this_ptr);
/* @internal */
export function UserConfig_get_channel_options(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UserConfig_get_channel_options(this_ptr);
	return nativeResponseValue;
}
	// void UserConfig_set_channel_options(struct LDKUserConfig *NONNULL_PTR this_ptr, struct LDKChannelConfig val);
/* @internal */
export function UserConfig_set_channel_options(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UserConfig_set_channel_options(this_ptr, val);
	// debug statements here
}
	// bool UserConfig_get_accept_forwards_to_priv_channels(const struct LDKUserConfig *NONNULL_PTR this_ptr);
/* @internal */
export function UserConfig_get_accept_forwards_to_priv_channels(this_ptr: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UserConfig_get_accept_forwards_to_priv_channels(this_ptr);
	return nativeResponseValue;
}
	// void UserConfig_set_accept_forwards_to_priv_channels(struct LDKUserConfig *NONNULL_PTR this_ptr, bool val);
/* @internal */
export function UserConfig_set_accept_forwards_to_priv_channels(this_ptr: number, val: boolean): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UserConfig_set_accept_forwards_to_priv_channels(this_ptr, val);
	// debug statements here
}
	// bool UserConfig_get_accept_inbound_channels(const struct LDKUserConfig *NONNULL_PTR this_ptr);
/* @internal */
export function UserConfig_get_accept_inbound_channels(this_ptr: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UserConfig_get_accept_inbound_channels(this_ptr);
	return nativeResponseValue;
}
	// void UserConfig_set_accept_inbound_channels(struct LDKUserConfig *NONNULL_PTR this_ptr, bool val);
/* @internal */
export function UserConfig_set_accept_inbound_channels(this_ptr: number, val: boolean): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UserConfig_set_accept_inbound_channels(this_ptr, val);
	// debug statements here
}
	// bool UserConfig_get_manually_accept_inbound_channels(const struct LDKUserConfig *NONNULL_PTR this_ptr);
/* @internal */
export function UserConfig_get_manually_accept_inbound_channels(this_ptr: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UserConfig_get_manually_accept_inbound_channels(this_ptr);
	return nativeResponseValue;
}
	// void UserConfig_set_manually_accept_inbound_channels(struct LDKUserConfig *NONNULL_PTR this_ptr, bool val);
/* @internal */
export function UserConfig_set_manually_accept_inbound_channels(this_ptr: number, val: boolean): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UserConfig_set_manually_accept_inbound_channels(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKUserConfig UserConfig_new(struct LDKChannelHandshakeConfig own_channel_config_arg, struct LDKChannelHandshakeLimits peer_channel_config_limits_arg, struct LDKChannelConfig channel_options_arg, bool accept_forwards_to_priv_channels_arg, bool accept_inbound_channels_arg, bool manually_accept_inbound_channels_arg);
/* @internal */
export function UserConfig_new(own_channel_config_arg: number, peer_channel_config_limits_arg: number, channel_options_arg: number, accept_forwards_to_priv_channels_arg: boolean, accept_inbound_channels_arg: boolean, manually_accept_inbound_channels_arg: boolean): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UserConfig_new(own_channel_config_arg, peer_channel_config_limits_arg, channel_options_arg, accept_forwards_to_priv_channels_arg, accept_inbound_channels_arg, manually_accept_inbound_channels_arg);
	return nativeResponseValue;
}
	// uintptr_t UserConfig_clone_ptr(LDKUserConfig *NONNULL_PTR arg);
/* @internal */
export function UserConfig_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UserConfig_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKUserConfig UserConfig_clone(const struct LDKUserConfig *NONNULL_PTR orig);
/* @internal */
export function UserConfig_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UserConfig_clone(orig);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKUserConfig UserConfig_default(void);
/* @internal */
export function UserConfig_default(): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UserConfig_default();
	return nativeResponseValue;
}
	// void BestBlock_free(struct LDKBestBlock this_obj);
/* @internal */
export function BestBlock_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BestBlock_free(this_obj);
	// debug statements here
}
	// uintptr_t BestBlock_clone_ptr(LDKBestBlock *NONNULL_PTR arg);
/* @internal */
export function BestBlock_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BestBlock_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKBestBlock BestBlock_clone(const struct LDKBestBlock *NONNULL_PTR orig);
/* @internal */
export function BestBlock_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BestBlock_clone(orig);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKBestBlock BestBlock_from_genesis(enum LDKNetwork network);
/* @internal */
export function BestBlock_from_genesis(network: Network): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BestBlock_from_genesis(network);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKBestBlock BestBlock_new(struct LDKThirtyTwoBytes block_hash, uint32_t height);
/* @internal */
export function BestBlock_new(block_hash: number, height: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BestBlock_new(block_hash, height);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKThirtyTwoBytes BestBlock_block_hash(const struct LDKBestBlock *NONNULL_PTR this_arg);
/* @internal */
export function BestBlock_block_hash(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BestBlock_block_hash(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES uint32_t BestBlock_height(const struct LDKBestBlock *NONNULL_PTR this_arg);
/* @internal */
export function BestBlock_height(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BestBlock_height(this_arg);
	return nativeResponseValue;
}
	// enum LDKAccessError AccessError_clone(const enum LDKAccessError *NONNULL_PTR orig);
/* @internal */
export function AccessError_clone(orig: number): AccessError {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AccessError_clone(orig);
	return nativeResponseValue;
}
	// enum LDKAccessError AccessError_unknown_chain(void);
/* @internal */
export function AccessError_unknown_chain(): AccessError {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AccessError_unknown_chain();
	return nativeResponseValue;
}
	// enum LDKAccessError AccessError_unknown_tx(void);
/* @internal */
export function AccessError_unknown_tx(): AccessError {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AccessError_unknown_tx();
	return nativeResponseValue;
}
	// void Access_free(struct LDKAccess this_ptr);
/* @internal */
export function Access_free(this_ptr: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Access_free(this_ptr);
	// debug statements here
}
	// void Listen_free(struct LDKListen this_ptr);
/* @internal */
export function Listen_free(this_ptr: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Listen_free(this_ptr);
	// debug statements here
}
	// void Confirm_free(struct LDKConfirm this_ptr);
/* @internal */
export function Confirm_free(this_ptr: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Confirm_free(this_ptr);
	// debug statements here
}
	// enum LDKChannelMonitorUpdateErr ChannelMonitorUpdateErr_clone(const enum LDKChannelMonitorUpdateErr *NONNULL_PTR orig);
/* @internal */
export function ChannelMonitorUpdateErr_clone(orig: number): ChannelMonitorUpdateErr {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMonitorUpdateErr_clone(orig);
	return nativeResponseValue;
}
	// enum LDKChannelMonitorUpdateErr ChannelMonitorUpdateErr_temporary_failure(void);
/* @internal */
export function ChannelMonitorUpdateErr_temporary_failure(): ChannelMonitorUpdateErr {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMonitorUpdateErr_temporary_failure();
	return nativeResponseValue;
}
	// enum LDKChannelMonitorUpdateErr ChannelMonitorUpdateErr_permanent_failure(void);
/* @internal */
export function ChannelMonitorUpdateErr_permanent_failure(): ChannelMonitorUpdateErr {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMonitorUpdateErr_permanent_failure();
	return nativeResponseValue;
}
	// void Watch_free(struct LDKWatch this_ptr);
/* @internal */
export function Watch_free(this_ptr: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Watch_free(this_ptr);
	// debug statements here
}
	// void Filter_free(struct LDKFilter this_ptr);
/* @internal */
export function Filter_free(this_ptr: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Filter_free(this_ptr);
	// debug statements here
}
	// void WatchedOutput_free(struct LDKWatchedOutput this_obj);
/* @internal */
export function WatchedOutput_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_WatchedOutput_free(this_obj);
	// debug statements here
}
	// struct LDKThirtyTwoBytes WatchedOutput_get_block_hash(const struct LDKWatchedOutput *NONNULL_PTR this_ptr);
/* @internal */
export function WatchedOutput_get_block_hash(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_WatchedOutput_get_block_hash(this_ptr);
	return nativeResponseValue;
}
	// void WatchedOutput_set_block_hash(struct LDKWatchedOutput *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function WatchedOutput_set_block_hash(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_WatchedOutput_set_block_hash(this_ptr, val);
	// debug statements here
}
	// struct LDKOutPoint WatchedOutput_get_outpoint(const struct LDKWatchedOutput *NONNULL_PTR this_ptr);
/* @internal */
export function WatchedOutput_get_outpoint(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_WatchedOutput_get_outpoint(this_ptr);
	return nativeResponseValue;
}
	// void WatchedOutput_set_outpoint(struct LDKWatchedOutput *NONNULL_PTR this_ptr, struct LDKOutPoint val);
/* @internal */
export function WatchedOutput_set_outpoint(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_WatchedOutput_set_outpoint(this_ptr, val);
	// debug statements here
}
	// struct LDKu8slice WatchedOutput_get_script_pubkey(const struct LDKWatchedOutput *NONNULL_PTR this_ptr);
/* @internal */
export function WatchedOutput_get_script_pubkey(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_WatchedOutput_get_script_pubkey(this_ptr);
	return nativeResponseValue;
}
	// void WatchedOutput_set_script_pubkey(struct LDKWatchedOutput *NONNULL_PTR this_ptr, struct LDKCVec_u8Z val);
/* @internal */
export function WatchedOutput_set_script_pubkey(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_WatchedOutput_set_script_pubkey(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKWatchedOutput WatchedOutput_new(struct LDKThirtyTwoBytes block_hash_arg, struct LDKOutPoint outpoint_arg, struct LDKCVec_u8Z script_pubkey_arg);
/* @internal */
export function WatchedOutput_new(block_hash_arg: number, outpoint_arg: number, script_pubkey_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_WatchedOutput_new(block_hash_arg, outpoint_arg, script_pubkey_arg);
	return nativeResponseValue;
}
	// uintptr_t WatchedOutput_clone_ptr(LDKWatchedOutput *NONNULL_PTR arg);
/* @internal */
export function WatchedOutput_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_WatchedOutput_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKWatchedOutput WatchedOutput_clone(const struct LDKWatchedOutput *NONNULL_PTR orig);
/* @internal */
export function WatchedOutput_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_WatchedOutput_clone(orig);
	return nativeResponseValue;
}
	// uint64_t WatchedOutput_hash(const struct LDKWatchedOutput *NONNULL_PTR o);
/* @internal */
export function WatchedOutput_hash(o: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_WatchedOutput_hash(o);
	return nativeResponseValue;
}
	// void BroadcasterInterface_free(struct LDKBroadcasterInterface this_ptr);
/* @internal */
export function BroadcasterInterface_free(this_ptr: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BroadcasterInterface_free(this_ptr);
	// debug statements here
}
	// enum LDKConfirmationTarget ConfirmationTarget_clone(const enum LDKConfirmationTarget *NONNULL_PTR orig);
/* @internal */
export function ConfirmationTarget_clone(orig: number): ConfirmationTarget {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ConfirmationTarget_clone(orig);
	return nativeResponseValue;
}
	// enum LDKConfirmationTarget ConfirmationTarget_background(void);
/* @internal */
export function ConfirmationTarget_background(): ConfirmationTarget {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ConfirmationTarget_background();
	return nativeResponseValue;
}
	// enum LDKConfirmationTarget ConfirmationTarget_normal(void);
/* @internal */
export function ConfirmationTarget_normal(): ConfirmationTarget {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ConfirmationTarget_normal();
	return nativeResponseValue;
}
	// enum LDKConfirmationTarget ConfirmationTarget_high_priority(void);
/* @internal */
export function ConfirmationTarget_high_priority(): ConfirmationTarget {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ConfirmationTarget_high_priority();
	return nativeResponseValue;
}
	// bool ConfirmationTarget_eq(const enum LDKConfirmationTarget *NONNULL_PTR a, const enum LDKConfirmationTarget *NONNULL_PTR b);
/* @internal */
export function ConfirmationTarget_eq(a: number, b: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ConfirmationTarget_eq(a, b);
	return nativeResponseValue;
}
	// void FeeEstimator_free(struct LDKFeeEstimator this_ptr);
/* @internal */
export function FeeEstimator_free(this_ptr: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_FeeEstimator_free(this_ptr);
	// debug statements here
}
	// void MonitorUpdateId_free(struct LDKMonitorUpdateId this_obj);
/* @internal */
export function MonitorUpdateId_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MonitorUpdateId_free(this_obj);
	// debug statements here
}
	// uintptr_t MonitorUpdateId_clone_ptr(LDKMonitorUpdateId *NONNULL_PTR arg);
/* @internal */
export function MonitorUpdateId_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MonitorUpdateId_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKMonitorUpdateId MonitorUpdateId_clone(const struct LDKMonitorUpdateId *NONNULL_PTR orig);
/* @internal */
export function MonitorUpdateId_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MonitorUpdateId_clone(orig);
	return nativeResponseValue;
}
	// uint64_t MonitorUpdateId_hash(const struct LDKMonitorUpdateId *NONNULL_PTR o);
/* @internal */
export function MonitorUpdateId_hash(o: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MonitorUpdateId_hash(o);
	return nativeResponseValue;
}
	// bool MonitorUpdateId_eq(const struct LDKMonitorUpdateId *NONNULL_PTR a, const struct LDKMonitorUpdateId *NONNULL_PTR b);
/* @internal */
export function MonitorUpdateId_eq(a: number, b: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MonitorUpdateId_eq(a, b);
	return nativeResponseValue;
}
	// void Persist_free(struct LDKPersist this_ptr);
/* @internal */
export function Persist_free(this_ptr: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Persist_free(this_ptr);
	// debug statements here
}
	// void LockedChannelMonitor_free(struct LDKLockedChannelMonitor this_obj);
/* @internal */
export function LockedChannelMonitor_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LockedChannelMonitor_free(this_obj);
	// debug statements here
}
	// void ChainMonitor_free(struct LDKChainMonitor this_obj);
/* @internal */
export function ChainMonitor_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChainMonitor_free(this_obj);
	// debug statements here
}
	// MUST_USE_RES struct LDKChainMonitor ChainMonitor_new(struct LDKCOption_FilterZ chain_source, struct LDKBroadcasterInterface broadcaster, struct LDKLogger logger, struct LDKFeeEstimator feeest, struct LDKPersist persister);
/* @internal */
export function ChainMonitor_new(chain_source: number, broadcaster: number, logger: number, feeest: number, persister: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChainMonitor_new(chain_source, broadcaster, logger, feeest, persister);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCVec_BalanceZ ChainMonitor_get_claimable_balances(const struct LDKChainMonitor *NONNULL_PTR this_arg, struct LDKCVec_ChannelDetailsZ ignored_channels);
/* @internal */
export function ChainMonitor_get_claimable_balances(this_arg: number, ignored_channels: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChainMonitor_get_claimable_balances(this_arg, ignored_channels);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_LockedChannelMonitorNoneZ ChainMonitor_get_monitor(const struct LDKChainMonitor *NONNULL_PTR this_arg, struct LDKOutPoint funding_txo);
/* @internal */
export function ChainMonitor_get_monitor(this_arg: number, funding_txo: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChainMonitor_get_monitor(this_arg, funding_txo);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCVec_OutPointZ ChainMonitor_list_monitors(const struct LDKChainMonitor *NONNULL_PTR this_arg);
/* @internal */
export function ChainMonitor_list_monitors(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChainMonitor_list_monitors(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_NoneAPIErrorZ ChainMonitor_channel_monitor_updated(const struct LDKChainMonitor *NONNULL_PTR this_arg, struct LDKOutPoint funding_txo, struct LDKMonitorUpdateId completed_update_id);
/* @internal */
export function ChainMonitor_channel_monitor_updated(this_arg: number, funding_txo: number, completed_update_id: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChainMonitor_channel_monitor_updated(this_arg, funding_txo, completed_update_id);
	return nativeResponseValue;
}
	// struct LDKListen ChainMonitor_as_Listen(const struct LDKChainMonitor *NONNULL_PTR this_arg);
/* @internal */
export function ChainMonitor_as_Listen(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChainMonitor_as_Listen(this_arg);
	return nativeResponseValue;
}
	// struct LDKConfirm ChainMonitor_as_Confirm(const struct LDKChainMonitor *NONNULL_PTR this_arg);
/* @internal */
export function ChainMonitor_as_Confirm(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChainMonitor_as_Confirm(this_arg);
	return nativeResponseValue;
}
	// struct LDKWatch ChainMonitor_as_Watch(const struct LDKChainMonitor *NONNULL_PTR this_arg);
/* @internal */
export function ChainMonitor_as_Watch(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChainMonitor_as_Watch(this_arg);
	return nativeResponseValue;
}
	// struct LDKEventsProvider ChainMonitor_as_EventsProvider(const struct LDKChainMonitor *NONNULL_PTR this_arg);
/* @internal */
export function ChainMonitor_as_EventsProvider(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChainMonitor_as_EventsProvider(this_arg);
	return nativeResponseValue;
}
	// void ChannelMonitorUpdate_free(struct LDKChannelMonitorUpdate this_obj);
/* @internal */
export function ChannelMonitorUpdate_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMonitorUpdate_free(this_obj);
	// debug statements here
}
	// uint64_t ChannelMonitorUpdate_get_update_id(const struct LDKChannelMonitorUpdate *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelMonitorUpdate_get_update_id(this_ptr: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMonitorUpdate_get_update_id(this_ptr);
	return nativeResponseValue;
}
	// void ChannelMonitorUpdate_set_update_id(struct LDKChannelMonitorUpdate *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function ChannelMonitorUpdate_set_update_id(this_ptr: number, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMonitorUpdate_set_update_id(this_ptr, val);
	// debug statements here
}
	// uintptr_t ChannelMonitorUpdate_clone_ptr(LDKChannelMonitorUpdate *NONNULL_PTR arg);
/* @internal */
export function ChannelMonitorUpdate_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMonitorUpdate_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKChannelMonitorUpdate ChannelMonitorUpdate_clone(const struct LDKChannelMonitorUpdate *NONNULL_PTR orig);
/* @internal */
export function ChannelMonitorUpdate_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMonitorUpdate_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z ChannelMonitorUpdate_write(const struct LDKChannelMonitorUpdate *NONNULL_PTR obj);
/* @internal */
export function ChannelMonitorUpdate_write(obj: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMonitorUpdate_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelMonitorUpdateDecodeErrorZ ChannelMonitorUpdate_read(struct LDKu8slice ser);
/* @internal */
export function ChannelMonitorUpdate_read(ser: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMonitorUpdate_read(ser);
	return nativeResponseValue;
}
	// void MonitorEvent_free(struct LDKMonitorEvent this_ptr);
/* @internal */
export function MonitorEvent_free(this_ptr: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MonitorEvent_free(this_ptr);
	// debug statements here
}
	// uintptr_t MonitorEvent_clone_ptr(LDKMonitorEvent *NONNULL_PTR arg);
/* @internal */
export function MonitorEvent_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MonitorEvent_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKMonitorEvent MonitorEvent_clone(const struct LDKMonitorEvent *NONNULL_PTR orig);
/* @internal */
export function MonitorEvent_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MonitorEvent_clone(orig);
	return nativeResponseValue;
}
	// struct LDKMonitorEvent MonitorEvent_htlcevent(struct LDKHTLCUpdate a);
/* @internal */
export function MonitorEvent_htlcevent(a: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MonitorEvent_htlcevent(a);
	return nativeResponseValue;
}
	// struct LDKMonitorEvent MonitorEvent_commitment_tx_confirmed(struct LDKOutPoint a);
/* @internal */
export function MonitorEvent_commitment_tx_confirmed(a: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MonitorEvent_commitment_tx_confirmed(a);
	return nativeResponseValue;
}
	// struct LDKMonitorEvent MonitorEvent_update_completed(struct LDKOutPoint funding_txo, uint64_t monitor_update_id);
/* @internal */
export function MonitorEvent_update_completed(funding_txo: number, monitor_update_id: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MonitorEvent_update_completed(funding_txo, monitor_update_id);
	return nativeResponseValue;
}
	// struct LDKMonitorEvent MonitorEvent_update_failed(struct LDKOutPoint a);
/* @internal */
export function MonitorEvent_update_failed(a: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MonitorEvent_update_failed(a);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z MonitorEvent_write(const struct LDKMonitorEvent *NONNULL_PTR obj);
/* @internal */
export function MonitorEvent_write(obj: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MonitorEvent_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_COption_MonitorEventZDecodeErrorZ MonitorEvent_read(struct LDKu8slice ser);
/* @internal */
export function MonitorEvent_read(ser: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MonitorEvent_read(ser);
	return nativeResponseValue;
}
	// void HTLCUpdate_free(struct LDKHTLCUpdate this_obj);
/* @internal */
export function HTLCUpdate_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HTLCUpdate_free(this_obj);
	// debug statements here
}
	// uintptr_t HTLCUpdate_clone_ptr(LDKHTLCUpdate *NONNULL_PTR arg);
/* @internal */
export function HTLCUpdate_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HTLCUpdate_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKHTLCUpdate HTLCUpdate_clone(const struct LDKHTLCUpdate *NONNULL_PTR orig);
/* @internal */
export function HTLCUpdate_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HTLCUpdate_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z HTLCUpdate_write(const struct LDKHTLCUpdate *NONNULL_PTR obj);
/* @internal */
export function HTLCUpdate_write(obj: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HTLCUpdate_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_HTLCUpdateDecodeErrorZ HTLCUpdate_read(struct LDKu8slice ser);
/* @internal */
export function HTLCUpdate_read(ser: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HTLCUpdate_read(ser);
	return nativeResponseValue;
}
	// void Balance_free(struct LDKBalance this_ptr);
/* @internal */
export function Balance_free(this_ptr: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Balance_free(this_ptr);
	// debug statements here
}
	// uintptr_t Balance_clone_ptr(LDKBalance *NONNULL_PTR arg);
/* @internal */
export function Balance_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Balance_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKBalance Balance_clone(const struct LDKBalance *NONNULL_PTR orig);
/* @internal */
export function Balance_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Balance_clone(orig);
	return nativeResponseValue;
}
	// struct LDKBalance Balance_claimable_on_channel_close(uint64_t claimable_amount_satoshis);
/* @internal */
export function Balance_claimable_on_channel_close(claimable_amount_satoshis: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Balance_claimable_on_channel_close(claimable_amount_satoshis);
	return nativeResponseValue;
}
	// struct LDKBalance Balance_claimable_awaiting_confirmations(uint64_t claimable_amount_satoshis, uint32_t confirmation_height);
/* @internal */
export function Balance_claimable_awaiting_confirmations(claimable_amount_satoshis: bigint, confirmation_height: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Balance_claimable_awaiting_confirmations(claimable_amount_satoshis, confirmation_height);
	return nativeResponseValue;
}
	// struct LDKBalance Balance_contentious_claimable(uint64_t claimable_amount_satoshis, uint32_t timeout_height);
/* @internal */
export function Balance_contentious_claimable(claimable_amount_satoshis: bigint, timeout_height: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Balance_contentious_claimable(claimable_amount_satoshis, timeout_height);
	return nativeResponseValue;
}
	// struct LDKBalance Balance_maybe_claimable_htlcawaiting_timeout(uint64_t claimable_amount_satoshis, uint32_t claimable_height);
/* @internal */
export function Balance_maybe_claimable_htlcawaiting_timeout(claimable_amount_satoshis: bigint, claimable_height: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Balance_maybe_claimable_htlcawaiting_timeout(claimable_amount_satoshis, claimable_height);
	return nativeResponseValue;
}
	// bool Balance_eq(const struct LDKBalance *NONNULL_PTR a, const struct LDKBalance *NONNULL_PTR b);
/* @internal */
export function Balance_eq(a: number, b: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Balance_eq(a, b);
	return nativeResponseValue;
}
	// void ChannelMonitor_free(struct LDKChannelMonitor this_obj);
/* @internal */
export function ChannelMonitor_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMonitor_free(this_obj);
	// debug statements here
}
	// uintptr_t ChannelMonitor_clone_ptr(LDKChannelMonitor *NONNULL_PTR arg);
/* @internal */
export function ChannelMonitor_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMonitor_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKChannelMonitor ChannelMonitor_clone(const struct LDKChannelMonitor *NONNULL_PTR orig);
/* @internal */
export function ChannelMonitor_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMonitor_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z ChannelMonitor_write(const struct LDKChannelMonitor *NONNULL_PTR obj);
/* @internal */
export function ChannelMonitor_write(obj: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMonitor_write(obj);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_NoneNoneZ ChannelMonitor_update_monitor(const struct LDKChannelMonitor *NONNULL_PTR this_arg, const struct LDKChannelMonitorUpdate *NONNULL_PTR updates, const struct LDKBroadcasterInterface *NONNULL_PTR broadcaster, const struct LDKFeeEstimator *NONNULL_PTR fee_estimator, const struct LDKLogger *NONNULL_PTR logger);
/* @internal */
export function ChannelMonitor_update_monitor(this_arg: number, updates: number, broadcaster: number, fee_estimator: number, logger: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMonitor_update_monitor(this_arg, updates, broadcaster, fee_estimator, logger);
	return nativeResponseValue;
}
	// MUST_USE_RES uint64_t ChannelMonitor_get_latest_update_id(const struct LDKChannelMonitor *NONNULL_PTR this_arg);
/* @internal */
export function ChannelMonitor_get_latest_update_id(this_arg: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMonitor_get_latest_update_id(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKC2Tuple_OutPointScriptZ ChannelMonitor_get_funding_txo(const struct LDKChannelMonitor *NONNULL_PTR this_arg);
/* @internal */
export function ChannelMonitor_get_funding_txo(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMonitor_get_funding_txo(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCVec_C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZZ ChannelMonitor_get_outputs_to_watch(const struct LDKChannelMonitor *NONNULL_PTR this_arg);
/* @internal */
export function ChannelMonitor_get_outputs_to_watch(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMonitor_get_outputs_to_watch(this_arg);
	return nativeResponseValue;
}
	// void ChannelMonitor_load_outputs_to_watch(const struct LDKChannelMonitor *NONNULL_PTR this_arg, const struct LDKFilter *NONNULL_PTR filter);
/* @internal */
export function ChannelMonitor_load_outputs_to_watch(this_arg: number, filter: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMonitor_load_outputs_to_watch(this_arg, filter);
	// debug statements here
}
	// MUST_USE_RES struct LDKCVec_MonitorEventZ ChannelMonitor_get_and_clear_pending_monitor_events(const struct LDKChannelMonitor *NONNULL_PTR this_arg);
/* @internal */
export function ChannelMonitor_get_and_clear_pending_monitor_events(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMonitor_get_and_clear_pending_monitor_events(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCVec_EventZ ChannelMonitor_get_and_clear_pending_events(const struct LDKChannelMonitor *NONNULL_PTR this_arg);
/* @internal */
export function ChannelMonitor_get_and_clear_pending_events(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMonitor_get_and_clear_pending_events(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCVec_TransactionZ ChannelMonitor_get_latest_holder_commitment_txn(const struct LDKChannelMonitor *NONNULL_PTR this_arg, const struct LDKLogger *NONNULL_PTR logger);
/* @internal */
export function ChannelMonitor_get_latest_holder_commitment_txn(this_arg: number, logger: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMonitor_get_latest_holder_commitment_txn(this_arg, logger);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCVec_C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZZ ChannelMonitor_block_connected(const struct LDKChannelMonitor *NONNULL_PTR this_arg, const uint8_t (*header)[80], struct LDKCVec_C2Tuple_usizeTransactionZZ txdata, uint32_t height, struct LDKBroadcasterInterface broadcaster, struct LDKFeeEstimator fee_estimator, struct LDKLogger logger);
/* @internal */
export function ChannelMonitor_block_connected(this_arg: number, header: number, txdata: number, height: number, broadcaster: number, fee_estimator: number, logger: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMonitor_block_connected(this_arg, header, txdata, height, broadcaster, fee_estimator, logger);
	return nativeResponseValue;
}
	// void ChannelMonitor_block_disconnected(const struct LDKChannelMonitor *NONNULL_PTR this_arg, const uint8_t (*header)[80], uint32_t height, struct LDKBroadcasterInterface broadcaster, struct LDKFeeEstimator fee_estimator, struct LDKLogger logger);
/* @internal */
export function ChannelMonitor_block_disconnected(this_arg: number, header: number, height: number, broadcaster: number, fee_estimator: number, logger: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMonitor_block_disconnected(this_arg, header, height, broadcaster, fee_estimator, logger);
	// debug statements here
}
	// MUST_USE_RES struct LDKCVec_C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZZ ChannelMonitor_transactions_confirmed(const struct LDKChannelMonitor *NONNULL_PTR this_arg, const uint8_t (*header)[80], struct LDKCVec_C2Tuple_usizeTransactionZZ txdata, uint32_t height, struct LDKBroadcasterInterface broadcaster, struct LDKFeeEstimator fee_estimator, struct LDKLogger logger);
/* @internal */
export function ChannelMonitor_transactions_confirmed(this_arg: number, header: number, txdata: number, height: number, broadcaster: number, fee_estimator: number, logger: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMonitor_transactions_confirmed(this_arg, header, txdata, height, broadcaster, fee_estimator, logger);
	return nativeResponseValue;
}
	// void ChannelMonitor_transaction_unconfirmed(const struct LDKChannelMonitor *NONNULL_PTR this_arg, const uint8_t (*txid)[32], struct LDKBroadcasterInterface broadcaster, struct LDKFeeEstimator fee_estimator, struct LDKLogger logger);
/* @internal */
export function ChannelMonitor_transaction_unconfirmed(this_arg: number, txid: number, broadcaster: number, fee_estimator: number, logger: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMonitor_transaction_unconfirmed(this_arg, txid, broadcaster, fee_estimator, logger);
	// debug statements here
}
	// MUST_USE_RES struct LDKCVec_C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZZ ChannelMonitor_best_block_updated(const struct LDKChannelMonitor *NONNULL_PTR this_arg, const uint8_t (*header)[80], uint32_t height, struct LDKBroadcasterInterface broadcaster, struct LDKFeeEstimator fee_estimator, struct LDKLogger logger);
/* @internal */
export function ChannelMonitor_best_block_updated(this_arg: number, header: number, height: number, broadcaster: number, fee_estimator: number, logger: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMonitor_best_block_updated(this_arg, header, height, broadcaster, fee_estimator, logger);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCVec_TxidZ ChannelMonitor_get_relevant_txids(const struct LDKChannelMonitor *NONNULL_PTR this_arg);
/* @internal */
export function ChannelMonitor_get_relevant_txids(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMonitor_get_relevant_txids(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKBestBlock ChannelMonitor_current_best_block(const struct LDKChannelMonitor *NONNULL_PTR this_arg);
/* @internal */
export function ChannelMonitor_current_best_block(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMonitor_current_best_block(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCVec_BalanceZ ChannelMonitor_get_claimable_balances(const struct LDKChannelMonitor *NONNULL_PTR this_arg);
/* @internal */
export function ChannelMonitor_get_claimable_balances(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMonitor_get_claimable_balances(this_arg);
	return nativeResponseValue;
}
	// struct LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ C2Tuple_BlockHashChannelMonitorZ_read(struct LDKu8slice ser, const struct LDKKeysInterface *NONNULL_PTR arg);
/* @internal */
export function C2Tuple_BlockHashChannelMonitorZ_read(ser: number, arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_BlockHashChannelMonitorZ_read(ser, arg);
	return nativeResponseValue;
}
	// void OutPoint_free(struct LDKOutPoint this_obj);
/* @internal */
export function OutPoint_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OutPoint_free(this_obj);
	// debug statements here
}
	// const uint8_t (*OutPoint_get_txid(const struct LDKOutPoint *NONNULL_PTR this_ptr))[32];
/* @internal */
export function OutPoint_get_txid(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OutPoint_get_txid(this_ptr);
	return nativeResponseValue;
}
	// void OutPoint_set_txid(struct LDKOutPoint *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function OutPoint_set_txid(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OutPoint_set_txid(this_ptr, val);
	// debug statements here
}
	// uint16_t OutPoint_get_index(const struct LDKOutPoint *NONNULL_PTR this_ptr);
/* @internal */
export function OutPoint_get_index(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OutPoint_get_index(this_ptr);
	return nativeResponseValue;
}
	// void OutPoint_set_index(struct LDKOutPoint *NONNULL_PTR this_ptr, uint16_t val);
/* @internal */
export function OutPoint_set_index(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OutPoint_set_index(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKOutPoint OutPoint_new(struct LDKThirtyTwoBytes txid_arg, uint16_t index_arg);
/* @internal */
export function OutPoint_new(txid_arg: number, index_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OutPoint_new(txid_arg, index_arg);
	return nativeResponseValue;
}
	// uintptr_t OutPoint_clone_ptr(LDKOutPoint *NONNULL_PTR arg);
/* @internal */
export function OutPoint_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OutPoint_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKOutPoint OutPoint_clone(const struct LDKOutPoint *NONNULL_PTR orig);
/* @internal */
export function OutPoint_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OutPoint_clone(orig);
	return nativeResponseValue;
}
	// bool OutPoint_eq(const struct LDKOutPoint *NONNULL_PTR a, const struct LDKOutPoint *NONNULL_PTR b);
/* @internal */
export function OutPoint_eq(a: number, b: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OutPoint_eq(a, b);
	return nativeResponseValue;
}
	// uint64_t OutPoint_hash(const struct LDKOutPoint *NONNULL_PTR o);
/* @internal */
export function OutPoint_hash(o: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OutPoint_hash(o);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKThirtyTwoBytes OutPoint_to_channel_id(const struct LDKOutPoint *NONNULL_PTR this_arg);
/* @internal */
export function OutPoint_to_channel_id(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OutPoint_to_channel_id(this_arg);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z OutPoint_write(const struct LDKOutPoint *NONNULL_PTR obj);
/* @internal */
export function OutPoint_write(obj: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OutPoint_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_OutPointDecodeErrorZ OutPoint_read(struct LDKu8slice ser);
/* @internal */
export function OutPoint_read(ser: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OutPoint_read(ser);
	return nativeResponseValue;
}
	// void DelayedPaymentOutputDescriptor_free(struct LDKDelayedPaymentOutputDescriptor this_obj);
/* @internal */
export function DelayedPaymentOutputDescriptor_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DelayedPaymentOutputDescriptor_free(this_obj);
	// debug statements here
}
	// struct LDKOutPoint DelayedPaymentOutputDescriptor_get_outpoint(const struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr);
/* @internal */
export function DelayedPaymentOutputDescriptor_get_outpoint(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DelayedPaymentOutputDescriptor_get_outpoint(this_ptr);
	return nativeResponseValue;
}
	// void DelayedPaymentOutputDescriptor_set_outpoint(struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr, struct LDKOutPoint val);
/* @internal */
export function DelayedPaymentOutputDescriptor_set_outpoint(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DelayedPaymentOutputDescriptor_set_outpoint(this_ptr, val);
	// debug statements here
}
	// struct LDKPublicKey DelayedPaymentOutputDescriptor_get_per_commitment_point(const struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr);
/* @internal */
export function DelayedPaymentOutputDescriptor_get_per_commitment_point(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DelayedPaymentOutputDescriptor_get_per_commitment_point(this_ptr);
	return nativeResponseValue;
}
	// void DelayedPaymentOutputDescriptor_set_per_commitment_point(struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */
export function DelayedPaymentOutputDescriptor_set_per_commitment_point(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DelayedPaymentOutputDescriptor_set_per_commitment_point(this_ptr, val);
	// debug statements here
}
	// uint16_t DelayedPaymentOutputDescriptor_get_to_self_delay(const struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr);
/* @internal */
export function DelayedPaymentOutputDescriptor_get_to_self_delay(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DelayedPaymentOutputDescriptor_get_to_self_delay(this_ptr);
	return nativeResponseValue;
}
	// void DelayedPaymentOutputDescriptor_set_to_self_delay(struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr, uint16_t val);
/* @internal */
export function DelayedPaymentOutputDescriptor_set_to_self_delay(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DelayedPaymentOutputDescriptor_set_to_self_delay(this_ptr, val);
	// debug statements here
}
	// void DelayedPaymentOutputDescriptor_set_output(struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr, struct LDKTxOut val);
/* @internal */
export function DelayedPaymentOutputDescriptor_set_output(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DelayedPaymentOutputDescriptor_set_output(this_ptr, val);
	// debug statements here
}
	// struct LDKPublicKey DelayedPaymentOutputDescriptor_get_revocation_pubkey(const struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr);
/* @internal */
export function DelayedPaymentOutputDescriptor_get_revocation_pubkey(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DelayedPaymentOutputDescriptor_get_revocation_pubkey(this_ptr);
	return nativeResponseValue;
}
	// void DelayedPaymentOutputDescriptor_set_revocation_pubkey(struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */
export function DelayedPaymentOutputDescriptor_set_revocation_pubkey(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DelayedPaymentOutputDescriptor_set_revocation_pubkey(this_ptr, val);
	// debug statements here
}
	// const uint8_t (*DelayedPaymentOutputDescriptor_get_channel_keys_id(const struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr))[32];
/* @internal */
export function DelayedPaymentOutputDescriptor_get_channel_keys_id(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DelayedPaymentOutputDescriptor_get_channel_keys_id(this_ptr);
	return nativeResponseValue;
}
	// void DelayedPaymentOutputDescriptor_set_channel_keys_id(struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function DelayedPaymentOutputDescriptor_set_channel_keys_id(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DelayedPaymentOutputDescriptor_set_channel_keys_id(this_ptr, val);
	// debug statements here
}
	// uint64_t DelayedPaymentOutputDescriptor_get_channel_value_satoshis(const struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr);
/* @internal */
export function DelayedPaymentOutputDescriptor_get_channel_value_satoshis(this_ptr: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DelayedPaymentOutputDescriptor_get_channel_value_satoshis(this_ptr);
	return nativeResponseValue;
}
	// void DelayedPaymentOutputDescriptor_set_channel_value_satoshis(struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function DelayedPaymentOutputDescriptor_set_channel_value_satoshis(this_ptr: number, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DelayedPaymentOutputDescriptor_set_channel_value_satoshis(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKDelayedPaymentOutputDescriptor DelayedPaymentOutputDescriptor_new(struct LDKOutPoint outpoint_arg, struct LDKPublicKey per_commitment_point_arg, uint16_t to_self_delay_arg, struct LDKTxOut output_arg, struct LDKPublicKey revocation_pubkey_arg, struct LDKThirtyTwoBytes channel_keys_id_arg, uint64_t channel_value_satoshis_arg);
/* @internal */
export function DelayedPaymentOutputDescriptor_new(outpoint_arg: number, per_commitment_point_arg: number, to_self_delay_arg: number, output_arg: number, revocation_pubkey_arg: number, channel_keys_id_arg: number, channel_value_satoshis_arg: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DelayedPaymentOutputDescriptor_new(outpoint_arg, per_commitment_point_arg, to_self_delay_arg, output_arg, revocation_pubkey_arg, channel_keys_id_arg, channel_value_satoshis_arg);
	return nativeResponseValue;
}
	// uintptr_t DelayedPaymentOutputDescriptor_clone_ptr(LDKDelayedPaymentOutputDescriptor *NONNULL_PTR arg);
/* @internal */
export function DelayedPaymentOutputDescriptor_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DelayedPaymentOutputDescriptor_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKDelayedPaymentOutputDescriptor DelayedPaymentOutputDescriptor_clone(const struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR orig);
/* @internal */
export function DelayedPaymentOutputDescriptor_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DelayedPaymentOutputDescriptor_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z DelayedPaymentOutputDescriptor_write(const struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR obj);
/* @internal */
export function DelayedPaymentOutputDescriptor_write(obj: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DelayedPaymentOutputDescriptor_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ DelayedPaymentOutputDescriptor_read(struct LDKu8slice ser);
/* @internal */
export function DelayedPaymentOutputDescriptor_read(ser: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DelayedPaymentOutputDescriptor_read(ser);
	return nativeResponseValue;
}
	// void StaticPaymentOutputDescriptor_free(struct LDKStaticPaymentOutputDescriptor this_obj);
/* @internal */
export function StaticPaymentOutputDescriptor_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_StaticPaymentOutputDescriptor_free(this_obj);
	// debug statements here
}
	// struct LDKOutPoint StaticPaymentOutputDescriptor_get_outpoint(const struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR this_ptr);
/* @internal */
export function StaticPaymentOutputDescriptor_get_outpoint(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_StaticPaymentOutputDescriptor_get_outpoint(this_ptr);
	return nativeResponseValue;
}
	// void StaticPaymentOutputDescriptor_set_outpoint(struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR this_ptr, struct LDKOutPoint val);
/* @internal */
export function StaticPaymentOutputDescriptor_set_outpoint(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_StaticPaymentOutputDescriptor_set_outpoint(this_ptr, val);
	// debug statements here
}
	// void StaticPaymentOutputDescriptor_set_output(struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR this_ptr, struct LDKTxOut val);
/* @internal */
export function StaticPaymentOutputDescriptor_set_output(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_StaticPaymentOutputDescriptor_set_output(this_ptr, val);
	// debug statements here
}
	// const uint8_t (*StaticPaymentOutputDescriptor_get_channel_keys_id(const struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR this_ptr))[32];
/* @internal */
export function StaticPaymentOutputDescriptor_get_channel_keys_id(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_StaticPaymentOutputDescriptor_get_channel_keys_id(this_ptr);
	return nativeResponseValue;
}
	// void StaticPaymentOutputDescriptor_set_channel_keys_id(struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function StaticPaymentOutputDescriptor_set_channel_keys_id(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_StaticPaymentOutputDescriptor_set_channel_keys_id(this_ptr, val);
	// debug statements here
}
	// uint64_t StaticPaymentOutputDescriptor_get_channel_value_satoshis(const struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR this_ptr);
/* @internal */
export function StaticPaymentOutputDescriptor_get_channel_value_satoshis(this_ptr: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_StaticPaymentOutputDescriptor_get_channel_value_satoshis(this_ptr);
	return nativeResponseValue;
}
	// void StaticPaymentOutputDescriptor_set_channel_value_satoshis(struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function StaticPaymentOutputDescriptor_set_channel_value_satoshis(this_ptr: number, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_StaticPaymentOutputDescriptor_set_channel_value_satoshis(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKStaticPaymentOutputDescriptor StaticPaymentOutputDescriptor_new(struct LDKOutPoint outpoint_arg, struct LDKTxOut output_arg, struct LDKThirtyTwoBytes channel_keys_id_arg, uint64_t channel_value_satoshis_arg);
/* @internal */
export function StaticPaymentOutputDescriptor_new(outpoint_arg: number, output_arg: number, channel_keys_id_arg: number, channel_value_satoshis_arg: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_StaticPaymentOutputDescriptor_new(outpoint_arg, output_arg, channel_keys_id_arg, channel_value_satoshis_arg);
	return nativeResponseValue;
}
	// uintptr_t StaticPaymentOutputDescriptor_clone_ptr(LDKStaticPaymentOutputDescriptor *NONNULL_PTR arg);
/* @internal */
export function StaticPaymentOutputDescriptor_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_StaticPaymentOutputDescriptor_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKStaticPaymentOutputDescriptor StaticPaymentOutputDescriptor_clone(const struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR orig);
/* @internal */
export function StaticPaymentOutputDescriptor_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_StaticPaymentOutputDescriptor_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z StaticPaymentOutputDescriptor_write(const struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR obj);
/* @internal */
export function StaticPaymentOutputDescriptor_write(obj: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_StaticPaymentOutputDescriptor_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ StaticPaymentOutputDescriptor_read(struct LDKu8slice ser);
/* @internal */
export function StaticPaymentOutputDescriptor_read(ser: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_StaticPaymentOutputDescriptor_read(ser);
	return nativeResponseValue;
}
	// void SpendableOutputDescriptor_free(struct LDKSpendableOutputDescriptor this_ptr);
/* @internal */
export function SpendableOutputDescriptor_free(this_ptr: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SpendableOutputDescriptor_free(this_ptr);
	// debug statements here
}
	// uintptr_t SpendableOutputDescriptor_clone_ptr(LDKSpendableOutputDescriptor *NONNULL_PTR arg);
/* @internal */
export function SpendableOutputDescriptor_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SpendableOutputDescriptor_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKSpendableOutputDescriptor SpendableOutputDescriptor_clone(const struct LDKSpendableOutputDescriptor *NONNULL_PTR orig);
/* @internal */
export function SpendableOutputDescriptor_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SpendableOutputDescriptor_clone(orig);
	return nativeResponseValue;
}
	// struct LDKSpendableOutputDescriptor SpendableOutputDescriptor_static_output(struct LDKOutPoint outpoint, struct LDKTxOut output);
/* @internal */
export function SpendableOutputDescriptor_static_output(outpoint: number, output: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SpendableOutputDescriptor_static_output(outpoint, output);
	return nativeResponseValue;
}
	// struct LDKSpendableOutputDescriptor SpendableOutputDescriptor_delayed_payment_output(struct LDKDelayedPaymentOutputDescriptor a);
/* @internal */
export function SpendableOutputDescriptor_delayed_payment_output(a: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SpendableOutputDescriptor_delayed_payment_output(a);
	return nativeResponseValue;
}
	// struct LDKSpendableOutputDescriptor SpendableOutputDescriptor_static_payment_output(struct LDKStaticPaymentOutputDescriptor a);
/* @internal */
export function SpendableOutputDescriptor_static_payment_output(a: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SpendableOutputDescriptor_static_payment_output(a);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z SpendableOutputDescriptor_write(const struct LDKSpendableOutputDescriptor *NONNULL_PTR obj);
/* @internal */
export function SpendableOutputDescriptor_write(obj: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SpendableOutputDescriptor_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_SpendableOutputDescriptorDecodeErrorZ SpendableOutputDescriptor_read(struct LDKu8slice ser);
/* @internal */
export function SpendableOutputDescriptor_read(ser: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SpendableOutputDescriptor_read(ser);
	return nativeResponseValue;
}
	// void BaseSign_free(struct LDKBaseSign this_ptr);
/* @internal */
export function BaseSign_free(this_ptr: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BaseSign_free(this_ptr);
	// debug statements here
}
	// uintptr_t Sign_clone_ptr(LDKSign *NONNULL_PTR arg);
/* @internal */
export function Sign_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Sign_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKSign Sign_clone(const struct LDKSign *NONNULL_PTR orig);
/* @internal */
export function Sign_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Sign_clone(orig);
	return nativeResponseValue;
}
	// void Sign_free(struct LDKSign this_ptr);
/* @internal */
export function Sign_free(this_ptr: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Sign_free(this_ptr);
	// debug statements here
}
	// enum LDKRecipient Recipient_clone(const enum LDKRecipient *NONNULL_PTR orig);
/* @internal */
export function Recipient_clone(orig: number): Recipient {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Recipient_clone(orig);
	return nativeResponseValue;
}
	// enum LDKRecipient Recipient_node(void);
/* @internal */
export function Recipient_node(): Recipient {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Recipient_node();
	return nativeResponseValue;
}
	// enum LDKRecipient Recipient_phantom_node(void);
/* @internal */
export function Recipient_phantom_node(): Recipient {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Recipient_phantom_node();
	return nativeResponseValue;
}
	// void KeysInterface_free(struct LDKKeysInterface this_ptr);
/* @internal */
export function KeysInterface_free(this_ptr: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_KeysInterface_free(this_ptr);
	// debug statements here
}
	// void InMemorySigner_free(struct LDKInMemorySigner this_obj);
/* @internal */
export function InMemorySigner_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InMemorySigner_free(this_obj);
	// debug statements here
}
	// const uint8_t (*InMemorySigner_get_funding_key(const struct LDKInMemorySigner *NONNULL_PTR this_ptr))[32];
/* @internal */
export function InMemorySigner_get_funding_key(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InMemorySigner_get_funding_key(this_ptr);
	return nativeResponseValue;
}
	// void InMemorySigner_set_funding_key(struct LDKInMemorySigner *NONNULL_PTR this_ptr, struct LDKSecretKey val);
/* @internal */
export function InMemorySigner_set_funding_key(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InMemorySigner_set_funding_key(this_ptr, val);
	// debug statements here
}
	// const uint8_t (*InMemorySigner_get_revocation_base_key(const struct LDKInMemorySigner *NONNULL_PTR this_ptr))[32];
/* @internal */
export function InMemorySigner_get_revocation_base_key(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InMemorySigner_get_revocation_base_key(this_ptr);
	return nativeResponseValue;
}
	// void InMemorySigner_set_revocation_base_key(struct LDKInMemorySigner *NONNULL_PTR this_ptr, struct LDKSecretKey val);
/* @internal */
export function InMemorySigner_set_revocation_base_key(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InMemorySigner_set_revocation_base_key(this_ptr, val);
	// debug statements here
}
	// const uint8_t (*InMemorySigner_get_payment_key(const struct LDKInMemorySigner *NONNULL_PTR this_ptr))[32];
/* @internal */
export function InMemorySigner_get_payment_key(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InMemorySigner_get_payment_key(this_ptr);
	return nativeResponseValue;
}
	// void InMemorySigner_set_payment_key(struct LDKInMemorySigner *NONNULL_PTR this_ptr, struct LDKSecretKey val);
/* @internal */
export function InMemorySigner_set_payment_key(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InMemorySigner_set_payment_key(this_ptr, val);
	// debug statements here
}
	// const uint8_t (*InMemorySigner_get_delayed_payment_base_key(const struct LDKInMemorySigner *NONNULL_PTR this_ptr))[32];
/* @internal */
export function InMemorySigner_get_delayed_payment_base_key(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InMemorySigner_get_delayed_payment_base_key(this_ptr);
	return nativeResponseValue;
}
	// void InMemorySigner_set_delayed_payment_base_key(struct LDKInMemorySigner *NONNULL_PTR this_ptr, struct LDKSecretKey val);
/* @internal */
export function InMemorySigner_set_delayed_payment_base_key(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InMemorySigner_set_delayed_payment_base_key(this_ptr, val);
	// debug statements here
}
	// const uint8_t (*InMemorySigner_get_htlc_base_key(const struct LDKInMemorySigner *NONNULL_PTR this_ptr))[32];
/* @internal */
export function InMemorySigner_get_htlc_base_key(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InMemorySigner_get_htlc_base_key(this_ptr);
	return nativeResponseValue;
}
	// void InMemorySigner_set_htlc_base_key(struct LDKInMemorySigner *NONNULL_PTR this_ptr, struct LDKSecretKey val);
/* @internal */
export function InMemorySigner_set_htlc_base_key(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InMemorySigner_set_htlc_base_key(this_ptr, val);
	// debug statements here
}
	// const uint8_t (*InMemorySigner_get_commitment_seed(const struct LDKInMemorySigner *NONNULL_PTR this_ptr))[32];
/* @internal */
export function InMemorySigner_get_commitment_seed(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InMemorySigner_get_commitment_seed(this_ptr);
	return nativeResponseValue;
}
	// void InMemorySigner_set_commitment_seed(struct LDKInMemorySigner *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function InMemorySigner_set_commitment_seed(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InMemorySigner_set_commitment_seed(this_ptr, val);
	// debug statements here
}
	// uintptr_t InMemorySigner_clone_ptr(LDKInMemorySigner *NONNULL_PTR arg);
/* @internal */
export function InMemorySigner_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InMemorySigner_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKInMemorySigner InMemorySigner_clone(const struct LDKInMemorySigner *NONNULL_PTR orig);
/* @internal */
export function InMemorySigner_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InMemorySigner_clone(orig);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKInMemorySigner InMemorySigner_new(struct LDKSecretKey node_secret, struct LDKSecretKey funding_key, struct LDKSecretKey revocation_base_key, struct LDKSecretKey payment_key, struct LDKSecretKey delayed_payment_base_key, struct LDKSecretKey htlc_base_key, struct LDKThirtyTwoBytes commitment_seed, uint64_t channel_value_satoshis, struct LDKThirtyTwoBytes channel_keys_id);
/* @internal */
export function InMemorySigner_new(node_secret: number, funding_key: number, revocation_base_key: number, payment_key: number, delayed_payment_base_key: number, htlc_base_key: number, commitment_seed: number, channel_value_satoshis: bigint, channel_keys_id: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InMemorySigner_new(node_secret, funding_key, revocation_base_key, payment_key, delayed_payment_base_key, htlc_base_key, commitment_seed, channel_value_satoshis, channel_keys_id);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKChannelPublicKeys InMemorySigner_counterparty_pubkeys(const struct LDKInMemorySigner *NONNULL_PTR this_arg);
/* @internal */
export function InMemorySigner_counterparty_pubkeys(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InMemorySigner_counterparty_pubkeys(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES uint16_t InMemorySigner_counterparty_selected_contest_delay(const struct LDKInMemorySigner *NONNULL_PTR this_arg);
/* @internal */
export function InMemorySigner_counterparty_selected_contest_delay(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InMemorySigner_counterparty_selected_contest_delay(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES uint16_t InMemorySigner_holder_selected_contest_delay(const struct LDKInMemorySigner *NONNULL_PTR this_arg);
/* @internal */
export function InMemorySigner_holder_selected_contest_delay(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InMemorySigner_holder_selected_contest_delay(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES bool InMemorySigner_is_outbound(const struct LDKInMemorySigner *NONNULL_PTR this_arg);
/* @internal */
export function InMemorySigner_is_outbound(this_arg: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InMemorySigner_is_outbound(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKOutPoint InMemorySigner_funding_outpoint(const struct LDKInMemorySigner *NONNULL_PTR this_arg);
/* @internal */
export function InMemorySigner_funding_outpoint(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InMemorySigner_funding_outpoint(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKChannelTransactionParameters InMemorySigner_get_channel_parameters(const struct LDKInMemorySigner *NONNULL_PTR this_arg);
/* @internal */
export function InMemorySigner_get_channel_parameters(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InMemorySigner_get_channel_parameters(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES bool InMemorySigner_opt_anchors(const struct LDKInMemorySigner *NONNULL_PTR this_arg);
/* @internal */
export function InMemorySigner_opt_anchors(this_arg: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InMemorySigner_opt_anchors(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_CVec_CVec_u8ZZNoneZ InMemorySigner_sign_counterparty_payment_input(const struct LDKInMemorySigner *NONNULL_PTR this_arg, struct LDKTransaction spend_tx, uintptr_t input_idx, const struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR descriptor);
/* @internal */
export function InMemorySigner_sign_counterparty_payment_input(this_arg: number, spend_tx: number, input_idx: number, descriptor: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InMemorySigner_sign_counterparty_payment_input(this_arg, spend_tx, input_idx, descriptor);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_CVec_CVec_u8ZZNoneZ InMemorySigner_sign_dynamic_p2wsh_input(const struct LDKInMemorySigner *NONNULL_PTR this_arg, struct LDKTransaction spend_tx, uintptr_t input_idx, const struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR descriptor);
/* @internal */
export function InMemorySigner_sign_dynamic_p2wsh_input(this_arg: number, spend_tx: number, input_idx: number, descriptor: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InMemorySigner_sign_dynamic_p2wsh_input(this_arg, spend_tx, input_idx, descriptor);
	return nativeResponseValue;
}
	// struct LDKBaseSign InMemorySigner_as_BaseSign(const struct LDKInMemorySigner *NONNULL_PTR this_arg);
/* @internal */
export function InMemorySigner_as_BaseSign(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InMemorySigner_as_BaseSign(this_arg);
	return nativeResponseValue;
}
	// struct LDKSign InMemorySigner_as_Sign(const struct LDKInMemorySigner *NONNULL_PTR this_arg);
/* @internal */
export function InMemorySigner_as_Sign(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InMemorySigner_as_Sign(this_arg);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z InMemorySigner_write(const struct LDKInMemorySigner *NONNULL_PTR obj);
/* @internal */
export function InMemorySigner_write(obj: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InMemorySigner_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_InMemorySignerDecodeErrorZ InMemorySigner_read(struct LDKu8slice ser, struct LDKSecretKey arg);
/* @internal */
export function InMemorySigner_read(ser: number, arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InMemorySigner_read(ser, arg);
	return nativeResponseValue;
}
	// void KeysManager_free(struct LDKKeysManager this_obj);
/* @internal */
export function KeysManager_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_KeysManager_free(this_obj);
	// debug statements here
}
	// MUST_USE_RES struct LDKKeysManager KeysManager_new(const uint8_t (*seed)[32], uint64_t starting_time_secs, uint32_t starting_time_nanos);
/* @internal */
export function KeysManager_new(seed: number, starting_time_secs: bigint, starting_time_nanos: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_KeysManager_new(seed, starting_time_secs, starting_time_nanos);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKInMemorySigner KeysManager_derive_channel_keys(const struct LDKKeysManager *NONNULL_PTR this_arg, uint64_t channel_value_satoshis, const uint8_t (*params)[32]);
/* @internal */
export function KeysManager_derive_channel_keys(this_arg: number, channel_value_satoshis: bigint, params: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_KeysManager_derive_channel_keys(this_arg, channel_value_satoshis, params);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_TransactionNoneZ KeysManager_spend_spendable_outputs(const struct LDKKeysManager *NONNULL_PTR this_arg, struct LDKCVec_SpendableOutputDescriptorZ descriptors, struct LDKCVec_TxOutZ outputs, struct LDKCVec_u8Z change_destination_script, uint32_t feerate_sat_per_1000_weight);
/* @internal */
export function KeysManager_spend_spendable_outputs(this_arg: number, descriptors: number, outputs: number, change_destination_script: number, feerate_sat_per_1000_weight: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_KeysManager_spend_spendable_outputs(this_arg, descriptors, outputs, change_destination_script, feerate_sat_per_1000_weight);
	return nativeResponseValue;
}
	// struct LDKKeysInterface KeysManager_as_KeysInterface(const struct LDKKeysManager *NONNULL_PTR this_arg);
/* @internal */
export function KeysManager_as_KeysInterface(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_KeysManager_as_KeysInterface(this_arg);
	return nativeResponseValue;
}
	// void PhantomKeysManager_free(struct LDKPhantomKeysManager this_obj);
/* @internal */
export function PhantomKeysManager_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PhantomKeysManager_free(this_obj);
	// debug statements here
}
	// struct LDKKeysInterface PhantomKeysManager_as_KeysInterface(const struct LDKPhantomKeysManager *NONNULL_PTR this_arg);
/* @internal */
export function PhantomKeysManager_as_KeysInterface(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PhantomKeysManager_as_KeysInterface(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKPhantomKeysManager PhantomKeysManager_new(const uint8_t (*seed)[32], uint64_t starting_time_secs, uint32_t starting_time_nanos, const uint8_t (*cross_node_seed)[32]);
/* @internal */
export function PhantomKeysManager_new(seed: number, starting_time_secs: bigint, starting_time_nanos: number, cross_node_seed: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PhantomKeysManager_new(seed, starting_time_secs, starting_time_nanos, cross_node_seed);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_TransactionNoneZ PhantomKeysManager_spend_spendable_outputs(const struct LDKPhantomKeysManager *NONNULL_PTR this_arg, struct LDKCVec_SpendableOutputDescriptorZ descriptors, struct LDKCVec_TxOutZ outputs, struct LDKCVec_u8Z change_destination_script, uint32_t feerate_sat_per_1000_weight);
/* @internal */
export function PhantomKeysManager_spend_spendable_outputs(this_arg: number, descriptors: number, outputs: number, change_destination_script: number, feerate_sat_per_1000_weight: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PhantomKeysManager_spend_spendable_outputs(this_arg, descriptors, outputs, change_destination_script, feerate_sat_per_1000_weight);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKInMemorySigner PhantomKeysManager_derive_channel_keys(const struct LDKPhantomKeysManager *NONNULL_PTR this_arg, uint64_t channel_value_satoshis, const uint8_t (*params)[32]);
/* @internal */
export function PhantomKeysManager_derive_channel_keys(this_arg: number, channel_value_satoshis: bigint, params: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PhantomKeysManager_derive_channel_keys(this_arg, channel_value_satoshis, params);
	return nativeResponseValue;
}
	// void ChannelManager_free(struct LDKChannelManager this_obj);
/* @internal */
export function ChannelManager_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManager_free(this_obj);
	// debug statements here
}
	// void ChainParameters_free(struct LDKChainParameters this_obj);
/* @internal */
export function ChainParameters_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChainParameters_free(this_obj);
	// debug statements here
}
	// enum LDKNetwork ChainParameters_get_network(const struct LDKChainParameters *NONNULL_PTR this_ptr);
/* @internal */
export function ChainParameters_get_network(this_ptr: number): Network {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChainParameters_get_network(this_ptr);
	return nativeResponseValue;
}
	// void ChainParameters_set_network(struct LDKChainParameters *NONNULL_PTR this_ptr, enum LDKNetwork val);
/* @internal */
export function ChainParameters_set_network(this_ptr: number, val: Network): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChainParameters_set_network(this_ptr, val);
	// debug statements here
}
	// struct LDKBestBlock ChainParameters_get_best_block(const struct LDKChainParameters *NONNULL_PTR this_ptr);
/* @internal */
export function ChainParameters_get_best_block(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChainParameters_get_best_block(this_ptr);
	return nativeResponseValue;
}
	// void ChainParameters_set_best_block(struct LDKChainParameters *NONNULL_PTR this_ptr, struct LDKBestBlock val);
/* @internal */
export function ChainParameters_set_best_block(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChainParameters_set_best_block(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKChainParameters ChainParameters_new(enum LDKNetwork network_arg, struct LDKBestBlock best_block_arg);
/* @internal */
export function ChainParameters_new(network_arg: Network, best_block_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChainParameters_new(network_arg, best_block_arg);
	return nativeResponseValue;
}
	// uintptr_t ChainParameters_clone_ptr(LDKChainParameters *NONNULL_PTR arg);
/* @internal */
export function ChainParameters_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChainParameters_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKChainParameters ChainParameters_clone(const struct LDKChainParameters *NONNULL_PTR orig);
/* @internal */
export function ChainParameters_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChainParameters_clone(orig);
	return nativeResponseValue;
}
	// void CounterpartyForwardingInfo_free(struct LDKCounterpartyForwardingInfo this_obj);
/* @internal */
export function CounterpartyForwardingInfo_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CounterpartyForwardingInfo_free(this_obj);
	// debug statements here
}
	// uint32_t CounterpartyForwardingInfo_get_fee_base_msat(const struct LDKCounterpartyForwardingInfo *NONNULL_PTR this_ptr);
/* @internal */
export function CounterpartyForwardingInfo_get_fee_base_msat(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CounterpartyForwardingInfo_get_fee_base_msat(this_ptr);
	return nativeResponseValue;
}
	// void CounterpartyForwardingInfo_set_fee_base_msat(struct LDKCounterpartyForwardingInfo *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */
export function CounterpartyForwardingInfo_set_fee_base_msat(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CounterpartyForwardingInfo_set_fee_base_msat(this_ptr, val);
	// debug statements here
}
	// uint32_t CounterpartyForwardingInfo_get_fee_proportional_millionths(const struct LDKCounterpartyForwardingInfo *NONNULL_PTR this_ptr);
/* @internal */
export function CounterpartyForwardingInfo_get_fee_proportional_millionths(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CounterpartyForwardingInfo_get_fee_proportional_millionths(this_ptr);
	return nativeResponseValue;
}
	// void CounterpartyForwardingInfo_set_fee_proportional_millionths(struct LDKCounterpartyForwardingInfo *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */
export function CounterpartyForwardingInfo_set_fee_proportional_millionths(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CounterpartyForwardingInfo_set_fee_proportional_millionths(this_ptr, val);
	// debug statements here
}
	// uint16_t CounterpartyForwardingInfo_get_cltv_expiry_delta(const struct LDKCounterpartyForwardingInfo *NONNULL_PTR this_ptr);
/* @internal */
export function CounterpartyForwardingInfo_get_cltv_expiry_delta(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CounterpartyForwardingInfo_get_cltv_expiry_delta(this_ptr);
	return nativeResponseValue;
}
	// void CounterpartyForwardingInfo_set_cltv_expiry_delta(struct LDKCounterpartyForwardingInfo *NONNULL_PTR this_ptr, uint16_t val);
/* @internal */
export function CounterpartyForwardingInfo_set_cltv_expiry_delta(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CounterpartyForwardingInfo_set_cltv_expiry_delta(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKCounterpartyForwardingInfo CounterpartyForwardingInfo_new(uint32_t fee_base_msat_arg, uint32_t fee_proportional_millionths_arg, uint16_t cltv_expiry_delta_arg);
/* @internal */
export function CounterpartyForwardingInfo_new(fee_base_msat_arg: number, fee_proportional_millionths_arg: number, cltv_expiry_delta_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CounterpartyForwardingInfo_new(fee_base_msat_arg, fee_proportional_millionths_arg, cltv_expiry_delta_arg);
	return nativeResponseValue;
}
	// uintptr_t CounterpartyForwardingInfo_clone_ptr(LDKCounterpartyForwardingInfo *NONNULL_PTR arg);
/* @internal */
export function CounterpartyForwardingInfo_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CounterpartyForwardingInfo_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCounterpartyForwardingInfo CounterpartyForwardingInfo_clone(const struct LDKCounterpartyForwardingInfo *NONNULL_PTR orig);
/* @internal */
export function CounterpartyForwardingInfo_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CounterpartyForwardingInfo_clone(orig);
	return nativeResponseValue;
}
	// void ChannelCounterparty_free(struct LDKChannelCounterparty this_obj);
/* @internal */
export function ChannelCounterparty_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelCounterparty_free(this_obj);
	// debug statements here
}
	// struct LDKPublicKey ChannelCounterparty_get_node_id(const struct LDKChannelCounterparty *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelCounterparty_get_node_id(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelCounterparty_get_node_id(this_ptr);
	return nativeResponseValue;
}
	// void ChannelCounterparty_set_node_id(struct LDKChannelCounterparty *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */
export function ChannelCounterparty_set_node_id(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelCounterparty_set_node_id(this_ptr, val);
	// debug statements here
}
	// struct LDKInitFeatures ChannelCounterparty_get_features(const struct LDKChannelCounterparty *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelCounterparty_get_features(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelCounterparty_get_features(this_ptr);
	return nativeResponseValue;
}
	// void ChannelCounterparty_set_features(struct LDKChannelCounterparty *NONNULL_PTR this_ptr, struct LDKInitFeatures val);
/* @internal */
export function ChannelCounterparty_set_features(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelCounterparty_set_features(this_ptr, val);
	// debug statements here
}
	// uint64_t ChannelCounterparty_get_unspendable_punishment_reserve(const struct LDKChannelCounterparty *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelCounterparty_get_unspendable_punishment_reserve(this_ptr: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelCounterparty_get_unspendable_punishment_reserve(this_ptr);
	return nativeResponseValue;
}
	// void ChannelCounterparty_set_unspendable_punishment_reserve(struct LDKChannelCounterparty *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function ChannelCounterparty_set_unspendable_punishment_reserve(this_ptr: number, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelCounterparty_set_unspendable_punishment_reserve(this_ptr, val);
	// debug statements here
}
	// struct LDKCounterpartyForwardingInfo ChannelCounterparty_get_forwarding_info(const struct LDKChannelCounterparty *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelCounterparty_get_forwarding_info(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelCounterparty_get_forwarding_info(this_ptr);
	return nativeResponseValue;
}
	// void ChannelCounterparty_set_forwarding_info(struct LDKChannelCounterparty *NONNULL_PTR this_ptr, struct LDKCounterpartyForwardingInfo val);
/* @internal */
export function ChannelCounterparty_set_forwarding_info(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelCounterparty_set_forwarding_info(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKChannelCounterparty ChannelCounterparty_new(struct LDKPublicKey node_id_arg, struct LDKInitFeatures features_arg, uint64_t unspendable_punishment_reserve_arg, struct LDKCounterpartyForwardingInfo forwarding_info_arg);
/* @internal */
export function ChannelCounterparty_new(node_id_arg: number, features_arg: number, unspendable_punishment_reserve_arg: bigint, forwarding_info_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelCounterparty_new(node_id_arg, features_arg, unspendable_punishment_reserve_arg, forwarding_info_arg);
	return nativeResponseValue;
}
	// uintptr_t ChannelCounterparty_clone_ptr(LDKChannelCounterparty *NONNULL_PTR arg);
/* @internal */
export function ChannelCounterparty_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelCounterparty_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKChannelCounterparty ChannelCounterparty_clone(const struct LDKChannelCounterparty *NONNULL_PTR orig);
/* @internal */
export function ChannelCounterparty_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelCounterparty_clone(orig);
	return nativeResponseValue;
}
	// void ChannelDetails_free(struct LDKChannelDetails this_obj);
/* @internal */
export function ChannelDetails_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_free(this_obj);
	// debug statements here
}
	// const uint8_t (*ChannelDetails_get_channel_id(const struct LDKChannelDetails *NONNULL_PTR this_ptr))[32];
/* @internal */
export function ChannelDetails_get_channel_id(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_get_channel_id(this_ptr);
	return nativeResponseValue;
}
	// void ChannelDetails_set_channel_id(struct LDKChannelDetails *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function ChannelDetails_set_channel_id(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_set_channel_id(this_ptr, val);
	// debug statements here
}
	// struct LDKChannelCounterparty ChannelDetails_get_counterparty(const struct LDKChannelDetails *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelDetails_get_counterparty(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_get_counterparty(this_ptr);
	return nativeResponseValue;
}
	// void ChannelDetails_set_counterparty(struct LDKChannelDetails *NONNULL_PTR this_ptr, struct LDKChannelCounterparty val);
/* @internal */
export function ChannelDetails_set_counterparty(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_set_counterparty(this_ptr, val);
	// debug statements here
}
	// struct LDKOutPoint ChannelDetails_get_funding_txo(const struct LDKChannelDetails *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelDetails_get_funding_txo(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_get_funding_txo(this_ptr);
	return nativeResponseValue;
}
	// void ChannelDetails_set_funding_txo(struct LDKChannelDetails *NONNULL_PTR this_ptr, struct LDKOutPoint val);
/* @internal */
export function ChannelDetails_set_funding_txo(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_set_funding_txo(this_ptr, val);
	// debug statements here
}
	// struct LDKChannelTypeFeatures ChannelDetails_get_channel_type(const struct LDKChannelDetails *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelDetails_get_channel_type(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_get_channel_type(this_ptr);
	return nativeResponseValue;
}
	// void ChannelDetails_set_channel_type(struct LDKChannelDetails *NONNULL_PTR this_ptr, struct LDKChannelTypeFeatures val);
/* @internal */
export function ChannelDetails_set_channel_type(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_set_channel_type(this_ptr, val);
	// debug statements here
}
	// struct LDKCOption_u64Z ChannelDetails_get_short_channel_id(const struct LDKChannelDetails *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelDetails_get_short_channel_id(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_get_short_channel_id(this_ptr);
	return nativeResponseValue;
}
	// void ChannelDetails_set_short_channel_id(struct LDKChannelDetails *NONNULL_PTR this_ptr, struct LDKCOption_u64Z val);
/* @internal */
export function ChannelDetails_set_short_channel_id(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_set_short_channel_id(this_ptr, val);
	// debug statements here
}
	// struct LDKCOption_u64Z ChannelDetails_get_inbound_scid_alias(const struct LDKChannelDetails *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelDetails_get_inbound_scid_alias(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_get_inbound_scid_alias(this_ptr);
	return nativeResponseValue;
}
	// void ChannelDetails_set_inbound_scid_alias(struct LDKChannelDetails *NONNULL_PTR this_ptr, struct LDKCOption_u64Z val);
/* @internal */
export function ChannelDetails_set_inbound_scid_alias(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_set_inbound_scid_alias(this_ptr, val);
	// debug statements here
}
	// uint64_t ChannelDetails_get_channel_value_satoshis(const struct LDKChannelDetails *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelDetails_get_channel_value_satoshis(this_ptr: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_get_channel_value_satoshis(this_ptr);
	return nativeResponseValue;
}
	// void ChannelDetails_set_channel_value_satoshis(struct LDKChannelDetails *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function ChannelDetails_set_channel_value_satoshis(this_ptr: number, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_set_channel_value_satoshis(this_ptr, val);
	// debug statements here
}
	// struct LDKCOption_u64Z ChannelDetails_get_unspendable_punishment_reserve(const struct LDKChannelDetails *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelDetails_get_unspendable_punishment_reserve(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_get_unspendable_punishment_reserve(this_ptr);
	return nativeResponseValue;
}
	// void ChannelDetails_set_unspendable_punishment_reserve(struct LDKChannelDetails *NONNULL_PTR this_ptr, struct LDKCOption_u64Z val);
/* @internal */
export function ChannelDetails_set_unspendable_punishment_reserve(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_set_unspendable_punishment_reserve(this_ptr, val);
	// debug statements here
}
	// uint64_t ChannelDetails_get_user_channel_id(const struct LDKChannelDetails *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelDetails_get_user_channel_id(this_ptr: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_get_user_channel_id(this_ptr);
	return nativeResponseValue;
}
	// void ChannelDetails_set_user_channel_id(struct LDKChannelDetails *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function ChannelDetails_set_user_channel_id(this_ptr: number, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_set_user_channel_id(this_ptr, val);
	// debug statements here
}
	// uint64_t ChannelDetails_get_balance_msat(const struct LDKChannelDetails *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelDetails_get_balance_msat(this_ptr: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_get_balance_msat(this_ptr);
	return nativeResponseValue;
}
	// void ChannelDetails_set_balance_msat(struct LDKChannelDetails *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function ChannelDetails_set_balance_msat(this_ptr: number, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_set_balance_msat(this_ptr, val);
	// debug statements here
}
	// uint64_t ChannelDetails_get_outbound_capacity_msat(const struct LDKChannelDetails *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelDetails_get_outbound_capacity_msat(this_ptr: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_get_outbound_capacity_msat(this_ptr);
	return nativeResponseValue;
}
	// void ChannelDetails_set_outbound_capacity_msat(struct LDKChannelDetails *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function ChannelDetails_set_outbound_capacity_msat(this_ptr: number, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_set_outbound_capacity_msat(this_ptr, val);
	// debug statements here
}
	// uint64_t ChannelDetails_get_inbound_capacity_msat(const struct LDKChannelDetails *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelDetails_get_inbound_capacity_msat(this_ptr: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_get_inbound_capacity_msat(this_ptr);
	return nativeResponseValue;
}
	// void ChannelDetails_set_inbound_capacity_msat(struct LDKChannelDetails *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function ChannelDetails_set_inbound_capacity_msat(this_ptr: number, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_set_inbound_capacity_msat(this_ptr, val);
	// debug statements here
}
	// struct LDKCOption_u32Z ChannelDetails_get_confirmations_required(const struct LDKChannelDetails *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelDetails_get_confirmations_required(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_get_confirmations_required(this_ptr);
	return nativeResponseValue;
}
	// void ChannelDetails_set_confirmations_required(struct LDKChannelDetails *NONNULL_PTR this_ptr, struct LDKCOption_u32Z val);
/* @internal */
export function ChannelDetails_set_confirmations_required(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_set_confirmations_required(this_ptr, val);
	// debug statements here
}
	// struct LDKCOption_u16Z ChannelDetails_get_force_close_spend_delay(const struct LDKChannelDetails *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelDetails_get_force_close_spend_delay(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_get_force_close_spend_delay(this_ptr);
	return nativeResponseValue;
}
	// void ChannelDetails_set_force_close_spend_delay(struct LDKChannelDetails *NONNULL_PTR this_ptr, struct LDKCOption_u16Z val);
/* @internal */
export function ChannelDetails_set_force_close_spend_delay(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_set_force_close_spend_delay(this_ptr, val);
	// debug statements here
}
	// bool ChannelDetails_get_is_outbound(const struct LDKChannelDetails *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelDetails_get_is_outbound(this_ptr: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_get_is_outbound(this_ptr);
	return nativeResponseValue;
}
	// void ChannelDetails_set_is_outbound(struct LDKChannelDetails *NONNULL_PTR this_ptr, bool val);
/* @internal */
export function ChannelDetails_set_is_outbound(this_ptr: number, val: boolean): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_set_is_outbound(this_ptr, val);
	// debug statements here
}
	// bool ChannelDetails_get_is_funding_locked(const struct LDKChannelDetails *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelDetails_get_is_funding_locked(this_ptr: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_get_is_funding_locked(this_ptr);
	return nativeResponseValue;
}
	// void ChannelDetails_set_is_funding_locked(struct LDKChannelDetails *NONNULL_PTR this_ptr, bool val);
/* @internal */
export function ChannelDetails_set_is_funding_locked(this_ptr: number, val: boolean): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_set_is_funding_locked(this_ptr, val);
	// debug statements here
}
	// bool ChannelDetails_get_is_usable(const struct LDKChannelDetails *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelDetails_get_is_usable(this_ptr: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_get_is_usable(this_ptr);
	return nativeResponseValue;
}
	// void ChannelDetails_set_is_usable(struct LDKChannelDetails *NONNULL_PTR this_ptr, bool val);
/* @internal */
export function ChannelDetails_set_is_usable(this_ptr: number, val: boolean): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_set_is_usable(this_ptr, val);
	// debug statements here
}
	// bool ChannelDetails_get_is_public(const struct LDKChannelDetails *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelDetails_get_is_public(this_ptr: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_get_is_public(this_ptr);
	return nativeResponseValue;
}
	// void ChannelDetails_set_is_public(struct LDKChannelDetails *NONNULL_PTR this_ptr, bool val);
/* @internal */
export function ChannelDetails_set_is_public(this_ptr: number, val: boolean): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_set_is_public(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKChannelDetails ChannelDetails_new(struct LDKThirtyTwoBytes channel_id_arg, struct LDKChannelCounterparty counterparty_arg, struct LDKOutPoint funding_txo_arg, struct LDKChannelTypeFeatures channel_type_arg, struct LDKCOption_u64Z short_channel_id_arg, struct LDKCOption_u64Z inbound_scid_alias_arg, uint64_t channel_value_satoshis_arg, struct LDKCOption_u64Z unspendable_punishment_reserve_arg, uint64_t user_channel_id_arg, uint64_t balance_msat_arg, uint64_t outbound_capacity_msat_arg, uint64_t inbound_capacity_msat_arg, struct LDKCOption_u32Z confirmations_required_arg, struct LDKCOption_u16Z force_close_spend_delay_arg, bool is_outbound_arg, bool is_funding_locked_arg, bool is_usable_arg, bool is_public_arg);
/* @internal */
export function ChannelDetails_new(channel_id_arg: number, counterparty_arg: number, funding_txo_arg: number, channel_type_arg: number, short_channel_id_arg: number, inbound_scid_alias_arg: number, channel_value_satoshis_arg: bigint, unspendable_punishment_reserve_arg: number, user_channel_id_arg: bigint, balance_msat_arg: bigint, outbound_capacity_msat_arg: bigint, inbound_capacity_msat_arg: bigint, confirmations_required_arg: number, force_close_spend_delay_arg: number, is_outbound_arg: boolean, is_funding_locked_arg: boolean, is_usable_arg: boolean, is_public_arg: boolean): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_new(channel_id_arg, counterparty_arg, funding_txo_arg, channel_type_arg, short_channel_id_arg, inbound_scid_alias_arg, channel_value_satoshis_arg, unspendable_punishment_reserve_arg, user_channel_id_arg, balance_msat_arg, outbound_capacity_msat_arg, inbound_capacity_msat_arg, confirmations_required_arg, force_close_spend_delay_arg, is_outbound_arg, is_funding_locked_arg, is_usable_arg, is_public_arg);
	return nativeResponseValue;
}
	// uintptr_t ChannelDetails_clone_ptr(LDKChannelDetails *NONNULL_PTR arg);
/* @internal */
export function ChannelDetails_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKChannelDetails ChannelDetails_clone(const struct LDKChannelDetails *NONNULL_PTR orig);
/* @internal */
export function ChannelDetails_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_clone(orig);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCOption_u64Z ChannelDetails_get_inbound_payment_scid(const struct LDKChannelDetails *NONNULL_PTR this_arg);
/* @internal */
export function ChannelDetails_get_inbound_payment_scid(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_get_inbound_payment_scid(this_arg);
	return nativeResponseValue;
}
	// void PaymentSendFailure_free(struct LDKPaymentSendFailure this_ptr);
/* @internal */
export function PaymentSendFailure_free(this_ptr: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentSendFailure_free(this_ptr);
	// debug statements here
}
	// uintptr_t PaymentSendFailure_clone_ptr(LDKPaymentSendFailure *NONNULL_PTR arg);
/* @internal */
export function PaymentSendFailure_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentSendFailure_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKPaymentSendFailure PaymentSendFailure_clone(const struct LDKPaymentSendFailure *NONNULL_PTR orig);
/* @internal */
export function PaymentSendFailure_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentSendFailure_clone(orig);
	return nativeResponseValue;
}
	// struct LDKPaymentSendFailure PaymentSendFailure_parameter_error(struct LDKAPIError a);
/* @internal */
export function PaymentSendFailure_parameter_error(a: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentSendFailure_parameter_error(a);
	return nativeResponseValue;
}
	// struct LDKPaymentSendFailure PaymentSendFailure_path_parameter_error(struct LDKCVec_CResult_NoneAPIErrorZZ a);
/* @internal */
export function PaymentSendFailure_path_parameter_error(a: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentSendFailure_path_parameter_error(a);
	return nativeResponseValue;
}
	// struct LDKPaymentSendFailure PaymentSendFailure_all_failed_retry_safe(struct LDKCVec_APIErrorZ a);
/* @internal */
export function PaymentSendFailure_all_failed_retry_safe(a: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentSendFailure_all_failed_retry_safe(a);
	return nativeResponseValue;
}
	// struct LDKPaymentSendFailure PaymentSendFailure_partial_failure(struct LDKCVec_CResult_NoneAPIErrorZZ results, struct LDKRouteParameters failed_paths_retry, struct LDKThirtyTwoBytes payment_id);
/* @internal */
export function PaymentSendFailure_partial_failure(results: number, failed_paths_retry: number, payment_id: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentSendFailure_partial_failure(results, failed_paths_retry, payment_id);
	return nativeResponseValue;
}
	// void PhantomRouteHints_free(struct LDKPhantomRouteHints this_obj);
/* @internal */
export function PhantomRouteHints_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PhantomRouteHints_free(this_obj);
	// debug statements here
}
	// struct LDKCVec_ChannelDetailsZ PhantomRouteHints_get_channels(const struct LDKPhantomRouteHints *NONNULL_PTR this_ptr);
/* @internal */
export function PhantomRouteHints_get_channels(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PhantomRouteHints_get_channels(this_ptr);
	return nativeResponseValue;
}
	// void PhantomRouteHints_set_channels(struct LDKPhantomRouteHints *NONNULL_PTR this_ptr, struct LDKCVec_ChannelDetailsZ val);
/* @internal */
export function PhantomRouteHints_set_channels(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PhantomRouteHints_set_channels(this_ptr, val);
	// debug statements here
}
	// uint64_t PhantomRouteHints_get_phantom_scid(const struct LDKPhantomRouteHints *NONNULL_PTR this_ptr);
/* @internal */
export function PhantomRouteHints_get_phantom_scid(this_ptr: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PhantomRouteHints_get_phantom_scid(this_ptr);
	return nativeResponseValue;
}
	// void PhantomRouteHints_set_phantom_scid(struct LDKPhantomRouteHints *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function PhantomRouteHints_set_phantom_scid(this_ptr: number, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PhantomRouteHints_set_phantom_scid(this_ptr, val);
	// debug statements here
}
	// struct LDKPublicKey PhantomRouteHints_get_real_node_pubkey(const struct LDKPhantomRouteHints *NONNULL_PTR this_ptr);
/* @internal */
export function PhantomRouteHints_get_real_node_pubkey(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PhantomRouteHints_get_real_node_pubkey(this_ptr);
	return nativeResponseValue;
}
	// void PhantomRouteHints_set_real_node_pubkey(struct LDKPhantomRouteHints *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */
export function PhantomRouteHints_set_real_node_pubkey(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PhantomRouteHints_set_real_node_pubkey(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKPhantomRouteHints PhantomRouteHints_new(struct LDKCVec_ChannelDetailsZ channels_arg, uint64_t phantom_scid_arg, struct LDKPublicKey real_node_pubkey_arg);
/* @internal */
export function PhantomRouteHints_new(channels_arg: number, phantom_scid_arg: bigint, real_node_pubkey_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PhantomRouteHints_new(channels_arg, phantom_scid_arg, real_node_pubkey_arg);
	return nativeResponseValue;
}
	// uintptr_t PhantomRouteHints_clone_ptr(LDKPhantomRouteHints *NONNULL_PTR arg);
/* @internal */
export function PhantomRouteHints_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PhantomRouteHints_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKPhantomRouteHints PhantomRouteHints_clone(const struct LDKPhantomRouteHints *NONNULL_PTR orig);
/* @internal */
export function PhantomRouteHints_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PhantomRouteHints_clone(orig);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKChannelManager ChannelManager_new(struct LDKFeeEstimator fee_est, struct LDKWatch chain_monitor, struct LDKBroadcasterInterface tx_broadcaster, struct LDKLogger logger, struct LDKKeysInterface keys_manager, struct LDKUserConfig config, struct LDKChainParameters params);
/* @internal */
export function ChannelManager_new(fee_est: number, chain_monitor: number, tx_broadcaster: number, logger: number, keys_manager: number, config: number, params: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManager_new(fee_est, chain_monitor, tx_broadcaster, logger, keys_manager, config, params);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKUserConfig ChannelManager_get_current_default_configuration(const struct LDKChannelManager *NONNULL_PTR this_arg);
/* @internal */
export function ChannelManager_get_current_default_configuration(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManager_get_current_default_configuration(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult__u832APIErrorZ ChannelManager_create_channel(const struct LDKChannelManager *NONNULL_PTR this_arg, struct LDKPublicKey their_network_key, uint64_t channel_value_satoshis, uint64_t push_msat, uint64_t user_channel_id, struct LDKUserConfig override_config);
/* @internal */
export function ChannelManager_create_channel(this_arg: number, their_network_key: number, channel_value_satoshis: bigint, push_msat: bigint, user_channel_id: bigint, override_config: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManager_create_channel(this_arg, their_network_key, channel_value_satoshis, push_msat, user_channel_id, override_config);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCVec_ChannelDetailsZ ChannelManager_list_channels(const struct LDKChannelManager *NONNULL_PTR this_arg);
/* @internal */
export function ChannelManager_list_channels(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManager_list_channels(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCVec_ChannelDetailsZ ChannelManager_list_usable_channels(const struct LDKChannelManager *NONNULL_PTR this_arg);
/* @internal */
export function ChannelManager_list_usable_channels(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManager_list_usable_channels(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_NoneAPIErrorZ ChannelManager_close_channel(const struct LDKChannelManager *NONNULL_PTR this_arg, const uint8_t (*channel_id)[32]);
/* @internal */
export function ChannelManager_close_channel(this_arg: number, channel_id: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManager_close_channel(this_arg, channel_id);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_NoneAPIErrorZ ChannelManager_close_channel_with_target_feerate(const struct LDKChannelManager *NONNULL_PTR this_arg, const uint8_t (*channel_id)[32], uint32_t target_feerate_sats_per_1000_weight);
/* @internal */
export function ChannelManager_close_channel_with_target_feerate(this_arg: number, channel_id: number, target_feerate_sats_per_1000_weight: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManager_close_channel_with_target_feerate(this_arg, channel_id, target_feerate_sats_per_1000_weight);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_NoneAPIErrorZ ChannelManager_force_close_channel(const struct LDKChannelManager *NONNULL_PTR this_arg, const uint8_t (*channel_id)[32]);
/* @internal */
export function ChannelManager_force_close_channel(this_arg: number, channel_id: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManager_force_close_channel(this_arg, channel_id);
	return nativeResponseValue;
}
	// void ChannelManager_force_close_all_channels(const struct LDKChannelManager *NONNULL_PTR this_arg);
/* @internal */
export function ChannelManager_force_close_all_channels(this_arg: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManager_force_close_all_channels(this_arg);
	// debug statements here
}
	// MUST_USE_RES struct LDKCResult_PaymentIdPaymentSendFailureZ ChannelManager_send_payment(const struct LDKChannelManager *NONNULL_PTR this_arg, const struct LDKRoute *NONNULL_PTR route, struct LDKThirtyTwoBytes payment_hash, struct LDKThirtyTwoBytes payment_secret);
/* @internal */
export function ChannelManager_send_payment(this_arg: number, route: number, payment_hash: number, payment_secret: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManager_send_payment(this_arg, route, payment_hash, payment_secret);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_NonePaymentSendFailureZ ChannelManager_retry_payment(const struct LDKChannelManager *NONNULL_PTR this_arg, const struct LDKRoute *NONNULL_PTR route, struct LDKThirtyTwoBytes payment_id);
/* @internal */
export function ChannelManager_retry_payment(this_arg: number, route: number, payment_id: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManager_retry_payment(this_arg, route, payment_id);
	return nativeResponseValue;
}
	// void ChannelManager_abandon_payment(const struct LDKChannelManager *NONNULL_PTR this_arg, struct LDKThirtyTwoBytes payment_id);
/* @internal */
export function ChannelManager_abandon_payment(this_arg: number, payment_id: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManager_abandon_payment(this_arg, payment_id);
	// debug statements here
}
	// MUST_USE_RES struct LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ ChannelManager_send_spontaneous_payment(const struct LDKChannelManager *NONNULL_PTR this_arg, const struct LDKRoute *NONNULL_PTR route, struct LDKThirtyTwoBytes payment_preimage);
/* @internal */
export function ChannelManager_send_spontaneous_payment(this_arg: number, route: number, payment_preimage: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManager_send_spontaneous_payment(this_arg, route, payment_preimage);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_NoneAPIErrorZ ChannelManager_funding_transaction_generated(const struct LDKChannelManager *NONNULL_PTR this_arg, const uint8_t (*temporary_channel_id)[32], struct LDKTransaction funding_transaction);
/* @internal */
export function ChannelManager_funding_transaction_generated(this_arg: number, temporary_channel_id: number, funding_transaction: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManager_funding_transaction_generated(this_arg, temporary_channel_id, funding_transaction);
	return nativeResponseValue;
}
	// void ChannelManager_broadcast_node_announcement(const struct LDKChannelManager *NONNULL_PTR this_arg, struct LDKThreeBytes rgb, struct LDKThirtyTwoBytes alias, struct LDKCVec_NetAddressZ addresses);
/* @internal */
export function ChannelManager_broadcast_node_announcement(this_arg: number, rgb: number, alias: number, addresses: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManager_broadcast_node_announcement(this_arg, rgb, alias, addresses);
	// debug statements here
}
	// void ChannelManager_process_pending_htlc_forwards(const struct LDKChannelManager *NONNULL_PTR this_arg);
/* @internal */
export function ChannelManager_process_pending_htlc_forwards(this_arg: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManager_process_pending_htlc_forwards(this_arg);
	// debug statements here
}
	// void ChannelManager_timer_tick_occurred(const struct LDKChannelManager *NONNULL_PTR this_arg);
/* @internal */
export function ChannelManager_timer_tick_occurred(this_arg: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManager_timer_tick_occurred(this_arg);
	// debug statements here
}
	// MUST_USE_RES bool ChannelManager_fail_htlc_backwards(const struct LDKChannelManager *NONNULL_PTR this_arg, const uint8_t (*payment_hash)[32]);
/* @internal */
export function ChannelManager_fail_htlc_backwards(this_arg: number, payment_hash: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManager_fail_htlc_backwards(this_arg, payment_hash);
	return nativeResponseValue;
}
	// MUST_USE_RES bool ChannelManager_claim_funds(const struct LDKChannelManager *NONNULL_PTR this_arg, struct LDKThirtyTwoBytes payment_preimage);
/* @internal */
export function ChannelManager_claim_funds(this_arg: number, payment_preimage: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManager_claim_funds(this_arg, payment_preimage);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKPublicKey ChannelManager_get_our_node_id(const struct LDKChannelManager *NONNULL_PTR this_arg);
/* @internal */
export function ChannelManager_get_our_node_id(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManager_get_our_node_id(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_NoneAPIErrorZ ChannelManager_accept_inbound_channel(const struct LDKChannelManager *NONNULL_PTR this_arg, const uint8_t (*temporary_channel_id)[32], uint64_t user_channel_id);
/* @internal */
export function ChannelManager_accept_inbound_channel(this_arg: number, temporary_channel_id: number, user_channel_id: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManager_accept_inbound_channel(this_arg, temporary_channel_id, user_channel_id);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_C2Tuple_PaymentHashPaymentSecretZNoneZ ChannelManager_create_inbound_payment(const struct LDKChannelManager *NONNULL_PTR this_arg, struct LDKCOption_u64Z min_value_msat, uint32_t invoice_expiry_delta_secs);
/* @internal */
export function ChannelManager_create_inbound_payment(this_arg: number, min_value_msat: number, invoice_expiry_delta_secs: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManager_create_inbound_payment(this_arg, min_value_msat, invoice_expiry_delta_secs);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_C2Tuple_PaymentHashPaymentSecretZAPIErrorZ ChannelManager_create_inbound_payment_legacy(const struct LDKChannelManager *NONNULL_PTR this_arg, struct LDKCOption_u64Z min_value_msat, uint32_t invoice_expiry_delta_secs);
/* @internal */
export function ChannelManager_create_inbound_payment_legacy(this_arg: number, min_value_msat: number, invoice_expiry_delta_secs: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManager_create_inbound_payment_legacy(this_arg, min_value_msat, invoice_expiry_delta_secs);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_PaymentSecretNoneZ ChannelManager_create_inbound_payment_for_hash(const struct LDKChannelManager *NONNULL_PTR this_arg, struct LDKThirtyTwoBytes payment_hash, struct LDKCOption_u64Z min_value_msat, uint32_t invoice_expiry_delta_secs);
/* @internal */
export function ChannelManager_create_inbound_payment_for_hash(this_arg: number, payment_hash: number, min_value_msat: number, invoice_expiry_delta_secs: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManager_create_inbound_payment_for_hash(this_arg, payment_hash, min_value_msat, invoice_expiry_delta_secs);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_PaymentSecretAPIErrorZ ChannelManager_create_inbound_payment_for_hash_legacy(const struct LDKChannelManager *NONNULL_PTR this_arg, struct LDKThirtyTwoBytes payment_hash, struct LDKCOption_u64Z min_value_msat, uint32_t invoice_expiry_delta_secs);
/* @internal */
export function ChannelManager_create_inbound_payment_for_hash_legacy(this_arg: number, payment_hash: number, min_value_msat: number, invoice_expiry_delta_secs: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManager_create_inbound_payment_for_hash_legacy(this_arg, payment_hash, min_value_msat, invoice_expiry_delta_secs);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_PaymentPreimageAPIErrorZ ChannelManager_get_payment_preimage(const struct LDKChannelManager *NONNULL_PTR this_arg, struct LDKThirtyTwoBytes payment_hash, struct LDKThirtyTwoBytes payment_secret);
/* @internal */
export function ChannelManager_get_payment_preimage(this_arg: number, payment_hash: number, payment_secret: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManager_get_payment_preimage(this_arg, payment_hash, payment_secret);
	return nativeResponseValue;
}
	// MUST_USE_RES uint64_t ChannelManager_get_phantom_scid(const struct LDKChannelManager *NONNULL_PTR this_arg);
/* @internal */
export function ChannelManager_get_phantom_scid(this_arg: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManager_get_phantom_scid(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKPhantomRouteHints ChannelManager_get_phantom_route_hints(const struct LDKChannelManager *NONNULL_PTR this_arg);
/* @internal */
export function ChannelManager_get_phantom_route_hints(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManager_get_phantom_route_hints(this_arg);
	return nativeResponseValue;
}
	// struct LDKMessageSendEventsProvider ChannelManager_as_MessageSendEventsProvider(const struct LDKChannelManager *NONNULL_PTR this_arg);
/* @internal */
export function ChannelManager_as_MessageSendEventsProvider(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManager_as_MessageSendEventsProvider(this_arg);
	return nativeResponseValue;
}
	// struct LDKEventsProvider ChannelManager_as_EventsProvider(const struct LDKChannelManager *NONNULL_PTR this_arg);
/* @internal */
export function ChannelManager_as_EventsProvider(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManager_as_EventsProvider(this_arg);
	return nativeResponseValue;
}
	// struct LDKListen ChannelManager_as_Listen(const struct LDKChannelManager *NONNULL_PTR this_arg);
/* @internal */
export function ChannelManager_as_Listen(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManager_as_Listen(this_arg);
	return nativeResponseValue;
}
	// struct LDKConfirm ChannelManager_as_Confirm(const struct LDKChannelManager *NONNULL_PTR this_arg);
/* @internal */
export function ChannelManager_as_Confirm(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManager_as_Confirm(this_arg);
	return nativeResponseValue;
}
	// void ChannelManager_await_persistable_update(const struct LDKChannelManager *NONNULL_PTR this_arg);
/* @internal */
export function ChannelManager_await_persistable_update(this_arg: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManager_await_persistable_update(this_arg);
	// debug statements here
}
	// MUST_USE_RES struct LDKBestBlock ChannelManager_current_best_block(const struct LDKChannelManager *NONNULL_PTR this_arg);
/* @internal */
export function ChannelManager_current_best_block(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManager_current_best_block(this_arg);
	return nativeResponseValue;
}
	// struct LDKChannelMessageHandler ChannelManager_as_ChannelMessageHandler(const struct LDKChannelManager *NONNULL_PTR this_arg);
/* @internal */
export function ChannelManager_as_ChannelMessageHandler(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManager_as_ChannelMessageHandler(this_arg);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z CounterpartyForwardingInfo_write(const struct LDKCounterpartyForwardingInfo *NONNULL_PTR obj);
/* @internal */
export function CounterpartyForwardingInfo_write(obj: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CounterpartyForwardingInfo_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_CounterpartyForwardingInfoDecodeErrorZ CounterpartyForwardingInfo_read(struct LDKu8slice ser);
/* @internal */
export function CounterpartyForwardingInfo_read(ser: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CounterpartyForwardingInfo_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z ChannelCounterparty_write(const struct LDKChannelCounterparty *NONNULL_PTR obj);
/* @internal */
export function ChannelCounterparty_write(obj: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelCounterparty_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelCounterpartyDecodeErrorZ ChannelCounterparty_read(struct LDKu8slice ser);
/* @internal */
export function ChannelCounterparty_read(ser: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelCounterparty_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z ChannelDetails_write(const struct LDKChannelDetails *NONNULL_PTR obj);
/* @internal */
export function ChannelDetails_write(obj: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelDetailsDecodeErrorZ ChannelDetails_read(struct LDKu8slice ser);
/* @internal */
export function ChannelDetails_read(ser: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelDetails_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z PhantomRouteHints_write(const struct LDKPhantomRouteHints *NONNULL_PTR obj);
/* @internal */
export function PhantomRouteHints_write(obj: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PhantomRouteHints_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_PhantomRouteHintsDecodeErrorZ PhantomRouteHints_read(struct LDKu8slice ser);
/* @internal */
export function PhantomRouteHints_read(ser: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PhantomRouteHints_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z ChannelManager_write(const struct LDKChannelManager *NONNULL_PTR obj);
/* @internal */
export function ChannelManager_write(obj: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManager_write(obj);
	return nativeResponseValue;
}
	// void ChannelManagerReadArgs_free(struct LDKChannelManagerReadArgs this_obj);
/* @internal */
export function ChannelManagerReadArgs_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManagerReadArgs_free(this_obj);
	// debug statements here
}
	// const struct LDKKeysInterface *ChannelManagerReadArgs_get_keys_manager(const struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelManagerReadArgs_get_keys_manager(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManagerReadArgs_get_keys_manager(this_ptr);
	return nativeResponseValue;
}
	// void ChannelManagerReadArgs_set_keys_manager(struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr, struct LDKKeysInterface val);
/* @internal */
export function ChannelManagerReadArgs_set_keys_manager(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManagerReadArgs_set_keys_manager(this_ptr, val);
	// debug statements here
}
	// const struct LDKFeeEstimator *ChannelManagerReadArgs_get_fee_estimator(const struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelManagerReadArgs_get_fee_estimator(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManagerReadArgs_get_fee_estimator(this_ptr);
	return nativeResponseValue;
}
	// void ChannelManagerReadArgs_set_fee_estimator(struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr, struct LDKFeeEstimator val);
/* @internal */
export function ChannelManagerReadArgs_set_fee_estimator(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManagerReadArgs_set_fee_estimator(this_ptr, val);
	// debug statements here
}
	// const struct LDKWatch *ChannelManagerReadArgs_get_chain_monitor(const struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelManagerReadArgs_get_chain_monitor(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManagerReadArgs_get_chain_monitor(this_ptr);
	return nativeResponseValue;
}
	// void ChannelManagerReadArgs_set_chain_monitor(struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr, struct LDKWatch val);
/* @internal */
export function ChannelManagerReadArgs_set_chain_monitor(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManagerReadArgs_set_chain_monitor(this_ptr, val);
	// debug statements here
}
	// const struct LDKBroadcasterInterface *ChannelManagerReadArgs_get_tx_broadcaster(const struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelManagerReadArgs_get_tx_broadcaster(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManagerReadArgs_get_tx_broadcaster(this_ptr);
	return nativeResponseValue;
}
	// void ChannelManagerReadArgs_set_tx_broadcaster(struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr, struct LDKBroadcasterInterface val);
/* @internal */
export function ChannelManagerReadArgs_set_tx_broadcaster(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManagerReadArgs_set_tx_broadcaster(this_ptr, val);
	// debug statements here
}
	// const struct LDKLogger *ChannelManagerReadArgs_get_logger(const struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelManagerReadArgs_get_logger(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManagerReadArgs_get_logger(this_ptr);
	return nativeResponseValue;
}
	// void ChannelManagerReadArgs_set_logger(struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr, struct LDKLogger val);
/* @internal */
export function ChannelManagerReadArgs_set_logger(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManagerReadArgs_set_logger(this_ptr, val);
	// debug statements here
}
	// struct LDKUserConfig ChannelManagerReadArgs_get_default_config(const struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelManagerReadArgs_get_default_config(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManagerReadArgs_get_default_config(this_ptr);
	return nativeResponseValue;
}
	// void ChannelManagerReadArgs_set_default_config(struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr, struct LDKUserConfig val);
/* @internal */
export function ChannelManagerReadArgs_set_default_config(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManagerReadArgs_set_default_config(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKChannelManagerReadArgs ChannelManagerReadArgs_new(struct LDKKeysInterface keys_manager, struct LDKFeeEstimator fee_estimator, struct LDKWatch chain_monitor, struct LDKBroadcasterInterface tx_broadcaster, struct LDKLogger logger, struct LDKUserConfig default_config, struct LDKCVec_ChannelMonitorZ channel_monitors);
/* @internal */
export function ChannelManagerReadArgs_new(keys_manager: number, fee_estimator: number, chain_monitor: number, tx_broadcaster: number, logger: number, default_config: number, channel_monitors: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManagerReadArgs_new(keys_manager, fee_estimator, chain_monitor, tx_broadcaster, logger, default_config, channel_monitors);
	return nativeResponseValue;
}
	// struct LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ C2Tuple_BlockHashChannelManagerZ_read(struct LDKu8slice ser, struct LDKChannelManagerReadArgs arg);
/* @internal */
export function C2Tuple_BlockHashChannelManagerZ_read(ser: number, arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_C2Tuple_BlockHashChannelManagerZ_read(ser, arg);
	return nativeResponseValue;
}
	// void DecodeError_free(struct LDKDecodeError this_obj);
/* @internal */
export function DecodeError_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DecodeError_free(this_obj);
	// debug statements here
}
	// uintptr_t DecodeError_clone_ptr(LDKDecodeError *NONNULL_PTR arg);
/* @internal */
export function DecodeError_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DecodeError_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKDecodeError DecodeError_clone(const struct LDKDecodeError *NONNULL_PTR orig);
/* @internal */
export function DecodeError_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DecodeError_clone(orig);
	return nativeResponseValue;
}
	// void Init_free(struct LDKInit this_obj);
/* @internal */
export function Init_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Init_free(this_obj);
	// debug statements here
}
	// struct LDKInitFeatures Init_get_features(const struct LDKInit *NONNULL_PTR this_ptr);
/* @internal */
export function Init_get_features(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Init_get_features(this_ptr);
	return nativeResponseValue;
}
	// void Init_set_features(struct LDKInit *NONNULL_PTR this_ptr, struct LDKInitFeatures val);
/* @internal */
export function Init_set_features(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Init_set_features(this_ptr, val);
	// debug statements here
}
	// struct LDKCOption_NetAddressZ Init_get_remote_network_address(const struct LDKInit *NONNULL_PTR this_ptr);
/* @internal */
export function Init_get_remote_network_address(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Init_get_remote_network_address(this_ptr);
	return nativeResponseValue;
}
	// void Init_set_remote_network_address(struct LDKInit *NONNULL_PTR this_ptr, struct LDKCOption_NetAddressZ val);
/* @internal */
export function Init_set_remote_network_address(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Init_set_remote_network_address(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKInit Init_new(struct LDKInitFeatures features_arg, struct LDKCOption_NetAddressZ remote_network_address_arg);
/* @internal */
export function Init_new(features_arg: number, remote_network_address_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Init_new(features_arg, remote_network_address_arg);
	return nativeResponseValue;
}
	// uintptr_t Init_clone_ptr(LDKInit *NONNULL_PTR arg);
/* @internal */
export function Init_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Init_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKInit Init_clone(const struct LDKInit *NONNULL_PTR orig);
/* @internal */
export function Init_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Init_clone(orig);
	return nativeResponseValue;
}
	// void ErrorMessage_free(struct LDKErrorMessage this_obj);
/* @internal */
export function ErrorMessage_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ErrorMessage_free(this_obj);
	// debug statements here
}
	// const uint8_t (*ErrorMessage_get_channel_id(const struct LDKErrorMessage *NONNULL_PTR this_ptr))[32];
/* @internal */
export function ErrorMessage_get_channel_id(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ErrorMessage_get_channel_id(this_ptr);
	return nativeResponseValue;
}
	// void ErrorMessage_set_channel_id(struct LDKErrorMessage *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function ErrorMessage_set_channel_id(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ErrorMessage_set_channel_id(this_ptr, val);
	// debug statements here
}
	// struct LDKStr ErrorMessage_get_data(const struct LDKErrorMessage *NONNULL_PTR this_ptr);
/* @internal */
export function ErrorMessage_get_data(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ErrorMessage_get_data(this_ptr);
	return nativeResponseValue;
}
	// void ErrorMessage_set_data(struct LDKErrorMessage *NONNULL_PTR this_ptr, struct LDKStr val);
/* @internal */
export function ErrorMessage_set_data(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ErrorMessage_set_data(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKErrorMessage ErrorMessage_new(struct LDKThirtyTwoBytes channel_id_arg, struct LDKStr data_arg);
/* @internal */
export function ErrorMessage_new(channel_id_arg: number, data_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ErrorMessage_new(channel_id_arg, data_arg);
	return nativeResponseValue;
}
	// uintptr_t ErrorMessage_clone_ptr(LDKErrorMessage *NONNULL_PTR arg);
/* @internal */
export function ErrorMessage_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ErrorMessage_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKErrorMessage ErrorMessage_clone(const struct LDKErrorMessage *NONNULL_PTR orig);
/* @internal */
export function ErrorMessage_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ErrorMessage_clone(orig);
	return nativeResponseValue;
}
	// void WarningMessage_free(struct LDKWarningMessage this_obj);
/* @internal */
export function WarningMessage_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_WarningMessage_free(this_obj);
	// debug statements here
}
	// const uint8_t (*WarningMessage_get_channel_id(const struct LDKWarningMessage *NONNULL_PTR this_ptr))[32];
/* @internal */
export function WarningMessage_get_channel_id(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_WarningMessage_get_channel_id(this_ptr);
	return nativeResponseValue;
}
	// void WarningMessage_set_channel_id(struct LDKWarningMessage *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function WarningMessage_set_channel_id(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_WarningMessage_set_channel_id(this_ptr, val);
	// debug statements here
}
	// struct LDKStr WarningMessage_get_data(const struct LDKWarningMessage *NONNULL_PTR this_ptr);
/* @internal */
export function WarningMessage_get_data(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_WarningMessage_get_data(this_ptr);
	return nativeResponseValue;
}
	// void WarningMessage_set_data(struct LDKWarningMessage *NONNULL_PTR this_ptr, struct LDKStr val);
/* @internal */
export function WarningMessage_set_data(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_WarningMessage_set_data(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKWarningMessage WarningMessage_new(struct LDKThirtyTwoBytes channel_id_arg, struct LDKStr data_arg);
/* @internal */
export function WarningMessage_new(channel_id_arg: number, data_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_WarningMessage_new(channel_id_arg, data_arg);
	return nativeResponseValue;
}
	// uintptr_t WarningMessage_clone_ptr(LDKWarningMessage *NONNULL_PTR arg);
/* @internal */
export function WarningMessage_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_WarningMessage_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKWarningMessage WarningMessage_clone(const struct LDKWarningMessage *NONNULL_PTR orig);
/* @internal */
export function WarningMessage_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_WarningMessage_clone(orig);
	return nativeResponseValue;
}
	// void Ping_free(struct LDKPing this_obj);
/* @internal */
export function Ping_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Ping_free(this_obj);
	// debug statements here
}
	// uint16_t Ping_get_ponglen(const struct LDKPing *NONNULL_PTR this_ptr);
/* @internal */
export function Ping_get_ponglen(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Ping_get_ponglen(this_ptr);
	return nativeResponseValue;
}
	// void Ping_set_ponglen(struct LDKPing *NONNULL_PTR this_ptr, uint16_t val);
/* @internal */
export function Ping_set_ponglen(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Ping_set_ponglen(this_ptr, val);
	// debug statements here
}
	// uint16_t Ping_get_byteslen(const struct LDKPing *NONNULL_PTR this_ptr);
/* @internal */
export function Ping_get_byteslen(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Ping_get_byteslen(this_ptr);
	return nativeResponseValue;
}
	// void Ping_set_byteslen(struct LDKPing *NONNULL_PTR this_ptr, uint16_t val);
/* @internal */
export function Ping_set_byteslen(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Ping_set_byteslen(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKPing Ping_new(uint16_t ponglen_arg, uint16_t byteslen_arg);
/* @internal */
export function Ping_new(ponglen_arg: number, byteslen_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Ping_new(ponglen_arg, byteslen_arg);
	return nativeResponseValue;
}
	// uintptr_t Ping_clone_ptr(LDKPing *NONNULL_PTR arg);
/* @internal */
export function Ping_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Ping_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKPing Ping_clone(const struct LDKPing *NONNULL_PTR orig);
/* @internal */
export function Ping_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Ping_clone(orig);
	return nativeResponseValue;
}
	// void Pong_free(struct LDKPong this_obj);
/* @internal */
export function Pong_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Pong_free(this_obj);
	// debug statements here
}
	// uint16_t Pong_get_byteslen(const struct LDKPong *NONNULL_PTR this_ptr);
/* @internal */
export function Pong_get_byteslen(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Pong_get_byteslen(this_ptr);
	return nativeResponseValue;
}
	// void Pong_set_byteslen(struct LDKPong *NONNULL_PTR this_ptr, uint16_t val);
/* @internal */
export function Pong_set_byteslen(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Pong_set_byteslen(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKPong Pong_new(uint16_t byteslen_arg);
/* @internal */
export function Pong_new(byteslen_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Pong_new(byteslen_arg);
	return nativeResponseValue;
}
	// uintptr_t Pong_clone_ptr(LDKPong *NONNULL_PTR arg);
/* @internal */
export function Pong_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Pong_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKPong Pong_clone(const struct LDKPong *NONNULL_PTR orig);
/* @internal */
export function Pong_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Pong_clone(orig);
	return nativeResponseValue;
}
	// void OpenChannel_free(struct LDKOpenChannel this_obj);
/* @internal */
export function OpenChannel_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannel_free(this_obj);
	// debug statements here
}
	// const uint8_t (*OpenChannel_get_chain_hash(const struct LDKOpenChannel *NONNULL_PTR this_ptr))[32];
/* @internal */
export function OpenChannel_get_chain_hash(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannel_get_chain_hash(this_ptr);
	return nativeResponseValue;
}
	// void OpenChannel_set_chain_hash(struct LDKOpenChannel *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function OpenChannel_set_chain_hash(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannel_set_chain_hash(this_ptr, val);
	// debug statements here
}
	// const uint8_t (*OpenChannel_get_temporary_channel_id(const struct LDKOpenChannel *NONNULL_PTR this_ptr))[32];
/* @internal */
export function OpenChannel_get_temporary_channel_id(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannel_get_temporary_channel_id(this_ptr);
	return nativeResponseValue;
}
	// void OpenChannel_set_temporary_channel_id(struct LDKOpenChannel *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function OpenChannel_set_temporary_channel_id(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannel_set_temporary_channel_id(this_ptr, val);
	// debug statements here
}
	// uint64_t OpenChannel_get_funding_satoshis(const struct LDKOpenChannel *NONNULL_PTR this_ptr);
/* @internal */
export function OpenChannel_get_funding_satoshis(this_ptr: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannel_get_funding_satoshis(this_ptr);
	return nativeResponseValue;
}
	// void OpenChannel_set_funding_satoshis(struct LDKOpenChannel *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function OpenChannel_set_funding_satoshis(this_ptr: number, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannel_set_funding_satoshis(this_ptr, val);
	// debug statements here
}
	// uint64_t OpenChannel_get_push_msat(const struct LDKOpenChannel *NONNULL_PTR this_ptr);
/* @internal */
export function OpenChannel_get_push_msat(this_ptr: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannel_get_push_msat(this_ptr);
	return nativeResponseValue;
}
	// void OpenChannel_set_push_msat(struct LDKOpenChannel *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function OpenChannel_set_push_msat(this_ptr: number, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannel_set_push_msat(this_ptr, val);
	// debug statements here
}
	// uint64_t OpenChannel_get_dust_limit_satoshis(const struct LDKOpenChannel *NONNULL_PTR this_ptr);
/* @internal */
export function OpenChannel_get_dust_limit_satoshis(this_ptr: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannel_get_dust_limit_satoshis(this_ptr);
	return nativeResponseValue;
}
	// void OpenChannel_set_dust_limit_satoshis(struct LDKOpenChannel *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function OpenChannel_set_dust_limit_satoshis(this_ptr: number, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannel_set_dust_limit_satoshis(this_ptr, val);
	// debug statements here
}
	// uint64_t OpenChannel_get_max_htlc_value_in_flight_msat(const struct LDKOpenChannel *NONNULL_PTR this_ptr);
/* @internal */
export function OpenChannel_get_max_htlc_value_in_flight_msat(this_ptr: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannel_get_max_htlc_value_in_flight_msat(this_ptr);
	return nativeResponseValue;
}
	// void OpenChannel_set_max_htlc_value_in_flight_msat(struct LDKOpenChannel *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function OpenChannel_set_max_htlc_value_in_flight_msat(this_ptr: number, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannel_set_max_htlc_value_in_flight_msat(this_ptr, val);
	// debug statements here
}
	// uint64_t OpenChannel_get_channel_reserve_satoshis(const struct LDKOpenChannel *NONNULL_PTR this_ptr);
/* @internal */
export function OpenChannel_get_channel_reserve_satoshis(this_ptr: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannel_get_channel_reserve_satoshis(this_ptr);
	return nativeResponseValue;
}
	// void OpenChannel_set_channel_reserve_satoshis(struct LDKOpenChannel *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function OpenChannel_set_channel_reserve_satoshis(this_ptr: number, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannel_set_channel_reserve_satoshis(this_ptr, val);
	// debug statements here
}
	// uint64_t OpenChannel_get_htlc_minimum_msat(const struct LDKOpenChannel *NONNULL_PTR this_ptr);
/* @internal */
export function OpenChannel_get_htlc_minimum_msat(this_ptr: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannel_get_htlc_minimum_msat(this_ptr);
	return nativeResponseValue;
}
	// void OpenChannel_set_htlc_minimum_msat(struct LDKOpenChannel *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function OpenChannel_set_htlc_minimum_msat(this_ptr: number, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannel_set_htlc_minimum_msat(this_ptr, val);
	// debug statements here
}
	// uint32_t OpenChannel_get_feerate_per_kw(const struct LDKOpenChannel *NONNULL_PTR this_ptr);
/* @internal */
export function OpenChannel_get_feerate_per_kw(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannel_get_feerate_per_kw(this_ptr);
	return nativeResponseValue;
}
	// void OpenChannel_set_feerate_per_kw(struct LDKOpenChannel *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */
export function OpenChannel_set_feerate_per_kw(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannel_set_feerate_per_kw(this_ptr, val);
	// debug statements here
}
	// uint16_t OpenChannel_get_to_self_delay(const struct LDKOpenChannel *NONNULL_PTR this_ptr);
/* @internal */
export function OpenChannel_get_to_self_delay(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannel_get_to_self_delay(this_ptr);
	return nativeResponseValue;
}
	// void OpenChannel_set_to_self_delay(struct LDKOpenChannel *NONNULL_PTR this_ptr, uint16_t val);
/* @internal */
export function OpenChannel_set_to_self_delay(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannel_set_to_self_delay(this_ptr, val);
	// debug statements here
}
	// uint16_t OpenChannel_get_max_accepted_htlcs(const struct LDKOpenChannel *NONNULL_PTR this_ptr);
/* @internal */
export function OpenChannel_get_max_accepted_htlcs(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannel_get_max_accepted_htlcs(this_ptr);
	return nativeResponseValue;
}
	// void OpenChannel_set_max_accepted_htlcs(struct LDKOpenChannel *NONNULL_PTR this_ptr, uint16_t val);
/* @internal */
export function OpenChannel_set_max_accepted_htlcs(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannel_set_max_accepted_htlcs(this_ptr, val);
	// debug statements here
}
	// struct LDKPublicKey OpenChannel_get_funding_pubkey(const struct LDKOpenChannel *NONNULL_PTR this_ptr);
/* @internal */
export function OpenChannel_get_funding_pubkey(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannel_get_funding_pubkey(this_ptr);
	return nativeResponseValue;
}
	// void OpenChannel_set_funding_pubkey(struct LDKOpenChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */
export function OpenChannel_set_funding_pubkey(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannel_set_funding_pubkey(this_ptr, val);
	// debug statements here
}
	// struct LDKPublicKey OpenChannel_get_revocation_basepoint(const struct LDKOpenChannel *NONNULL_PTR this_ptr);
/* @internal */
export function OpenChannel_get_revocation_basepoint(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannel_get_revocation_basepoint(this_ptr);
	return nativeResponseValue;
}
	// void OpenChannel_set_revocation_basepoint(struct LDKOpenChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */
export function OpenChannel_set_revocation_basepoint(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannel_set_revocation_basepoint(this_ptr, val);
	// debug statements here
}
	// struct LDKPublicKey OpenChannel_get_payment_point(const struct LDKOpenChannel *NONNULL_PTR this_ptr);
/* @internal */
export function OpenChannel_get_payment_point(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannel_get_payment_point(this_ptr);
	return nativeResponseValue;
}
	// void OpenChannel_set_payment_point(struct LDKOpenChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */
export function OpenChannel_set_payment_point(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannel_set_payment_point(this_ptr, val);
	// debug statements here
}
	// struct LDKPublicKey OpenChannel_get_delayed_payment_basepoint(const struct LDKOpenChannel *NONNULL_PTR this_ptr);
/* @internal */
export function OpenChannel_get_delayed_payment_basepoint(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannel_get_delayed_payment_basepoint(this_ptr);
	return nativeResponseValue;
}
	// void OpenChannel_set_delayed_payment_basepoint(struct LDKOpenChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */
export function OpenChannel_set_delayed_payment_basepoint(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannel_set_delayed_payment_basepoint(this_ptr, val);
	// debug statements here
}
	// struct LDKPublicKey OpenChannel_get_htlc_basepoint(const struct LDKOpenChannel *NONNULL_PTR this_ptr);
/* @internal */
export function OpenChannel_get_htlc_basepoint(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannel_get_htlc_basepoint(this_ptr);
	return nativeResponseValue;
}
	// void OpenChannel_set_htlc_basepoint(struct LDKOpenChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */
export function OpenChannel_set_htlc_basepoint(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannel_set_htlc_basepoint(this_ptr, val);
	// debug statements here
}
	// struct LDKPublicKey OpenChannel_get_first_per_commitment_point(const struct LDKOpenChannel *NONNULL_PTR this_ptr);
/* @internal */
export function OpenChannel_get_first_per_commitment_point(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannel_get_first_per_commitment_point(this_ptr);
	return nativeResponseValue;
}
	// void OpenChannel_set_first_per_commitment_point(struct LDKOpenChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */
export function OpenChannel_set_first_per_commitment_point(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannel_set_first_per_commitment_point(this_ptr, val);
	// debug statements here
}
	// uint8_t OpenChannel_get_channel_flags(const struct LDKOpenChannel *NONNULL_PTR this_ptr);
/* @internal */
export function OpenChannel_get_channel_flags(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannel_get_channel_flags(this_ptr);
	return nativeResponseValue;
}
	// void OpenChannel_set_channel_flags(struct LDKOpenChannel *NONNULL_PTR this_ptr, uint8_t val);
/* @internal */
export function OpenChannel_set_channel_flags(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannel_set_channel_flags(this_ptr, val);
	// debug statements here
}
	// struct LDKChannelTypeFeatures OpenChannel_get_channel_type(const struct LDKOpenChannel *NONNULL_PTR this_ptr);
/* @internal */
export function OpenChannel_get_channel_type(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannel_get_channel_type(this_ptr);
	return nativeResponseValue;
}
	// void OpenChannel_set_channel_type(struct LDKOpenChannel *NONNULL_PTR this_ptr, struct LDKChannelTypeFeatures val);
/* @internal */
export function OpenChannel_set_channel_type(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannel_set_channel_type(this_ptr, val);
	// debug statements here
}
	// uintptr_t OpenChannel_clone_ptr(LDKOpenChannel *NONNULL_PTR arg);
/* @internal */
export function OpenChannel_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannel_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKOpenChannel OpenChannel_clone(const struct LDKOpenChannel *NONNULL_PTR orig);
/* @internal */
export function OpenChannel_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannel_clone(orig);
	return nativeResponseValue;
}
	// void AcceptChannel_free(struct LDKAcceptChannel this_obj);
/* @internal */
export function AcceptChannel_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannel_free(this_obj);
	// debug statements here
}
	// const uint8_t (*AcceptChannel_get_temporary_channel_id(const struct LDKAcceptChannel *NONNULL_PTR this_ptr))[32];
/* @internal */
export function AcceptChannel_get_temporary_channel_id(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannel_get_temporary_channel_id(this_ptr);
	return nativeResponseValue;
}
	// void AcceptChannel_set_temporary_channel_id(struct LDKAcceptChannel *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function AcceptChannel_set_temporary_channel_id(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannel_set_temporary_channel_id(this_ptr, val);
	// debug statements here
}
	// uint64_t AcceptChannel_get_dust_limit_satoshis(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);
/* @internal */
export function AcceptChannel_get_dust_limit_satoshis(this_ptr: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannel_get_dust_limit_satoshis(this_ptr);
	return nativeResponseValue;
}
	// void AcceptChannel_set_dust_limit_satoshis(struct LDKAcceptChannel *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function AcceptChannel_set_dust_limit_satoshis(this_ptr: number, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannel_set_dust_limit_satoshis(this_ptr, val);
	// debug statements here
}
	// uint64_t AcceptChannel_get_max_htlc_value_in_flight_msat(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);
/* @internal */
export function AcceptChannel_get_max_htlc_value_in_flight_msat(this_ptr: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannel_get_max_htlc_value_in_flight_msat(this_ptr);
	return nativeResponseValue;
}
	// void AcceptChannel_set_max_htlc_value_in_flight_msat(struct LDKAcceptChannel *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function AcceptChannel_set_max_htlc_value_in_flight_msat(this_ptr: number, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannel_set_max_htlc_value_in_flight_msat(this_ptr, val);
	// debug statements here
}
	// uint64_t AcceptChannel_get_channel_reserve_satoshis(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);
/* @internal */
export function AcceptChannel_get_channel_reserve_satoshis(this_ptr: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannel_get_channel_reserve_satoshis(this_ptr);
	return nativeResponseValue;
}
	// void AcceptChannel_set_channel_reserve_satoshis(struct LDKAcceptChannel *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function AcceptChannel_set_channel_reserve_satoshis(this_ptr: number, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannel_set_channel_reserve_satoshis(this_ptr, val);
	// debug statements here
}
	// uint64_t AcceptChannel_get_htlc_minimum_msat(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);
/* @internal */
export function AcceptChannel_get_htlc_minimum_msat(this_ptr: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannel_get_htlc_minimum_msat(this_ptr);
	return nativeResponseValue;
}
	// void AcceptChannel_set_htlc_minimum_msat(struct LDKAcceptChannel *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function AcceptChannel_set_htlc_minimum_msat(this_ptr: number, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannel_set_htlc_minimum_msat(this_ptr, val);
	// debug statements here
}
	// uint32_t AcceptChannel_get_minimum_depth(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);
/* @internal */
export function AcceptChannel_get_minimum_depth(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannel_get_minimum_depth(this_ptr);
	return nativeResponseValue;
}
	// void AcceptChannel_set_minimum_depth(struct LDKAcceptChannel *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */
export function AcceptChannel_set_minimum_depth(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannel_set_minimum_depth(this_ptr, val);
	// debug statements here
}
	// uint16_t AcceptChannel_get_to_self_delay(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);
/* @internal */
export function AcceptChannel_get_to_self_delay(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannel_get_to_self_delay(this_ptr);
	return nativeResponseValue;
}
	// void AcceptChannel_set_to_self_delay(struct LDKAcceptChannel *NONNULL_PTR this_ptr, uint16_t val);
/* @internal */
export function AcceptChannel_set_to_self_delay(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannel_set_to_self_delay(this_ptr, val);
	// debug statements here
}
	// uint16_t AcceptChannel_get_max_accepted_htlcs(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);
/* @internal */
export function AcceptChannel_get_max_accepted_htlcs(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannel_get_max_accepted_htlcs(this_ptr);
	return nativeResponseValue;
}
	// void AcceptChannel_set_max_accepted_htlcs(struct LDKAcceptChannel *NONNULL_PTR this_ptr, uint16_t val);
/* @internal */
export function AcceptChannel_set_max_accepted_htlcs(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannel_set_max_accepted_htlcs(this_ptr, val);
	// debug statements here
}
	// struct LDKPublicKey AcceptChannel_get_funding_pubkey(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);
/* @internal */
export function AcceptChannel_get_funding_pubkey(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannel_get_funding_pubkey(this_ptr);
	return nativeResponseValue;
}
	// void AcceptChannel_set_funding_pubkey(struct LDKAcceptChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */
export function AcceptChannel_set_funding_pubkey(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannel_set_funding_pubkey(this_ptr, val);
	// debug statements here
}
	// struct LDKPublicKey AcceptChannel_get_revocation_basepoint(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);
/* @internal */
export function AcceptChannel_get_revocation_basepoint(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannel_get_revocation_basepoint(this_ptr);
	return nativeResponseValue;
}
	// void AcceptChannel_set_revocation_basepoint(struct LDKAcceptChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */
export function AcceptChannel_set_revocation_basepoint(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannel_set_revocation_basepoint(this_ptr, val);
	// debug statements here
}
	// struct LDKPublicKey AcceptChannel_get_payment_point(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);
/* @internal */
export function AcceptChannel_get_payment_point(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannel_get_payment_point(this_ptr);
	return nativeResponseValue;
}
	// void AcceptChannel_set_payment_point(struct LDKAcceptChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */
export function AcceptChannel_set_payment_point(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannel_set_payment_point(this_ptr, val);
	// debug statements here
}
	// struct LDKPublicKey AcceptChannel_get_delayed_payment_basepoint(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);
/* @internal */
export function AcceptChannel_get_delayed_payment_basepoint(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannel_get_delayed_payment_basepoint(this_ptr);
	return nativeResponseValue;
}
	// void AcceptChannel_set_delayed_payment_basepoint(struct LDKAcceptChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */
export function AcceptChannel_set_delayed_payment_basepoint(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannel_set_delayed_payment_basepoint(this_ptr, val);
	// debug statements here
}
	// struct LDKPublicKey AcceptChannel_get_htlc_basepoint(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);
/* @internal */
export function AcceptChannel_get_htlc_basepoint(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannel_get_htlc_basepoint(this_ptr);
	return nativeResponseValue;
}
	// void AcceptChannel_set_htlc_basepoint(struct LDKAcceptChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */
export function AcceptChannel_set_htlc_basepoint(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannel_set_htlc_basepoint(this_ptr, val);
	// debug statements here
}
	// struct LDKPublicKey AcceptChannel_get_first_per_commitment_point(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);
/* @internal */
export function AcceptChannel_get_first_per_commitment_point(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannel_get_first_per_commitment_point(this_ptr);
	return nativeResponseValue;
}
	// void AcceptChannel_set_first_per_commitment_point(struct LDKAcceptChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */
export function AcceptChannel_set_first_per_commitment_point(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannel_set_first_per_commitment_point(this_ptr, val);
	// debug statements here
}
	// struct LDKChannelTypeFeatures AcceptChannel_get_channel_type(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);
/* @internal */
export function AcceptChannel_get_channel_type(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannel_get_channel_type(this_ptr);
	return nativeResponseValue;
}
	// void AcceptChannel_set_channel_type(struct LDKAcceptChannel *NONNULL_PTR this_ptr, struct LDKChannelTypeFeatures val);
/* @internal */
export function AcceptChannel_set_channel_type(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannel_set_channel_type(this_ptr, val);
	// debug statements here
}
	// uintptr_t AcceptChannel_clone_ptr(LDKAcceptChannel *NONNULL_PTR arg);
/* @internal */
export function AcceptChannel_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannel_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKAcceptChannel AcceptChannel_clone(const struct LDKAcceptChannel *NONNULL_PTR orig);
/* @internal */
export function AcceptChannel_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannel_clone(orig);
	return nativeResponseValue;
}
	// void FundingCreated_free(struct LDKFundingCreated this_obj);
/* @internal */
export function FundingCreated_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_FundingCreated_free(this_obj);
	// debug statements here
}
	// const uint8_t (*FundingCreated_get_temporary_channel_id(const struct LDKFundingCreated *NONNULL_PTR this_ptr))[32];
/* @internal */
export function FundingCreated_get_temporary_channel_id(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_FundingCreated_get_temporary_channel_id(this_ptr);
	return nativeResponseValue;
}
	// void FundingCreated_set_temporary_channel_id(struct LDKFundingCreated *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function FundingCreated_set_temporary_channel_id(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_FundingCreated_set_temporary_channel_id(this_ptr, val);
	// debug statements here
}
	// const uint8_t (*FundingCreated_get_funding_txid(const struct LDKFundingCreated *NONNULL_PTR this_ptr))[32];
/* @internal */
export function FundingCreated_get_funding_txid(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_FundingCreated_get_funding_txid(this_ptr);
	return nativeResponseValue;
}
	// void FundingCreated_set_funding_txid(struct LDKFundingCreated *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function FundingCreated_set_funding_txid(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_FundingCreated_set_funding_txid(this_ptr, val);
	// debug statements here
}
	// uint16_t FundingCreated_get_funding_output_index(const struct LDKFundingCreated *NONNULL_PTR this_ptr);
/* @internal */
export function FundingCreated_get_funding_output_index(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_FundingCreated_get_funding_output_index(this_ptr);
	return nativeResponseValue;
}
	// void FundingCreated_set_funding_output_index(struct LDKFundingCreated *NONNULL_PTR this_ptr, uint16_t val);
/* @internal */
export function FundingCreated_set_funding_output_index(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_FundingCreated_set_funding_output_index(this_ptr, val);
	// debug statements here
}
	// struct LDKSignature FundingCreated_get_signature(const struct LDKFundingCreated *NONNULL_PTR this_ptr);
/* @internal */
export function FundingCreated_get_signature(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_FundingCreated_get_signature(this_ptr);
	return nativeResponseValue;
}
	// void FundingCreated_set_signature(struct LDKFundingCreated *NONNULL_PTR this_ptr, struct LDKSignature val);
/* @internal */
export function FundingCreated_set_signature(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_FundingCreated_set_signature(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKFundingCreated FundingCreated_new(struct LDKThirtyTwoBytes temporary_channel_id_arg, struct LDKThirtyTwoBytes funding_txid_arg, uint16_t funding_output_index_arg, struct LDKSignature signature_arg);
/* @internal */
export function FundingCreated_new(temporary_channel_id_arg: number, funding_txid_arg: number, funding_output_index_arg: number, signature_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_FundingCreated_new(temporary_channel_id_arg, funding_txid_arg, funding_output_index_arg, signature_arg);
	return nativeResponseValue;
}
	// uintptr_t FundingCreated_clone_ptr(LDKFundingCreated *NONNULL_PTR arg);
/* @internal */
export function FundingCreated_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_FundingCreated_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKFundingCreated FundingCreated_clone(const struct LDKFundingCreated *NONNULL_PTR orig);
/* @internal */
export function FundingCreated_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_FundingCreated_clone(orig);
	return nativeResponseValue;
}
	// void FundingSigned_free(struct LDKFundingSigned this_obj);
/* @internal */
export function FundingSigned_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_FundingSigned_free(this_obj);
	// debug statements here
}
	// const uint8_t (*FundingSigned_get_channel_id(const struct LDKFundingSigned *NONNULL_PTR this_ptr))[32];
/* @internal */
export function FundingSigned_get_channel_id(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_FundingSigned_get_channel_id(this_ptr);
	return nativeResponseValue;
}
	// void FundingSigned_set_channel_id(struct LDKFundingSigned *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function FundingSigned_set_channel_id(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_FundingSigned_set_channel_id(this_ptr, val);
	// debug statements here
}
	// struct LDKSignature FundingSigned_get_signature(const struct LDKFundingSigned *NONNULL_PTR this_ptr);
/* @internal */
export function FundingSigned_get_signature(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_FundingSigned_get_signature(this_ptr);
	return nativeResponseValue;
}
	// void FundingSigned_set_signature(struct LDKFundingSigned *NONNULL_PTR this_ptr, struct LDKSignature val);
/* @internal */
export function FundingSigned_set_signature(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_FundingSigned_set_signature(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKFundingSigned FundingSigned_new(struct LDKThirtyTwoBytes channel_id_arg, struct LDKSignature signature_arg);
/* @internal */
export function FundingSigned_new(channel_id_arg: number, signature_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_FundingSigned_new(channel_id_arg, signature_arg);
	return nativeResponseValue;
}
	// uintptr_t FundingSigned_clone_ptr(LDKFundingSigned *NONNULL_PTR arg);
/* @internal */
export function FundingSigned_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_FundingSigned_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKFundingSigned FundingSigned_clone(const struct LDKFundingSigned *NONNULL_PTR orig);
/* @internal */
export function FundingSigned_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_FundingSigned_clone(orig);
	return nativeResponseValue;
}
	// void FundingLocked_free(struct LDKFundingLocked this_obj);
/* @internal */
export function FundingLocked_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_FundingLocked_free(this_obj);
	// debug statements here
}
	// const uint8_t (*FundingLocked_get_channel_id(const struct LDKFundingLocked *NONNULL_PTR this_ptr))[32];
/* @internal */
export function FundingLocked_get_channel_id(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_FundingLocked_get_channel_id(this_ptr);
	return nativeResponseValue;
}
	// void FundingLocked_set_channel_id(struct LDKFundingLocked *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function FundingLocked_set_channel_id(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_FundingLocked_set_channel_id(this_ptr, val);
	// debug statements here
}
	// struct LDKPublicKey FundingLocked_get_next_per_commitment_point(const struct LDKFundingLocked *NONNULL_PTR this_ptr);
/* @internal */
export function FundingLocked_get_next_per_commitment_point(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_FundingLocked_get_next_per_commitment_point(this_ptr);
	return nativeResponseValue;
}
	// void FundingLocked_set_next_per_commitment_point(struct LDKFundingLocked *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */
export function FundingLocked_set_next_per_commitment_point(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_FundingLocked_set_next_per_commitment_point(this_ptr, val);
	// debug statements here
}
	// struct LDKCOption_u64Z FundingLocked_get_short_channel_id_alias(const struct LDKFundingLocked *NONNULL_PTR this_ptr);
/* @internal */
export function FundingLocked_get_short_channel_id_alias(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_FundingLocked_get_short_channel_id_alias(this_ptr);
	return nativeResponseValue;
}
	// void FundingLocked_set_short_channel_id_alias(struct LDKFundingLocked *NONNULL_PTR this_ptr, struct LDKCOption_u64Z val);
/* @internal */
export function FundingLocked_set_short_channel_id_alias(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_FundingLocked_set_short_channel_id_alias(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKFundingLocked FundingLocked_new(struct LDKThirtyTwoBytes channel_id_arg, struct LDKPublicKey next_per_commitment_point_arg, struct LDKCOption_u64Z short_channel_id_alias_arg);
/* @internal */
export function FundingLocked_new(channel_id_arg: number, next_per_commitment_point_arg: number, short_channel_id_alias_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_FundingLocked_new(channel_id_arg, next_per_commitment_point_arg, short_channel_id_alias_arg);
	return nativeResponseValue;
}
	// uintptr_t FundingLocked_clone_ptr(LDKFundingLocked *NONNULL_PTR arg);
/* @internal */
export function FundingLocked_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_FundingLocked_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKFundingLocked FundingLocked_clone(const struct LDKFundingLocked *NONNULL_PTR orig);
/* @internal */
export function FundingLocked_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_FundingLocked_clone(orig);
	return nativeResponseValue;
}
	// void Shutdown_free(struct LDKShutdown this_obj);
/* @internal */
export function Shutdown_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Shutdown_free(this_obj);
	// debug statements here
}
	// const uint8_t (*Shutdown_get_channel_id(const struct LDKShutdown *NONNULL_PTR this_ptr))[32];
/* @internal */
export function Shutdown_get_channel_id(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Shutdown_get_channel_id(this_ptr);
	return nativeResponseValue;
}
	// void Shutdown_set_channel_id(struct LDKShutdown *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function Shutdown_set_channel_id(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Shutdown_set_channel_id(this_ptr, val);
	// debug statements here
}
	// struct LDKu8slice Shutdown_get_scriptpubkey(const struct LDKShutdown *NONNULL_PTR this_ptr);
/* @internal */
export function Shutdown_get_scriptpubkey(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Shutdown_get_scriptpubkey(this_ptr);
	return nativeResponseValue;
}
	// void Shutdown_set_scriptpubkey(struct LDKShutdown *NONNULL_PTR this_ptr, struct LDKCVec_u8Z val);
/* @internal */
export function Shutdown_set_scriptpubkey(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Shutdown_set_scriptpubkey(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKShutdown Shutdown_new(struct LDKThirtyTwoBytes channel_id_arg, struct LDKCVec_u8Z scriptpubkey_arg);
/* @internal */
export function Shutdown_new(channel_id_arg: number, scriptpubkey_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Shutdown_new(channel_id_arg, scriptpubkey_arg);
	return nativeResponseValue;
}
	// uintptr_t Shutdown_clone_ptr(LDKShutdown *NONNULL_PTR arg);
/* @internal */
export function Shutdown_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Shutdown_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKShutdown Shutdown_clone(const struct LDKShutdown *NONNULL_PTR orig);
/* @internal */
export function Shutdown_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Shutdown_clone(orig);
	return nativeResponseValue;
}
	// void ClosingSignedFeeRange_free(struct LDKClosingSignedFeeRange this_obj);
/* @internal */
export function ClosingSignedFeeRange_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosingSignedFeeRange_free(this_obj);
	// debug statements here
}
	// uint64_t ClosingSignedFeeRange_get_min_fee_satoshis(const struct LDKClosingSignedFeeRange *NONNULL_PTR this_ptr);
/* @internal */
export function ClosingSignedFeeRange_get_min_fee_satoshis(this_ptr: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosingSignedFeeRange_get_min_fee_satoshis(this_ptr);
	return nativeResponseValue;
}
	// void ClosingSignedFeeRange_set_min_fee_satoshis(struct LDKClosingSignedFeeRange *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function ClosingSignedFeeRange_set_min_fee_satoshis(this_ptr: number, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosingSignedFeeRange_set_min_fee_satoshis(this_ptr, val);
	// debug statements here
}
	// uint64_t ClosingSignedFeeRange_get_max_fee_satoshis(const struct LDKClosingSignedFeeRange *NONNULL_PTR this_ptr);
/* @internal */
export function ClosingSignedFeeRange_get_max_fee_satoshis(this_ptr: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosingSignedFeeRange_get_max_fee_satoshis(this_ptr);
	return nativeResponseValue;
}
	// void ClosingSignedFeeRange_set_max_fee_satoshis(struct LDKClosingSignedFeeRange *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function ClosingSignedFeeRange_set_max_fee_satoshis(this_ptr: number, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosingSignedFeeRange_set_max_fee_satoshis(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKClosingSignedFeeRange ClosingSignedFeeRange_new(uint64_t min_fee_satoshis_arg, uint64_t max_fee_satoshis_arg);
/* @internal */
export function ClosingSignedFeeRange_new(min_fee_satoshis_arg: bigint, max_fee_satoshis_arg: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosingSignedFeeRange_new(min_fee_satoshis_arg, max_fee_satoshis_arg);
	return nativeResponseValue;
}
	// uintptr_t ClosingSignedFeeRange_clone_ptr(LDKClosingSignedFeeRange *NONNULL_PTR arg);
/* @internal */
export function ClosingSignedFeeRange_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosingSignedFeeRange_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKClosingSignedFeeRange ClosingSignedFeeRange_clone(const struct LDKClosingSignedFeeRange *NONNULL_PTR orig);
/* @internal */
export function ClosingSignedFeeRange_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosingSignedFeeRange_clone(orig);
	return nativeResponseValue;
}
	// void ClosingSigned_free(struct LDKClosingSigned this_obj);
/* @internal */
export function ClosingSigned_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosingSigned_free(this_obj);
	// debug statements here
}
	// const uint8_t (*ClosingSigned_get_channel_id(const struct LDKClosingSigned *NONNULL_PTR this_ptr))[32];
/* @internal */
export function ClosingSigned_get_channel_id(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosingSigned_get_channel_id(this_ptr);
	return nativeResponseValue;
}
	// void ClosingSigned_set_channel_id(struct LDKClosingSigned *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function ClosingSigned_set_channel_id(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosingSigned_set_channel_id(this_ptr, val);
	// debug statements here
}
	// uint64_t ClosingSigned_get_fee_satoshis(const struct LDKClosingSigned *NONNULL_PTR this_ptr);
/* @internal */
export function ClosingSigned_get_fee_satoshis(this_ptr: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosingSigned_get_fee_satoshis(this_ptr);
	return nativeResponseValue;
}
	// void ClosingSigned_set_fee_satoshis(struct LDKClosingSigned *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function ClosingSigned_set_fee_satoshis(this_ptr: number, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosingSigned_set_fee_satoshis(this_ptr, val);
	// debug statements here
}
	// struct LDKSignature ClosingSigned_get_signature(const struct LDKClosingSigned *NONNULL_PTR this_ptr);
/* @internal */
export function ClosingSigned_get_signature(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosingSigned_get_signature(this_ptr);
	return nativeResponseValue;
}
	// void ClosingSigned_set_signature(struct LDKClosingSigned *NONNULL_PTR this_ptr, struct LDKSignature val);
/* @internal */
export function ClosingSigned_set_signature(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosingSigned_set_signature(this_ptr, val);
	// debug statements here
}
	// struct LDKClosingSignedFeeRange ClosingSigned_get_fee_range(const struct LDKClosingSigned *NONNULL_PTR this_ptr);
/* @internal */
export function ClosingSigned_get_fee_range(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosingSigned_get_fee_range(this_ptr);
	return nativeResponseValue;
}
	// void ClosingSigned_set_fee_range(struct LDKClosingSigned *NONNULL_PTR this_ptr, struct LDKClosingSignedFeeRange val);
/* @internal */
export function ClosingSigned_set_fee_range(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosingSigned_set_fee_range(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKClosingSigned ClosingSigned_new(struct LDKThirtyTwoBytes channel_id_arg, uint64_t fee_satoshis_arg, struct LDKSignature signature_arg, struct LDKClosingSignedFeeRange fee_range_arg);
/* @internal */
export function ClosingSigned_new(channel_id_arg: number, fee_satoshis_arg: bigint, signature_arg: number, fee_range_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosingSigned_new(channel_id_arg, fee_satoshis_arg, signature_arg, fee_range_arg);
	return nativeResponseValue;
}
	// uintptr_t ClosingSigned_clone_ptr(LDKClosingSigned *NONNULL_PTR arg);
/* @internal */
export function ClosingSigned_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosingSigned_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKClosingSigned ClosingSigned_clone(const struct LDKClosingSigned *NONNULL_PTR orig);
/* @internal */
export function ClosingSigned_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosingSigned_clone(orig);
	return nativeResponseValue;
}
	// void UpdateAddHTLC_free(struct LDKUpdateAddHTLC this_obj);
/* @internal */
export function UpdateAddHTLC_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateAddHTLC_free(this_obj);
	// debug statements here
}
	// const uint8_t (*UpdateAddHTLC_get_channel_id(const struct LDKUpdateAddHTLC *NONNULL_PTR this_ptr))[32];
/* @internal */
export function UpdateAddHTLC_get_channel_id(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateAddHTLC_get_channel_id(this_ptr);
	return nativeResponseValue;
}
	// void UpdateAddHTLC_set_channel_id(struct LDKUpdateAddHTLC *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function UpdateAddHTLC_set_channel_id(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateAddHTLC_set_channel_id(this_ptr, val);
	// debug statements here
}
	// uint64_t UpdateAddHTLC_get_htlc_id(const struct LDKUpdateAddHTLC *NONNULL_PTR this_ptr);
/* @internal */
export function UpdateAddHTLC_get_htlc_id(this_ptr: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateAddHTLC_get_htlc_id(this_ptr);
	return nativeResponseValue;
}
	// void UpdateAddHTLC_set_htlc_id(struct LDKUpdateAddHTLC *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function UpdateAddHTLC_set_htlc_id(this_ptr: number, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateAddHTLC_set_htlc_id(this_ptr, val);
	// debug statements here
}
	// uint64_t UpdateAddHTLC_get_amount_msat(const struct LDKUpdateAddHTLC *NONNULL_PTR this_ptr);
/* @internal */
export function UpdateAddHTLC_get_amount_msat(this_ptr: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateAddHTLC_get_amount_msat(this_ptr);
	return nativeResponseValue;
}
	// void UpdateAddHTLC_set_amount_msat(struct LDKUpdateAddHTLC *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function UpdateAddHTLC_set_amount_msat(this_ptr: number, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateAddHTLC_set_amount_msat(this_ptr, val);
	// debug statements here
}
	// const uint8_t (*UpdateAddHTLC_get_payment_hash(const struct LDKUpdateAddHTLC *NONNULL_PTR this_ptr))[32];
/* @internal */
export function UpdateAddHTLC_get_payment_hash(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateAddHTLC_get_payment_hash(this_ptr);
	return nativeResponseValue;
}
	// void UpdateAddHTLC_set_payment_hash(struct LDKUpdateAddHTLC *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function UpdateAddHTLC_set_payment_hash(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateAddHTLC_set_payment_hash(this_ptr, val);
	// debug statements here
}
	// uint32_t UpdateAddHTLC_get_cltv_expiry(const struct LDKUpdateAddHTLC *NONNULL_PTR this_ptr);
/* @internal */
export function UpdateAddHTLC_get_cltv_expiry(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateAddHTLC_get_cltv_expiry(this_ptr);
	return nativeResponseValue;
}
	// void UpdateAddHTLC_set_cltv_expiry(struct LDKUpdateAddHTLC *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */
export function UpdateAddHTLC_set_cltv_expiry(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateAddHTLC_set_cltv_expiry(this_ptr, val);
	// debug statements here
}
	// uintptr_t UpdateAddHTLC_clone_ptr(LDKUpdateAddHTLC *NONNULL_PTR arg);
/* @internal */
export function UpdateAddHTLC_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateAddHTLC_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKUpdateAddHTLC UpdateAddHTLC_clone(const struct LDKUpdateAddHTLC *NONNULL_PTR orig);
/* @internal */
export function UpdateAddHTLC_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateAddHTLC_clone(orig);
	return nativeResponseValue;
}
	// void UpdateFulfillHTLC_free(struct LDKUpdateFulfillHTLC this_obj);
/* @internal */
export function UpdateFulfillHTLC_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateFulfillHTLC_free(this_obj);
	// debug statements here
}
	// const uint8_t (*UpdateFulfillHTLC_get_channel_id(const struct LDKUpdateFulfillHTLC *NONNULL_PTR this_ptr))[32];
/* @internal */
export function UpdateFulfillHTLC_get_channel_id(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateFulfillHTLC_get_channel_id(this_ptr);
	return nativeResponseValue;
}
	// void UpdateFulfillHTLC_set_channel_id(struct LDKUpdateFulfillHTLC *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function UpdateFulfillHTLC_set_channel_id(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateFulfillHTLC_set_channel_id(this_ptr, val);
	// debug statements here
}
	// uint64_t UpdateFulfillHTLC_get_htlc_id(const struct LDKUpdateFulfillHTLC *NONNULL_PTR this_ptr);
/* @internal */
export function UpdateFulfillHTLC_get_htlc_id(this_ptr: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateFulfillHTLC_get_htlc_id(this_ptr);
	return nativeResponseValue;
}
	// void UpdateFulfillHTLC_set_htlc_id(struct LDKUpdateFulfillHTLC *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function UpdateFulfillHTLC_set_htlc_id(this_ptr: number, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateFulfillHTLC_set_htlc_id(this_ptr, val);
	// debug statements here
}
	// const uint8_t (*UpdateFulfillHTLC_get_payment_preimage(const struct LDKUpdateFulfillHTLC *NONNULL_PTR this_ptr))[32];
/* @internal */
export function UpdateFulfillHTLC_get_payment_preimage(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateFulfillHTLC_get_payment_preimage(this_ptr);
	return nativeResponseValue;
}
	// void UpdateFulfillHTLC_set_payment_preimage(struct LDKUpdateFulfillHTLC *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function UpdateFulfillHTLC_set_payment_preimage(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateFulfillHTLC_set_payment_preimage(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKUpdateFulfillHTLC UpdateFulfillHTLC_new(struct LDKThirtyTwoBytes channel_id_arg, uint64_t htlc_id_arg, struct LDKThirtyTwoBytes payment_preimage_arg);
/* @internal */
export function UpdateFulfillHTLC_new(channel_id_arg: number, htlc_id_arg: bigint, payment_preimage_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateFulfillHTLC_new(channel_id_arg, htlc_id_arg, payment_preimage_arg);
	return nativeResponseValue;
}
	// uintptr_t UpdateFulfillHTLC_clone_ptr(LDKUpdateFulfillHTLC *NONNULL_PTR arg);
/* @internal */
export function UpdateFulfillHTLC_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateFulfillHTLC_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKUpdateFulfillHTLC UpdateFulfillHTLC_clone(const struct LDKUpdateFulfillHTLC *NONNULL_PTR orig);
/* @internal */
export function UpdateFulfillHTLC_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateFulfillHTLC_clone(orig);
	return nativeResponseValue;
}
	// void UpdateFailHTLC_free(struct LDKUpdateFailHTLC this_obj);
/* @internal */
export function UpdateFailHTLC_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateFailHTLC_free(this_obj);
	// debug statements here
}
	// const uint8_t (*UpdateFailHTLC_get_channel_id(const struct LDKUpdateFailHTLC *NONNULL_PTR this_ptr))[32];
/* @internal */
export function UpdateFailHTLC_get_channel_id(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateFailHTLC_get_channel_id(this_ptr);
	return nativeResponseValue;
}
	// void UpdateFailHTLC_set_channel_id(struct LDKUpdateFailHTLC *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function UpdateFailHTLC_set_channel_id(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateFailHTLC_set_channel_id(this_ptr, val);
	// debug statements here
}
	// uint64_t UpdateFailHTLC_get_htlc_id(const struct LDKUpdateFailHTLC *NONNULL_PTR this_ptr);
/* @internal */
export function UpdateFailHTLC_get_htlc_id(this_ptr: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateFailHTLC_get_htlc_id(this_ptr);
	return nativeResponseValue;
}
	// void UpdateFailHTLC_set_htlc_id(struct LDKUpdateFailHTLC *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function UpdateFailHTLC_set_htlc_id(this_ptr: number, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateFailHTLC_set_htlc_id(this_ptr, val);
	// debug statements here
}
	// uintptr_t UpdateFailHTLC_clone_ptr(LDKUpdateFailHTLC *NONNULL_PTR arg);
/* @internal */
export function UpdateFailHTLC_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateFailHTLC_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKUpdateFailHTLC UpdateFailHTLC_clone(const struct LDKUpdateFailHTLC *NONNULL_PTR orig);
/* @internal */
export function UpdateFailHTLC_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateFailHTLC_clone(orig);
	return nativeResponseValue;
}
	// void UpdateFailMalformedHTLC_free(struct LDKUpdateFailMalformedHTLC this_obj);
/* @internal */
export function UpdateFailMalformedHTLC_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateFailMalformedHTLC_free(this_obj);
	// debug statements here
}
	// const uint8_t (*UpdateFailMalformedHTLC_get_channel_id(const struct LDKUpdateFailMalformedHTLC *NONNULL_PTR this_ptr))[32];
/* @internal */
export function UpdateFailMalformedHTLC_get_channel_id(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateFailMalformedHTLC_get_channel_id(this_ptr);
	return nativeResponseValue;
}
	// void UpdateFailMalformedHTLC_set_channel_id(struct LDKUpdateFailMalformedHTLC *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function UpdateFailMalformedHTLC_set_channel_id(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateFailMalformedHTLC_set_channel_id(this_ptr, val);
	// debug statements here
}
	// uint64_t UpdateFailMalformedHTLC_get_htlc_id(const struct LDKUpdateFailMalformedHTLC *NONNULL_PTR this_ptr);
/* @internal */
export function UpdateFailMalformedHTLC_get_htlc_id(this_ptr: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateFailMalformedHTLC_get_htlc_id(this_ptr);
	return nativeResponseValue;
}
	// void UpdateFailMalformedHTLC_set_htlc_id(struct LDKUpdateFailMalformedHTLC *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function UpdateFailMalformedHTLC_set_htlc_id(this_ptr: number, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateFailMalformedHTLC_set_htlc_id(this_ptr, val);
	// debug statements here
}
	// uint16_t UpdateFailMalformedHTLC_get_failure_code(const struct LDKUpdateFailMalformedHTLC *NONNULL_PTR this_ptr);
/* @internal */
export function UpdateFailMalformedHTLC_get_failure_code(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateFailMalformedHTLC_get_failure_code(this_ptr);
	return nativeResponseValue;
}
	// void UpdateFailMalformedHTLC_set_failure_code(struct LDKUpdateFailMalformedHTLC *NONNULL_PTR this_ptr, uint16_t val);
/* @internal */
export function UpdateFailMalformedHTLC_set_failure_code(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateFailMalformedHTLC_set_failure_code(this_ptr, val);
	// debug statements here
}
	// uintptr_t UpdateFailMalformedHTLC_clone_ptr(LDKUpdateFailMalformedHTLC *NONNULL_PTR arg);
/* @internal */
export function UpdateFailMalformedHTLC_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateFailMalformedHTLC_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKUpdateFailMalformedHTLC UpdateFailMalformedHTLC_clone(const struct LDKUpdateFailMalformedHTLC *NONNULL_PTR orig);
/* @internal */
export function UpdateFailMalformedHTLC_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateFailMalformedHTLC_clone(orig);
	return nativeResponseValue;
}
	// void CommitmentSigned_free(struct LDKCommitmentSigned this_obj);
/* @internal */
export function CommitmentSigned_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CommitmentSigned_free(this_obj);
	// debug statements here
}
	// const uint8_t (*CommitmentSigned_get_channel_id(const struct LDKCommitmentSigned *NONNULL_PTR this_ptr))[32];
/* @internal */
export function CommitmentSigned_get_channel_id(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CommitmentSigned_get_channel_id(this_ptr);
	return nativeResponseValue;
}
	// void CommitmentSigned_set_channel_id(struct LDKCommitmentSigned *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function CommitmentSigned_set_channel_id(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CommitmentSigned_set_channel_id(this_ptr, val);
	// debug statements here
}
	// struct LDKSignature CommitmentSigned_get_signature(const struct LDKCommitmentSigned *NONNULL_PTR this_ptr);
/* @internal */
export function CommitmentSigned_get_signature(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CommitmentSigned_get_signature(this_ptr);
	return nativeResponseValue;
}
	// void CommitmentSigned_set_signature(struct LDKCommitmentSigned *NONNULL_PTR this_ptr, struct LDKSignature val);
/* @internal */
export function CommitmentSigned_set_signature(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CommitmentSigned_set_signature(this_ptr, val);
	// debug statements here
}
	// void CommitmentSigned_set_htlc_signatures(struct LDKCommitmentSigned *NONNULL_PTR this_ptr, struct LDKCVec_SignatureZ val);
/* @internal */
export function CommitmentSigned_set_htlc_signatures(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CommitmentSigned_set_htlc_signatures(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKCommitmentSigned CommitmentSigned_new(struct LDKThirtyTwoBytes channel_id_arg, struct LDKSignature signature_arg, struct LDKCVec_SignatureZ htlc_signatures_arg);
/* @internal */
export function CommitmentSigned_new(channel_id_arg: number, signature_arg: number, htlc_signatures_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CommitmentSigned_new(channel_id_arg, signature_arg, htlc_signatures_arg);
	return nativeResponseValue;
}
	// uintptr_t CommitmentSigned_clone_ptr(LDKCommitmentSigned *NONNULL_PTR arg);
/* @internal */
export function CommitmentSigned_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CommitmentSigned_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCommitmentSigned CommitmentSigned_clone(const struct LDKCommitmentSigned *NONNULL_PTR orig);
/* @internal */
export function CommitmentSigned_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CommitmentSigned_clone(orig);
	return nativeResponseValue;
}
	// void RevokeAndACK_free(struct LDKRevokeAndACK this_obj);
/* @internal */
export function RevokeAndACK_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RevokeAndACK_free(this_obj);
	// debug statements here
}
	// const uint8_t (*RevokeAndACK_get_channel_id(const struct LDKRevokeAndACK *NONNULL_PTR this_ptr))[32];
/* @internal */
export function RevokeAndACK_get_channel_id(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RevokeAndACK_get_channel_id(this_ptr);
	return nativeResponseValue;
}
	// void RevokeAndACK_set_channel_id(struct LDKRevokeAndACK *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function RevokeAndACK_set_channel_id(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RevokeAndACK_set_channel_id(this_ptr, val);
	// debug statements here
}
	// const uint8_t (*RevokeAndACK_get_per_commitment_secret(const struct LDKRevokeAndACK *NONNULL_PTR this_ptr))[32];
/* @internal */
export function RevokeAndACK_get_per_commitment_secret(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RevokeAndACK_get_per_commitment_secret(this_ptr);
	return nativeResponseValue;
}
	// void RevokeAndACK_set_per_commitment_secret(struct LDKRevokeAndACK *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function RevokeAndACK_set_per_commitment_secret(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RevokeAndACK_set_per_commitment_secret(this_ptr, val);
	// debug statements here
}
	// struct LDKPublicKey RevokeAndACK_get_next_per_commitment_point(const struct LDKRevokeAndACK *NONNULL_PTR this_ptr);
/* @internal */
export function RevokeAndACK_get_next_per_commitment_point(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RevokeAndACK_get_next_per_commitment_point(this_ptr);
	return nativeResponseValue;
}
	// void RevokeAndACK_set_next_per_commitment_point(struct LDKRevokeAndACK *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */
export function RevokeAndACK_set_next_per_commitment_point(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RevokeAndACK_set_next_per_commitment_point(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKRevokeAndACK RevokeAndACK_new(struct LDKThirtyTwoBytes channel_id_arg, struct LDKThirtyTwoBytes per_commitment_secret_arg, struct LDKPublicKey next_per_commitment_point_arg);
/* @internal */
export function RevokeAndACK_new(channel_id_arg: number, per_commitment_secret_arg: number, next_per_commitment_point_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RevokeAndACK_new(channel_id_arg, per_commitment_secret_arg, next_per_commitment_point_arg);
	return nativeResponseValue;
}
	// uintptr_t RevokeAndACK_clone_ptr(LDKRevokeAndACK *NONNULL_PTR arg);
/* @internal */
export function RevokeAndACK_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RevokeAndACK_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKRevokeAndACK RevokeAndACK_clone(const struct LDKRevokeAndACK *NONNULL_PTR orig);
/* @internal */
export function RevokeAndACK_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RevokeAndACK_clone(orig);
	return nativeResponseValue;
}
	// void UpdateFee_free(struct LDKUpdateFee this_obj);
/* @internal */
export function UpdateFee_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateFee_free(this_obj);
	// debug statements here
}
	// const uint8_t (*UpdateFee_get_channel_id(const struct LDKUpdateFee *NONNULL_PTR this_ptr))[32];
/* @internal */
export function UpdateFee_get_channel_id(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateFee_get_channel_id(this_ptr);
	return nativeResponseValue;
}
	// void UpdateFee_set_channel_id(struct LDKUpdateFee *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function UpdateFee_set_channel_id(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateFee_set_channel_id(this_ptr, val);
	// debug statements here
}
	// uint32_t UpdateFee_get_feerate_per_kw(const struct LDKUpdateFee *NONNULL_PTR this_ptr);
/* @internal */
export function UpdateFee_get_feerate_per_kw(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateFee_get_feerate_per_kw(this_ptr);
	return nativeResponseValue;
}
	// void UpdateFee_set_feerate_per_kw(struct LDKUpdateFee *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */
export function UpdateFee_set_feerate_per_kw(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateFee_set_feerate_per_kw(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKUpdateFee UpdateFee_new(struct LDKThirtyTwoBytes channel_id_arg, uint32_t feerate_per_kw_arg);
/* @internal */
export function UpdateFee_new(channel_id_arg: number, feerate_per_kw_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateFee_new(channel_id_arg, feerate_per_kw_arg);
	return nativeResponseValue;
}
	// uintptr_t UpdateFee_clone_ptr(LDKUpdateFee *NONNULL_PTR arg);
/* @internal */
export function UpdateFee_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateFee_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKUpdateFee UpdateFee_clone(const struct LDKUpdateFee *NONNULL_PTR orig);
/* @internal */
export function UpdateFee_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateFee_clone(orig);
	return nativeResponseValue;
}
	// void DataLossProtect_free(struct LDKDataLossProtect this_obj);
/* @internal */
export function DataLossProtect_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DataLossProtect_free(this_obj);
	// debug statements here
}
	// const uint8_t (*DataLossProtect_get_your_last_per_commitment_secret(const struct LDKDataLossProtect *NONNULL_PTR this_ptr))[32];
/* @internal */
export function DataLossProtect_get_your_last_per_commitment_secret(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DataLossProtect_get_your_last_per_commitment_secret(this_ptr);
	return nativeResponseValue;
}
	// void DataLossProtect_set_your_last_per_commitment_secret(struct LDKDataLossProtect *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function DataLossProtect_set_your_last_per_commitment_secret(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DataLossProtect_set_your_last_per_commitment_secret(this_ptr, val);
	// debug statements here
}
	// struct LDKPublicKey DataLossProtect_get_my_current_per_commitment_point(const struct LDKDataLossProtect *NONNULL_PTR this_ptr);
/* @internal */
export function DataLossProtect_get_my_current_per_commitment_point(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DataLossProtect_get_my_current_per_commitment_point(this_ptr);
	return nativeResponseValue;
}
	// void DataLossProtect_set_my_current_per_commitment_point(struct LDKDataLossProtect *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */
export function DataLossProtect_set_my_current_per_commitment_point(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DataLossProtect_set_my_current_per_commitment_point(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKDataLossProtect DataLossProtect_new(struct LDKThirtyTwoBytes your_last_per_commitment_secret_arg, struct LDKPublicKey my_current_per_commitment_point_arg);
/* @internal */
export function DataLossProtect_new(your_last_per_commitment_secret_arg: number, my_current_per_commitment_point_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DataLossProtect_new(your_last_per_commitment_secret_arg, my_current_per_commitment_point_arg);
	return nativeResponseValue;
}
	// uintptr_t DataLossProtect_clone_ptr(LDKDataLossProtect *NONNULL_PTR arg);
/* @internal */
export function DataLossProtect_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DataLossProtect_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKDataLossProtect DataLossProtect_clone(const struct LDKDataLossProtect *NONNULL_PTR orig);
/* @internal */
export function DataLossProtect_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DataLossProtect_clone(orig);
	return nativeResponseValue;
}
	// void ChannelReestablish_free(struct LDKChannelReestablish this_obj);
/* @internal */
export function ChannelReestablish_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelReestablish_free(this_obj);
	// debug statements here
}
	// const uint8_t (*ChannelReestablish_get_channel_id(const struct LDKChannelReestablish *NONNULL_PTR this_ptr))[32];
/* @internal */
export function ChannelReestablish_get_channel_id(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelReestablish_get_channel_id(this_ptr);
	return nativeResponseValue;
}
	// void ChannelReestablish_set_channel_id(struct LDKChannelReestablish *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function ChannelReestablish_set_channel_id(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelReestablish_set_channel_id(this_ptr, val);
	// debug statements here
}
	// uint64_t ChannelReestablish_get_next_local_commitment_number(const struct LDKChannelReestablish *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelReestablish_get_next_local_commitment_number(this_ptr: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelReestablish_get_next_local_commitment_number(this_ptr);
	return nativeResponseValue;
}
	// void ChannelReestablish_set_next_local_commitment_number(struct LDKChannelReestablish *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function ChannelReestablish_set_next_local_commitment_number(this_ptr: number, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelReestablish_set_next_local_commitment_number(this_ptr, val);
	// debug statements here
}
	// uint64_t ChannelReestablish_get_next_remote_commitment_number(const struct LDKChannelReestablish *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelReestablish_get_next_remote_commitment_number(this_ptr: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelReestablish_get_next_remote_commitment_number(this_ptr);
	return nativeResponseValue;
}
	// void ChannelReestablish_set_next_remote_commitment_number(struct LDKChannelReestablish *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function ChannelReestablish_set_next_remote_commitment_number(this_ptr: number, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelReestablish_set_next_remote_commitment_number(this_ptr, val);
	// debug statements here
}
	// uintptr_t ChannelReestablish_clone_ptr(LDKChannelReestablish *NONNULL_PTR arg);
/* @internal */
export function ChannelReestablish_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelReestablish_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKChannelReestablish ChannelReestablish_clone(const struct LDKChannelReestablish *NONNULL_PTR orig);
/* @internal */
export function ChannelReestablish_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelReestablish_clone(orig);
	return nativeResponseValue;
}
	// void AnnouncementSignatures_free(struct LDKAnnouncementSignatures this_obj);
/* @internal */
export function AnnouncementSignatures_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AnnouncementSignatures_free(this_obj);
	// debug statements here
}
	// const uint8_t (*AnnouncementSignatures_get_channel_id(const struct LDKAnnouncementSignatures *NONNULL_PTR this_ptr))[32];
/* @internal */
export function AnnouncementSignatures_get_channel_id(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AnnouncementSignatures_get_channel_id(this_ptr);
	return nativeResponseValue;
}
	// void AnnouncementSignatures_set_channel_id(struct LDKAnnouncementSignatures *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function AnnouncementSignatures_set_channel_id(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AnnouncementSignatures_set_channel_id(this_ptr, val);
	// debug statements here
}
	// uint64_t AnnouncementSignatures_get_short_channel_id(const struct LDKAnnouncementSignatures *NONNULL_PTR this_ptr);
/* @internal */
export function AnnouncementSignatures_get_short_channel_id(this_ptr: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AnnouncementSignatures_get_short_channel_id(this_ptr);
	return nativeResponseValue;
}
	// void AnnouncementSignatures_set_short_channel_id(struct LDKAnnouncementSignatures *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function AnnouncementSignatures_set_short_channel_id(this_ptr: number, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AnnouncementSignatures_set_short_channel_id(this_ptr, val);
	// debug statements here
}
	// struct LDKSignature AnnouncementSignatures_get_node_signature(const struct LDKAnnouncementSignatures *NONNULL_PTR this_ptr);
/* @internal */
export function AnnouncementSignatures_get_node_signature(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AnnouncementSignatures_get_node_signature(this_ptr);
	return nativeResponseValue;
}
	// void AnnouncementSignatures_set_node_signature(struct LDKAnnouncementSignatures *NONNULL_PTR this_ptr, struct LDKSignature val);
/* @internal */
export function AnnouncementSignatures_set_node_signature(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AnnouncementSignatures_set_node_signature(this_ptr, val);
	// debug statements here
}
	// struct LDKSignature AnnouncementSignatures_get_bitcoin_signature(const struct LDKAnnouncementSignatures *NONNULL_PTR this_ptr);
/* @internal */
export function AnnouncementSignatures_get_bitcoin_signature(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AnnouncementSignatures_get_bitcoin_signature(this_ptr);
	return nativeResponseValue;
}
	// void AnnouncementSignatures_set_bitcoin_signature(struct LDKAnnouncementSignatures *NONNULL_PTR this_ptr, struct LDKSignature val);
/* @internal */
export function AnnouncementSignatures_set_bitcoin_signature(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AnnouncementSignatures_set_bitcoin_signature(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKAnnouncementSignatures AnnouncementSignatures_new(struct LDKThirtyTwoBytes channel_id_arg, uint64_t short_channel_id_arg, struct LDKSignature node_signature_arg, struct LDKSignature bitcoin_signature_arg);
/* @internal */
export function AnnouncementSignatures_new(channel_id_arg: number, short_channel_id_arg: bigint, node_signature_arg: number, bitcoin_signature_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AnnouncementSignatures_new(channel_id_arg, short_channel_id_arg, node_signature_arg, bitcoin_signature_arg);
	return nativeResponseValue;
}
	// uintptr_t AnnouncementSignatures_clone_ptr(LDKAnnouncementSignatures *NONNULL_PTR arg);
/* @internal */
export function AnnouncementSignatures_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AnnouncementSignatures_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKAnnouncementSignatures AnnouncementSignatures_clone(const struct LDKAnnouncementSignatures *NONNULL_PTR orig);
/* @internal */
export function AnnouncementSignatures_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AnnouncementSignatures_clone(orig);
	return nativeResponseValue;
}
	// void NetAddress_free(struct LDKNetAddress this_ptr);
/* @internal */
export function NetAddress_free(this_ptr: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NetAddress_free(this_ptr);
	// debug statements here
}
	// uintptr_t NetAddress_clone_ptr(LDKNetAddress *NONNULL_PTR arg);
/* @internal */
export function NetAddress_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NetAddress_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKNetAddress NetAddress_clone(const struct LDKNetAddress *NONNULL_PTR orig);
/* @internal */
export function NetAddress_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NetAddress_clone(orig);
	return nativeResponseValue;
}
	// struct LDKNetAddress NetAddress_ipv4(struct LDKFourBytes addr, uint16_t port);
/* @internal */
export function NetAddress_ipv4(addr: number, port: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NetAddress_ipv4(addr, port);
	return nativeResponseValue;
}
	// struct LDKNetAddress NetAddress_ipv6(struct LDKSixteenBytes addr, uint16_t port);
/* @internal */
export function NetAddress_ipv6(addr: number, port: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NetAddress_ipv6(addr, port);
	return nativeResponseValue;
}
	// struct LDKNetAddress NetAddress_onion_v2(struct LDKTwelveBytes a);
/* @internal */
export function NetAddress_onion_v2(a: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NetAddress_onion_v2(a);
	return nativeResponseValue;
}
	// struct LDKNetAddress NetAddress_onion_v3(struct LDKThirtyTwoBytes ed25519_pubkey, uint16_t checksum, uint8_t version, uint16_t port);
/* @internal */
export function NetAddress_onion_v3(ed25519_pubkey: number, checksum: number, version: number, port: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NetAddress_onion_v3(ed25519_pubkey, checksum, version, port);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z NetAddress_write(const struct LDKNetAddress *NONNULL_PTR obj);
/* @internal */
export function NetAddress_write(obj: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NetAddress_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_NetAddressDecodeErrorZ NetAddress_read(struct LDKu8slice ser);
/* @internal */
export function NetAddress_read(ser: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NetAddress_read(ser);
	return nativeResponseValue;
}
	// void UnsignedNodeAnnouncement_free(struct LDKUnsignedNodeAnnouncement this_obj);
/* @internal */
export function UnsignedNodeAnnouncement_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedNodeAnnouncement_free(this_obj);
	// debug statements here
}
	// struct LDKNodeFeatures UnsignedNodeAnnouncement_get_features(const struct LDKUnsignedNodeAnnouncement *NONNULL_PTR this_ptr);
/* @internal */
export function UnsignedNodeAnnouncement_get_features(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedNodeAnnouncement_get_features(this_ptr);
	return nativeResponseValue;
}
	// void UnsignedNodeAnnouncement_set_features(struct LDKUnsignedNodeAnnouncement *NONNULL_PTR this_ptr, struct LDKNodeFeatures val);
/* @internal */
export function UnsignedNodeAnnouncement_set_features(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedNodeAnnouncement_set_features(this_ptr, val);
	// debug statements here
}
	// uint32_t UnsignedNodeAnnouncement_get_timestamp(const struct LDKUnsignedNodeAnnouncement *NONNULL_PTR this_ptr);
/* @internal */
export function UnsignedNodeAnnouncement_get_timestamp(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedNodeAnnouncement_get_timestamp(this_ptr);
	return nativeResponseValue;
}
	// void UnsignedNodeAnnouncement_set_timestamp(struct LDKUnsignedNodeAnnouncement *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */
export function UnsignedNodeAnnouncement_set_timestamp(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedNodeAnnouncement_set_timestamp(this_ptr, val);
	// debug statements here
}
	// struct LDKPublicKey UnsignedNodeAnnouncement_get_node_id(const struct LDKUnsignedNodeAnnouncement *NONNULL_PTR this_ptr);
/* @internal */
export function UnsignedNodeAnnouncement_get_node_id(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedNodeAnnouncement_get_node_id(this_ptr);
	return nativeResponseValue;
}
	// void UnsignedNodeAnnouncement_set_node_id(struct LDKUnsignedNodeAnnouncement *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */
export function UnsignedNodeAnnouncement_set_node_id(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedNodeAnnouncement_set_node_id(this_ptr, val);
	// debug statements here
}
	// const uint8_t (*UnsignedNodeAnnouncement_get_rgb(const struct LDKUnsignedNodeAnnouncement *NONNULL_PTR this_ptr))[3];
/* @internal */
export function UnsignedNodeAnnouncement_get_rgb(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedNodeAnnouncement_get_rgb(this_ptr);
	return nativeResponseValue;
}
	// void UnsignedNodeAnnouncement_set_rgb(struct LDKUnsignedNodeAnnouncement *NONNULL_PTR this_ptr, struct LDKThreeBytes val);
/* @internal */
export function UnsignedNodeAnnouncement_set_rgb(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedNodeAnnouncement_set_rgb(this_ptr, val);
	// debug statements here
}
	// const uint8_t (*UnsignedNodeAnnouncement_get_alias(const struct LDKUnsignedNodeAnnouncement *NONNULL_PTR this_ptr))[32];
/* @internal */
export function UnsignedNodeAnnouncement_get_alias(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedNodeAnnouncement_get_alias(this_ptr);
	return nativeResponseValue;
}
	// void UnsignedNodeAnnouncement_set_alias(struct LDKUnsignedNodeAnnouncement *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function UnsignedNodeAnnouncement_set_alias(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedNodeAnnouncement_set_alias(this_ptr, val);
	// debug statements here
}
	// void UnsignedNodeAnnouncement_set_addresses(struct LDKUnsignedNodeAnnouncement *NONNULL_PTR this_ptr, struct LDKCVec_NetAddressZ val);
/* @internal */
export function UnsignedNodeAnnouncement_set_addresses(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedNodeAnnouncement_set_addresses(this_ptr, val);
	// debug statements here
}
	// uintptr_t UnsignedNodeAnnouncement_clone_ptr(LDKUnsignedNodeAnnouncement *NONNULL_PTR arg);
/* @internal */
export function UnsignedNodeAnnouncement_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedNodeAnnouncement_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKUnsignedNodeAnnouncement UnsignedNodeAnnouncement_clone(const struct LDKUnsignedNodeAnnouncement *NONNULL_PTR orig);
/* @internal */
export function UnsignedNodeAnnouncement_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedNodeAnnouncement_clone(orig);
	return nativeResponseValue;
}
	// void NodeAnnouncement_free(struct LDKNodeAnnouncement this_obj);
/* @internal */
export function NodeAnnouncement_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeAnnouncement_free(this_obj);
	// debug statements here
}
	// struct LDKSignature NodeAnnouncement_get_signature(const struct LDKNodeAnnouncement *NONNULL_PTR this_ptr);
/* @internal */
export function NodeAnnouncement_get_signature(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeAnnouncement_get_signature(this_ptr);
	return nativeResponseValue;
}
	// void NodeAnnouncement_set_signature(struct LDKNodeAnnouncement *NONNULL_PTR this_ptr, struct LDKSignature val);
/* @internal */
export function NodeAnnouncement_set_signature(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeAnnouncement_set_signature(this_ptr, val);
	// debug statements here
}
	// struct LDKUnsignedNodeAnnouncement NodeAnnouncement_get_contents(const struct LDKNodeAnnouncement *NONNULL_PTR this_ptr);
/* @internal */
export function NodeAnnouncement_get_contents(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeAnnouncement_get_contents(this_ptr);
	return nativeResponseValue;
}
	// void NodeAnnouncement_set_contents(struct LDKNodeAnnouncement *NONNULL_PTR this_ptr, struct LDKUnsignedNodeAnnouncement val);
/* @internal */
export function NodeAnnouncement_set_contents(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeAnnouncement_set_contents(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKNodeAnnouncement NodeAnnouncement_new(struct LDKSignature signature_arg, struct LDKUnsignedNodeAnnouncement contents_arg);
/* @internal */
export function NodeAnnouncement_new(signature_arg: number, contents_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeAnnouncement_new(signature_arg, contents_arg);
	return nativeResponseValue;
}
	// uintptr_t NodeAnnouncement_clone_ptr(LDKNodeAnnouncement *NONNULL_PTR arg);
/* @internal */
export function NodeAnnouncement_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeAnnouncement_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKNodeAnnouncement NodeAnnouncement_clone(const struct LDKNodeAnnouncement *NONNULL_PTR orig);
/* @internal */
export function NodeAnnouncement_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeAnnouncement_clone(orig);
	return nativeResponseValue;
}
	// void UnsignedChannelAnnouncement_free(struct LDKUnsignedChannelAnnouncement this_obj);
/* @internal */
export function UnsignedChannelAnnouncement_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedChannelAnnouncement_free(this_obj);
	// debug statements here
}
	// struct LDKChannelFeatures UnsignedChannelAnnouncement_get_features(const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr);
/* @internal */
export function UnsignedChannelAnnouncement_get_features(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedChannelAnnouncement_get_features(this_ptr);
	return nativeResponseValue;
}
	// void UnsignedChannelAnnouncement_set_features(struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr, struct LDKChannelFeatures val);
/* @internal */
export function UnsignedChannelAnnouncement_set_features(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedChannelAnnouncement_set_features(this_ptr, val);
	// debug statements here
}
	// const uint8_t (*UnsignedChannelAnnouncement_get_chain_hash(const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr))[32];
/* @internal */
export function UnsignedChannelAnnouncement_get_chain_hash(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedChannelAnnouncement_get_chain_hash(this_ptr);
	return nativeResponseValue;
}
	// void UnsignedChannelAnnouncement_set_chain_hash(struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function UnsignedChannelAnnouncement_set_chain_hash(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedChannelAnnouncement_set_chain_hash(this_ptr, val);
	// debug statements here
}
	// uint64_t UnsignedChannelAnnouncement_get_short_channel_id(const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr);
/* @internal */
export function UnsignedChannelAnnouncement_get_short_channel_id(this_ptr: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedChannelAnnouncement_get_short_channel_id(this_ptr);
	return nativeResponseValue;
}
	// void UnsignedChannelAnnouncement_set_short_channel_id(struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function UnsignedChannelAnnouncement_set_short_channel_id(this_ptr: number, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedChannelAnnouncement_set_short_channel_id(this_ptr, val);
	// debug statements here
}
	// struct LDKPublicKey UnsignedChannelAnnouncement_get_node_id_1(const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr);
/* @internal */
export function UnsignedChannelAnnouncement_get_node_id_1(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedChannelAnnouncement_get_node_id_1(this_ptr);
	return nativeResponseValue;
}
	// void UnsignedChannelAnnouncement_set_node_id_1(struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */
export function UnsignedChannelAnnouncement_set_node_id_1(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedChannelAnnouncement_set_node_id_1(this_ptr, val);
	// debug statements here
}
	// struct LDKPublicKey UnsignedChannelAnnouncement_get_node_id_2(const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr);
/* @internal */
export function UnsignedChannelAnnouncement_get_node_id_2(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedChannelAnnouncement_get_node_id_2(this_ptr);
	return nativeResponseValue;
}
	// void UnsignedChannelAnnouncement_set_node_id_2(struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */
export function UnsignedChannelAnnouncement_set_node_id_2(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedChannelAnnouncement_set_node_id_2(this_ptr, val);
	// debug statements here
}
	// struct LDKPublicKey UnsignedChannelAnnouncement_get_bitcoin_key_1(const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr);
/* @internal */
export function UnsignedChannelAnnouncement_get_bitcoin_key_1(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedChannelAnnouncement_get_bitcoin_key_1(this_ptr);
	return nativeResponseValue;
}
	// void UnsignedChannelAnnouncement_set_bitcoin_key_1(struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */
export function UnsignedChannelAnnouncement_set_bitcoin_key_1(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedChannelAnnouncement_set_bitcoin_key_1(this_ptr, val);
	// debug statements here
}
	// struct LDKPublicKey UnsignedChannelAnnouncement_get_bitcoin_key_2(const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr);
/* @internal */
export function UnsignedChannelAnnouncement_get_bitcoin_key_2(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedChannelAnnouncement_get_bitcoin_key_2(this_ptr);
	return nativeResponseValue;
}
	// void UnsignedChannelAnnouncement_set_bitcoin_key_2(struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */
export function UnsignedChannelAnnouncement_set_bitcoin_key_2(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedChannelAnnouncement_set_bitcoin_key_2(this_ptr, val);
	// debug statements here
}
	// uintptr_t UnsignedChannelAnnouncement_clone_ptr(LDKUnsignedChannelAnnouncement *NONNULL_PTR arg);
/* @internal */
export function UnsignedChannelAnnouncement_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedChannelAnnouncement_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKUnsignedChannelAnnouncement UnsignedChannelAnnouncement_clone(const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR orig);
/* @internal */
export function UnsignedChannelAnnouncement_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedChannelAnnouncement_clone(orig);
	return nativeResponseValue;
}
	// void ChannelAnnouncement_free(struct LDKChannelAnnouncement this_obj);
/* @internal */
export function ChannelAnnouncement_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelAnnouncement_free(this_obj);
	// debug statements here
}
	// struct LDKSignature ChannelAnnouncement_get_node_signature_1(const struct LDKChannelAnnouncement *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelAnnouncement_get_node_signature_1(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelAnnouncement_get_node_signature_1(this_ptr);
	return nativeResponseValue;
}
	// void ChannelAnnouncement_set_node_signature_1(struct LDKChannelAnnouncement *NONNULL_PTR this_ptr, struct LDKSignature val);
/* @internal */
export function ChannelAnnouncement_set_node_signature_1(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelAnnouncement_set_node_signature_1(this_ptr, val);
	// debug statements here
}
	// struct LDKSignature ChannelAnnouncement_get_node_signature_2(const struct LDKChannelAnnouncement *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelAnnouncement_get_node_signature_2(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelAnnouncement_get_node_signature_2(this_ptr);
	return nativeResponseValue;
}
	// void ChannelAnnouncement_set_node_signature_2(struct LDKChannelAnnouncement *NONNULL_PTR this_ptr, struct LDKSignature val);
/* @internal */
export function ChannelAnnouncement_set_node_signature_2(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelAnnouncement_set_node_signature_2(this_ptr, val);
	// debug statements here
}
	// struct LDKSignature ChannelAnnouncement_get_bitcoin_signature_1(const struct LDKChannelAnnouncement *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelAnnouncement_get_bitcoin_signature_1(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelAnnouncement_get_bitcoin_signature_1(this_ptr);
	return nativeResponseValue;
}
	// void ChannelAnnouncement_set_bitcoin_signature_1(struct LDKChannelAnnouncement *NONNULL_PTR this_ptr, struct LDKSignature val);
/* @internal */
export function ChannelAnnouncement_set_bitcoin_signature_1(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelAnnouncement_set_bitcoin_signature_1(this_ptr, val);
	// debug statements here
}
	// struct LDKSignature ChannelAnnouncement_get_bitcoin_signature_2(const struct LDKChannelAnnouncement *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelAnnouncement_get_bitcoin_signature_2(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelAnnouncement_get_bitcoin_signature_2(this_ptr);
	return nativeResponseValue;
}
	// void ChannelAnnouncement_set_bitcoin_signature_2(struct LDKChannelAnnouncement *NONNULL_PTR this_ptr, struct LDKSignature val);
/* @internal */
export function ChannelAnnouncement_set_bitcoin_signature_2(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelAnnouncement_set_bitcoin_signature_2(this_ptr, val);
	// debug statements here
}
	// struct LDKUnsignedChannelAnnouncement ChannelAnnouncement_get_contents(const struct LDKChannelAnnouncement *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelAnnouncement_get_contents(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelAnnouncement_get_contents(this_ptr);
	return nativeResponseValue;
}
	// void ChannelAnnouncement_set_contents(struct LDKChannelAnnouncement *NONNULL_PTR this_ptr, struct LDKUnsignedChannelAnnouncement val);
/* @internal */
export function ChannelAnnouncement_set_contents(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelAnnouncement_set_contents(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKChannelAnnouncement ChannelAnnouncement_new(struct LDKSignature node_signature_1_arg, struct LDKSignature node_signature_2_arg, struct LDKSignature bitcoin_signature_1_arg, struct LDKSignature bitcoin_signature_2_arg, struct LDKUnsignedChannelAnnouncement contents_arg);
/* @internal */
export function ChannelAnnouncement_new(node_signature_1_arg: number, node_signature_2_arg: number, bitcoin_signature_1_arg: number, bitcoin_signature_2_arg: number, contents_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelAnnouncement_new(node_signature_1_arg, node_signature_2_arg, bitcoin_signature_1_arg, bitcoin_signature_2_arg, contents_arg);
	return nativeResponseValue;
}
	// uintptr_t ChannelAnnouncement_clone_ptr(LDKChannelAnnouncement *NONNULL_PTR arg);
/* @internal */
export function ChannelAnnouncement_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelAnnouncement_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKChannelAnnouncement ChannelAnnouncement_clone(const struct LDKChannelAnnouncement *NONNULL_PTR orig);
/* @internal */
export function ChannelAnnouncement_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelAnnouncement_clone(orig);
	return nativeResponseValue;
}
	// void UnsignedChannelUpdate_free(struct LDKUnsignedChannelUpdate this_obj);
/* @internal */
export function UnsignedChannelUpdate_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedChannelUpdate_free(this_obj);
	// debug statements here
}
	// const uint8_t (*UnsignedChannelUpdate_get_chain_hash(const struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr))[32];
/* @internal */
export function UnsignedChannelUpdate_get_chain_hash(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedChannelUpdate_get_chain_hash(this_ptr);
	return nativeResponseValue;
}
	// void UnsignedChannelUpdate_set_chain_hash(struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function UnsignedChannelUpdate_set_chain_hash(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedChannelUpdate_set_chain_hash(this_ptr, val);
	// debug statements here
}
	// uint64_t UnsignedChannelUpdate_get_short_channel_id(const struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr);
/* @internal */
export function UnsignedChannelUpdate_get_short_channel_id(this_ptr: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedChannelUpdate_get_short_channel_id(this_ptr);
	return nativeResponseValue;
}
	// void UnsignedChannelUpdate_set_short_channel_id(struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function UnsignedChannelUpdate_set_short_channel_id(this_ptr: number, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedChannelUpdate_set_short_channel_id(this_ptr, val);
	// debug statements here
}
	// uint32_t UnsignedChannelUpdate_get_timestamp(const struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr);
/* @internal */
export function UnsignedChannelUpdate_get_timestamp(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedChannelUpdate_get_timestamp(this_ptr);
	return nativeResponseValue;
}
	// void UnsignedChannelUpdate_set_timestamp(struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */
export function UnsignedChannelUpdate_set_timestamp(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedChannelUpdate_set_timestamp(this_ptr, val);
	// debug statements here
}
	// uint8_t UnsignedChannelUpdate_get_flags(const struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr);
/* @internal */
export function UnsignedChannelUpdate_get_flags(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedChannelUpdate_get_flags(this_ptr);
	return nativeResponseValue;
}
	// void UnsignedChannelUpdate_set_flags(struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr, uint8_t val);
/* @internal */
export function UnsignedChannelUpdate_set_flags(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedChannelUpdate_set_flags(this_ptr, val);
	// debug statements here
}
	// uint16_t UnsignedChannelUpdate_get_cltv_expiry_delta(const struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr);
/* @internal */
export function UnsignedChannelUpdate_get_cltv_expiry_delta(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedChannelUpdate_get_cltv_expiry_delta(this_ptr);
	return nativeResponseValue;
}
	// void UnsignedChannelUpdate_set_cltv_expiry_delta(struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr, uint16_t val);
/* @internal */
export function UnsignedChannelUpdate_set_cltv_expiry_delta(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedChannelUpdate_set_cltv_expiry_delta(this_ptr, val);
	// debug statements here
}
	// uint64_t UnsignedChannelUpdate_get_htlc_minimum_msat(const struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr);
/* @internal */
export function UnsignedChannelUpdate_get_htlc_minimum_msat(this_ptr: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedChannelUpdate_get_htlc_minimum_msat(this_ptr);
	return nativeResponseValue;
}
	// void UnsignedChannelUpdate_set_htlc_minimum_msat(struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function UnsignedChannelUpdate_set_htlc_minimum_msat(this_ptr: number, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedChannelUpdate_set_htlc_minimum_msat(this_ptr, val);
	// debug statements here
}
	// uint32_t UnsignedChannelUpdate_get_fee_base_msat(const struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr);
/* @internal */
export function UnsignedChannelUpdate_get_fee_base_msat(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedChannelUpdate_get_fee_base_msat(this_ptr);
	return nativeResponseValue;
}
	// void UnsignedChannelUpdate_set_fee_base_msat(struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */
export function UnsignedChannelUpdate_set_fee_base_msat(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedChannelUpdate_set_fee_base_msat(this_ptr, val);
	// debug statements here
}
	// uint32_t UnsignedChannelUpdate_get_fee_proportional_millionths(const struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr);
/* @internal */
export function UnsignedChannelUpdate_get_fee_proportional_millionths(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedChannelUpdate_get_fee_proportional_millionths(this_ptr);
	return nativeResponseValue;
}
	// void UnsignedChannelUpdate_set_fee_proportional_millionths(struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */
export function UnsignedChannelUpdate_set_fee_proportional_millionths(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedChannelUpdate_set_fee_proportional_millionths(this_ptr, val);
	// debug statements here
}
	// uintptr_t UnsignedChannelUpdate_clone_ptr(LDKUnsignedChannelUpdate *NONNULL_PTR arg);
/* @internal */
export function UnsignedChannelUpdate_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedChannelUpdate_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKUnsignedChannelUpdate UnsignedChannelUpdate_clone(const struct LDKUnsignedChannelUpdate *NONNULL_PTR orig);
/* @internal */
export function UnsignedChannelUpdate_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedChannelUpdate_clone(orig);
	return nativeResponseValue;
}
	// void ChannelUpdate_free(struct LDKChannelUpdate this_obj);
/* @internal */
export function ChannelUpdate_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelUpdate_free(this_obj);
	// debug statements here
}
	// struct LDKSignature ChannelUpdate_get_signature(const struct LDKChannelUpdate *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelUpdate_get_signature(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelUpdate_get_signature(this_ptr);
	return nativeResponseValue;
}
	// void ChannelUpdate_set_signature(struct LDKChannelUpdate *NONNULL_PTR this_ptr, struct LDKSignature val);
/* @internal */
export function ChannelUpdate_set_signature(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelUpdate_set_signature(this_ptr, val);
	// debug statements here
}
	// struct LDKUnsignedChannelUpdate ChannelUpdate_get_contents(const struct LDKChannelUpdate *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelUpdate_get_contents(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelUpdate_get_contents(this_ptr);
	return nativeResponseValue;
}
	// void ChannelUpdate_set_contents(struct LDKChannelUpdate *NONNULL_PTR this_ptr, struct LDKUnsignedChannelUpdate val);
/* @internal */
export function ChannelUpdate_set_contents(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelUpdate_set_contents(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKChannelUpdate ChannelUpdate_new(struct LDKSignature signature_arg, struct LDKUnsignedChannelUpdate contents_arg);
/* @internal */
export function ChannelUpdate_new(signature_arg: number, contents_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelUpdate_new(signature_arg, contents_arg);
	return nativeResponseValue;
}
	// uintptr_t ChannelUpdate_clone_ptr(LDKChannelUpdate *NONNULL_PTR arg);
/* @internal */
export function ChannelUpdate_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelUpdate_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKChannelUpdate ChannelUpdate_clone(const struct LDKChannelUpdate *NONNULL_PTR orig);
/* @internal */
export function ChannelUpdate_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelUpdate_clone(orig);
	return nativeResponseValue;
}
	// void QueryChannelRange_free(struct LDKQueryChannelRange this_obj);
/* @internal */
export function QueryChannelRange_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_QueryChannelRange_free(this_obj);
	// debug statements here
}
	// const uint8_t (*QueryChannelRange_get_chain_hash(const struct LDKQueryChannelRange *NONNULL_PTR this_ptr))[32];
/* @internal */
export function QueryChannelRange_get_chain_hash(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_QueryChannelRange_get_chain_hash(this_ptr);
	return nativeResponseValue;
}
	// void QueryChannelRange_set_chain_hash(struct LDKQueryChannelRange *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function QueryChannelRange_set_chain_hash(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_QueryChannelRange_set_chain_hash(this_ptr, val);
	// debug statements here
}
	// uint32_t QueryChannelRange_get_first_blocknum(const struct LDKQueryChannelRange *NONNULL_PTR this_ptr);
/* @internal */
export function QueryChannelRange_get_first_blocknum(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_QueryChannelRange_get_first_blocknum(this_ptr);
	return nativeResponseValue;
}
	// void QueryChannelRange_set_first_blocknum(struct LDKQueryChannelRange *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */
export function QueryChannelRange_set_first_blocknum(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_QueryChannelRange_set_first_blocknum(this_ptr, val);
	// debug statements here
}
	// uint32_t QueryChannelRange_get_number_of_blocks(const struct LDKQueryChannelRange *NONNULL_PTR this_ptr);
/* @internal */
export function QueryChannelRange_get_number_of_blocks(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_QueryChannelRange_get_number_of_blocks(this_ptr);
	return nativeResponseValue;
}
	// void QueryChannelRange_set_number_of_blocks(struct LDKQueryChannelRange *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */
export function QueryChannelRange_set_number_of_blocks(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_QueryChannelRange_set_number_of_blocks(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKQueryChannelRange QueryChannelRange_new(struct LDKThirtyTwoBytes chain_hash_arg, uint32_t first_blocknum_arg, uint32_t number_of_blocks_arg);
/* @internal */
export function QueryChannelRange_new(chain_hash_arg: number, first_blocknum_arg: number, number_of_blocks_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_QueryChannelRange_new(chain_hash_arg, first_blocknum_arg, number_of_blocks_arg);
	return nativeResponseValue;
}
	// uintptr_t QueryChannelRange_clone_ptr(LDKQueryChannelRange *NONNULL_PTR arg);
/* @internal */
export function QueryChannelRange_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_QueryChannelRange_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKQueryChannelRange QueryChannelRange_clone(const struct LDKQueryChannelRange *NONNULL_PTR orig);
/* @internal */
export function QueryChannelRange_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_QueryChannelRange_clone(orig);
	return nativeResponseValue;
}
	// void ReplyChannelRange_free(struct LDKReplyChannelRange this_obj);
/* @internal */
export function ReplyChannelRange_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ReplyChannelRange_free(this_obj);
	// debug statements here
}
	// const uint8_t (*ReplyChannelRange_get_chain_hash(const struct LDKReplyChannelRange *NONNULL_PTR this_ptr))[32];
/* @internal */
export function ReplyChannelRange_get_chain_hash(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ReplyChannelRange_get_chain_hash(this_ptr);
	return nativeResponseValue;
}
	// void ReplyChannelRange_set_chain_hash(struct LDKReplyChannelRange *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function ReplyChannelRange_set_chain_hash(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ReplyChannelRange_set_chain_hash(this_ptr, val);
	// debug statements here
}
	// uint32_t ReplyChannelRange_get_first_blocknum(const struct LDKReplyChannelRange *NONNULL_PTR this_ptr);
/* @internal */
export function ReplyChannelRange_get_first_blocknum(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ReplyChannelRange_get_first_blocknum(this_ptr);
	return nativeResponseValue;
}
	// void ReplyChannelRange_set_first_blocknum(struct LDKReplyChannelRange *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */
export function ReplyChannelRange_set_first_blocknum(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ReplyChannelRange_set_first_blocknum(this_ptr, val);
	// debug statements here
}
	// uint32_t ReplyChannelRange_get_number_of_blocks(const struct LDKReplyChannelRange *NONNULL_PTR this_ptr);
/* @internal */
export function ReplyChannelRange_get_number_of_blocks(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ReplyChannelRange_get_number_of_blocks(this_ptr);
	return nativeResponseValue;
}
	// void ReplyChannelRange_set_number_of_blocks(struct LDKReplyChannelRange *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */
export function ReplyChannelRange_set_number_of_blocks(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ReplyChannelRange_set_number_of_blocks(this_ptr, val);
	// debug statements here
}
	// bool ReplyChannelRange_get_sync_complete(const struct LDKReplyChannelRange *NONNULL_PTR this_ptr);
/* @internal */
export function ReplyChannelRange_get_sync_complete(this_ptr: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ReplyChannelRange_get_sync_complete(this_ptr);
	return nativeResponseValue;
}
	// void ReplyChannelRange_set_sync_complete(struct LDKReplyChannelRange *NONNULL_PTR this_ptr, bool val);
/* @internal */
export function ReplyChannelRange_set_sync_complete(this_ptr: number, val: boolean): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ReplyChannelRange_set_sync_complete(this_ptr, val);
	// debug statements here
}
	// void ReplyChannelRange_set_short_channel_ids(struct LDKReplyChannelRange *NONNULL_PTR this_ptr, struct LDKCVec_u64Z val);
/* @internal */
export function ReplyChannelRange_set_short_channel_ids(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ReplyChannelRange_set_short_channel_ids(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKReplyChannelRange ReplyChannelRange_new(struct LDKThirtyTwoBytes chain_hash_arg, uint32_t first_blocknum_arg, uint32_t number_of_blocks_arg, bool sync_complete_arg, struct LDKCVec_u64Z short_channel_ids_arg);
/* @internal */
export function ReplyChannelRange_new(chain_hash_arg: number, first_blocknum_arg: number, number_of_blocks_arg: number, sync_complete_arg: boolean, short_channel_ids_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ReplyChannelRange_new(chain_hash_arg, first_blocknum_arg, number_of_blocks_arg, sync_complete_arg, short_channel_ids_arg);
	return nativeResponseValue;
}
	// uintptr_t ReplyChannelRange_clone_ptr(LDKReplyChannelRange *NONNULL_PTR arg);
/* @internal */
export function ReplyChannelRange_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ReplyChannelRange_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKReplyChannelRange ReplyChannelRange_clone(const struct LDKReplyChannelRange *NONNULL_PTR orig);
/* @internal */
export function ReplyChannelRange_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ReplyChannelRange_clone(orig);
	return nativeResponseValue;
}
	// void QueryShortChannelIds_free(struct LDKQueryShortChannelIds this_obj);
/* @internal */
export function QueryShortChannelIds_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_QueryShortChannelIds_free(this_obj);
	// debug statements here
}
	// const uint8_t (*QueryShortChannelIds_get_chain_hash(const struct LDKQueryShortChannelIds *NONNULL_PTR this_ptr))[32];
/* @internal */
export function QueryShortChannelIds_get_chain_hash(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_QueryShortChannelIds_get_chain_hash(this_ptr);
	return nativeResponseValue;
}
	// void QueryShortChannelIds_set_chain_hash(struct LDKQueryShortChannelIds *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function QueryShortChannelIds_set_chain_hash(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_QueryShortChannelIds_set_chain_hash(this_ptr, val);
	// debug statements here
}
	// void QueryShortChannelIds_set_short_channel_ids(struct LDKQueryShortChannelIds *NONNULL_PTR this_ptr, struct LDKCVec_u64Z val);
/* @internal */
export function QueryShortChannelIds_set_short_channel_ids(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_QueryShortChannelIds_set_short_channel_ids(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKQueryShortChannelIds QueryShortChannelIds_new(struct LDKThirtyTwoBytes chain_hash_arg, struct LDKCVec_u64Z short_channel_ids_arg);
/* @internal */
export function QueryShortChannelIds_new(chain_hash_arg: number, short_channel_ids_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_QueryShortChannelIds_new(chain_hash_arg, short_channel_ids_arg);
	return nativeResponseValue;
}
	// uintptr_t QueryShortChannelIds_clone_ptr(LDKQueryShortChannelIds *NONNULL_PTR arg);
/* @internal */
export function QueryShortChannelIds_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_QueryShortChannelIds_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKQueryShortChannelIds QueryShortChannelIds_clone(const struct LDKQueryShortChannelIds *NONNULL_PTR orig);
/* @internal */
export function QueryShortChannelIds_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_QueryShortChannelIds_clone(orig);
	return nativeResponseValue;
}
	// void ReplyShortChannelIdsEnd_free(struct LDKReplyShortChannelIdsEnd this_obj);
/* @internal */
export function ReplyShortChannelIdsEnd_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ReplyShortChannelIdsEnd_free(this_obj);
	// debug statements here
}
	// const uint8_t (*ReplyShortChannelIdsEnd_get_chain_hash(const struct LDKReplyShortChannelIdsEnd *NONNULL_PTR this_ptr))[32];
/* @internal */
export function ReplyShortChannelIdsEnd_get_chain_hash(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ReplyShortChannelIdsEnd_get_chain_hash(this_ptr);
	return nativeResponseValue;
}
	// void ReplyShortChannelIdsEnd_set_chain_hash(struct LDKReplyShortChannelIdsEnd *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function ReplyShortChannelIdsEnd_set_chain_hash(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ReplyShortChannelIdsEnd_set_chain_hash(this_ptr, val);
	// debug statements here
}
	// bool ReplyShortChannelIdsEnd_get_full_information(const struct LDKReplyShortChannelIdsEnd *NONNULL_PTR this_ptr);
/* @internal */
export function ReplyShortChannelIdsEnd_get_full_information(this_ptr: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ReplyShortChannelIdsEnd_get_full_information(this_ptr);
	return nativeResponseValue;
}
	// void ReplyShortChannelIdsEnd_set_full_information(struct LDKReplyShortChannelIdsEnd *NONNULL_PTR this_ptr, bool val);
/* @internal */
export function ReplyShortChannelIdsEnd_set_full_information(this_ptr: number, val: boolean): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ReplyShortChannelIdsEnd_set_full_information(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKReplyShortChannelIdsEnd ReplyShortChannelIdsEnd_new(struct LDKThirtyTwoBytes chain_hash_arg, bool full_information_arg);
/* @internal */
export function ReplyShortChannelIdsEnd_new(chain_hash_arg: number, full_information_arg: boolean): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ReplyShortChannelIdsEnd_new(chain_hash_arg, full_information_arg);
	return nativeResponseValue;
}
	// uintptr_t ReplyShortChannelIdsEnd_clone_ptr(LDKReplyShortChannelIdsEnd *NONNULL_PTR arg);
/* @internal */
export function ReplyShortChannelIdsEnd_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ReplyShortChannelIdsEnd_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKReplyShortChannelIdsEnd ReplyShortChannelIdsEnd_clone(const struct LDKReplyShortChannelIdsEnd *NONNULL_PTR orig);
/* @internal */
export function ReplyShortChannelIdsEnd_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ReplyShortChannelIdsEnd_clone(orig);
	return nativeResponseValue;
}
	// void GossipTimestampFilter_free(struct LDKGossipTimestampFilter this_obj);
/* @internal */
export function GossipTimestampFilter_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_GossipTimestampFilter_free(this_obj);
	// debug statements here
}
	// const uint8_t (*GossipTimestampFilter_get_chain_hash(const struct LDKGossipTimestampFilter *NONNULL_PTR this_ptr))[32];
/* @internal */
export function GossipTimestampFilter_get_chain_hash(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_GossipTimestampFilter_get_chain_hash(this_ptr);
	return nativeResponseValue;
}
	// void GossipTimestampFilter_set_chain_hash(struct LDKGossipTimestampFilter *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function GossipTimestampFilter_set_chain_hash(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_GossipTimestampFilter_set_chain_hash(this_ptr, val);
	// debug statements here
}
	// uint32_t GossipTimestampFilter_get_first_timestamp(const struct LDKGossipTimestampFilter *NONNULL_PTR this_ptr);
/* @internal */
export function GossipTimestampFilter_get_first_timestamp(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_GossipTimestampFilter_get_first_timestamp(this_ptr);
	return nativeResponseValue;
}
	// void GossipTimestampFilter_set_first_timestamp(struct LDKGossipTimestampFilter *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */
export function GossipTimestampFilter_set_first_timestamp(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_GossipTimestampFilter_set_first_timestamp(this_ptr, val);
	// debug statements here
}
	// uint32_t GossipTimestampFilter_get_timestamp_range(const struct LDKGossipTimestampFilter *NONNULL_PTR this_ptr);
/* @internal */
export function GossipTimestampFilter_get_timestamp_range(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_GossipTimestampFilter_get_timestamp_range(this_ptr);
	return nativeResponseValue;
}
	// void GossipTimestampFilter_set_timestamp_range(struct LDKGossipTimestampFilter *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */
export function GossipTimestampFilter_set_timestamp_range(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_GossipTimestampFilter_set_timestamp_range(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKGossipTimestampFilter GossipTimestampFilter_new(struct LDKThirtyTwoBytes chain_hash_arg, uint32_t first_timestamp_arg, uint32_t timestamp_range_arg);
/* @internal */
export function GossipTimestampFilter_new(chain_hash_arg: number, first_timestamp_arg: number, timestamp_range_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_GossipTimestampFilter_new(chain_hash_arg, first_timestamp_arg, timestamp_range_arg);
	return nativeResponseValue;
}
	// uintptr_t GossipTimestampFilter_clone_ptr(LDKGossipTimestampFilter *NONNULL_PTR arg);
/* @internal */
export function GossipTimestampFilter_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_GossipTimestampFilter_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKGossipTimestampFilter GossipTimestampFilter_clone(const struct LDKGossipTimestampFilter *NONNULL_PTR orig);
/* @internal */
export function GossipTimestampFilter_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_GossipTimestampFilter_clone(orig);
	return nativeResponseValue;
}
	// void ErrorAction_free(struct LDKErrorAction this_ptr);
/* @internal */
export function ErrorAction_free(this_ptr: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ErrorAction_free(this_ptr);
	// debug statements here
}
	// uintptr_t ErrorAction_clone_ptr(LDKErrorAction *NONNULL_PTR arg);
/* @internal */
export function ErrorAction_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ErrorAction_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKErrorAction ErrorAction_clone(const struct LDKErrorAction *NONNULL_PTR orig);
/* @internal */
export function ErrorAction_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ErrorAction_clone(orig);
	return nativeResponseValue;
}
	// struct LDKErrorAction ErrorAction_disconnect_peer(struct LDKErrorMessage msg);
/* @internal */
export function ErrorAction_disconnect_peer(msg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ErrorAction_disconnect_peer(msg);
	return nativeResponseValue;
}
	// struct LDKErrorAction ErrorAction_ignore_error(void);
/* @internal */
export function ErrorAction_ignore_error(): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ErrorAction_ignore_error();
	return nativeResponseValue;
}
	// struct LDKErrorAction ErrorAction_ignore_and_log(enum LDKLevel a);
/* @internal */
export function ErrorAction_ignore_and_log(a: Level): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ErrorAction_ignore_and_log(a);
	return nativeResponseValue;
}
	// struct LDKErrorAction ErrorAction_ignore_duplicate_gossip(void);
/* @internal */
export function ErrorAction_ignore_duplicate_gossip(): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ErrorAction_ignore_duplicate_gossip();
	return nativeResponseValue;
}
	// struct LDKErrorAction ErrorAction_send_error_message(struct LDKErrorMessage msg);
/* @internal */
export function ErrorAction_send_error_message(msg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ErrorAction_send_error_message(msg);
	return nativeResponseValue;
}
	// struct LDKErrorAction ErrorAction_send_warning_message(struct LDKWarningMessage msg, enum LDKLevel log_level);
/* @internal */
export function ErrorAction_send_warning_message(msg: number, log_level: Level): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ErrorAction_send_warning_message(msg, log_level);
	return nativeResponseValue;
}
	// void LightningError_free(struct LDKLightningError this_obj);
/* @internal */
export function LightningError_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LightningError_free(this_obj);
	// debug statements here
}
	// struct LDKStr LightningError_get_err(const struct LDKLightningError *NONNULL_PTR this_ptr);
/* @internal */
export function LightningError_get_err(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LightningError_get_err(this_ptr);
	return nativeResponseValue;
}
	// void LightningError_set_err(struct LDKLightningError *NONNULL_PTR this_ptr, struct LDKStr val);
/* @internal */
export function LightningError_set_err(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LightningError_set_err(this_ptr, val);
	// debug statements here
}
	// struct LDKErrorAction LightningError_get_action(const struct LDKLightningError *NONNULL_PTR this_ptr);
/* @internal */
export function LightningError_get_action(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LightningError_get_action(this_ptr);
	return nativeResponseValue;
}
	// void LightningError_set_action(struct LDKLightningError *NONNULL_PTR this_ptr, struct LDKErrorAction val);
/* @internal */
export function LightningError_set_action(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LightningError_set_action(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKLightningError LightningError_new(struct LDKStr err_arg, struct LDKErrorAction action_arg);
/* @internal */
export function LightningError_new(err_arg: number, action_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LightningError_new(err_arg, action_arg);
	return nativeResponseValue;
}
	// uintptr_t LightningError_clone_ptr(LDKLightningError *NONNULL_PTR arg);
/* @internal */
export function LightningError_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LightningError_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKLightningError LightningError_clone(const struct LDKLightningError *NONNULL_PTR orig);
/* @internal */
export function LightningError_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LightningError_clone(orig);
	return nativeResponseValue;
}
	// void CommitmentUpdate_free(struct LDKCommitmentUpdate this_obj);
/* @internal */
export function CommitmentUpdate_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CommitmentUpdate_free(this_obj);
	// debug statements here
}
	// struct LDKCVec_UpdateAddHTLCZ CommitmentUpdate_get_update_add_htlcs(const struct LDKCommitmentUpdate *NONNULL_PTR this_ptr);
/* @internal */
export function CommitmentUpdate_get_update_add_htlcs(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CommitmentUpdate_get_update_add_htlcs(this_ptr);
	return nativeResponseValue;
}
	// void CommitmentUpdate_set_update_add_htlcs(struct LDKCommitmentUpdate *NONNULL_PTR this_ptr, struct LDKCVec_UpdateAddHTLCZ val);
/* @internal */
export function CommitmentUpdate_set_update_add_htlcs(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CommitmentUpdate_set_update_add_htlcs(this_ptr, val);
	// debug statements here
}
	// struct LDKCVec_UpdateFulfillHTLCZ CommitmentUpdate_get_update_fulfill_htlcs(const struct LDKCommitmentUpdate *NONNULL_PTR this_ptr);
/* @internal */
export function CommitmentUpdate_get_update_fulfill_htlcs(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CommitmentUpdate_get_update_fulfill_htlcs(this_ptr);
	return nativeResponseValue;
}
	// void CommitmentUpdate_set_update_fulfill_htlcs(struct LDKCommitmentUpdate *NONNULL_PTR this_ptr, struct LDKCVec_UpdateFulfillHTLCZ val);
/* @internal */
export function CommitmentUpdate_set_update_fulfill_htlcs(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CommitmentUpdate_set_update_fulfill_htlcs(this_ptr, val);
	// debug statements here
}
	// struct LDKCVec_UpdateFailHTLCZ CommitmentUpdate_get_update_fail_htlcs(const struct LDKCommitmentUpdate *NONNULL_PTR this_ptr);
/* @internal */
export function CommitmentUpdate_get_update_fail_htlcs(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CommitmentUpdate_get_update_fail_htlcs(this_ptr);
	return nativeResponseValue;
}
	// void CommitmentUpdate_set_update_fail_htlcs(struct LDKCommitmentUpdate *NONNULL_PTR this_ptr, struct LDKCVec_UpdateFailHTLCZ val);
/* @internal */
export function CommitmentUpdate_set_update_fail_htlcs(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CommitmentUpdate_set_update_fail_htlcs(this_ptr, val);
	// debug statements here
}
	// struct LDKCVec_UpdateFailMalformedHTLCZ CommitmentUpdate_get_update_fail_malformed_htlcs(const struct LDKCommitmentUpdate *NONNULL_PTR this_ptr);
/* @internal */
export function CommitmentUpdate_get_update_fail_malformed_htlcs(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CommitmentUpdate_get_update_fail_malformed_htlcs(this_ptr);
	return nativeResponseValue;
}
	// void CommitmentUpdate_set_update_fail_malformed_htlcs(struct LDKCommitmentUpdate *NONNULL_PTR this_ptr, struct LDKCVec_UpdateFailMalformedHTLCZ val);
/* @internal */
export function CommitmentUpdate_set_update_fail_malformed_htlcs(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CommitmentUpdate_set_update_fail_malformed_htlcs(this_ptr, val);
	// debug statements here
}
	// struct LDKUpdateFee CommitmentUpdate_get_update_fee(const struct LDKCommitmentUpdate *NONNULL_PTR this_ptr);
/* @internal */
export function CommitmentUpdate_get_update_fee(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CommitmentUpdate_get_update_fee(this_ptr);
	return nativeResponseValue;
}
	// void CommitmentUpdate_set_update_fee(struct LDKCommitmentUpdate *NONNULL_PTR this_ptr, struct LDKUpdateFee val);
/* @internal */
export function CommitmentUpdate_set_update_fee(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CommitmentUpdate_set_update_fee(this_ptr, val);
	// debug statements here
}
	// struct LDKCommitmentSigned CommitmentUpdate_get_commitment_signed(const struct LDKCommitmentUpdate *NONNULL_PTR this_ptr);
/* @internal */
export function CommitmentUpdate_get_commitment_signed(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CommitmentUpdate_get_commitment_signed(this_ptr);
	return nativeResponseValue;
}
	// void CommitmentUpdate_set_commitment_signed(struct LDKCommitmentUpdate *NONNULL_PTR this_ptr, struct LDKCommitmentSigned val);
/* @internal */
export function CommitmentUpdate_set_commitment_signed(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CommitmentUpdate_set_commitment_signed(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKCommitmentUpdate CommitmentUpdate_new(struct LDKCVec_UpdateAddHTLCZ update_add_htlcs_arg, struct LDKCVec_UpdateFulfillHTLCZ update_fulfill_htlcs_arg, struct LDKCVec_UpdateFailHTLCZ update_fail_htlcs_arg, struct LDKCVec_UpdateFailMalformedHTLCZ update_fail_malformed_htlcs_arg, struct LDKUpdateFee update_fee_arg, struct LDKCommitmentSigned commitment_signed_arg);
/* @internal */
export function CommitmentUpdate_new(update_add_htlcs_arg: number, update_fulfill_htlcs_arg: number, update_fail_htlcs_arg: number, update_fail_malformed_htlcs_arg: number, update_fee_arg: number, commitment_signed_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CommitmentUpdate_new(update_add_htlcs_arg, update_fulfill_htlcs_arg, update_fail_htlcs_arg, update_fail_malformed_htlcs_arg, update_fee_arg, commitment_signed_arg);
	return nativeResponseValue;
}
	// uintptr_t CommitmentUpdate_clone_ptr(LDKCommitmentUpdate *NONNULL_PTR arg);
/* @internal */
export function CommitmentUpdate_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CommitmentUpdate_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCommitmentUpdate CommitmentUpdate_clone(const struct LDKCommitmentUpdate *NONNULL_PTR orig);
/* @internal */
export function CommitmentUpdate_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CommitmentUpdate_clone(orig);
	return nativeResponseValue;
}
	// void ChannelMessageHandler_free(struct LDKChannelMessageHandler this_ptr);
/* @internal */
export function ChannelMessageHandler_free(this_ptr: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelMessageHandler_free(this_ptr);
	// debug statements here
}
	// void RoutingMessageHandler_free(struct LDKRoutingMessageHandler this_ptr);
/* @internal */
export function RoutingMessageHandler_free(this_ptr: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RoutingMessageHandler_free(this_ptr);
	// debug statements here
}
	// struct LDKCVec_u8Z AcceptChannel_write(const struct LDKAcceptChannel *NONNULL_PTR obj);
/* @internal */
export function AcceptChannel_write(obj: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannel_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_AcceptChannelDecodeErrorZ AcceptChannel_read(struct LDKu8slice ser);
/* @internal */
export function AcceptChannel_read(ser: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AcceptChannel_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z AnnouncementSignatures_write(const struct LDKAnnouncementSignatures *NONNULL_PTR obj);
/* @internal */
export function AnnouncementSignatures_write(obj: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AnnouncementSignatures_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_AnnouncementSignaturesDecodeErrorZ AnnouncementSignatures_read(struct LDKu8slice ser);
/* @internal */
export function AnnouncementSignatures_read(ser: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_AnnouncementSignatures_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z ChannelReestablish_write(const struct LDKChannelReestablish *NONNULL_PTR obj);
/* @internal */
export function ChannelReestablish_write(obj: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelReestablish_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelReestablishDecodeErrorZ ChannelReestablish_read(struct LDKu8slice ser);
/* @internal */
export function ChannelReestablish_read(ser: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelReestablish_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z ClosingSigned_write(const struct LDKClosingSigned *NONNULL_PTR obj);
/* @internal */
export function ClosingSigned_write(obj: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosingSigned_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_ClosingSignedDecodeErrorZ ClosingSigned_read(struct LDKu8slice ser);
/* @internal */
export function ClosingSigned_read(ser: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosingSigned_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z ClosingSignedFeeRange_write(const struct LDKClosingSignedFeeRange *NONNULL_PTR obj);
/* @internal */
export function ClosingSignedFeeRange_write(obj: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosingSignedFeeRange_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_ClosingSignedFeeRangeDecodeErrorZ ClosingSignedFeeRange_read(struct LDKu8slice ser);
/* @internal */
export function ClosingSignedFeeRange_read(ser: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosingSignedFeeRange_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z CommitmentSigned_write(const struct LDKCommitmentSigned *NONNULL_PTR obj);
/* @internal */
export function CommitmentSigned_write(obj: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CommitmentSigned_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_CommitmentSignedDecodeErrorZ CommitmentSigned_read(struct LDKu8slice ser);
/* @internal */
export function CommitmentSigned_read(ser: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CommitmentSigned_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z FundingCreated_write(const struct LDKFundingCreated *NONNULL_PTR obj);
/* @internal */
export function FundingCreated_write(obj: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_FundingCreated_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_FundingCreatedDecodeErrorZ FundingCreated_read(struct LDKu8slice ser);
/* @internal */
export function FundingCreated_read(ser: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_FundingCreated_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z FundingSigned_write(const struct LDKFundingSigned *NONNULL_PTR obj);
/* @internal */
export function FundingSigned_write(obj: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_FundingSigned_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_FundingSignedDecodeErrorZ FundingSigned_read(struct LDKu8slice ser);
/* @internal */
export function FundingSigned_read(ser: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_FundingSigned_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z FundingLocked_write(const struct LDKFundingLocked *NONNULL_PTR obj);
/* @internal */
export function FundingLocked_write(obj: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_FundingLocked_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_FundingLockedDecodeErrorZ FundingLocked_read(struct LDKu8slice ser);
/* @internal */
export function FundingLocked_read(ser: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_FundingLocked_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z Init_write(const struct LDKInit *NONNULL_PTR obj);
/* @internal */
export function Init_write(obj: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Init_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_InitDecodeErrorZ Init_read(struct LDKu8slice ser);
/* @internal */
export function Init_read(ser: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Init_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z OpenChannel_write(const struct LDKOpenChannel *NONNULL_PTR obj);
/* @internal */
export function OpenChannel_write(obj: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannel_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_OpenChannelDecodeErrorZ OpenChannel_read(struct LDKu8slice ser);
/* @internal */
export function OpenChannel_read(ser: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_OpenChannel_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z RevokeAndACK_write(const struct LDKRevokeAndACK *NONNULL_PTR obj);
/* @internal */
export function RevokeAndACK_write(obj: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RevokeAndACK_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_RevokeAndACKDecodeErrorZ RevokeAndACK_read(struct LDKu8slice ser);
/* @internal */
export function RevokeAndACK_read(ser: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RevokeAndACK_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z Shutdown_write(const struct LDKShutdown *NONNULL_PTR obj);
/* @internal */
export function Shutdown_write(obj: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Shutdown_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_ShutdownDecodeErrorZ Shutdown_read(struct LDKu8slice ser);
/* @internal */
export function Shutdown_read(ser: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Shutdown_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z UpdateFailHTLC_write(const struct LDKUpdateFailHTLC *NONNULL_PTR obj);
/* @internal */
export function UpdateFailHTLC_write(obj: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateFailHTLC_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_UpdateFailHTLCDecodeErrorZ UpdateFailHTLC_read(struct LDKu8slice ser);
/* @internal */
export function UpdateFailHTLC_read(ser: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateFailHTLC_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z UpdateFailMalformedHTLC_write(const struct LDKUpdateFailMalformedHTLC *NONNULL_PTR obj);
/* @internal */
export function UpdateFailMalformedHTLC_write(obj: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateFailMalformedHTLC_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ UpdateFailMalformedHTLC_read(struct LDKu8slice ser);
/* @internal */
export function UpdateFailMalformedHTLC_read(ser: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateFailMalformedHTLC_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z UpdateFee_write(const struct LDKUpdateFee *NONNULL_PTR obj);
/* @internal */
export function UpdateFee_write(obj: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateFee_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_UpdateFeeDecodeErrorZ UpdateFee_read(struct LDKu8slice ser);
/* @internal */
export function UpdateFee_read(ser: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateFee_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z UpdateFulfillHTLC_write(const struct LDKUpdateFulfillHTLC *NONNULL_PTR obj);
/* @internal */
export function UpdateFulfillHTLC_write(obj: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateFulfillHTLC_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_UpdateFulfillHTLCDecodeErrorZ UpdateFulfillHTLC_read(struct LDKu8slice ser);
/* @internal */
export function UpdateFulfillHTLC_read(ser: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateFulfillHTLC_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z UpdateAddHTLC_write(const struct LDKUpdateAddHTLC *NONNULL_PTR obj);
/* @internal */
export function UpdateAddHTLC_write(obj: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateAddHTLC_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_UpdateAddHTLCDecodeErrorZ UpdateAddHTLC_read(struct LDKu8slice ser);
/* @internal */
export function UpdateAddHTLC_read(ser: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UpdateAddHTLC_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z Ping_write(const struct LDKPing *NONNULL_PTR obj);
/* @internal */
export function Ping_write(obj: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Ping_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_PingDecodeErrorZ Ping_read(struct LDKu8slice ser);
/* @internal */
export function Ping_read(ser: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Ping_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z Pong_write(const struct LDKPong *NONNULL_PTR obj);
/* @internal */
export function Pong_write(obj: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Pong_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_PongDecodeErrorZ Pong_read(struct LDKu8slice ser);
/* @internal */
export function Pong_read(ser: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Pong_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z UnsignedChannelAnnouncement_write(const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR obj);
/* @internal */
export function UnsignedChannelAnnouncement_write(obj: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedChannelAnnouncement_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ UnsignedChannelAnnouncement_read(struct LDKu8slice ser);
/* @internal */
export function UnsignedChannelAnnouncement_read(ser: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedChannelAnnouncement_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z ChannelAnnouncement_write(const struct LDKChannelAnnouncement *NONNULL_PTR obj);
/* @internal */
export function ChannelAnnouncement_write(obj: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelAnnouncement_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelAnnouncementDecodeErrorZ ChannelAnnouncement_read(struct LDKu8slice ser);
/* @internal */
export function ChannelAnnouncement_read(ser: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelAnnouncement_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z UnsignedChannelUpdate_write(const struct LDKUnsignedChannelUpdate *NONNULL_PTR obj);
/* @internal */
export function UnsignedChannelUpdate_write(obj: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedChannelUpdate_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_UnsignedChannelUpdateDecodeErrorZ UnsignedChannelUpdate_read(struct LDKu8slice ser);
/* @internal */
export function UnsignedChannelUpdate_read(ser: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedChannelUpdate_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z ChannelUpdate_write(const struct LDKChannelUpdate *NONNULL_PTR obj);
/* @internal */
export function ChannelUpdate_write(obj: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelUpdate_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelUpdateDecodeErrorZ ChannelUpdate_read(struct LDKu8slice ser);
/* @internal */
export function ChannelUpdate_read(ser: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelUpdate_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z ErrorMessage_write(const struct LDKErrorMessage *NONNULL_PTR obj);
/* @internal */
export function ErrorMessage_write(obj: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ErrorMessage_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_ErrorMessageDecodeErrorZ ErrorMessage_read(struct LDKu8slice ser);
/* @internal */
export function ErrorMessage_read(ser: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ErrorMessage_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z WarningMessage_write(const struct LDKWarningMessage *NONNULL_PTR obj);
/* @internal */
export function WarningMessage_write(obj: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_WarningMessage_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_WarningMessageDecodeErrorZ WarningMessage_read(struct LDKu8slice ser);
/* @internal */
export function WarningMessage_read(ser: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_WarningMessage_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z UnsignedNodeAnnouncement_write(const struct LDKUnsignedNodeAnnouncement *NONNULL_PTR obj);
/* @internal */
export function UnsignedNodeAnnouncement_write(obj: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedNodeAnnouncement_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ UnsignedNodeAnnouncement_read(struct LDKu8slice ser);
/* @internal */
export function UnsignedNodeAnnouncement_read(ser: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_UnsignedNodeAnnouncement_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z NodeAnnouncement_write(const struct LDKNodeAnnouncement *NONNULL_PTR obj);
/* @internal */
export function NodeAnnouncement_write(obj: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeAnnouncement_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_NodeAnnouncementDecodeErrorZ NodeAnnouncement_read(struct LDKu8slice ser);
/* @internal */
export function NodeAnnouncement_read(ser: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeAnnouncement_read(ser);
	return nativeResponseValue;
}
	// struct LDKCResult_QueryShortChannelIdsDecodeErrorZ QueryShortChannelIds_read(struct LDKu8slice ser);
/* @internal */
export function QueryShortChannelIds_read(ser: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_QueryShortChannelIds_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z QueryShortChannelIds_write(const struct LDKQueryShortChannelIds *NONNULL_PTR obj);
/* @internal */
export function QueryShortChannelIds_write(obj: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_QueryShortChannelIds_write(obj);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z ReplyShortChannelIdsEnd_write(const struct LDKReplyShortChannelIdsEnd *NONNULL_PTR obj);
/* @internal */
export function ReplyShortChannelIdsEnd_write(obj: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ReplyShortChannelIdsEnd_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ ReplyShortChannelIdsEnd_read(struct LDKu8slice ser);
/* @internal */
export function ReplyShortChannelIdsEnd_read(ser: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ReplyShortChannelIdsEnd_read(ser);
	return nativeResponseValue;
}
	// MUST_USE_RES uint32_t QueryChannelRange_end_blocknum(const struct LDKQueryChannelRange *NONNULL_PTR this_arg);
/* @internal */
export function QueryChannelRange_end_blocknum(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_QueryChannelRange_end_blocknum(this_arg);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z QueryChannelRange_write(const struct LDKQueryChannelRange *NONNULL_PTR obj);
/* @internal */
export function QueryChannelRange_write(obj: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_QueryChannelRange_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_QueryChannelRangeDecodeErrorZ QueryChannelRange_read(struct LDKu8slice ser);
/* @internal */
export function QueryChannelRange_read(ser: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_QueryChannelRange_read(ser);
	return nativeResponseValue;
}
	// struct LDKCResult_ReplyChannelRangeDecodeErrorZ ReplyChannelRange_read(struct LDKu8slice ser);
/* @internal */
export function ReplyChannelRange_read(ser: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ReplyChannelRange_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z ReplyChannelRange_write(const struct LDKReplyChannelRange *NONNULL_PTR obj);
/* @internal */
export function ReplyChannelRange_write(obj: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ReplyChannelRange_write(obj);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z GossipTimestampFilter_write(const struct LDKGossipTimestampFilter *NONNULL_PTR obj);
/* @internal */
export function GossipTimestampFilter_write(obj: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_GossipTimestampFilter_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_GossipTimestampFilterDecodeErrorZ GossipTimestampFilter_read(struct LDKu8slice ser);
/* @internal */
export function GossipTimestampFilter_read(ser: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_GossipTimestampFilter_read(ser);
	return nativeResponseValue;
}
	// void CustomMessageHandler_free(struct LDKCustomMessageHandler this_ptr);
/* @internal */
export function CustomMessageHandler_free(this_ptr: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CustomMessageHandler_free(this_ptr);
	// debug statements here
}
	// void IgnoringMessageHandler_free(struct LDKIgnoringMessageHandler this_obj);
/* @internal */
export function IgnoringMessageHandler_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_IgnoringMessageHandler_free(this_obj);
	// debug statements here
}
	// MUST_USE_RES struct LDKIgnoringMessageHandler IgnoringMessageHandler_new(void);
/* @internal */
export function IgnoringMessageHandler_new(): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_IgnoringMessageHandler_new();
	return nativeResponseValue;
}
	// struct LDKMessageSendEventsProvider IgnoringMessageHandler_as_MessageSendEventsProvider(const struct LDKIgnoringMessageHandler *NONNULL_PTR this_arg);
/* @internal */
export function IgnoringMessageHandler_as_MessageSendEventsProvider(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_IgnoringMessageHandler_as_MessageSendEventsProvider(this_arg);
	return nativeResponseValue;
}
	// struct LDKRoutingMessageHandler IgnoringMessageHandler_as_RoutingMessageHandler(const struct LDKIgnoringMessageHandler *NONNULL_PTR this_arg);
/* @internal */
export function IgnoringMessageHandler_as_RoutingMessageHandler(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_IgnoringMessageHandler_as_RoutingMessageHandler(this_arg);
	return nativeResponseValue;
}
	// struct LDKCustomMessageReader IgnoringMessageHandler_as_CustomMessageReader(const struct LDKIgnoringMessageHandler *NONNULL_PTR this_arg);
/* @internal */
export function IgnoringMessageHandler_as_CustomMessageReader(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_IgnoringMessageHandler_as_CustomMessageReader(this_arg);
	return nativeResponseValue;
}
	// struct LDKCustomMessageHandler IgnoringMessageHandler_as_CustomMessageHandler(const struct LDKIgnoringMessageHandler *NONNULL_PTR this_arg);
/* @internal */
export function IgnoringMessageHandler_as_CustomMessageHandler(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_IgnoringMessageHandler_as_CustomMessageHandler(this_arg);
	return nativeResponseValue;
}
	// void ErroringMessageHandler_free(struct LDKErroringMessageHandler this_obj);
/* @internal */
export function ErroringMessageHandler_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ErroringMessageHandler_free(this_obj);
	// debug statements here
}
	// MUST_USE_RES struct LDKErroringMessageHandler ErroringMessageHandler_new(void);
/* @internal */
export function ErroringMessageHandler_new(): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ErroringMessageHandler_new();
	return nativeResponseValue;
}
	// struct LDKMessageSendEventsProvider ErroringMessageHandler_as_MessageSendEventsProvider(const struct LDKErroringMessageHandler *NONNULL_PTR this_arg);
/* @internal */
export function ErroringMessageHandler_as_MessageSendEventsProvider(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ErroringMessageHandler_as_MessageSendEventsProvider(this_arg);
	return nativeResponseValue;
}
	// struct LDKChannelMessageHandler ErroringMessageHandler_as_ChannelMessageHandler(const struct LDKErroringMessageHandler *NONNULL_PTR this_arg);
/* @internal */
export function ErroringMessageHandler_as_ChannelMessageHandler(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ErroringMessageHandler_as_ChannelMessageHandler(this_arg);
	return nativeResponseValue;
}
	// void MessageHandler_free(struct LDKMessageHandler this_obj);
/* @internal */
export function MessageHandler_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MessageHandler_free(this_obj);
	// debug statements here
}
	// const struct LDKChannelMessageHandler *MessageHandler_get_chan_handler(const struct LDKMessageHandler *NONNULL_PTR this_ptr);
/* @internal */
export function MessageHandler_get_chan_handler(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MessageHandler_get_chan_handler(this_ptr);
	return nativeResponseValue;
}
	// void MessageHandler_set_chan_handler(struct LDKMessageHandler *NONNULL_PTR this_ptr, struct LDKChannelMessageHandler val);
/* @internal */
export function MessageHandler_set_chan_handler(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MessageHandler_set_chan_handler(this_ptr, val);
	// debug statements here
}
	// const struct LDKRoutingMessageHandler *MessageHandler_get_route_handler(const struct LDKMessageHandler *NONNULL_PTR this_ptr);
/* @internal */
export function MessageHandler_get_route_handler(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MessageHandler_get_route_handler(this_ptr);
	return nativeResponseValue;
}
	// void MessageHandler_set_route_handler(struct LDKMessageHandler *NONNULL_PTR this_ptr, struct LDKRoutingMessageHandler val);
/* @internal */
export function MessageHandler_set_route_handler(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MessageHandler_set_route_handler(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKMessageHandler MessageHandler_new(struct LDKChannelMessageHandler chan_handler_arg, struct LDKRoutingMessageHandler route_handler_arg);
/* @internal */
export function MessageHandler_new(chan_handler_arg: number, route_handler_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MessageHandler_new(chan_handler_arg, route_handler_arg);
	return nativeResponseValue;
}
	// uintptr_t SocketDescriptor_clone_ptr(LDKSocketDescriptor *NONNULL_PTR arg);
/* @internal */
export function SocketDescriptor_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SocketDescriptor_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKSocketDescriptor SocketDescriptor_clone(const struct LDKSocketDescriptor *NONNULL_PTR orig);
/* @internal */
export function SocketDescriptor_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SocketDescriptor_clone(orig);
	return nativeResponseValue;
}
	// void SocketDescriptor_free(struct LDKSocketDescriptor this_ptr);
/* @internal */
export function SocketDescriptor_free(this_ptr: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SocketDescriptor_free(this_ptr);
	// debug statements here
}
	// void PeerHandleError_free(struct LDKPeerHandleError this_obj);
/* @internal */
export function PeerHandleError_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PeerHandleError_free(this_obj);
	// debug statements here
}
	// bool PeerHandleError_get_no_connection_possible(const struct LDKPeerHandleError *NONNULL_PTR this_ptr);
/* @internal */
export function PeerHandleError_get_no_connection_possible(this_ptr: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PeerHandleError_get_no_connection_possible(this_ptr);
	return nativeResponseValue;
}
	// void PeerHandleError_set_no_connection_possible(struct LDKPeerHandleError *NONNULL_PTR this_ptr, bool val);
/* @internal */
export function PeerHandleError_set_no_connection_possible(this_ptr: number, val: boolean): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PeerHandleError_set_no_connection_possible(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKPeerHandleError PeerHandleError_new(bool no_connection_possible_arg);
/* @internal */
export function PeerHandleError_new(no_connection_possible_arg: boolean): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PeerHandleError_new(no_connection_possible_arg);
	return nativeResponseValue;
}
	// uintptr_t PeerHandleError_clone_ptr(LDKPeerHandleError *NONNULL_PTR arg);
/* @internal */
export function PeerHandleError_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PeerHandleError_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKPeerHandleError PeerHandleError_clone(const struct LDKPeerHandleError *NONNULL_PTR orig);
/* @internal */
export function PeerHandleError_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PeerHandleError_clone(orig);
	return nativeResponseValue;
}
	// void PeerManager_free(struct LDKPeerManager this_obj);
/* @internal */
export function PeerManager_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PeerManager_free(this_obj);
	// debug statements here
}
	// MUST_USE_RES struct LDKPeerManager PeerManager_new(struct LDKMessageHandler message_handler, struct LDKSecretKey our_node_secret, const uint8_t (*ephemeral_random_data)[32], struct LDKLogger logger, struct LDKCustomMessageHandler custom_message_handler);
/* @internal */
export function PeerManager_new(message_handler: number, our_node_secret: number, ephemeral_random_data: number, logger: number, custom_message_handler: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PeerManager_new(message_handler, our_node_secret, ephemeral_random_data, logger, custom_message_handler);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCVec_PublicKeyZ PeerManager_get_peer_node_ids(const struct LDKPeerManager *NONNULL_PTR this_arg);
/* @internal */
export function PeerManager_get_peer_node_ids(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PeerManager_get_peer_node_ids(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_CVec_u8ZPeerHandleErrorZ PeerManager_new_outbound_connection(const struct LDKPeerManager *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, struct LDKSocketDescriptor descriptor, struct LDKCOption_NetAddressZ remote_network_address);
/* @internal */
export function PeerManager_new_outbound_connection(this_arg: number, their_node_id: number, descriptor: number, remote_network_address: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PeerManager_new_outbound_connection(this_arg, their_node_id, descriptor, remote_network_address);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_NonePeerHandleErrorZ PeerManager_new_inbound_connection(const struct LDKPeerManager *NONNULL_PTR this_arg, struct LDKSocketDescriptor descriptor, struct LDKCOption_NetAddressZ remote_network_address);
/* @internal */
export function PeerManager_new_inbound_connection(this_arg: number, descriptor: number, remote_network_address: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PeerManager_new_inbound_connection(this_arg, descriptor, remote_network_address);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_NonePeerHandleErrorZ PeerManager_write_buffer_space_avail(const struct LDKPeerManager *NONNULL_PTR this_arg, struct LDKSocketDescriptor *NONNULL_PTR descriptor);
/* @internal */
export function PeerManager_write_buffer_space_avail(this_arg: number, descriptor: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PeerManager_write_buffer_space_avail(this_arg, descriptor);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_boolPeerHandleErrorZ PeerManager_read_event(const struct LDKPeerManager *NONNULL_PTR this_arg, struct LDKSocketDescriptor *NONNULL_PTR peer_descriptor, struct LDKu8slice data);
/* @internal */
export function PeerManager_read_event(this_arg: number, peer_descriptor: number, data: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PeerManager_read_event(this_arg, peer_descriptor, data);
	return nativeResponseValue;
}
	// void PeerManager_process_events(const struct LDKPeerManager *NONNULL_PTR this_arg);
/* @internal */
export function PeerManager_process_events(this_arg: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PeerManager_process_events(this_arg);
	// debug statements here
}
	// void PeerManager_socket_disconnected(const struct LDKPeerManager *NONNULL_PTR this_arg, const struct LDKSocketDescriptor *NONNULL_PTR descriptor);
/* @internal */
export function PeerManager_socket_disconnected(this_arg: number, descriptor: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PeerManager_socket_disconnected(this_arg, descriptor);
	// debug statements here
}
	// void PeerManager_disconnect_by_node_id(const struct LDKPeerManager *NONNULL_PTR this_arg, struct LDKPublicKey node_id, bool no_connection_possible);
/* @internal */
export function PeerManager_disconnect_by_node_id(this_arg: number, node_id: number, no_connection_possible: boolean): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PeerManager_disconnect_by_node_id(this_arg, node_id, no_connection_possible);
	// debug statements here
}
	// void PeerManager_disconnect_all_peers(const struct LDKPeerManager *NONNULL_PTR this_arg);
/* @internal */
export function PeerManager_disconnect_all_peers(this_arg: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PeerManager_disconnect_all_peers(this_arg);
	// debug statements here
}
	// void PeerManager_timer_tick_occurred(const struct LDKPeerManager *NONNULL_PTR this_arg);
/* @internal */
export function PeerManager_timer_tick_occurred(this_arg: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PeerManager_timer_tick_occurred(this_arg);
	// debug statements here
}
	// uint64_t htlc_success_tx_weight(bool opt_anchors);
/* @internal */
export function htlc_success_tx_weight(opt_anchors: boolean): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_htlc_success_tx_weight(opt_anchors);
	return nativeResponseValue;
}
	// uint64_t htlc_timeout_tx_weight(bool opt_anchors);
/* @internal */
export function htlc_timeout_tx_weight(opt_anchors: boolean): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_htlc_timeout_tx_weight(opt_anchors);
	return nativeResponseValue;
}
	// struct LDKThirtyTwoBytes build_commitment_secret(const uint8_t (*commitment_seed)[32], uint64_t idx);
/* @internal */
export function build_commitment_secret(commitment_seed: number, idx: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_build_commitment_secret(commitment_seed, idx);
	return nativeResponseValue;
}
	// struct LDKTransaction build_closing_transaction(uint64_t to_holder_value_sat, uint64_t to_counterparty_value_sat, struct LDKCVec_u8Z to_holder_script, struct LDKCVec_u8Z to_counterparty_script, struct LDKOutPoint funding_outpoint);
/* @internal */
export function build_closing_transaction(to_holder_value_sat: bigint, to_counterparty_value_sat: bigint, to_holder_script: number, to_counterparty_script: number, funding_outpoint: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_build_closing_transaction(to_holder_value_sat, to_counterparty_value_sat, to_holder_script, to_counterparty_script, funding_outpoint);
	return nativeResponseValue;
}
	// void CounterpartyCommitmentSecrets_free(struct LDKCounterpartyCommitmentSecrets this_obj);
/* @internal */
export function CounterpartyCommitmentSecrets_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CounterpartyCommitmentSecrets_free(this_obj);
	// debug statements here
}
	// uintptr_t CounterpartyCommitmentSecrets_clone_ptr(LDKCounterpartyCommitmentSecrets *NONNULL_PTR arg);
/* @internal */
export function CounterpartyCommitmentSecrets_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CounterpartyCommitmentSecrets_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCounterpartyCommitmentSecrets CounterpartyCommitmentSecrets_clone(const struct LDKCounterpartyCommitmentSecrets *NONNULL_PTR orig);
/* @internal */
export function CounterpartyCommitmentSecrets_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CounterpartyCommitmentSecrets_clone(orig);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCounterpartyCommitmentSecrets CounterpartyCommitmentSecrets_new(void);
/* @internal */
export function CounterpartyCommitmentSecrets_new(): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CounterpartyCommitmentSecrets_new();
	return nativeResponseValue;
}
	// MUST_USE_RES uint64_t CounterpartyCommitmentSecrets_get_min_seen_secret(const struct LDKCounterpartyCommitmentSecrets *NONNULL_PTR this_arg);
/* @internal */
export function CounterpartyCommitmentSecrets_get_min_seen_secret(this_arg: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CounterpartyCommitmentSecrets_get_min_seen_secret(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_NoneNoneZ CounterpartyCommitmentSecrets_provide_secret(struct LDKCounterpartyCommitmentSecrets *NONNULL_PTR this_arg, uint64_t idx, struct LDKThirtyTwoBytes secret);
/* @internal */
export function CounterpartyCommitmentSecrets_provide_secret(this_arg: number, idx: bigint, secret: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CounterpartyCommitmentSecrets_provide_secret(this_arg, idx, secret);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKThirtyTwoBytes CounterpartyCommitmentSecrets_get_secret(const struct LDKCounterpartyCommitmentSecrets *NONNULL_PTR this_arg, uint64_t idx);
/* @internal */
export function CounterpartyCommitmentSecrets_get_secret(this_arg: number, idx: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CounterpartyCommitmentSecrets_get_secret(this_arg, idx);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z CounterpartyCommitmentSecrets_write(const struct LDKCounterpartyCommitmentSecrets *NONNULL_PTR obj);
/* @internal */
export function CounterpartyCommitmentSecrets_write(obj: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CounterpartyCommitmentSecrets_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_CounterpartyCommitmentSecretsDecodeErrorZ CounterpartyCommitmentSecrets_read(struct LDKu8slice ser);
/* @internal */
export function CounterpartyCommitmentSecrets_read(ser: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CounterpartyCommitmentSecrets_read(ser);
	return nativeResponseValue;
}
	// struct LDKCResult_SecretKeyErrorZ derive_private_key(struct LDKPublicKey per_commitment_point, const uint8_t (*base_secret)[32]);
/* @internal */
export function derive_private_key(per_commitment_point: number, base_secret: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_derive_private_key(per_commitment_point, base_secret);
	return nativeResponseValue;
}
	// struct LDKCResult_PublicKeyErrorZ derive_public_key(struct LDKPublicKey per_commitment_point, struct LDKPublicKey base_point);
/* @internal */
export function derive_public_key(per_commitment_point: number, base_point: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_derive_public_key(per_commitment_point, base_point);
	return nativeResponseValue;
}
	// struct LDKCResult_SecretKeyErrorZ derive_private_revocation_key(const uint8_t (*per_commitment_secret)[32], const uint8_t (*countersignatory_revocation_base_secret)[32]);
/* @internal */
export function derive_private_revocation_key(per_commitment_secret: number, countersignatory_revocation_base_secret: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_derive_private_revocation_key(per_commitment_secret, countersignatory_revocation_base_secret);
	return nativeResponseValue;
}
	// struct LDKCResult_PublicKeyErrorZ derive_public_revocation_key(struct LDKPublicKey per_commitment_point, struct LDKPublicKey countersignatory_revocation_base_point);
/* @internal */
export function derive_public_revocation_key(per_commitment_point: number, countersignatory_revocation_base_point: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_derive_public_revocation_key(per_commitment_point, countersignatory_revocation_base_point);
	return nativeResponseValue;
}
	// void TxCreationKeys_free(struct LDKTxCreationKeys this_obj);
/* @internal */
export function TxCreationKeys_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxCreationKeys_free(this_obj);
	// debug statements here
}
	// struct LDKPublicKey TxCreationKeys_get_per_commitment_point(const struct LDKTxCreationKeys *NONNULL_PTR this_ptr);
/* @internal */
export function TxCreationKeys_get_per_commitment_point(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxCreationKeys_get_per_commitment_point(this_ptr);
	return nativeResponseValue;
}
	// void TxCreationKeys_set_per_commitment_point(struct LDKTxCreationKeys *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */
export function TxCreationKeys_set_per_commitment_point(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxCreationKeys_set_per_commitment_point(this_ptr, val);
	// debug statements here
}
	// struct LDKPublicKey TxCreationKeys_get_revocation_key(const struct LDKTxCreationKeys *NONNULL_PTR this_ptr);
/* @internal */
export function TxCreationKeys_get_revocation_key(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxCreationKeys_get_revocation_key(this_ptr);
	return nativeResponseValue;
}
	// void TxCreationKeys_set_revocation_key(struct LDKTxCreationKeys *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */
export function TxCreationKeys_set_revocation_key(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxCreationKeys_set_revocation_key(this_ptr, val);
	// debug statements here
}
	// struct LDKPublicKey TxCreationKeys_get_broadcaster_htlc_key(const struct LDKTxCreationKeys *NONNULL_PTR this_ptr);
/* @internal */
export function TxCreationKeys_get_broadcaster_htlc_key(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxCreationKeys_get_broadcaster_htlc_key(this_ptr);
	return nativeResponseValue;
}
	// void TxCreationKeys_set_broadcaster_htlc_key(struct LDKTxCreationKeys *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */
export function TxCreationKeys_set_broadcaster_htlc_key(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxCreationKeys_set_broadcaster_htlc_key(this_ptr, val);
	// debug statements here
}
	// struct LDKPublicKey TxCreationKeys_get_countersignatory_htlc_key(const struct LDKTxCreationKeys *NONNULL_PTR this_ptr);
/* @internal */
export function TxCreationKeys_get_countersignatory_htlc_key(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxCreationKeys_get_countersignatory_htlc_key(this_ptr);
	return nativeResponseValue;
}
	// void TxCreationKeys_set_countersignatory_htlc_key(struct LDKTxCreationKeys *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */
export function TxCreationKeys_set_countersignatory_htlc_key(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxCreationKeys_set_countersignatory_htlc_key(this_ptr, val);
	// debug statements here
}
	// struct LDKPublicKey TxCreationKeys_get_broadcaster_delayed_payment_key(const struct LDKTxCreationKeys *NONNULL_PTR this_ptr);
/* @internal */
export function TxCreationKeys_get_broadcaster_delayed_payment_key(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxCreationKeys_get_broadcaster_delayed_payment_key(this_ptr);
	return nativeResponseValue;
}
	// void TxCreationKeys_set_broadcaster_delayed_payment_key(struct LDKTxCreationKeys *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */
export function TxCreationKeys_set_broadcaster_delayed_payment_key(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxCreationKeys_set_broadcaster_delayed_payment_key(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKTxCreationKeys TxCreationKeys_new(struct LDKPublicKey per_commitment_point_arg, struct LDKPublicKey revocation_key_arg, struct LDKPublicKey broadcaster_htlc_key_arg, struct LDKPublicKey countersignatory_htlc_key_arg, struct LDKPublicKey broadcaster_delayed_payment_key_arg);
/* @internal */
export function TxCreationKeys_new(per_commitment_point_arg: number, revocation_key_arg: number, broadcaster_htlc_key_arg: number, countersignatory_htlc_key_arg: number, broadcaster_delayed_payment_key_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxCreationKeys_new(per_commitment_point_arg, revocation_key_arg, broadcaster_htlc_key_arg, countersignatory_htlc_key_arg, broadcaster_delayed_payment_key_arg);
	return nativeResponseValue;
}
	// uintptr_t TxCreationKeys_clone_ptr(LDKTxCreationKeys *NONNULL_PTR arg);
/* @internal */
export function TxCreationKeys_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxCreationKeys_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKTxCreationKeys TxCreationKeys_clone(const struct LDKTxCreationKeys *NONNULL_PTR orig);
/* @internal */
export function TxCreationKeys_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxCreationKeys_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z TxCreationKeys_write(const struct LDKTxCreationKeys *NONNULL_PTR obj);
/* @internal */
export function TxCreationKeys_write(obj: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxCreationKeys_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_TxCreationKeysDecodeErrorZ TxCreationKeys_read(struct LDKu8slice ser);
/* @internal */
export function TxCreationKeys_read(ser: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxCreationKeys_read(ser);
	return nativeResponseValue;
}
	// void ChannelPublicKeys_free(struct LDKChannelPublicKeys this_obj);
/* @internal */
export function ChannelPublicKeys_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelPublicKeys_free(this_obj);
	// debug statements here
}
	// struct LDKPublicKey ChannelPublicKeys_get_funding_pubkey(const struct LDKChannelPublicKeys *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelPublicKeys_get_funding_pubkey(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelPublicKeys_get_funding_pubkey(this_ptr);
	return nativeResponseValue;
}
	// void ChannelPublicKeys_set_funding_pubkey(struct LDKChannelPublicKeys *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */
export function ChannelPublicKeys_set_funding_pubkey(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelPublicKeys_set_funding_pubkey(this_ptr, val);
	// debug statements here
}
	// struct LDKPublicKey ChannelPublicKeys_get_revocation_basepoint(const struct LDKChannelPublicKeys *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelPublicKeys_get_revocation_basepoint(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelPublicKeys_get_revocation_basepoint(this_ptr);
	return nativeResponseValue;
}
	// void ChannelPublicKeys_set_revocation_basepoint(struct LDKChannelPublicKeys *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */
export function ChannelPublicKeys_set_revocation_basepoint(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelPublicKeys_set_revocation_basepoint(this_ptr, val);
	// debug statements here
}
	// struct LDKPublicKey ChannelPublicKeys_get_payment_point(const struct LDKChannelPublicKeys *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelPublicKeys_get_payment_point(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelPublicKeys_get_payment_point(this_ptr);
	return nativeResponseValue;
}
	// void ChannelPublicKeys_set_payment_point(struct LDKChannelPublicKeys *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */
export function ChannelPublicKeys_set_payment_point(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelPublicKeys_set_payment_point(this_ptr, val);
	// debug statements here
}
	// struct LDKPublicKey ChannelPublicKeys_get_delayed_payment_basepoint(const struct LDKChannelPublicKeys *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelPublicKeys_get_delayed_payment_basepoint(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelPublicKeys_get_delayed_payment_basepoint(this_ptr);
	return nativeResponseValue;
}
	// void ChannelPublicKeys_set_delayed_payment_basepoint(struct LDKChannelPublicKeys *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */
export function ChannelPublicKeys_set_delayed_payment_basepoint(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelPublicKeys_set_delayed_payment_basepoint(this_ptr, val);
	// debug statements here
}
	// struct LDKPublicKey ChannelPublicKeys_get_htlc_basepoint(const struct LDKChannelPublicKeys *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelPublicKeys_get_htlc_basepoint(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelPublicKeys_get_htlc_basepoint(this_ptr);
	return nativeResponseValue;
}
	// void ChannelPublicKeys_set_htlc_basepoint(struct LDKChannelPublicKeys *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */
export function ChannelPublicKeys_set_htlc_basepoint(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelPublicKeys_set_htlc_basepoint(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKChannelPublicKeys ChannelPublicKeys_new(struct LDKPublicKey funding_pubkey_arg, struct LDKPublicKey revocation_basepoint_arg, struct LDKPublicKey payment_point_arg, struct LDKPublicKey delayed_payment_basepoint_arg, struct LDKPublicKey htlc_basepoint_arg);
/* @internal */
export function ChannelPublicKeys_new(funding_pubkey_arg: number, revocation_basepoint_arg: number, payment_point_arg: number, delayed_payment_basepoint_arg: number, htlc_basepoint_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelPublicKeys_new(funding_pubkey_arg, revocation_basepoint_arg, payment_point_arg, delayed_payment_basepoint_arg, htlc_basepoint_arg);
	return nativeResponseValue;
}
	// uintptr_t ChannelPublicKeys_clone_ptr(LDKChannelPublicKeys *NONNULL_PTR arg);
/* @internal */
export function ChannelPublicKeys_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelPublicKeys_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKChannelPublicKeys ChannelPublicKeys_clone(const struct LDKChannelPublicKeys *NONNULL_PTR orig);
/* @internal */
export function ChannelPublicKeys_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelPublicKeys_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z ChannelPublicKeys_write(const struct LDKChannelPublicKeys *NONNULL_PTR obj);
/* @internal */
export function ChannelPublicKeys_write(obj: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelPublicKeys_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelPublicKeysDecodeErrorZ ChannelPublicKeys_read(struct LDKu8slice ser);
/* @internal */
export function ChannelPublicKeys_read(ser: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelPublicKeys_read(ser);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_TxCreationKeysErrorZ TxCreationKeys_derive_new(struct LDKPublicKey per_commitment_point, struct LDKPublicKey broadcaster_delayed_payment_base, struct LDKPublicKey broadcaster_htlc_base, struct LDKPublicKey countersignatory_revocation_base, struct LDKPublicKey countersignatory_htlc_base);
/* @internal */
export function TxCreationKeys_derive_new(per_commitment_point: number, broadcaster_delayed_payment_base: number, broadcaster_htlc_base: number, countersignatory_revocation_base: number, countersignatory_htlc_base: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxCreationKeys_derive_new(per_commitment_point, broadcaster_delayed_payment_base, broadcaster_htlc_base, countersignatory_revocation_base, countersignatory_htlc_base);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_TxCreationKeysErrorZ TxCreationKeys_from_channel_static_keys(struct LDKPublicKey per_commitment_point, const struct LDKChannelPublicKeys *NONNULL_PTR broadcaster_keys, const struct LDKChannelPublicKeys *NONNULL_PTR countersignatory_keys);
/* @internal */
export function TxCreationKeys_from_channel_static_keys(per_commitment_point: number, broadcaster_keys: number, countersignatory_keys: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TxCreationKeys_from_channel_static_keys(per_commitment_point, broadcaster_keys, countersignatory_keys);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z get_revokeable_redeemscript(struct LDKPublicKey revocation_key, uint16_t contest_delay, struct LDKPublicKey broadcaster_delayed_payment_key);
/* @internal */
export function get_revokeable_redeemscript(revocation_key: number, contest_delay: number, broadcaster_delayed_payment_key: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_get_revokeable_redeemscript(revocation_key, contest_delay, broadcaster_delayed_payment_key);
	return nativeResponseValue;
}
	// void HTLCOutputInCommitment_free(struct LDKHTLCOutputInCommitment this_obj);
/* @internal */
export function HTLCOutputInCommitment_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HTLCOutputInCommitment_free(this_obj);
	// debug statements here
}
	// bool HTLCOutputInCommitment_get_offered(const struct LDKHTLCOutputInCommitment *NONNULL_PTR this_ptr);
/* @internal */
export function HTLCOutputInCommitment_get_offered(this_ptr: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HTLCOutputInCommitment_get_offered(this_ptr);
	return nativeResponseValue;
}
	// void HTLCOutputInCommitment_set_offered(struct LDKHTLCOutputInCommitment *NONNULL_PTR this_ptr, bool val);
/* @internal */
export function HTLCOutputInCommitment_set_offered(this_ptr: number, val: boolean): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HTLCOutputInCommitment_set_offered(this_ptr, val);
	// debug statements here
}
	// uint64_t HTLCOutputInCommitment_get_amount_msat(const struct LDKHTLCOutputInCommitment *NONNULL_PTR this_ptr);
/* @internal */
export function HTLCOutputInCommitment_get_amount_msat(this_ptr: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HTLCOutputInCommitment_get_amount_msat(this_ptr);
	return nativeResponseValue;
}
	// void HTLCOutputInCommitment_set_amount_msat(struct LDKHTLCOutputInCommitment *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function HTLCOutputInCommitment_set_amount_msat(this_ptr: number, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HTLCOutputInCommitment_set_amount_msat(this_ptr, val);
	// debug statements here
}
	// uint32_t HTLCOutputInCommitment_get_cltv_expiry(const struct LDKHTLCOutputInCommitment *NONNULL_PTR this_ptr);
/* @internal */
export function HTLCOutputInCommitment_get_cltv_expiry(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HTLCOutputInCommitment_get_cltv_expiry(this_ptr);
	return nativeResponseValue;
}
	// void HTLCOutputInCommitment_set_cltv_expiry(struct LDKHTLCOutputInCommitment *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */
export function HTLCOutputInCommitment_set_cltv_expiry(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HTLCOutputInCommitment_set_cltv_expiry(this_ptr, val);
	// debug statements here
}
	// const uint8_t (*HTLCOutputInCommitment_get_payment_hash(const struct LDKHTLCOutputInCommitment *NONNULL_PTR this_ptr))[32];
/* @internal */
export function HTLCOutputInCommitment_get_payment_hash(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HTLCOutputInCommitment_get_payment_hash(this_ptr);
	return nativeResponseValue;
}
	// void HTLCOutputInCommitment_set_payment_hash(struct LDKHTLCOutputInCommitment *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function HTLCOutputInCommitment_set_payment_hash(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HTLCOutputInCommitment_set_payment_hash(this_ptr, val);
	// debug statements here
}
	// struct LDKCOption_u32Z HTLCOutputInCommitment_get_transaction_output_index(const struct LDKHTLCOutputInCommitment *NONNULL_PTR this_ptr);
/* @internal */
export function HTLCOutputInCommitment_get_transaction_output_index(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HTLCOutputInCommitment_get_transaction_output_index(this_ptr);
	return nativeResponseValue;
}
	// void HTLCOutputInCommitment_set_transaction_output_index(struct LDKHTLCOutputInCommitment *NONNULL_PTR this_ptr, struct LDKCOption_u32Z val);
/* @internal */
export function HTLCOutputInCommitment_set_transaction_output_index(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HTLCOutputInCommitment_set_transaction_output_index(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKHTLCOutputInCommitment HTLCOutputInCommitment_new(bool offered_arg, uint64_t amount_msat_arg, uint32_t cltv_expiry_arg, struct LDKThirtyTwoBytes payment_hash_arg, struct LDKCOption_u32Z transaction_output_index_arg);
/* @internal */
export function HTLCOutputInCommitment_new(offered_arg: boolean, amount_msat_arg: bigint, cltv_expiry_arg: number, payment_hash_arg: number, transaction_output_index_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HTLCOutputInCommitment_new(offered_arg, amount_msat_arg, cltv_expiry_arg, payment_hash_arg, transaction_output_index_arg);
	return nativeResponseValue;
}
	// uintptr_t HTLCOutputInCommitment_clone_ptr(LDKHTLCOutputInCommitment *NONNULL_PTR arg);
/* @internal */
export function HTLCOutputInCommitment_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HTLCOutputInCommitment_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKHTLCOutputInCommitment HTLCOutputInCommitment_clone(const struct LDKHTLCOutputInCommitment *NONNULL_PTR orig);
/* @internal */
export function HTLCOutputInCommitment_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HTLCOutputInCommitment_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z HTLCOutputInCommitment_write(const struct LDKHTLCOutputInCommitment *NONNULL_PTR obj);
/* @internal */
export function HTLCOutputInCommitment_write(obj: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HTLCOutputInCommitment_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_HTLCOutputInCommitmentDecodeErrorZ HTLCOutputInCommitment_read(struct LDKu8slice ser);
/* @internal */
export function HTLCOutputInCommitment_read(ser: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HTLCOutputInCommitment_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z get_htlc_redeemscript(const struct LDKHTLCOutputInCommitment *NONNULL_PTR htlc, bool opt_anchors, const struct LDKTxCreationKeys *NONNULL_PTR keys);
/* @internal */
export function get_htlc_redeemscript(htlc: number, opt_anchors: boolean, keys: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_get_htlc_redeemscript(htlc, opt_anchors, keys);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z make_funding_redeemscript(struct LDKPublicKey broadcaster, struct LDKPublicKey countersignatory);
/* @internal */
export function make_funding_redeemscript(broadcaster: number, countersignatory: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_make_funding_redeemscript(broadcaster, countersignatory);
	return nativeResponseValue;
}
	// struct LDKTransaction build_htlc_transaction(const uint8_t (*commitment_txid)[32], uint32_t feerate_per_kw, uint16_t contest_delay, const struct LDKHTLCOutputInCommitment *NONNULL_PTR htlc, bool opt_anchors, struct LDKPublicKey broadcaster_delayed_payment_key, struct LDKPublicKey revocation_key);
/* @internal */
export function build_htlc_transaction(commitment_txid: number, feerate_per_kw: number, contest_delay: number, htlc: number, opt_anchors: boolean, broadcaster_delayed_payment_key: number, revocation_key: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_build_htlc_transaction(commitment_txid, feerate_per_kw, contest_delay, htlc, opt_anchors, broadcaster_delayed_payment_key, revocation_key);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z get_anchor_redeemscript(struct LDKPublicKey funding_pubkey);
/* @internal */
export function get_anchor_redeemscript(funding_pubkey: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_get_anchor_redeemscript(funding_pubkey);
	return nativeResponseValue;
}
	// void ChannelTransactionParameters_free(struct LDKChannelTransactionParameters this_obj);
/* @internal */
export function ChannelTransactionParameters_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelTransactionParameters_free(this_obj);
	// debug statements here
}
	// struct LDKChannelPublicKeys ChannelTransactionParameters_get_holder_pubkeys(const struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelTransactionParameters_get_holder_pubkeys(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelTransactionParameters_get_holder_pubkeys(this_ptr);
	return nativeResponseValue;
}
	// void ChannelTransactionParameters_set_holder_pubkeys(struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr, struct LDKChannelPublicKeys val);
/* @internal */
export function ChannelTransactionParameters_set_holder_pubkeys(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelTransactionParameters_set_holder_pubkeys(this_ptr, val);
	// debug statements here
}
	// uint16_t ChannelTransactionParameters_get_holder_selected_contest_delay(const struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelTransactionParameters_get_holder_selected_contest_delay(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelTransactionParameters_get_holder_selected_contest_delay(this_ptr);
	return nativeResponseValue;
}
	// void ChannelTransactionParameters_set_holder_selected_contest_delay(struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr, uint16_t val);
/* @internal */
export function ChannelTransactionParameters_set_holder_selected_contest_delay(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelTransactionParameters_set_holder_selected_contest_delay(this_ptr, val);
	// debug statements here
}
	// bool ChannelTransactionParameters_get_is_outbound_from_holder(const struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelTransactionParameters_get_is_outbound_from_holder(this_ptr: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelTransactionParameters_get_is_outbound_from_holder(this_ptr);
	return nativeResponseValue;
}
	// void ChannelTransactionParameters_set_is_outbound_from_holder(struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr, bool val);
/* @internal */
export function ChannelTransactionParameters_set_is_outbound_from_holder(this_ptr: number, val: boolean): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelTransactionParameters_set_is_outbound_from_holder(this_ptr, val);
	// debug statements here
}
	// struct LDKCounterpartyChannelTransactionParameters ChannelTransactionParameters_get_counterparty_parameters(const struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelTransactionParameters_get_counterparty_parameters(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelTransactionParameters_get_counterparty_parameters(this_ptr);
	return nativeResponseValue;
}
	// void ChannelTransactionParameters_set_counterparty_parameters(struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr, struct LDKCounterpartyChannelTransactionParameters val);
/* @internal */
export function ChannelTransactionParameters_set_counterparty_parameters(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelTransactionParameters_set_counterparty_parameters(this_ptr, val);
	// debug statements here
}
	// struct LDKOutPoint ChannelTransactionParameters_get_funding_outpoint(const struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelTransactionParameters_get_funding_outpoint(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelTransactionParameters_get_funding_outpoint(this_ptr);
	return nativeResponseValue;
}
	// void ChannelTransactionParameters_set_funding_outpoint(struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr, struct LDKOutPoint val);
/* @internal */
export function ChannelTransactionParameters_set_funding_outpoint(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelTransactionParameters_set_funding_outpoint(this_ptr, val);
	// debug statements here
}
	// enum LDKCOption_NoneZ ChannelTransactionParameters_get_opt_anchors(const struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelTransactionParameters_get_opt_anchors(this_ptr: number): COption_NoneZ {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelTransactionParameters_get_opt_anchors(this_ptr);
	return nativeResponseValue;
}
	// void ChannelTransactionParameters_set_opt_anchors(struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr, enum LDKCOption_NoneZ val);
/* @internal */
export function ChannelTransactionParameters_set_opt_anchors(this_ptr: number, val: COption_NoneZ): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelTransactionParameters_set_opt_anchors(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKChannelTransactionParameters ChannelTransactionParameters_new(struct LDKChannelPublicKeys holder_pubkeys_arg, uint16_t holder_selected_contest_delay_arg, bool is_outbound_from_holder_arg, struct LDKCounterpartyChannelTransactionParameters counterparty_parameters_arg, struct LDKOutPoint funding_outpoint_arg, enum LDKCOption_NoneZ opt_anchors_arg);
/* @internal */
export function ChannelTransactionParameters_new(holder_pubkeys_arg: number, holder_selected_contest_delay_arg: number, is_outbound_from_holder_arg: boolean, counterparty_parameters_arg: number, funding_outpoint_arg: number, opt_anchors_arg: COption_NoneZ): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelTransactionParameters_new(holder_pubkeys_arg, holder_selected_contest_delay_arg, is_outbound_from_holder_arg, counterparty_parameters_arg, funding_outpoint_arg, opt_anchors_arg);
	return nativeResponseValue;
}
	// uintptr_t ChannelTransactionParameters_clone_ptr(LDKChannelTransactionParameters *NONNULL_PTR arg);
/* @internal */
export function ChannelTransactionParameters_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelTransactionParameters_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKChannelTransactionParameters ChannelTransactionParameters_clone(const struct LDKChannelTransactionParameters *NONNULL_PTR orig);
/* @internal */
export function ChannelTransactionParameters_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelTransactionParameters_clone(orig);
	return nativeResponseValue;
}
	// void CounterpartyChannelTransactionParameters_free(struct LDKCounterpartyChannelTransactionParameters this_obj);
/* @internal */
export function CounterpartyChannelTransactionParameters_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CounterpartyChannelTransactionParameters_free(this_obj);
	// debug statements here
}
	// struct LDKChannelPublicKeys CounterpartyChannelTransactionParameters_get_pubkeys(const struct LDKCounterpartyChannelTransactionParameters *NONNULL_PTR this_ptr);
/* @internal */
export function CounterpartyChannelTransactionParameters_get_pubkeys(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CounterpartyChannelTransactionParameters_get_pubkeys(this_ptr);
	return nativeResponseValue;
}
	// void CounterpartyChannelTransactionParameters_set_pubkeys(struct LDKCounterpartyChannelTransactionParameters *NONNULL_PTR this_ptr, struct LDKChannelPublicKeys val);
/* @internal */
export function CounterpartyChannelTransactionParameters_set_pubkeys(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CounterpartyChannelTransactionParameters_set_pubkeys(this_ptr, val);
	// debug statements here
}
	// uint16_t CounterpartyChannelTransactionParameters_get_selected_contest_delay(const struct LDKCounterpartyChannelTransactionParameters *NONNULL_PTR this_ptr);
/* @internal */
export function CounterpartyChannelTransactionParameters_get_selected_contest_delay(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CounterpartyChannelTransactionParameters_get_selected_contest_delay(this_ptr);
	return nativeResponseValue;
}
	// void CounterpartyChannelTransactionParameters_set_selected_contest_delay(struct LDKCounterpartyChannelTransactionParameters *NONNULL_PTR this_ptr, uint16_t val);
/* @internal */
export function CounterpartyChannelTransactionParameters_set_selected_contest_delay(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CounterpartyChannelTransactionParameters_set_selected_contest_delay(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKCounterpartyChannelTransactionParameters CounterpartyChannelTransactionParameters_new(struct LDKChannelPublicKeys pubkeys_arg, uint16_t selected_contest_delay_arg);
/* @internal */
export function CounterpartyChannelTransactionParameters_new(pubkeys_arg: number, selected_contest_delay_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CounterpartyChannelTransactionParameters_new(pubkeys_arg, selected_contest_delay_arg);
	return nativeResponseValue;
}
	// uintptr_t CounterpartyChannelTransactionParameters_clone_ptr(LDKCounterpartyChannelTransactionParameters *NONNULL_PTR arg);
/* @internal */
export function CounterpartyChannelTransactionParameters_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CounterpartyChannelTransactionParameters_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCounterpartyChannelTransactionParameters CounterpartyChannelTransactionParameters_clone(const struct LDKCounterpartyChannelTransactionParameters *NONNULL_PTR orig);
/* @internal */
export function CounterpartyChannelTransactionParameters_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CounterpartyChannelTransactionParameters_clone(orig);
	return nativeResponseValue;
}
	// MUST_USE_RES bool ChannelTransactionParameters_is_populated(const struct LDKChannelTransactionParameters *NONNULL_PTR this_arg);
/* @internal */
export function ChannelTransactionParameters_is_populated(this_arg: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelTransactionParameters_is_populated(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKDirectedChannelTransactionParameters ChannelTransactionParameters_as_holder_broadcastable(const struct LDKChannelTransactionParameters *NONNULL_PTR this_arg);
/* @internal */
export function ChannelTransactionParameters_as_holder_broadcastable(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelTransactionParameters_as_holder_broadcastable(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKDirectedChannelTransactionParameters ChannelTransactionParameters_as_counterparty_broadcastable(const struct LDKChannelTransactionParameters *NONNULL_PTR this_arg);
/* @internal */
export function ChannelTransactionParameters_as_counterparty_broadcastable(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelTransactionParameters_as_counterparty_broadcastable(this_arg);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z CounterpartyChannelTransactionParameters_write(const struct LDKCounterpartyChannelTransactionParameters *NONNULL_PTR obj);
/* @internal */
export function CounterpartyChannelTransactionParameters_write(obj: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CounterpartyChannelTransactionParameters_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ CounterpartyChannelTransactionParameters_read(struct LDKu8slice ser);
/* @internal */
export function CounterpartyChannelTransactionParameters_read(ser: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CounterpartyChannelTransactionParameters_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z ChannelTransactionParameters_write(const struct LDKChannelTransactionParameters *NONNULL_PTR obj);
/* @internal */
export function ChannelTransactionParameters_write(obj: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelTransactionParameters_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelTransactionParametersDecodeErrorZ ChannelTransactionParameters_read(struct LDKu8slice ser);
/* @internal */
export function ChannelTransactionParameters_read(ser: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelTransactionParameters_read(ser);
	return nativeResponseValue;
}
	// void DirectedChannelTransactionParameters_free(struct LDKDirectedChannelTransactionParameters this_obj);
/* @internal */
export function DirectedChannelTransactionParameters_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DirectedChannelTransactionParameters_free(this_obj);
	// debug statements here
}
	// MUST_USE_RES struct LDKChannelPublicKeys DirectedChannelTransactionParameters_broadcaster_pubkeys(const struct LDKDirectedChannelTransactionParameters *NONNULL_PTR this_arg);
/* @internal */
export function DirectedChannelTransactionParameters_broadcaster_pubkeys(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DirectedChannelTransactionParameters_broadcaster_pubkeys(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKChannelPublicKeys DirectedChannelTransactionParameters_countersignatory_pubkeys(const struct LDKDirectedChannelTransactionParameters *NONNULL_PTR this_arg);
/* @internal */
export function DirectedChannelTransactionParameters_countersignatory_pubkeys(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DirectedChannelTransactionParameters_countersignatory_pubkeys(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES uint16_t DirectedChannelTransactionParameters_contest_delay(const struct LDKDirectedChannelTransactionParameters *NONNULL_PTR this_arg);
/* @internal */
export function DirectedChannelTransactionParameters_contest_delay(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DirectedChannelTransactionParameters_contest_delay(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES bool DirectedChannelTransactionParameters_is_outbound(const struct LDKDirectedChannelTransactionParameters *NONNULL_PTR this_arg);
/* @internal */
export function DirectedChannelTransactionParameters_is_outbound(this_arg: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DirectedChannelTransactionParameters_is_outbound(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKOutPoint DirectedChannelTransactionParameters_funding_outpoint(const struct LDKDirectedChannelTransactionParameters *NONNULL_PTR this_arg);
/* @internal */
export function DirectedChannelTransactionParameters_funding_outpoint(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DirectedChannelTransactionParameters_funding_outpoint(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES bool DirectedChannelTransactionParameters_opt_anchors(const struct LDKDirectedChannelTransactionParameters *NONNULL_PTR this_arg);
/* @internal */
export function DirectedChannelTransactionParameters_opt_anchors(this_arg: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DirectedChannelTransactionParameters_opt_anchors(this_arg);
	return nativeResponseValue;
}
	// void HolderCommitmentTransaction_free(struct LDKHolderCommitmentTransaction this_obj);
/* @internal */
export function HolderCommitmentTransaction_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HolderCommitmentTransaction_free(this_obj);
	// debug statements here
}
	// struct LDKSignature HolderCommitmentTransaction_get_counterparty_sig(const struct LDKHolderCommitmentTransaction *NONNULL_PTR this_ptr);
/* @internal */
export function HolderCommitmentTransaction_get_counterparty_sig(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HolderCommitmentTransaction_get_counterparty_sig(this_ptr);
	return nativeResponseValue;
}
	// void HolderCommitmentTransaction_set_counterparty_sig(struct LDKHolderCommitmentTransaction *NONNULL_PTR this_ptr, struct LDKSignature val);
/* @internal */
export function HolderCommitmentTransaction_set_counterparty_sig(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HolderCommitmentTransaction_set_counterparty_sig(this_ptr, val);
	// debug statements here
}
	// void HolderCommitmentTransaction_set_counterparty_htlc_sigs(struct LDKHolderCommitmentTransaction *NONNULL_PTR this_ptr, struct LDKCVec_SignatureZ val);
/* @internal */
export function HolderCommitmentTransaction_set_counterparty_htlc_sigs(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HolderCommitmentTransaction_set_counterparty_htlc_sigs(this_ptr, val);
	// debug statements here
}
	// uintptr_t HolderCommitmentTransaction_clone_ptr(LDKHolderCommitmentTransaction *NONNULL_PTR arg);
/* @internal */
export function HolderCommitmentTransaction_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HolderCommitmentTransaction_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKHolderCommitmentTransaction HolderCommitmentTransaction_clone(const struct LDKHolderCommitmentTransaction *NONNULL_PTR orig);
/* @internal */
export function HolderCommitmentTransaction_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HolderCommitmentTransaction_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z HolderCommitmentTransaction_write(const struct LDKHolderCommitmentTransaction *NONNULL_PTR obj);
/* @internal */
export function HolderCommitmentTransaction_write(obj: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HolderCommitmentTransaction_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_HolderCommitmentTransactionDecodeErrorZ HolderCommitmentTransaction_read(struct LDKu8slice ser);
/* @internal */
export function HolderCommitmentTransaction_read(ser: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HolderCommitmentTransaction_read(ser);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKHolderCommitmentTransaction HolderCommitmentTransaction_new(struct LDKCommitmentTransaction commitment_tx, struct LDKSignature counterparty_sig, struct LDKCVec_SignatureZ counterparty_htlc_sigs, struct LDKPublicKey holder_funding_key, struct LDKPublicKey counterparty_funding_key);
/* @internal */
export function HolderCommitmentTransaction_new(commitment_tx: number, counterparty_sig: number, counterparty_htlc_sigs: number, holder_funding_key: number, counterparty_funding_key: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_HolderCommitmentTransaction_new(commitment_tx, counterparty_sig, counterparty_htlc_sigs, holder_funding_key, counterparty_funding_key);
	return nativeResponseValue;
}
	// void BuiltCommitmentTransaction_free(struct LDKBuiltCommitmentTransaction this_obj);
/* @internal */
export function BuiltCommitmentTransaction_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BuiltCommitmentTransaction_free(this_obj);
	// debug statements here
}
	// struct LDKTransaction BuiltCommitmentTransaction_get_transaction(const struct LDKBuiltCommitmentTransaction *NONNULL_PTR this_ptr);
/* @internal */
export function BuiltCommitmentTransaction_get_transaction(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BuiltCommitmentTransaction_get_transaction(this_ptr);
	return nativeResponseValue;
}
	// void BuiltCommitmentTransaction_set_transaction(struct LDKBuiltCommitmentTransaction *NONNULL_PTR this_ptr, struct LDKTransaction val);
/* @internal */
export function BuiltCommitmentTransaction_set_transaction(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BuiltCommitmentTransaction_set_transaction(this_ptr, val);
	// debug statements here
}
	// const uint8_t (*BuiltCommitmentTransaction_get_txid(const struct LDKBuiltCommitmentTransaction *NONNULL_PTR this_ptr))[32];
/* @internal */
export function BuiltCommitmentTransaction_get_txid(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BuiltCommitmentTransaction_get_txid(this_ptr);
	return nativeResponseValue;
}
	// void BuiltCommitmentTransaction_set_txid(struct LDKBuiltCommitmentTransaction *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function BuiltCommitmentTransaction_set_txid(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BuiltCommitmentTransaction_set_txid(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKBuiltCommitmentTransaction BuiltCommitmentTransaction_new(struct LDKTransaction transaction_arg, struct LDKThirtyTwoBytes txid_arg);
/* @internal */
export function BuiltCommitmentTransaction_new(transaction_arg: number, txid_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BuiltCommitmentTransaction_new(transaction_arg, txid_arg);
	return nativeResponseValue;
}
	// uintptr_t BuiltCommitmentTransaction_clone_ptr(LDKBuiltCommitmentTransaction *NONNULL_PTR arg);
/* @internal */
export function BuiltCommitmentTransaction_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BuiltCommitmentTransaction_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKBuiltCommitmentTransaction BuiltCommitmentTransaction_clone(const struct LDKBuiltCommitmentTransaction *NONNULL_PTR orig);
/* @internal */
export function BuiltCommitmentTransaction_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BuiltCommitmentTransaction_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z BuiltCommitmentTransaction_write(const struct LDKBuiltCommitmentTransaction *NONNULL_PTR obj);
/* @internal */
export function BuiltCommitmentTransaction_write(obj: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BuiltCommitmentTransaction_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_BuiltCommitmentTransactionDecodeErrorZ BuiltCommitmentTransaction_read(struct LDKu8slice ser);
/* @internal */
export function BuiltCommitmentTransaction_read(ser: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BuiltCommitmentTransaction_read(ser);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKThirtyTwoBytes BuiltCommitmentTransaction_get_sighash_all(const struct LDKBuiltCommitmentTransaction *NONNULL_PTR this_arg, struct LDKu8slice funding_redeemscript, uint64_t channel_value_satoshis);
/* @internal */
export function BuiltCommitmentTransaction_get_sighash_all(this_arg: number, funding_redeemscript: number, channel_value_satoshis: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BuiltCommitmentTransaction_get_sighash_all(this_arg, funding_redeemscript, channel_value_satoshis);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKSignature BuiltCommitmentTransaction_sign(const struct LDKBuiltCommitmentTransaction *NONNULL_PTR this_arg, const uint8_t (*funding_key)[32], struct LDKu8slice funding_redeemscript, uint64_t channel_value_satoshis);
/* @internal */
export function BuiltCommitmentTransaction_sign(this_arg: number, funding_key: number, funding_redeemscript: number, channel_value_satoshis: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_BuiltCommitmentTransaction_sign(this_arg, funding_key, funding_redeemscript, channel_value_satoshis);
	return nativeResponseValue;
}
	// void ClosingTransaction_free(struct LDKClosingTransaction this_obj);
/* @internal */
export function ClosingTransaction_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosingTransaction_free(this_obj);
	// debug statements here
}
	// uintptr_t ClosingTransaction_clone_ptr(LDKClosingTransaction *NONNULL_PTR arg);
/* @internal */
export function ClosingTransaction_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosingTransaction_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKClosingTransaction ClosingTransaction_clone(const struct LDKClosingTransaction *NONNULL_PTR orig);
/* @internal */
export function ClosingTransaction_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosingTransaction_clone(orig);
	return nativeResponseValue;
}
	// uint64_t ClosingTransaction_hash(const struct LDKClosingTransaction *NONNULL_PTR o);
/* @internal */
export function ClosingTransaction_hash(o: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosingTransaction_hash(o);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKClosingTransaction ClosingTransaction_new(uint64_t to_holder_value_sat, uint64_t to_counterparty_value_sat, struct LDKCVec_u8Z to_holder_script, struct LDKCVec_u8Z to_counterparty_script, struct LDKOutPoint funding_outpoint);
/* @internal */
export function ClosingTransaction_new(to_holder_value_sat: bigint, to_counterparty_value_sat: bigint, to_holder_script: number, to_counterparty_script: number, funding_outpoint: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosingTransaction_new(to_holder_value_sat, to_counterparty_value_sat, to_holder_script, to_counterparty_script, funding_outpoint);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKTrustedClosingTransaction ClosingTransaction_trust(const struct LDKClosingTransaction *NONNULL_PTR this_arg);
/* @internal */
export function ClosingTransaction_trust(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosingTransaction_trust(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_TrustedClosingTransactionNoneZ ClosingTransaction_verify(const struct LDKClosingTransaction *NONNULL_PTR this_arg, struct LDKOutPoint funding_outpoint);
/* @internal */
export function ClosingTransaction_verify(this_arg: number, funding_outpoint: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosingTransaction_verify(this_arg, funding_outpoint);
	return nativeResponseValue;
}
	// MUST_USE_RES uint64_t ClosingTransaction_to_holder_value_sat(const struct LDKClosingTransaction *NONNULL_PTR this_arg);
/* @internal */
export function ClosingTransaction_to_holder_value_sat(this_arg: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosingTransaction_to_holder_value_sat(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES uint64_t ClosingTransaction_to_counterparty_value_sat(const struct LDKClosingTransaction *NONNULL_PTR this_arg);
/* @internal */
export function ClosingTransaction_to_counterparty_value_sat(this_arg: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosingTransaction_to_counterparty_value_sat(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKu8slice ClosingTransaction_to_holder_script(const struct LDKClosingTransaction *NONNULL_PTR this_arg);
/* @internal */
export function ClosingTransaction_to_holder_script(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosingTransaction_to_holder_script(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKu8slice ClosingTransaction_to_counterparty_script(const struct LDKClosingTransaction *NONNULL_PTR this_arg);
/* @internal */
export function ClosingTransaction_to_counterparty_script(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ClosingTransaction_to_counterparty_script(this_arg);
	return nativeResponseValue;
}
	// void TrustedClosingTransaction_free(struct LDKTrustedClosingTransaction this_obj);
/* @internal */
export function TrustedClosingTransaction_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TrustedClosingTransaction_free(this_obj);
	// debug statements here
}
	// MUST_USE_RES struct LDKTransaction TrustedClosingTransaction_built_transaction(const struct LDKTrustedClosingTransaction *NONNULL_PTR this_arg);
/* @internal */
export function TrustedClosingTransaction_built_transaction(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TrustedClosingTransaction_built_transaction(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKThirtyTwoBytes TrustedClosingTransaction_get_sighash_all(const struct LDKTrustedClosingTransaction *NONNULL_PTR this_arg, struct LDKu8slice funding_redeemscript, uint64_t channel_value_satoshis);
/* @internal */
export function TrustedClosingTransaction_get_sighash_all(this_arg: number, funding_redeemscript: number, channel_value_satoshis: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TrustedClosingTransaction_get_sighash_all(this_arg, funding_redeemscript, channel_value_satoshis);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKSignature TrustedClosingTransaction_sign(const struct LDKTrustedClosingTransaction *NONNULL_PTR this_arg, const uint8_t (*funding_key)[32], struct LDKu8slice funding_redeemscript, uint64_t channel_value_satoshis);
/* @internal */
export function TrustedClosingTransaction_sign(this_arg: number, funding_key: number, funding_redeemscript: number, channel_value_satoshis: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TrustedClosingTransaction_sign(this_arg, funding_key, funding_redeemscript, channel_value_satoshis);
	return nativeResponseValue;
}
	// void CommitmentTransaction_free(struct LDKCommitmentTransaction this_obj);
/* @internal */
export function CommitmentTransaction_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CommitmentTransaction_free(this_obj);
	// debug statements here
}
	// uintptr_t CommitmentTransaction_clone_ptr(LDKCommitmentTransaction *NONNULL_PTR arg);
/* @internal */
export function CommitmentTransaction_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CommitmentTransaction_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKCommitmentTransaction CommitmentTransaction_clone(const struct LDKCommitmentTransaction *NONNULL_PTR orig);
/* @internal */
export function CommitmentTransaction_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CommitmentTransaction_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z CommitmentTransaction_write(const struct LDKCommitmentTransaction *NONNULL_PTR obj);
/* @internal */
export function CommitmentTransaction_write(obj: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CommitmentTransaction_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_CommitmentTransactionDecodeErrorZ CommitmentTransaction_read(struct LDKu8slice ser);
/* @internal */
export function CommitmentTransaction_read(ser: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CommitmentTransaction_read(ser);
	return nativeResponseValue;
}
	// MUST_USE_RES uint64_t CommitmentTransaction_commitment_number(const struct LDKCommitmentTransaction *NONNULL_PTR this_arg);
/* @internal */
export function CommitmentTransaction_commitment_number(this_arg: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CommitmentTransaction_commitment_number(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES uint64_t CommitmentTransaction_to_broadcaster_value_sat(const struct LDKCommitmentTransaction *NONNULL_PTR this_arg);
/* @internal */
export function CommitmentTransaction_to_broadcaster_value_sat(this_arg: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CommitmentTransaction_to_broadcaster_value_sat(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES uint64_t CommitmentTransaction_to_countersignatory_value_sat(const struct LDKCommitmentTransaction *NONNULL_PTR this_arg);
/* @internal */
export function CommitmentTransaction_to_countersignatory_value_sat(this_arg: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CommitmentTransaction_to_countersignatory_value_sat(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES uint32_t CommitmentTransaction_feerate_per_kw(const struct LDKCommitmentTransaction *NONNULL_PTR this_arg);
/* @internal */
export function CommitmentTransaction_feerate_per_kw(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CommitmentTransaction_feerate_per_kw(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKTrustedCommitmentTransaction CommitmentTransaction_trust(const struct LDKCommitmentTransaction *NONNULL_PTR this_arg);
/* @internal */
export function CommitmentTransaction_trust(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CommitmentTransaction_trust(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_TrustedCommitmentTransactionNoneZ CommitmentTransaction_verify(const struct LDKCommitmentTransaction *NONNULL_PTR this_arg, const struct LDKDirectedChannelTransactionParameters *NONNULL_PTR channel_parameters, const struct LDKChannelPublicKeys *NONNULL_PTR broadcaster_keys, const struct LDKChannelPublicKeys *NONNULL_PTR countersignatory_keys);
/* @internal */
export function CommitmentTransaction_verify(this_arg: number, channel_parameters: number, broadcaster_keys: number, countersignatory_keys: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CommitmentTransaction_verify(this_arg, channel_parameters, broadcaster_keys, countersignatory_keys);
	return nativeResponseValue;
}
	// void TrustedCommitmentTransaction_free(struct LDKTrustedCommitmentTransaction this_obj);
/* @internal */
export function TrustedCommitmentTransaction_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TrustedCommitmentTransaction_free(this_obj);
	// debug statements here
}
	// MUST_USE_RES struct LDKThirtyTwoBytes TrustedCommitmentTransaction_txid(const struct LDKTrustedCommitmentTransaction *NONNULL_PTR this_arg);
/* @internal */
export function TrustedCommitmentTransaction_txid(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TrustedCommitmentTransaction_txid(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKBuiltCommitmentTransaction TrustedCommitmentTransaction_built_transaction(const struct LDKTrustedCommitmentTransaction *NONNULL_PTR this_arg);
/* @internal */
export function TrustedCommitmentTransaction_built_transaction(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TrustedCommitmentTransaction_built_transaction(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKTxCreationKeys TrustedCommitmentTransaction_keys(const struct LDKTrustedCommitmentTransaction *NONNULL_PTR this_arg);
/* @internal */
export function TrustedCommitmentTransaction_keys(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TrustedCommitmentTransaction_keys(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES bool TrustedCommitmentTransaction_opt_anchors(const struct LDKTrustedCommitmentTransaction *NONNULL_PTR this_arg);
/* @internal */
export function TrustedCommitmentTransaction_opt_anchors(this_arg: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TrustedCommitmentTransaction_opt_anchors(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_CVec_SignatureZNoneZ TrustedCommitmentTransaction_get_htlc_sigs(const struct LDKTrustedCommitmentTransaction *NONNULL_PTR this_arg, const uint8_t (*htlc_base_key)[32], const struct LDKDirectedChannelTransactionParameters *NONNULL_PTR channel_parameters);
/* @internal */
export function TrustedCommitmentTransaction_get_htlc_sigs(this_arg: number, htlc_base_key: number, channel_parameters: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_TrustedCommitmentTransaction_get_htlc_sigs(this_arg, htlc_base_key, channel_parameters);
	return nativeResponseValue;
}
	// uint64_t get_commitment_transaction_number_obscure_factor(struct LDKPublicKey broadcaster_payment_basepoint, struct LDKPublicKey countersignatory_payment_basepoint, bool outbound_from_broadcaster);
/* @internal */
export function get_commitment_transaction_number_obscure_factor(broadcaster_payment_basepoint: number, countersignatory_payment_basepoint: number, outbound_from_broadcaster: boolean): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_get_commitment_transaction_number_obscure_factor(broadcaster_payment_basepoint, countersignatory_payment_basepoint, outbound_from_broadcaster);
	return nativeResponseValue;
}
	// bool InitFeatures_eq(const struct LDKInitFeatures *NONNULL_PTR a, const struct LDKInitFeatures *NONNULL_PTR b);
/* @internal */
export function InitFeatures_eq(a: number, b: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InitFeatures_eq(a, b);
	return nativeResponseValue;
}
	// bool NodeFeatures_eq(const struct LDKNodeFeatures *NONNULL_PTR a, const struct LDKNodeFeatures *NONNULL_PTR b);
/* @internal */
export function NodeFeatures_eq(a: number, b: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeFeatures_eq(a, b);
	return nativeResponseValue;
}
	// bool ChannelFeatures_eq(const struct LDKChannelFeatures *NONNULL_PTR a, const struct LDKChannelFeatures *NONNULL_PTR b);
/* @internal */
export function ChannelFeatures_eq(a: number, b: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelFeatures_eq(a, b);
	return nativeResponseValue;
}
	// bool InvoiceFeatures_eq(const struct LDKInvoiceFeatures *NONNULL_PTR a, const struct LDKInvoiceFeatures *NONNULL_PTR b);
/* @internal */
export function InvoiceFeatures_eq(a: number, b: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InvoiceFeatures_eq(a, b);
	return nativeResponseValue;
}
	// bool ChannelTypeFeatures_eq(const struct LDKChannelTypeFeatures *NONNULL_PTR a, const struct LDKChannelTypeFeatures *NONNULL_PTR b);
/* @internal */
export function ChannelTypeFeatures_eq(a: number, b: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelTypeFeatures_eq(a, b);
	return nativeResponseValue;
}
	// uintptr_t InitFeatures_clone_ptr(LDKInitFeatures *NONNULL_PTR arg);
/* @internal */
export function InitFeatures_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InitFeatures_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKInitFeatures InitFeatures_clone(const struct LDKInitFeatures *NONNULL_PTR orig);
/* @internal */
export function InitFeatures_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InitFeatures_clone(orig);
	return nativeResponseValue;
}
	// uintptr_t NodeFeatures_clone_ptr(LDKNodeFeatures *NONNULL_PTR arg);
/* @internal */
export function NodeFeatures_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeFeatures_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKNodeFeatures NodeFeatures_clone(const struct LDKNodeFeatures *NONNULL_PTR orig);
/* @internal */
export function NodeFeatures_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeFeatures_clone(orig);
	return nativeResponseValue;
}
	// uintptr_t ChannelFeatures_clone_ptr(LDKChannelFeatures *NONNULL_PTR arg);
/* @internal */
export function ChannelFeatures_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelFeatures_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKChannelFeatures ChannelFeatures_clone(const struct LDKChannelFeatures *NONNULL_PTR orig);
/* @internal */
export function ChannelFeatures_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelFeatures_clone(orig);
	return nativeResponseValue;
}
	// uintptr_t InvoiceFeatures_clone_ptr(LDKInvoiceFeatures *NONNULL_PTR arg);
/* @internal */
export function InvoiceFeatures_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InvoiceFeatures_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKInvoiceFeatures InvoiceFeatures_clone(const struct LDKInvoiceFeatures *NONNULL_PTR orig);
/* @internal */
export function InvoiceFeatures_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InvoiceFeatures_clone(orig);
	return nativeResponseValue;
}
	// uintptr_t ChannelTypeFeatures_clone_ptr(LDKChannelTypeFeatures *NONNULL_PTR arg);
/* @internal */
export function ChannelTypeFeatures_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelTypeFeatures_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKChannelTypeFeatures ChannelTypeFeatures_clone(const struct LDKChannelTypeFeatures *NONNULL_PTR orig);
/* @internal */
export function ChannelTypeFeatures_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelTypeFeatures_clone(orig);
	return nativeResponseValue;
}
	// void InitFeatures_free(struct LDKInitFeatures this_obj);
/* @internal */
export function InitFeatures_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InitFeatures_free(this_obj);
	// debug statements here
}
	// void NodeFeatures_free(struct LDKNodeFeatures this_obj);
/* @internal */
export function NodeFeatures_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeFeatures_free(this_obj);
	// debug statements here
}
	// void ChannelFeatures_free(struct LDKChannelFeatures this_obj);
/* @internal */
export function ChannelFeatures_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelFeatures_free(this_obj);
	// debug statements here
}
	// void InvoiceFeatures_free(struct LDKInvoiceFeatures this_obj);
/* @internal */
export function InvoiceFeatures_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InvoiceFeatures_free(this_obj);
	// debug statements here
}
	// void ChannelTypeFeatures_free(struct LDKChannelTypeFeatures this_obj);
/* @internal */
export function ChannelTypeFeatures_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelTypeFeatures_free(this_obj);
	// debug statements here
}
	// MUST_USE_RES struct LDKInitFeatures InitFeatures_empty(void);
/* @internal */
export function InitFeatures_empty(): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InitFeatures_empty();
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKInitFeatures InitFeatures_known(void);
/* @internal */
export function InitFeatures_known(): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InitFeatures_known();
	return nativeResponseValue;
}
	// MUST_USE_RES bool InitFeatures_requires_unknown_bits(const struct LDKInitFeatures *NONNULL_PTR this_arg);
/* @internal */
export function InitFeatures_requires_unknown_bits(this_arg: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InitFeatures_requires_unknown_bits(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKNodeFeatures NodeFeatures_empty(void);
/* @internal */
export function NodeFeatures_empty(): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeFeatures_empty();
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKNodeFeatures NodeFeatures_known(void);
/* @internal */
export function NodeFeatures_known(): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeFeatures_known();
	return nativeResponseValue;
}
	// MUST_USE_RES bool NodeFeatures_requires_unknown_bits(const struct LDKNodeFeatures *NONNULL_PTR this_arg);
/* @internal */
export function NodeFeatures_requires_unknown_bits(this_arg: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeFeatures_requires_unknown_bits(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKChannelFeatures ChannelFeatures_empty(void);
/* @internal */
export function ChannelFeatures_empty(): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelFeatures_empty();
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKChannelFeatures ChannelFeatures_known(void);
/* @internal */
export function ChannelFeatures_known(): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelFeatures_known();
	return nativeResponseValue;
}
	// MUST_USE_RES bool ChannelFeatures_requires_unknown_bits(const struct LDKChannelFeatures *NONNULL_PTR this_arg);
/* @internal */
export function ChannelFeatures_requires_unknown_bits(this_arg: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelFeatures_requires_unknown_bits(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKInvoiceFeatures InvoiceFeatures_empty(void);
/* @internal */
export function InvoiceFeatures_empty(): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InvoiceFeatures_empty();
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKInvoiceFeatures InvoiceFeatures_known(void);
/* @internal */
export function InvoiceFeatures_known(): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InvoiceFeatures_known();
	return nativeResponseValue;
}
	// MUST_USE_RES bool InvoiceFeatures_requires_unknown_bits(const struct LDKInvoiceFeatures *NONNULL_PTR this_arg);
/* @internal */
export function InvoiceFeatures_requires_unknown_bits(this_arg: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InvoiceFeatures_requires_unknown_bits(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKChannelTypeFeatures ChannelTypeFeatures_empty(void);
/* @internal */
export function ChannelTypeFeatures_empty(): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelTypeFeatures_empty();
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKChannelTypeFeatures ChannelTypeFeatures_known(void);
/* @internal */
export function ChannelTypeFeatures_known(): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelTypeFeatures_known();
	return nativeResponseValue;
}
	// MUST_USE_RES bool ChannelTypeFeatures_requires_unknown_bits(const struct LDKChannelTypeFeatures *NONNULL_PTR this_arg);
/* @internal */
export function ChannelTypeFeatures_requires_unknown_bits(this_arg: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelTypeFeatures_requires_unknown_bits(this_arg);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z InitFeatures_write(const struct LDKInitFeatures *NONNULL_PTR obj);
/* @internal */
export function InitFeatures_write(obj: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InitFeatures_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_InitFeaturesDecodeErrorZ InitFeatures_read(struct LDKu8slice ser);
/* @internal */
export function InitFeatures_read(ser: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InitFeatures_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z ChannelFeatures_write(const struct LDKChannelFeatures *NONNULL_PTR obj);
/* @internal */
export function ChannelFeatures_write(obj: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelFeatures_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelFeaturesDecodeErrorZ ChannelFeatures_read(struct LDKu8slice ser);
/* @internal */
export function ChannelFeatures_read(ser: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelFeatures_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z NodeFeatures_write(const struct LDKNodeFeatures *NONNULL_PTR obj);
/* @internal */
export function NodeFeatures_write(obj: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeFeatures_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_NodeFeaturesDecodeErrorZ NodeFeatures_read(struct LDKu8slice ser);
/* @internal */
export function NodeFeatures_read(ser: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeFeatures_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z InvoiceFeatures_write(const struct LDKInvoiceFeatures *NONNULL_PTR obj);
/* @internal */
export function InvoiceFeatures_write(obj: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InvoiceFeatures_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_InvoiceFeaturesDecodeErrorZ InvoiceFeatures_read(struct LDKu8slice ser);
/* @internal */
export function InvoiceFeatures_read(ser: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InvoiceFeatures_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z ChannelTypeFeatures_write(const struct LDKChannelTypeFeatures *NONNULL_PTR obj);
/* @internal */
export function ChannelTypeFeatures_write(obj: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelTypeFeatures_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelTypeFeaturesDecodeErrorZ ChannelTypeFeatures_read(struct LDKu8slice ser);
/* @internal */
export function ChannelTypeFeatures_read(ser: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelTypeFeatures_read(ser);
	return nativeResponseValue;
}
	// void ShutdownScript_free(struct LDKShutdownScript this_obj);
/* @internal */
export function ShutdownScript_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ShutdownScript_free(this_obj);
	// debug statements here
}
	// uintptr_t ShutdownScript_clone_ptr(LDKShutdownScript *NONNULL_PTR arg);
/* @internal */
export function ShutdownScript_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ShutdownScript_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKShutdownScript ShutdownScript_clone(const struct LDKShutdownScript *NONNULL_PTR orig);
/* @internal */
export function ShutdownScript_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ShutdownScript_clone(orig);
	return nativeResponseValue;
}
	// void InvalidShutdownScript_free(struct LDKInvalidShutdownScript this_obj);
/* @internal */
export function InvalidShutdownScript_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InvalidShutdownScript_free(this_obj);
	// debug statements here
}
	// struct LDKu8slice InvalidShutdownScript_get_script(const struct LDKInvalidShutdownScript *NONNULL_PTR this_ptr);
/* @internal */
export function InvalidShutdownScript_get_script(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InvalidShutdownScript_get_script(this_ptr);
	return nativeResponseValue;
}
	// void InvalidShutdownScript_set_script(struct LDKInvalidShutdownScript *NONNULL_PTR this_ptr, struct LDKCVec_u8Z val);
/* @internal */
export function InvalidShutdownScript_set_script(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InvalidShutdownScript_set_script(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKInvalidShutdownScript InvalidShutdownScript_new(struct LDKCVec_u8Z script_arg);
/* @internal */
export function InvalidShutdownScript_new(script_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InvalidShutdownScript_new(script_arg);
	return nativeResponseValue;
}
	// uintptr_t InvalidShutdownScript_clone_ptr(LDKInvalidShutdownScript *NONNULL_PTR arg);
/* @internal */
export function InvalidShutdownScript_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InvalidShutdownScript_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKInvalidShutdownScript InvalidShutdownScript_clone(const struct LDKInvalidShutdownScript *NONNULL_PTR orig);
/* @internal */
export function InvalidShutdownScript_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InvalidShutdownScript_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z ShutdownScript_write(const struct LDKShutdownScript *NONNULL_PTR obj);
/* @internal */
export function ShutdownScript_write(obj: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ShutdownScript_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_ShutdownScriptDecodeErrorZ ShutdownScript_read(struct LDKu8slice ser);
/* @internal */
export function ShutdownScript_read(ser: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ShutdownScript_read(ser);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKShutdownScript ShutdownScript_new_p2wpkh(const uint8_t (*pubkey_hash)[20]);
/* @internal */
export function ShutdownScript_new_p2wpkh(pubkey_hash: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ShutdownScript_new_p2wpkh(pubkey_hash);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKShutdownScript ShutdownScript_new_p2wsh(const uint8_t (*script_hash)[32]);
/* @internal */
export function ShutdownScript_new_p2wsh(script_hash: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ShutdownScript_new_p2wsh(script_hash);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_ShutdownScriptInvalidShutdownScriptZ ShutdownScript_new_witness_program(uint8_t version, struct LDKu8slice program);
/* @internal */
export function ShutdownScript_new_witness_program(version: number, program: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ShutdownScript_new_witness_program(version, program);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCVec_u8Z ShutdownScript_into_inner(struct LDKShutdownScript this_arg);
/* @internal */
export function ShutdownScript_into_inner(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ShutdownScript_into_inner(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKPublicKey ShutdownScript_as_legacy_pubkey(const struct LDKShutdownScript *NONNULL_PTR this_arg);
/* @internal */
export function ShutdownScript_as_legacy_pubkey(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ShutdownScript_as_legacy_pubkey(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES bool ShutdownScript_is_compatible(const struct LDKShutdownScript *NONNULL_PTR this_arg, const struct LDKInitFeatures *NONNULL_PTR features);
/* @internal */
export function ShutdownScript_is_compatible(this_arg: number, features: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ShutdownScript_is_compatible(this_arg, features);
	return nativeResponseValue;
}
	// void CustomMessageReader_free(struct LDKCustomMessageReader this_ptr);
/* @internal */
export function CustomMessageReader_free(this_ptr: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CustomMessageReader_free(this_ptr);
	// debug statements here
}
	// uintptr_t Type_clone_ptr(LDKType *NONNULL_PTR arg);
/* @internal */
export function Type_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Type_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKType Type_clone(const struct LDKType *NONNULL_PTR orig);
/* @internal */
export function Type_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Type_clone(orig);
	return nativeResponseValue;
}
	// void Type_free(struct LDKType this_ptr);
/* @internal */
export function Type_free(this_ptr: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Type_free(this_ptr);
	// debug statements here
}
	// void NodeId_free(struct LDKNodeId this_obj);
/* @internal */
export function NodeId_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeId_free(this_obj);
	// debug statements here
}
	// uintptr_t NodeId_clone_ptr(LDKNodeId *NONNULL_PTR arg);
/* @internal */
export function NodeId_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeId_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKNodeId NodeId_clone(const struct LDKNodeId *NONNULL_PTR orig);
/* @internal */
export function NodeId_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeId_clone(orig);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKNodeId NodeId_from_pubkey(struct LDKPublicKey pubkey);
/* @internal */
export function NodeId_from_pubkey(pubkey: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeId_from_pubkey(pubkey);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKu8slice NodeId_as_slice(const struct LDKNodeId *NONNULL_PTR this_arg);
/* @internal */
export function NodeId_as_slice(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeId_as_slice(this_arg);
	return nativeResponseValue;
}
	// uint64_t NodeId_hash(const struct LDKNodeId *NONNULL_PTR o);
/* @internal */
export function NodeId_hash(o: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeId_hash(o);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z NodeId_write(const struct LDKNodeId *NONNULL_PTR obj);
/* @internal */
export function NodeId_write(obj: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeId_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_NodeIdDecodeErrorZ NodeId_read(struct LDKu8slice ser);
/* @internal */
export function NodeId_read(ser: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeId_read(ser);
	return nativeResponseValue;
}
	// void NetworkGraph_free(struct LDKNetworkGraph this_obj);
/* @internal */
export function NetworkGraph_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NetworkGraph_free(this_obj);
	// debug statements here
}
	// uintptr_t NetworkGraph_clone_ptr(LDKNetworkGraph *NONNULL_PTR arg);
/* @internal */
export function NetworkGraph_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NetworkGraph_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKNetworkGraph NetworkGraph_clone(const struct LDKNetworkGraph *NONNULL_PTR orig);
/* @internal */
export function NetworkGraph_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NetworkGraph_clone(orig);
	return nativeResponseValue;
}
	// void ReadOnlyNetworkGraph_free(struct LDKReadOnlyNetworkGraph this_obj);
/* @internal */
export function ReadOnlyNetworkGraph_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ReadOnlyNetworkGraph_free(this_obj);
	// debug statements here
}
	// void NetworkUpdate_free(struct LDKNetworkUpdate this_ptr);
/* @internal */
export function NetworkUpdate_free(this_ptr: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NetworkUpdate_free(this_ptr);
	// debug statements here
}
	// uintptr_t NetworkUpdate_clone_ptr(LDKNetworkUpdate *NONNULL_PTR arg);
/* @internal */
export function NetworkUpdate_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NetworkUpdate_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKNetworkUpdate NetworkUpdate_clone(const struct LDKNetworkUpdate *NONNULL_PTR orig);
/* @internal */
export function NetworkUpdate_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NetworkUpdate_clone(orig);
	return nativeResponseValue;
}
	// struct LDKNetworkUpdate NetworkUpdate_channel_update_message(struct LDKChannelUpdate msg);
/* @internal */
export function NetworkUpdate_channel_update_message(msg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NetworkUpdate_channel_update_message(msg);
	return nativeResponseValue;
}
	// struct LDKNetworkUpdate NetworkUpdate_channel_closed(uint64_t short_channel_id, bool is_permanent);
/* @internal */
export function NetworkUpdate_channel_closed(short_channel_id: bigint, is_permanent: boolean): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NetworkUpdate_channel_closed(short_channel_id, is_permanent);
	return nativeResponseValue;
}
	// struct LDKNetworkUpdate NetworkUpdate_node_failure(struct LDKPublicKey node_id, bool is_permanent);
/* @internal */
export function NetworkUpdate_node_failure(node_id: number, is_permanent: boolean): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NetworkUpdate_node_failure(node_id, is_permanent);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z NetworkUpdate_write(const struct LDKNetworkUpdate *NONNULL_PTR obj);
/* @internal */
export function NetworkUpdate_write(obj: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NetworkUpdate_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_COption_NetworkUpdateZDecodeErrorZ NetworkUpdate_read(struct LDKu8slice ser);
/* @internal */
export function NetworkUpdate_read(ser: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NetworkUpdate_read(ser);
	return nativeResponseValue;
}
	// struct LDKEventHandler NetGraphMsgHandler_as_EventHandler(const struct LDKNetGraphMsgHandler *NONNULL_PTR this_arg);
/* @internal */
export function NetGraphMsgHandler_as_EventHandler(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NetGraphMsgHandler_as_EventHandler(this_arg);
	return nativeResponseValue;
}
	// void NetGraphMsgHandler_free(struct LDKNetGraphMsgHandler this_obj);
/* @internal */
export function NetGraphMsgHandler_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NetGraphMsgHandler_free(this_obj);
	// debug statements here
}
	// MUST_USE_RES struct LDKNetGraphMsgHandler NetGraphMsgHandler_new(const struct LDKNetworkGraph *NONNULL_PTR network_graph, struct LDKCOption_AccessZ chain_access, struct LDKLogger logger);
/* @internal */
export function NetGraphMsgHandler_new(network_graph: number, chain_access: number, logger: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NetGraphMsgHandler_new(network_graph, chain_access, logger);
	return nativeResponseValue;
}
	// void NetGraphMsgHandler_add_chain_access(struct LDKNetGraphMsgHandler *NONNULL_PTR this_arg, struct LDKCOption_AccessZ chain_access);
/* @internal */
export function NetGraphMsgHandler_add_chain_access(this_arg: number, chain_access: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NetGraphMsgHandler_add_chain_access(this_arg, chain_access);
	// debug statements here
}
	// struct LDKRoutingMessageHandler NetGraphMsgHandler_as_RoutingMessageHandler(const struct LDKNetGraphMsgHandler *NONNULL_PTR this_arg);
/* @internal */
export function NetGraphMsgHandler_as_RoutingMessageHandler(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NetGraphMsgHandler_as_RoutingMessageHandler(this_arg);
	return nativeResponseValue;
}
	// struct LDKMessageSendEventsProvider NetGraphMsgHandler_as_MessageSendEventsProvider(const struct LDKNetGraphMsgHandler *NONNULL_PTR this_arg);
/* @internal */
export function NetGraphMsgHandler_as_MessageSendEventsProvider(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NetGraphMsgHandler_as_MessageSendEventsProvider(this_arg);
	return nativeResponseValue;
}
	// void ChannelUpdateInfo_free(struct LDKChannelUpdateInfo this_obj);
/* @internal */
export function ChannelUpdateInfo_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelUpdateInfo_free(this_obj);
	// debug statements here
}
	// uint32_t ChannelUpdateInfo_get_last_update(const struct LDKChannelUpdateInfo *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelUpdateInfo_get_last_update(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelUpdateInfo_get_last_update(this_ptr);
	return nativeResponseValue;
}
	// void ChannelUpdateInfo_set_last_update(struct LDKChannelUpdateInfo *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */
export function ChannelUpdateInfo_set_last_update(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelUpdateInfo_set_last_update(this_ptr, val);
	// debug statements here
}
	// bool ChannelUpdateInfo_get_enabled(const struct LDKChannelUpdateInfo *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelUpdateInfo_get_enabled(this_ptr: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelUpdateInfo_get_enabled(this_ptr);
	return nativeResponseValue;
}
	// void ChannelUpdateInfo_set_enabled(struct LDKChannelUpdateInfo *NONNULL_PTR this_ptr, bool val);
/* @internal */
export function ChannelUpdateInfo_set_enabled(this_ptr: number, val: boolean): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelUpdateInfo_set_enabled(this_ptr, val);
	// debug statements here
}
	// uint16_t ChannelUpdateInfo_get_cltv_expiry_delta(const struct LDKChannelUpdateInfo *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelUpdateInfo_get_cltv_expiry_delta(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelUpdateInfo_get_cltv_expiry_delta(this_ptr);
	return nativeResponseValue;
}
	// void ChannelUpdateInfo_set_cltv_expiry_delta(struct LDKChannelUpdateInfo *NONNULL_PTR this_ptr, uint16_t val);
/* @internal */
export function ChannelUpdateInfo_set_cltv_expiry_delta(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelUpdateInfo_set_cltv_expiry_delta(this_ptr, val);
	// debug statements here
}
	// uint64_t ChannelUpdateInfo_get_htlc_minimum_msat(const struct LDKChannelUpdateInfo *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelUpdateInfo_get_htlc_minimum_msat(this_ptr: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelUpdateInfo_get_htlc_minimum_msat(this_ptr);
	return nativeResponseValue;
}
	// void ChannelUpdateInfo_set_htlc_minimum_msat(struct LDKChannelUpdateInfo *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function ChannelUpdateInfo_set_htlc_minimum_msat(this_ptr: number, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelUpdateInfo_set_htlc_minimum_msat(this_ptr, val);
	// debug statements here
}
	// struct LDKCOption_u64Z ChannelUpdateInfo_get_htlc_maximum_msat(const struct LDKChannelUpdateInfo *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelUpdateInfo_get_htlc_maximum_msat(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelUpdateInfo_get_htlc_maximum_msat(this_ptr);
	return nativeResponseValue;
}
	// void ChannelUpdateInfo_set_htlc_maximum_msat(struct LDKChannelUpdateInfo *NONNULL_PTR this_ptr, struct LDKCOption_u64Z val);
/* @internal */
export function ChannelUpdateInfo_set_htlc_maximum_msat(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelUpdateInfo_set_htlc_maximum_msat(this_ptr, val);
	// debug statements here
}
	// struct LDKRoutingFees ChannelUpdateInfo_get_fees(const struct LDKChannelUpdateInfo *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelUpdateInfo_get_fees(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelUpdateInfo_get_fees(this_ptr);
	return nativeResponseValue;
}
	// void ChannelUpdateInfo_set_fees(struct LDKChannelUpdateInfo *NONNULL_PTR this_ptr, struct LDKRoutingFees val);
/* @internal */
export function ChannelUpdateInfo_set_fees(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelUpdateInfo_set_fees(this_ptr, val);
	// debug statements here
}
	// struct LDKChannelUpdate ChannelUpdateInfo_get_last_update_message(const struct LDKChannelUpdateInfo *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelUpdateInfo_get_last_update_message(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelUpdateInfo_get_last_update_message(this_ptr);
	return nativeResponseValue;
}
	// void ChannelUpdateInfo_set_last_update_message(struct LDKChannelUpdateInfo *NONNULL_PTR this_ptr, struct LDKChannelUpdate val);
/* @internal */
export function ChannelUpdateInfo_set_last_update_message(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelUpdateInfo_set_last_update_message(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKChannelUpdateInfo ChannelUpdateInfo_new(uint32_t last_update_arg, bool enabled_arg, uint16_t cltv_expiry_delta_arg, uint64_t htlc_minimum_msat_arg, struct LDKCOption_u64Z htlc_maximum_msat_arg, struct LDKRoutingFees fees_arg, struct LDKChannelUpdate last_update_message_arg);
/* @internal */
export function ChannelUpdateInfo_new(last_update_arg: number, enabled_arg: boolean, cltv_expiry_delta_arg: number, htlc_minimum_msat_arg: bigint, htlc_maximum_msat_arg: number, fees_arg: number, last_update_message_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelUpdateInfo_new(last_update_arg, enabled_arg, cltv_expiry_delta_arg, htlc_minimum_msat_arg, htlc_maximum_msat_arg, fees_arg, last_update_message_arg);
	return nativeResponseValue;
}
	// uintptr_t ChannelUpdateInfo_clone_ptr(LDKChannelUpdateInfo *NONNULL_PTR arg);
/* @internal */
export function ChannelUpdateInfo_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelUpdateInfo_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKChannelUpdateInfo ChannelUpdateInfo_clone(const struct LDKChannelUpdateInfo *NONNULL_PTR orig);
/* @internal */
export function ChannelUpdateInfo_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelUpdateInfo_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z ChannelUpdateInfo_write(const struct LDKChannelUpdateInfo *NONNULL_PTR obj);
/* @internal */
export function ChannelUpdateInfo_write(obj: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelUpdateInfo_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelUpdateInfoDecodeErrorZ ChannelUpdateInfo_read(struct LDKu8slice ser);
/* @internal */
export function ChannelUpdateInfo_read(ser: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelUpdateInfo_read(ser);
	return nativeResponseValue;
}
	// void ChannelInfo_free(struct LDKChannelInfo this_obj);
/* @internal */
export function ChannelInfo_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelInfo_free(this_obj);
	// debug statements here
}
	// struct LDKChannelFeatures ChannelInfo_get_features(const struct LDKChannelInfo *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelInfo_get_features(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelInfo_get_features(this_ptr);
	return nativeResponseValue;
}
	// void ChannelInfo_set_features(struct LDKChannelInfo *NONNULL_PTR this_ptr, struct LDKChannelFeatures val);
/* @internal */
export function ChannelInfo_set_features(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelInfo_set_features(this_ptr, val);
	// debug statements here
}
	// struct LDKNodeId ChannelInfo_get_node_one(const struct LDKChannelInfo *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelInfo_get_node_one(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelInfo_get_node_one(this_ptr);
	return nativeResponseValue;
}
	// void ChannelInfo_set_node_one(struct LDKChannelInfo *NONNULL_PTR this_ptr, struct LDKNodeId val);
/* @internal */
export function ChannelInfo_set_node_one(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelInfo_set_node_one(this_ptr, val);
	// debug statements here
}
	// struct LDKChannelUpdateInfo ChannelInfo_get_one_to_two(const struct LDKChannelInfo *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelInfo_get_one_to_two(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelInfo_get_one_to_two(this_ptr);
	return nativeResponseValue;
}
	// void ChannelInfo_set_one_to_two(struct LDKChannelInfo *NONNULL_PTR this_ptr, struct LDKChannelUpdateInfo val);
/* @internal */
export function ChannelInfo_set_one_to_two(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelInfo_set_one_to_two(this_ptr, val);
	// debug statements here
}
	// struct LDKNodeId ChannelInfo_get_node_two(const struct LDKChannelInfo *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelInfo_get_node_two(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelInfo_get_node_two(this_ptr);
	return nativeResponseValue;
}
	// void ChannelInfo_set_node_two(struct LDKChannelInfo *NONNULL_PTR this_ptr, struct LDKNodeId val);
/* @internal */
export function ChannelInfo_set_node_two(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelInfo_set_node_two(this_ptr, val);
	// debug statements here
}
	// struct LDKChannelUpdateInfo ChannelInfo_get_two_to_one(const struct LDKChannelInfo *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelInfo_get_two_to_one(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelInfo_get_two_to_one(this_ptr);
	return nativeResponseValue;
}
	// void ChannelInfo_set_two_to_one(struct LDKChannelInfo *NONNULL_PTR this_ptr, struct LDKChannelUpdateInfo val);
/* @internal */
export function ChannelInfo_set_two_to_one(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelInfo_set_two_to_one(this_ptr, val);
	// debug statements here
}
	// struct LDKCOption_u64Z ChannelInfo_get_capacity_sats(const struct LDKChannelInfo *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelInfo_get_capacity_sats(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelInfo_get_capacity_sats(this_ptr);
	return nativeResponseValue;
}
	// void ChannelInfo_set_capacity_sats(struct LDKChannelInfo *NONNULL_PTR this_ptr, struct LDKCOption_u64Z val);
/* @internal */
export function ChannelInfo_set_capacity_sats(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelInfo_set_capacity_sats(this_ptr, val);
	// debug statements here
}
	// struct LDKChannelAnnouncement ChannelInfo_get_announcement_message(const struct LDKChannelInfo *NONNULL_PTR this_ptr);
/* @internal */
export function ChannelInfo_get_announcement_message(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelInfo_get_announcement_message(this_ptr);
	return nativeResponseValue;
}
	// void ChannelInfo_set_announcement_message(struct LDKChannelInfo *NONNULL_PTR this_ptr, struct LDKChannelAnnouncement val);
/* @internal */
export function ChannelInfo_set_announcement_message(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelInfo_set_announcement_message(this_ptr, val);
	// debug statements here
}
	// uintptr_t ChannelInfo_clone_ptr(LDKChannelInfo *NONNULL_PTR arg);
/* @internal */
export function ChannelInfo_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelInfo_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKChannelInfo ChannelInfo_clone(const struct LDKChannelInfo *NONNULL_PTR orig);
/* @internal */
export function ChannelInfo_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelInfo_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z ChannelInfo_write(const struct LDKChannelInfo *NONNULL_PTR obj);
/* @internal */
export function ChannelInfo_write(obj: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelInfo_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_ChannelInfoDecodeErrorZ ChannelInfo_read(struct LDKu8slice ser);
/* @internal */
export function ChannelInfo_read(ser: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelInfo_read(ser);
	return nativeResponseValue;
}
	// void DirectedChannelInfo_free(struct LDKDirectedChannelInfo this_obj);
/* @internal */
export function DirectedChannelInfo_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DirectedChannelInfo_free(this_obj);
	// debug statements here
}
	// uintptr_t DirectedChannelInfo_clone_ptr(LDKDirectedChannelInfo *NONNULL_PTR arg);
/* @internal */
export function DirectedChannelInfo_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DirectedChannelInfo_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKDirectedChannelInfo DirectedChannelInfo_clone(const struct LDKDirectedChannelInfo *NONNULL_PTR orig);
/* @internal */
export function DirectedChannelInfo_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DirectedChannelInfo_clone(orig);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKChannelInfo DirectedChannelInfo_channel(const struct LDKDirectedChannelInfo *NONNULL_PTR this_arg);
/* @internal */
export function DirectedChannelInfo_channel(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DirectedChannelInfo_channel(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKChannelUpdateInfo DirectedChannelInfo_direction(const struct LDKDirectedChannelInfo *NONNULL_PTR this_arg);
/* @internal */
export function DirectedChannelInfo_direction(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DirectedChannelInfo_direction(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKEffectiveCapacity DirectedChannelInfo_effective_capacity(const struct LDKDirectedChannelInfo *NONNULL_PTR this_arg);
/* @internal */
export function DirectedChannelInfo_effective_capacity(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DirectedChannelInfo_effective_capacity(this_arg);
	return nativeResponseValue;
}
	// void EffectiveCapacity_free(struct LDKEffectiveCapacity this_ptr);
/* @internal */
export function EffectiveCapacity_free(this_ptr: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_EffectiveCapacity_free(this_ptr);
	// debug statements here
}
	// uintptr_t EffectiveCapacity_clone_ptr(LDKEffectiveCapacity *NONNULL_PTR arg);
/* @internal */
export function EffectiveCapacity_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_EffectiveCapacity_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKEffectiveCapacity EffectiveCapacity_clone(const struct LDKEffectiveCapacity *NONNULL_PTR orig);
/* @internal */
export function EffectiveCapacity_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_EffectiveCapacity_clone(orig);
	return nativeResponseValue;
}
	// struct LDKEffectiveCapacity EffectiveCapacity_exact_liquidity(uint64_t liquidity_msat);
/* @internal */
export function EffectiveCapacity_exact_liquidity(liquidity_msat: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_EffectiveCapacity_exact_liquidity(liquidity_msat);
	return nativeResponseValue;
}
	// struct LDKEffectiveCapacity EffectiveCapacity_maximum_htlc(uint64_t amount_msat);
/* @internal */
export function EffectiveCapacity_maximum_htlc(amount_msat: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_EffectiveCapacity_maximum_htlc(amount_msat);
	return nativeResponseValue;
}
	// struct LDKEffectiveCapacity EffectiveCapacity_total(uint64_t capacity_msat);
/* @internal */
export function EffectiveCapacity_total(capacity_msat: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_EffectiveCapacity_total(capacity_msat);
	return nativeResponseValue;
}
	// struct LDKEffectiveCapacity EffectiveCapacity_infinite(void);
/* @internal */
export function EffectiveCapacity_infinite(): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_EffectiveCapacity_infinite();
	return nativeResponseValue;
}
	// struct LDKEffectiveCapacity EffectiveCapacity_unknown(void);
/* @internal */
export function EffectiveCapacity_unknown(): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_EffectiveCapacity_unknown();
	return nativeResponseValue;
}
	// MUST_USE_RES uint64_t EffectiveCapacity_as_msat(const struct LDKEffectiveCapacity *NONNULL_PTR this_arg);
/* @internal */
export function EffectiveCapacity_as_msat(this_arg: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_EffectiveCapacity_as_msat(this_arg);
	return nativeResponseValue;
}
	// void RoutingFees_free(struct LDKRoutingFees this_obj);
/* @internal */
export function RoutingFees_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RoutingFees_free(this_obj);
	// debug statements here
}
	// uint32_t RoutingFees_get_base_msat(const struct LDKRoutingFees *NONNULL_PTR this_ptr);
/* @internal */
export function RoutingFees_get_base_msat(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RoutingFees_get_base_msat(this_ptr);
	return nativeResponseValue;
}
	// void RoutingFees_set_base_msat(struct LDKRoutingFees *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */
export function RoutingFees_set_base_msat(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RoutingFees_set_base_msat(this_ptr, val);
	// debug statements here
}
	// uint32_t RoutingFees_get_proportional_millionths(const struct LDKRoutingFees *NONNULL_PTR this_ptr);
/* @internal */
export function RoutingFees_get_proportional_millionths(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RoutingFees_get_proportional_millionths(this_ptr);
	return nativeResponseValue;
}
	// void RoutingFees_set_proportional_millionths(struct LDKRoutingFees *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */
export function RoutingFees_set_proportional_millionths(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RoutingFees_set_proportional_millionths(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKRoutingFees RoutingFees_new(uint32_t base_msat_arg, uint32_t proportional_millionths_arg);
/* @internal */
export function RoutingFees_new(base_msat_arg: number, proportional_millionths_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RoutingFees_new(base_msat_arg, proportional_millionths_arg);
	return nativeResponseValue;
}
	// bool RoutingFees_eq(const struct LDKRoutingFees *NONNULL_PTR a, const struct LDKRoutingFees *NONNULL_PTR b);
/* @internal */
export function RoutingFees_eq(a: number, b: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RoutingFees_eq(a, b);
	return nativeResponseValue;
}
	// uintptr_t RoutingFees_clone_ptr(LDKRoutingFees *NONNULL_PTR arg);
/* @internal */
export function RoutingFees_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RoutingFees_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKRoutingFees RoutingFees_clone(const struct LDKRoutingFees *NONNULL_PTR orig);
/* @internal */
export function RoutingFees_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RoutingFees_clone(orig);
	return nativeResponseValue;
}
	// uint64_t RoutingFees_hash(const struct LDKRoutingFees *NONNULL_PTR o);
/* @internal */
export function RoutingFees_hash(o: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RoutingFees_hash(o);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z RoutingFees_write(const struct LDKRoutingFees *NONNULL_PTR obj);
/* @internal */
export function RoutingFees_write(obj: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RoutingFees_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_RoutingFeesDecodeErrorZ RoutingFees_read(struct LDKu8slice ser);
/* @internal */
export function RoutingFees_read(ser: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RoutingFees_read(ser);
	return nativeResponseValue;
}
	// void NodeAnnouncementInfo_free(struct LDKNodeAnnouncementInfo this_obj);
/* @internal */
export function NodeAnnouncementInfo_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeAnnouncementInfo_free(this_obj);
	// debug statements here
}
	// struct LDKNodeFeatures NodeAnnouncementInfo_get_features(const struct LDKNodeAnnouncementInfo *NONNULL_PTR this_ptr);
/* @internal */
export function NodeAnnouncementInfo_get_features(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeAnnouncementInfo_get_features(this_ptr);
	return nativeResponseValue;
}
	// void NodeAnnouncementInfo_set_features(struct LDKNodeAnnouncementInfo *NONNULL_PTR this_ptr, struct LDKNodeFeatures val);
/* @internal */
export function NodeAnnouncementInfo_set_features(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeAnnouncementInfo_set_features(this_ptr, val);
	// debug statements here
}
	// uint32_t NodeAnnouncementInfo_get_last_update(const struct LDKNodeAnnouncementInfo *NONNULL_PTR this_ptr);
/* @internal */
export function NodeAnnouncementInfo_get_last_update(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeAnnouncementInfo_get_last_update(this_ptr);
	return nativeResponseValue;
}
	// void NodeAnnouncementInfo_set_last_update(struct LDKNodeAnnouncementInfo *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */
export function NodeAnnouncementInfo_set_last_update(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeAnnouncementInfo_set_last_update(this_ptr, val);
	// debug statements here
}
	// const uint8_t (*NodeAnnouncementInfo_get_rgb(const struct LDKNodeAnnouncementInfo *NONNULL_PTR this_ptr))[3];
/* @internal */
export function NodeAnnouncementInfo_get_rgb(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeAnnouncementInfo_get_rgb(this_ptr);
	return nativeResponseValue;
}
	// void NodeAnnouncementInfo_set_rgb(struct LDKNodeAnnouncementInfo *NONNULL_PTR this_ptr, struct LDKThreeBytes val);
/* @internal */
export function NodeAnnouncementInfo_set_rgb(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeAnnouncementInfo_set_rgb(this_ptr, val);
	// debug statements here
}
	// const uint8_t (*NodeAnnouncementInfo_get_alias(const struct LDKNodeAnnouncementInfo *NONNULL_PTR this_ptr))[32];
/* @internal */
export function NodeAnnouncementInfo_get_alias(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeAnnouncementInfo_get_alias(this_ptr);
	return nativeResponseValue;
}
	// void NodeAnnouncementInfo_set_alias(struct LDKNodeAnnouncementInfo *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);
/* @internal */
export function NodeAnnouncementInfo_set_alias(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeAnnouncementInfo_set_alias(this_ptr, val);
	// debug statements here
}
	// void NodeAnnouncementInfo_set_addresses(struct LDKNodeAnnouncementInfo *NONNULL_PTR this_ptr, struct LDKCVec_NetAddressZ val);
/* @internal */
export function NodeAnnouncementInfo_set_addresses(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeAnnouncementInfo_set_addresses(this_ptr, val);
	// debug statements here
}
	// struct LDKNodeAnnouncement NodeAnnouncementInfo_get_announcement_message(const struct LDKNodeAnnouncementInfo *NONNULL_PTR this_ptr);
/* @internal */
export function NodeAnnouncementInfo_get_announcement_message(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeAnnouncementInfo_get_announcement_message(this_ptr);
	return nativeResponseValue;
}
	// void NodeAnnouncementInfo_set_announcement_message(struct LDKNodeAnnouncementInfo *NONNULL_PTR this_ptr, struct LDKNodeAnnouncement val);
/* @internal */
export function NodeAnnouncementInfo_set_announcement_message(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeAnnouncementInfo_set_announcement_message(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKNodeAnnouncementInfo NodeAnnouncementInfo_new(struct LDKNodeFeatures features_arg, uint32_t last_update_arg, struct LDKThreeBytes rgb_arg, struct LDKThirtyTwoBytes alias_arg, struct LDKCVec_NetAddressZ addresses_arg, struct LDKNodeAnnouncement announcement_message_arg);
/* @internal */
export function NodeAnnouncementInfo_new(features_arg: number, last_update_arg: number, rgb_arg: number, alias_arg: number, addresses_arg: number, announcement_message_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeAnnouncementInfo_new(features_arg, last_update_arg, rgb_arg, alias_arg, addresses_arg, announcement_message_arg);
	return nativeResponseValue;
}
	// uintptr_t NodeAnnouncementInfo_clone_ptr(LDKNodeAnnouncementInfo *NONNULL_PTR arg);
/* @internal */
export function NodeAnnouncementInfo_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeAnnouncementInfo_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKNodeAnnouncementInfo NodeAnnouncementInfo_clone(const struct LDKNodeAnnouncementInfo *NONNULL_PTR orig);
/* @internal */
export function NodeAnnouncementInfo_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeAnnouncementInfo_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z NodeAnnouncementInfo_write(const struct LDKNodeAnnouncementInfo *NONNULL_PTR obj);
/* @internal */
export function NodeAnnouncementInfo_write(obj: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeAnnouncementInfo_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_NodeAnnouncementInfoDecodeErrorZ NodeAnnouncementInfo_read(struct LDKu8slice ser);
/* @internal */
export function NodeAnnouncementInfo_read(ser: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeAnnouncementInfo_read(ser);
	return nativeResponseValue;
}
	// void NodeInfo_free(struct LDKNodeInfo this_obj);
/* @internal */
export function NodeInfo_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeInfo_free(this_obj);
	// debug statements here
}
	// void NodeInfo_set_channels(struct LDKNodeInfo *NONNULL_PTR this_ptr, struct LDKCVec_u64Z val);
/* @internal */
export function NodeInfo_set_channels(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeInfo_set_channels(this_ptr, val);
	// debug statements here
}
	// struct LDKRoutingFees NodeInfo_get_lowest_inbound_channel_fees(const struct LDKNodeInfo *NONNULL_PTR this_ptr);
/* @internal */
export function NodeInfo_get_lowest_inbound_channel_fees(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeInfo_get_lowest_inbound_channel_fees(this_ptr);
	return nativeResponseValue;
}
	// void NodeInfo_set_lowest_inbound_channel_fees(struct LDKNodeInfo *NONNULL_PTR this_ptr, struct LDKRoutingFees val);
/* @internal */
export function NodeInfo_set_lowest_inbound_channel_fees(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeInfo_set_lowest_inbound_channel_fees(this_ptr, val);
	// debug statements here
}
	// struct LDKNodeAnnouncementInfo NodeInfo_get_announcement_info(const struct LDKNodeInfo *NONNULL_PTR this_ptr);
/* @internal */
export function NodeInfo_get_announcement_info(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeInfo_get_announcement_info(this_ptr);
	return nativeResponseValue;
}
	// void NodeInfo_set_announcement_info(struct LDKNodeInfo *NONNULL_PTR this_ptr, struct LDKNodeAnnouncementInfo val);
/* @internal */
export function NodeInfo_set_announcement_info(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeInfo_set_announcement_info(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKNodeInfo NodeInfo_new(struct LDKCVec_u64Z channels_arg, struct LDKRoutingFees lowest_inbound_channel_fees_arg, struct LDKNodeAnnouncementInfo announcement_info_arg);
/* @internal */
export function NodeInfo_new(channels_arg: number, lowest_inbound_channel_fees_arg: number, announcement_info_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeInfo_new(channels_arg, lowest_inbound_channel_fees_arg, announcement_info_arg);
	return nativeResponseValue;
}
	// uintptr_t NodeInfo_clone_ptr(LDKNodeInfo *NONNULL_PTR arg);
/* @internal */
export function NodeInfo_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeInfo_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKNodeInfo NodeInfo_clone(const struct LDKNodeInfo *NONNULL_PTR orig);
/* @internal */
export function NodeInfo_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeInfo_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z NodeInfo_write(const struct LDKNodeInfo *NONNULL_PTR obj);
/* @internal */
export function NodeInfo_write(obj: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeInfo_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_NodeInfoDecodeErrorZ NodeInfo_read(struct LDKu8slice ser);
/* @internal */
export function NodeInfo_read(ser: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NodeInfo_read(ser);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z NetworkGraph_write(const struct LDKNetworkGraph *NONNULL_PTR obj);
/* @internal */
export function NetworkGraph_write(obj: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NetworkGraph_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_NetworkGraphDecodeErrorZ NetworkGraph_read(struct LDKu8slice ser);
/* @internal */
export function NetworkGraph_read(ser: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NetworkGraph_read(ser);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKNetworkGraph NetworkGraph_new(struct LDKThirtyTwoBytes genesis_hash);
/* @internal */
export function NetworkGraph_new(genesis_hash: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NetworkGraph_new(genesis_hash);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKReadOnlyNetworkGraph NetworkGraph_read_only(const struct LDKNetworkGraph *NONNULL_PTR this_arg);
/* @internal */
export function NetworkGraph_read_only(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NetworkGraph_read_only(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_NoneLightningErrorZ NetworkGraph_update_node_from_announcement(const struct LDKNetworkGraph *NONNULL_PTR this_arg, const struct LDKNodeAnnouncement *NONNULL_PTR msg);
/* @internal */
export function NetworkGraph_update_node_from_announcement(this_arg: number, msg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NetworkGraph_update_node_from_announcement(this_arg, msg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_NoneLightningErrorZ NetworkGraph_update_node_from_unsigned_announcement(const struct LDKNetworkGraph *NONNULL_PTR this_arg, const struct LDKUnsignedNodeAnnouncement *NONNULL_PTR msg);
/* @internal */
export function NetworkGraph_update_node_from_unsigned_announcement(this_arg: number, msg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NetworkGraph_update_node_from_unsigned_announcement(this_arg, msg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_NoneLightningErrorZ NetworkGraph_update_channel_from_announcement(const struct LDKNetworkGraph *NONNULL_PTR this_arg, const struct LDKChannelAnnouncement *NONNULL_PTR msg, struct LDKCOption_AccessZ chain_access);
/* @internal */
export function NetworkGraph_update_channel_from_announcement(this_arg: number, msg: number, chain_access: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NetworkGraph_update_channel_from_announcement(this_arg, msg, chain_access);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_NoneLightningErrorZ NetworkGraph_update_channel_from_unsigned_announcement(const struct LDKNetworkGraph *NONNULL_PTR this_arg, const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR msg, struct LDKCOption_AccessZ chain_access);
/* @internal */
export function NetworkGraph_update_channel_from_unsigned_announcement(this_arg: number, msg: number, chain_access: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NetworkGraph_update_channel_from_unsigned_announcement(this_arg, msg, chain_access);
	return nativeResponseValue;
}
	// void NetworkGraph_close_channel_from_update(const struct LDKNetworkGraph *NONNULL_PTR this_arg, uint64_t short_channel_id, bool is_permanent);
/* @internal */
export function NetworkGraph_close_channel_from_update(this_arg: number, short_channel_id: bigint, is_permanent: boolean): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NetworkGraph_close_channel_from_update(this_arg, short_channel_id, is_permanent);
	// debug statements here
}
	// void NetworkGraph_fail_node(const struct LDKNetworkGraph *NONNULL_PTR this_arg, struct LDKPublicKey _node_id, bool is_permanent);
/* @internal */
export function NetworkGraph_fail_node(this_arg: number, _node_id: number, is_permanent: boolean): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NetworkGraph_fail_node(this_arg, _node_id, is_permanent);
	// debug statements here
}
	// void NetworkGraph_remove_stale_channels_with_time(const struct LDKNetworkGraph *NONNULL_PTR this_arg, uint64_t current_time_unix);
/* @internal */
export function NetworkGraph_remove_stale_channels_with_time(this_arg: number, current_time_unix: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NetworkGraph_remove_stale_channels_with_time(this_arg, current_time_unix);
	// debug statements here
}
	// MUST_USE_RES struct LDKCResult_NoneLightningErrorZ NetworkGraph_update_channel(const struct LDKNetworkGraph *NONNULL_PTR this_arg, const struct LDKChannelUpdate *NONNULL_PTR msg);
/* @internal */
export function NetworkGraph_update_channel(this_arg: number, msg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NetworkGraph_update_channel(this_arg, msg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_NoneLightningErrorZ NetworkGraph_update_channel_unsigned(const struct LDKNetworkGraph *NONNULL_PTR this_arg, const struct LDKUnsignedChannelUpdate *NONNULL_PTR msg);
/* @internal */
export function NetworkGraph_update_channel_unsigned(this_arg: number, msg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_NetworkGraph_update_channel_unsigned(this_arg, msg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCOption_CVec_NetAddressZZ ReadOnlyNetworkGraph_get_addresses(const struct LDKReadOnlyNetworkGraph *NONNULL_PTR this_arg, struct LDKPublicKey pubkey);
/* @internal */
export function ReadOnlyNetworkGraph_get_addresses(this_arg: number, pubkey: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ReadOnlyNetworkGraph_get_addresses(this_arg, pubkey);
	return nativeResponseValue;
}
	// void RouteHop_free(struct LDKRouteHop this_obj);
/* @internal */
export function RouteHop_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHop_free(this_obj);
	// debug statements here
}
	// struct LDKPublicKey RouteHop_get_pubkey(const struct LDKRouteHop *NONNULL_PTR this_ptr);
/* @internal */
export function RouteHop_get_pubkey(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHop_get_pubkey(this_ptr);
	return nativeResponseValue;
}
	// void RouteHop_set_pubkey(struct LDKRouteHop *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */
export function RouteHop_set_pubkey(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHop_set_pubkey(this_ptr, val);
	// debug statements here
}
	// struct LDKNodeFeatures RouteHop_get_node_features(const struct LDKRouteHop *NONNULL_PTR this_ptr);
/* @internal */
export function RouteHop_get_node_features(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHop_get_node_features(this_ptr);
	return nativeResponseValue;
}
	// void RouteHop_set_node_features(struct LDKRouteHop *NONNULL_PTR this_ptr, struct LDKNodeFeatures val);
/* @internal */
export function RouteHop_set_node_features(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHop_set_node_features(this_ptr, val);
	// debug statements here
}
	// uint64_t RouteHop_get_short_channel_id(const struct LDKRouteHop *NONNULL_PTR this_ptr);
/* @internal */
export function RouteHop_get_short_channel_id(this_ptr: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHop_get_short_channel_id(this_ptr);
	return nativeResponseValue;
}
	// void RouteHop_set_short_channel_id(struct LDKRouteHop *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function RouteHop_set_short_channel_id(this_ptr: number, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHop_set_short_channel_id(this_ptr, val);
	// debug statements here
}
	// struct LDKChannelFeatures RouteHop_get_channel_features(const struct LDKRouteHop *NONNULL_PTR this_ptr);
/* @internal */
export function RouteHop_get_channel_features(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHop_get_channel_features(this_ptr);
	return nativeResponseValue;
}
	// void RouteHop_set_channel_features(struct LDKRouteHop *NONNULL_PTR this_ptr, struct LDKChannelFeatures val);
/* @internal */
export function RouteHop_set_channel_features(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHop_set_channel_features(this_ptr, val);
	// debug statements here
}
	// uint64_t RouteHop_get_fee_msat(const struct LDKRouteHop *NONNULL_PTR this_ptr);
/* @internal */
export function RouteHop_get_fee_msat(this_ptr: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHop_get_fee_msat(this_ptr);
	return nativeResponseValue;
}
	// void RouteHop_set_fee_msat(struct LDKRouteHop *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function RouteHop_set_fee_msat(this_ptr: number, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHop_set_fee_msat(this_ptr, val);
	// debug statements here
}
	// uint32_t RouteHop_get_cltv_expiry_delta(const struct LDKRouteHop *NONNULL_PTR this_ptr);
/* @internal */
export function RouteHop_get_cltv_expiry_delta(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHop_get_cltv_expiry_delta(this_ptr);
	return nativeResponseValue;
}
	// void RouteHop_set_cltv_expiry_delta(struct LDKRouteHop *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */
export function RouteHop_set_cltv_expiry_delta(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHop_set_cltv_expiry_delta(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKRouteHop RouteHop_new(struct LDKPublicKey pubkey_arg, struct LDKNodeFeatures node_features_arg, uint64_t short_channel_id_arg, struct LDKChannelFeatures channel_features_arg, uint64_t fee_msat_arg, uint32_t cltv_expiry_delta_arg);
/* @internal */
export function RouteHop_new(pubkey_arg: number, node_features_arg: number, short_channel_id_arg: bigint, channel_features_arg: number, fee_msat_arg: bigint, cltv_expiry_delta_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHop_new(pubkey_arg, node_features_arg, short_channel_id_arg, channel_features_arg, fee_msat_arg, cltv_expiry_delta_arg);
	return nativeResponseValue;
}
	// uintptr_t RouteHop_clone_ptr(LDKRouteHop *NONNULL_PTR arg);
/* @internal */
export function RouteHop_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHop_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKRouteHop RouteHop_clone(const struct LDKRouteHop *NONNULL_PTR orig);
/* @internal */
export function RouteHop_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHop_clone(orig);
	return nativeResponseValue;
}
	// uint64_t RouteHop_hash(const struct LDKRouteHop *NONNULL_PTR o);
/* @internal */
export function RouteHop_hash(o: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHop_hash(o);
	return nativeResponseValue;
}
	// bool RouteHop_eq(const struct LDKRouteHop *NONNULL_PTR a, const struct LDKRouteHop *NONNULL_PTR b);
/* @internal */
export function RouteHop_eq(a: number, b: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHop_eq(a, b);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z RouteHop_write(const struct LDKRouteHop *NONNULL_PTR obj);
/* @internal */
export function RouteHop_write(obj: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHop_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_RouteHopDecodeErrorZ RouteHop_read(struct LDKu8slice ser);
/* @internal */
export function RouteHop_read(ser: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHop_read(ser);
	return nativeResponseValue;
}
	// void Route_free(struct LDKRoute this_obj);
/* @internal */
export function Route_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Route_free(this_obj);
	// debug statements here
}
	// struct LDKCVec_CVec_RouteHopZZ Route_get_paths(const struct LDKRoute *NONNULL_PTR this_ptr);
/* @internal */
export function Route_get_paths(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Route_get_paths(this_ptr);
	return nativeResponseValue;
}
	// void Route_set_paths(struct LDKRoute *NONNULL_PTR this_ptr, struct LDKCVec_CVec_RouteHopZZ val);
/* @internal */
export function Route_set_paths(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Route_set_paths(this_ptr, val);
	// debug statements here
}
	// struct LDKPaymentParameters Route_get_payment_params(const struct LDKRoute *NONNULL_PTR this_ptr);
/* @internal */
export function Route_get_payment_params(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Route_get_payment_params(this_ptr);
	return nativeResponseValue;
}
	// void Route_set_payment_params(struct LDKRoute *NONNULL_PTR this_ptr, struct LDKPaymentParameters val);
/* @internal */
export function Route_set_payment_params(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Route_set_payment_params(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKRoute Route_new(struct LDKCVec_CVec_RouteHopZZ paths_arg, struct LDKPaymentParameters payment_params_arg);
/* @internal */
export function Route_new(paths_arg: number, payment_params_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Route_new(paths_arg, payment_params_arg);
	return nativeResponseValue;
}
	// uintptr_t Route_clone_ptr(LDKRoute *NONNULL_PTR arg);
/* @internal */
export function Route_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Route_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKRoute Route_clone(const struct LDKRoute *NONNULL_PTR orig);
/* @internal */
export function Route_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Route_clone(orig);
	return nativeResponseValue;
}
	// uint64_t Route_hash(const struct LDKRoute *NONNULL_PTR o);
/* @internal */
export function Route_hash(o: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Route_hash(o);
	return nativeResponseValue;
}
	// bool Route_eq(const struct LDKRoute *NONNULL_PTR a, const struct LDKRoute *NONNULL_PTR b);
/* @internal */
export function Route_eq(a: number, b: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Route_eq(a, b);
	return nativeResponseValue;
}
	// MUST_USE_RES uint64_t Route_get_total_fees(const struct LDKRoute *NONNULL_PTR this_arg);
/* @internal */
export function Route_get_total_fees(this_arg: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Route_get_total_fees(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES uint64_t Route_get_total_amount(const struct LDKRoute *NONNULL_PTR this_arg);
/* @internal */
export function Route_get_total_amount(this_arg: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Route_get_total_amount(this_arg);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z Route_write(const struct LDKRoute *NONNULL_PTR obj);
/* @internal */
export function Route_write(obj: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Route_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_RouteDecodeErrorZ Route_read(struct LDKu8slice ser);
/* @internal */
export function Route_read(ser: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Route_read(ser);
	return nativeResponseValue;
}
	// void RouteParameters_free(struct LDKRouteParameters this_obj);
/* @internal */
export function RouteParameters_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteParameters_free(this_obj);
	// debug statements here
}
	// struct LDKPaymentParameters RouteParameters_get_payment_params(const struct LDKRouteParameters *NONNULL_PTR this_ptr);
/* @internal */
export function RouteParameters_get_payment_params(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteParameters_get_payment_params(this_ptr);
	return nativeResponseValue;
}
	// void RouteParameters_set_payment_params(struct LDKRouteParameters *NONNULL_PTR this_ptr, struct LDKPaymentParameters val);
/* @internal */
export function RouteParameters_set_payment_params(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteParameters_set_payment_params(this_ptr, val);
	// debug statements here
}
	// uint64_t RouteParameters_get_final_value_msat(const struct LDKRouteParameters *NONNULL_PTR this_ptr);
/* @internal */
export function RouteParameters_get_final_value_msat(this_ptr: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteParameters_get_final_value_msat(this_ptr);
	return nativeResponseValue;
}
	// void RouteParameters_set_final_value_msat(struct LDKRouteParameters *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function RouteParameters_set_final_value_msat(this_ptr: number, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteParameters_set_final_value_msat(this_ptr, val);
	// debug statements here
}
	// uint32_t RouteParameters_get_final_cltv_expiry_delta(const struct LDKRouteParameters *NONNULL_PTR this_ptr);
/* @internal */
export function RouteParameters_get_final_cltv_expiry_delta(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteParameters_get_final_cltv_expiry_delta(this_ptr);
	return nativeResponseValue;
}
	// void RouteParameters_set_final_cltv_expiry_delta(struct LDKRouteParameters *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */
export function RouteParameters_set_final_cltv_expiry_delta(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteParameters_set_final_cltv_expiry_delta(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKRouteParameters RouteParameters_new(struct LDKPaymentParameters payment_params_arg, uint64_t final_value_msat_arg, uint32_t final_cltv_expiry_delta_arg);
/* @internal */
export function RouteParameters_new(payment_params_arg: number, final_value_msat_arg: bigint, final_cltv_expiry_delta_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteParameters_new(payment_params_arg, final_value_msat_arg, final_cltv_expiry_delta_arg);
	return nativeResponseValue;
}
	// uintptr_t RouteParameters_clone_ptr(LDKRouteParameters *NONNULL_PTR arg);
/* @internal */
export function RouteParameters_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteParameters_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKRouteParameters RouteParameters_clone(const struct LDKRouteParameters *NONNULL_PTR orig);
/* @internal */
export function RouteParameters_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteParameters_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z RouteParameters_write(const struct LDKRouteParameters *NONNULL_PTR obj);
/* @internal */
export function RouteParameters_write(obj: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteParameters_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_RouteParametersDecodeErrorZ RouteParameters_read(struct LDKu8slice ser);
/* @internal */
export function RouteParameters_read(ser: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteParameters_read(ser);
	return nativeResponseValue;
}
	// void PaymentParameters_free(struct LDKPaymentParameters this_obj);
/* @internal */
export function PaymentParameters_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentParameters_free(this_obj);
	// debug statements here
}
	// struct LDKPublicKey PaymentParameters_get_payee_pubkey(const struct LDKPaymentParameters *NONNULL_PTR this_ptr);
/* @internal */
export function PaymentParameters_get_payee_pubkey(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentParameters_get_payee_pubkey(this_ptr);
	return nativeResponseValue;
}
	// void PaymentParameters_set_payee_pubkey(struct LDKPaymentParameters *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */
export function PaymentParameters_set_payee_pubkey(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentParameters_set_payee_pubkey(this_ptr, val);
	// debug statements here
}
	// struct LDKInvoiceFeatures PaymentParameters_get_features(const struct LDKPaymentParameters *NONNULL_PTR this_ptr);
/* @internal */
export function PaymentParameters_get_features(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentParameters_get_features(this_ptr);
	return nativeResponseValue;
}
	// void PaymentParameters_set_features(struct LDKPaymentParameters *NONNULL_PTR this_ptr, struct LDKInvoiceFeatures val);
/* @internal */
export function PaymentParameters_set_features(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentParameters_set_features(this_ptr, val);
	// debug statements here
}
	// struct LDKCVec_RouteHintZ PaymentParameters_get_route_hints(const struct LDKPaymentParameters *NONNULL_PTR this_ptr);
/* @internal */
export function PaymentParameters_get_route_hints(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentParameters_get_route_hints(this_ptr);
	return nativeResponseValue;
}
	// void PaymentParameters_set_route_hints(struct LDKPaymentParameters *NONNULL_PTR this_ptr, struct LDKCVec_RouteHintZ val);
/* @internal */
export function PaymentParameters_set_route_hints(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentParameters_set_route_hints(this_ptr, val);
	// debug statements here
}
	// struct LDKCOption_u64Z PaymentParameters_get_expiry_time(const struct LDKPaymentParameters *NONNULL_PTR this_ptr);
/* @internal */
export function PaymentParameters_get_expiry_time(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentParameters_get_expiry_time(this_ptr);
	return nativeResponseValue;
}
	// void PaymentParameters_set_expiry_time(struct LDKPaymentParameters *NONNULL_PTR this_ptr, struct LDKCOption_u64Z val);
/* @internal */
export function PaymentParameters_set_expiry_time(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentParameters_set_expiry_time(this_ptr, val);
	// debug statements here
}
	// uint32_t PaymentParameters_get_max_total_cltv_expiry_delta(const struct LDKPaymentParameters *NONNULL_PTR this_ptr);
/* @internal */
export function PaymentParameters_get_max_total_cltv_expiry_delta(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentParameters_get_max_total_cltv_expiry_delta(this_ptr);
	return nativeResponseValue;
}
	// void PaymentParameters_set_max_total_cltv_expiry_delta(struct LDKPaymentParameters *NONNULL_PTR this_ptr, uint32_t val);
/* @internal */
export function PaymentParameters_set_max_total_cltv_expiry_delta(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentParameters_set_max_total_cltv_expiry_delta(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKPaymentParameters PaymentParameters_new(struct LDKPublicKey payee_pubkey_arg, struct LDKInvoiceFeatures features_arg, struct LDKCVec_RouteHintZ route_hints_arg, struct LDKCOption_u64Z expiry_time_arg, uint32_t max_total_cltv_expiry_delta_arg);
/* @internal */
export function PaymentParameters_new(payee_pubkey_arg: number, features_arg: number, route_hints_arg: number, expiry_time_arg: number, max_total_cltv_expiry_delta_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentParameters_new(payee_pubkey_arg, features_arg, route_hints_arg, expiry_time_arg, max_total_cltv_expiry_delta_arg);
	return nativeResponseValue;
}
	// uintptr_t PaymentParameters_clone_ptr(LDKPaymentParameters *NONNULL_PTR arg);
/* @internal */
export function PaymentParameters_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentParameters_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKPaymentParameters PaymentParameters_clone(const struct LDKPaymentParameters *NONNULL_PTR orig);
/* @internal */
export function PaymentParameters_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentParameters_clone(orig);
	return nativeResponseValue;
}
	// uint64_t PaymentParameters_hash(const struct LDKPaymentParameters *NONNULL_PTR o);
/* @internal */
export function PaymentParameters_hash(o: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentParameters_hash(o);
	return nativeResponseValue;
}
	// bool PaymentParameters_eq(const struct LDKPaymentParameters *NONNULL_PTR a, const struct LDKPaymentParameters *NONNULL_PTR b);
/* @internal */
export function PaymentParameters_eq(a: number, b: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentParameters_eq(a, b);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z PaymentParameters_write(const struct LDKPaymentParameters *NONNULL_PTR obj);
/* @internal */
export function PaymentParameters_write(obj: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentParameters_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_PaymentParametersDecodeErrorZ PaymentParameters_read(struct LDKu8slice ser);
/* @internal */
export function PaymentParameters_read(ser: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentParameters_read(ser);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKPaymentParameters PaymentParameters_from_node_id(struct LDKPublicKey payee_pubkey);
/* @internal */
export function PaymentParameters_from_node_id(payee_pubkey: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentParameters_from_node_id(payee_pubkey);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKPaymentParameters PaymentParameters_for_keysend(struct LDKPublicKey payee_pubkey);
/* @internal */
export function PaymentParameters_for_keysend(payee_pubkey: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentParameters_for_keysend(payee_pubkey);
	return nativeResponseValue;
}
	// void RouteHint_free(struct LDKRouteHint this_obj);
/* @internal */
export function RouteHint_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHint_free(this_obj);
	// debug statements here
}
	// struct LDKCVec_RouteHintHopZ RouteHint_get_a(const struct LDKRouteHint *NONNULL_PTR this_ptr);
/* @internal */
export function RouteHint_get_a(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHint_get_a(this_ptr);
	return nativeResponseValue;
}
	// void RouteHint_set_a(struct LDKRouteHint *NONNULL_PTR this_ptr, struct LDKCVec_RouteHintHopZ val);
/* @internal */
export function RouteHint_set_a(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHint_set_a(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKRouteHint RouteHint_new(struct LDKCVec_RouteHintHopZ a_arg);
/* @internal */
export function RouteHint_new(a_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHint_new(a_arg);
	return nativeResponseValue;
}
	// uintptr_t RouteHint_clone_ptr(LDKRouteHint *NONNULL_PTR arg);
/* @internal */
export function RouteHint_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHint_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKRouteHint RouteHint_clone(const struct LDKRouteHint *NONNULL_PTR orig);
/* @internal */
export function RouteHint_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHint_clone(orig);
	return nativeResponseValue;
}
	// uint64_t RouteHint_hash(const struct LDKRouteHint *NONNULL_PTR o);
/* @internal */
export function RouteHint_hash(o: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHint_hash(o);
	return nativeResponseValue;
}
	// bool RouteHint_eq(const struct LDKRouteHint *NONNULL_PTR a, const struct LDKRouteHint *NONNULL_PTR b);
/* @internal */
export function RouteHint_eq(a: number, b: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHint_eq(a, b);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z RouteHint_write(const struct LDKRouteHint *NONNULL_PTR obj);
/* @internal */
export function RouteHint_write(obj: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHint_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_RouteHintDecodeErrorZ RouteHint_read(struct LDKu8slice ser);
/* @internal */
export function RouteHint_read(ser: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHint_read(ser);
	return nativeResponseValue;
}
	// void RouteHintHop_free(struct LDKRouteHintHop this_obj);
/* @internal */
export function RouteHintHop_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHintHop_free(this_obj);
	// debug statements here
}
	// struct LDKPublicKey RouteHintHop_get_src_node_id(const struct LDKRouteHintHop *NONNULL_PTR this_ptr);
/* @internal */
export function RouteHintHop_get_src_node_id(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHintHop_get_src_node_id(this_ptr);
	return nativeResponseValue;
}
	// void RouteHintHop_set_src_node_id(struct LDKRouteHintHop *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */
export function RouteHintHop_set_src_node_id(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHintHop_set_src_node_id(this_ptr, val);
	// debug statements here
}
	// uint64_t RouteHintHop_get_short_channel_id(const struct LDKRouteHintHop *NONNULL_PTR this_ptr);
/* @internal */
export function RouteHintHop_get_short_channel_id(this_ptr: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHintHop_get_short_channel_id(this_ptr);
	return nativeResponseValue;
}
	// void RouteHintHop_set_short_channel_id(struct LDKRouteHintHop *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function RouteHintHop_set_short_channel_id(this_ptr: number, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHintHop_set_short_channel_id(this_ptr, val);
	// debug statements here
}
	// struct LDKRoutingFees RouteHintHop_get_fees(const struct LDKRouteHintHop *NONNULL_PTR this_ptr);
/* @internal */
export function RouteHintHop_get_fees(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHintHop_get_fees(this_ptr);
	return nativeResponseValue;
}
	// void RouteHintHop_set_fees(struct LDKRouteHintHop *NONNULL_PTR this_ptr, struct LDKRoutingFees val);
/* @internal */
export function RouteHintHop_set_fees(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHintHop_set_fees(this_ptr, val);
	// debug statements here
}
	// uint16_t RouteHintHop_get_cltv_expiry_delta(const struct LDKRouteHintHop *NONNULL_PTR this_ptr);
/* @internal */
export function RouteHintHop_get_cltv_expiry_delta(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHintHop_get_cltv_expiry_delta(this_ptr);
	return nativeResponseValue;
}
	// void RouteHintHop_set_cltv_expiry_delta(struct LDKRouteHintHop *NONNULL_PTR this_ptr, uint16_t val);
/* @internal */
export function RouteHintHop_set_cltv_expiry_delta(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHintHop_set_cltv_expiry_delta(this_ptr, val);
	// debug statements here
}
	// struct LDKCOption_u64Z RouteHintHop_get_htlc_minimum_msat(const struct LDKRouteHintHop *NONNULL_PTR this_ptr);
/* @internal */
export function RouteHintHop_get_htlc_minimum_msat(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHintHop_get_htlc_minimum_msat(this_ptr);
	return nativeResponseValue;
}
	// void RouteHintHop_set_htlc_minimum_msat(struct LDKRouteHintHop *NONNULL_PTR this_ptr, struct LDKCOption_u64Z val);
/* @internal */
export function RouteHintHop_set_htlc_minimum_msat(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHintHop_set_htlc_minimum_msat(this_ptr, val);
	// debug statements here
}
	// struct LDKCOption_u64Z RouteHintHop_get_htlc_maximum_msat(const struct LDKRouteHintHop *NONNULL_PTR this_ptr);
/* @internal */
export function RouteHintHop_get_htlc_maximum_msat(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHintHop_get_htlc_maximum_msat(this_ptr);
	return nativeResponseValue;
}
	// void RouteHintHop_set_htlc_maximum_msat(struct LDKRouteHintHop *NONNULL_PTR this_ptr, struct LDKCOption_u64Z val);
/* @internal */
export function RouteHintHop_set_htlc_maximum_msat(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHintHop_set_htlc_maximum_msat(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKRouteHintHop RouteHintHop_new(struct LDKPublicKey src_node_id_arg, uint64_t short_channel_id_arg, struct LDKRoutingFees fees_arg, uint16_t cltv_expiry_delta_arg, struct LDKCOption_u64Z htlc_minimum_msat_arg, struct LDKCOption_u64Z htlc_maximum_msat_arg);
/* @internal */
export function RouteHintHop_new(src_node_id_arg: number, short_channel_id_arg: bigint, fees_arg: number, cltv_expiry_delta_arg: number, htlc_minimum_msat_arg: number, htlc_maximum_msat_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHintHop_new(src_node_id_arg, short_channel_id_arg, fees_arg, cltv_expiry_delta_arg, htlc_minimum_msat_arg, htlc_maximum_msat_arg);
	return nativeResponseValue;
}
	// uintptr_t RouteHintHop_clone_ptr(LDKRouteHintHop *NONNULL_PTR arg);
/* @internal */
export function RouteHintHop_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHintHop_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKRouteHintHop RouteHintHop_clone(const struct LDKRouteHintHop *NONNULL_PTR orig);
/* @internal */
export function RouteHintHop_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHintHop_clone(orig);
	return nativeResponseValue;
}
	// uint64_t RouteHintHop_hash(const struct LDKRouteHintHop *NONNULL_PTR o);
/* @internal */
export function RouteHintHop_hash(o: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHintHop_hash(o);
	return nativeResponseValue;
}
	// bool RouteHintHop_eq(const struct LDKRouteHintHop *NONNULL_PTR a, const struct LDKRouteHintHop *NONNULL_PTR b);
/* @internal */
export function RouteHintHop_eq(a: number, b: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHintHop_eq(a, b);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z RouteHintHop_write(const struct LDKRouteHintHop *NONNULL_PTR obj);
/* @internal */
export function RouteHintHop_write(obj: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHintHop_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_RouteHintHopDecodeErrorZ RouteHintHop_read(struct LDKu8slice ser);
/* @internal */
export function RouteHintHop_read(ser: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RouteHintHop_read(ser);
	return nativeResponseValue;
}
	// struct LDKCResult_RouteLightningErrorZ find_route(struct LDKPublicKey our_node_pubkey, const struct LDKRouteParameters *NONNULL_PTR route_params, const struct LDKNetworkGraph *NONNULL_PTR network, struct LDKCVec_ChannelDetailsZ *first_hops, struct LDKLogger logger, const struct LDKScore *NONNULL_PTR scorer, const uint8_t (*random_seed_bytes)[32]);
/* @internal */
export function find_route(our_node_pubkey: number, route_params: number, network: number, first_hops: number, logger: number, scorer: number, random_seed_bytes: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_find_route(our_node_pubkey, route_params, network, first_hops, logger, scorer, random_seed_bytes);
	return nativeResponseValue;
}
	// void Score_free(struct LDKScore this_ptr);
/* @internal */
export function Score_free(this_ptr: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Score_free(this_ptr);
	// debug statements here
}
	// void LockableScore_free(struct LDKLockableScore this_ptr);
/* @internal */
export function LockableScore_free(this_ptr: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_LockableScore_free(this_ptr);
	// debug statements here
}
	// void MultiThreadedLockableScore_free(struct LDKMultiThreadedLockableScore this_obj);
/* @internal */
export function MultiThreadedLockableScore_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MultiThreadedLockableScore_free(this_obj);
	// debug statements here
}
	// MUST_USE_RES struct LDKMultiThreadedLockableScore MultiThreadedLockableScore_new(struct LDKScore score);
/* @internal */
export function MultiThreadedLockableScore_new(score: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MultiThreadedLockableScore_new(score);
	return nativeResponseValue;
}
	// void FixedPenaltyScorer_free(struct LDKFixedPenaltyScorer this_obj);
/* @internal */
export function FixedPenaltyScorer_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_FixedPenaltyScorer_free(this_obj);
	// debug statements here
}
	// uintptr_t FixedPenaltyScorer_clone_ptr(LDKFixedPenaltyScorer *NONNULL_PTR arg);
/* @internal */
export function FixedPenaltyScorer_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_FixedPenaltyScorer_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKFixedPenaltyScorer FixedPenaltyScorer_clone(const struct LDKFixedPenaltyScorer *NONNULL_PTR orig);
/* @internal */
export function FixedPenaltyScorer_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_FixedPenaltyScorer_clone(orig);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKFixedPenaltyScorer FixedPenaltyScorer_with_penalty(uint64_t penalty_msat);
/* @internal */
export function FixedPenaltyScorer_with_penalty(penalty_msat: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_FixedPenaltyScorer_with_penalty(penalty_msat);
	return nativeResponseValue;
}
	// struct LDKScore FixedPenaltyScorer_as_Score(const struct LDKFixedPenaltyScorer *NONNULL_PTR this_arg);
/* @internal */
export function FixedPenaltyScorer_as_Score(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_FixedPenaltyScorer_as_Score(this_arg);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z FixedPenaltyScorer_write(const struct LDKFixedPenaltyScorer *NONNULL_PTR obj);
/* @internal */
export function FixedPenaltyScorer_write(obj: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_FixedPenaltyScorer_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_FixedPenaltyScorerDecodeErrorZ FixedPenaltyScorer_read(struct LDKu8slice ser, uint64_t arg);
/* @internal */
export function FixedPenaltyScorer_read(ser: number, arg: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_FixedPenaltyScorer_read(ser, arg);
	return nativeResponseValue;
}
	// void Scorer_free(struct LDKScorer this_obj);
/* @internal */
export function Scorer_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Scorer_free(this_obj);
	// debug statements here
}
	// void ScoringParameters_free(struct LDKScoringParameters this_obj);
/* @internal */
export function ScoringParameters_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ScoringParameters_free(this_obj);
	// debug statements here
}
	// uint64_t ScoringParameters_get_base_penalty_msat(const struct LDKScoringParameters *NONNULL_PTR this_ptr);
/* @internal */
export function ScoringParameters_get_base_penalty_msat(this_ptr: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ScoringParameters_get_base_penalty_msat(this_ptr);
	return nativeResponseValue;
}
	// void ScoringParameters_set_base_penalty_msat(struct LDKScoringParameters *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function ScoringParameters_set_base_penalty_msat(this_ptr: number, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ScoringParameters_set_base_penalty_msat(this_ptr, val);
	// debug statements here
}
	// uint64_t ScoringParameters_get_failure_penalty_msat(const struct LDKScoringParameters *NONNULL_PTR this_ptr);
/* @internal */
export function ScoringParameters_get_failure_penalty_msat(this_ptr: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ScoringParameters_get_failure_penalty_msat(this_ptr);
	return nativeResponseValue;
}
	// void ScoringParameters_set_failure_penalty_msat(struct LDKScoringParameters *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function ScoringParameters_set_failure_penalty_msat(this_ptr: number, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ScoringParameters_set_failure_penalty_msat(this_ptr, val);
	// debug statements here
}
	// uint16_t ScoringParameters_get_overuse_penalty_start_1024th(const struct LDKScoringParameters *NONNULL_PTR this_ptr);
/* @internal */
export function ScoringParameters_get_overuse_penalty_start_1024th(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ScoringParameters_get_overuse_penalty_start_1024th(this_ptr);
	return nativeResponseValue;
}
	// void ScoringParameters_set_overuse_penalty_start_1024th(struct LDKScoringParameters *NONNULL_PTR this_ptr, uint16_t val);
/* @internal */
export function ScoringParameters_set_overuse_penalty_start_1024th(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ScoringParameters_set_overuse_penalty_start_1024th(this_ptr, val);
	// debug statements here
}
	// uint64_t ScoringParameters_get_overuse_penalty_msat_per_1024th(const struct LDKScoringParameters *NONNULL_PTR this_ptr);
/* @internal */
export function ScoringParameters_get_overuse_penalty_msat_per_1024th(this_ptr: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ScoringParameters_get_overuse_penalty_msat_per_1024th(this_ptr);
	return nativeResponseValue;
}
	// void ScoringParameters_set_overuse_penalty_msat_per_1024th(struct LDKScoringParameters *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function ScoringParameters_set_overuse_penalty_msat_per_1024th(this_ptr: number, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ScoringParameters_set_overuse_penalty_msat_per_1024th(this_ptr, val);
	// debug statements here
}
	// uint64_t ScoringParameters_get_failure_penalty_half_life(const struct LDKScoringParameters *NONNULL_PTR this_ptr);
/* @internal */
export function ScoringParameters_get_failure_penalty_half_life(this_ptr: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ScoringParameters_get_failure_penalty_half_life(this_ptr);
	return nativeResponseValue;
}
	// void ScoringParameters_set_failure_penalty_half_life(struct LDKScoringParameters *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function ScoringParameters_set_failure_penalty_half_life(this_ptr: number, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ScoringParameters_set_failure_penalty_half_life(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKScoringParameters ScoringParameters_new(uint64_t base_penalty_msat_arg, uint64_t failure_penalty_msat_arg, uint16_t overuse_penalty_start_1024th_arg, uint64_t overuse_penalty_msat_per_1024th_arg, uint64_t failure_penalty_half_life_arg);
/* @internal */
export function ScoringParameters_new(base_penalty_msat_arg: bigint, failure_penalty_msat_arg: bigint, overuse_penalty_start_1024th_arg: number, overuse_penalty_msat_per_1024th_arg: bigint, failure_penalty_half_life_arg: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ScoringParameters_new(base_penalty_msat_arg, failure_penalty_msat_arg, overuse_penalty_start_1024th_arg, overuse_penalty_msat_per_1024th_arg, failure_penalty_half_life_arg);
	return nativeResponseValue;
}
	// uintptr_t ScoringParameters_clone_ptr(LDKScoringParameters *NONNULL_PTR arg);
/* @internal */
export function ScoringParameters_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ScoringParameters_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKScoringParameters ScoringParameters_clone(const struct LDKScoringParameters *NONNULL_PTR orig);
/* @internal */
export function ScoringParameters_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ScoringParameters_clone(orig);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z ScoringParameters_write(const struct LDKScoringParameters *NONNULL_PTR obj);
/* @internal */
export function ScoringParameters_write(obj: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ScoringParameters_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_ScoringParametersDecodeErrorZ ScoringParameters_read(struct LDKu8slice ser);
/* @internal */
export function ScoringParameters_read(ser: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ScoringParameters_read(ser);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKScorer Scorer_new(struct LDKScoringParameters params);
/* @internal */
export function Scorer_new(params: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Scorer_new(params);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKScorer Scorer_default(void);
/* @internal */
export function Scorer_default(): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Scorer_default();
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKScoringParameters ScoringParameters_default(void);
/* @internal */
export function ScoringParameters_default(): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ScoringParameters_default();
	return nativeResponseValue;
}
	// struct LDKScore Scorer_as_Score(const struct LDKScorer *NONNULL_PTR this_arg);
/* @internal */
export function Scorer_as_Score(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Scorer_as_Score(this_arg);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z Scorer_write(const struct LDKScorer *NONNULL_PTR obj);
/* @internal */
export function Scorer_write(obj: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Scorer_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_ScorerDecodeErrorZ Scorer_read(struct LDKu8slice ser);
/* @internal */
export function Scorer_read(ser: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Scorer_read(ser);
	return nativeResponseValue;
}
	// void ProbabilisticScorer_free(struct LDKProbabilisticScorer this_obj);
/* @internal */
export function ProbabilisticScorer_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ProbabilisticScorer_free(this_obj);
	// debug statements here
}
	// void ProbabilisticScoringParameters_free(struct LDKProbabilisticScoringParameters this_obj);
/* @internal */
export function ProbabilisticScoringParameters_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ProbabilisticScoringParameters_free(this_obj);
	// debug statements here
}
	// uint64_t ProbabilisticScoringParameters_get_base_penalty_msat(const struct LDKProbabilisticScoringParameters *NONNULL_PTR this_ptr);
/* @internal */
export function ProbabilisticScoringParameters_get_base_penalty_msat(this_ptr: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ProbabilisticScoringParameters_get_base_penalty_msat(this_ptr);
	return nativeResponseValue;
}
	// void ProbabilisticScoringParameters_set_base_penalty_msat(struct LDKProbabilisticScoringParameters *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function ProbabilisticScoringParameters_set_base_penalty_msat(this_ptr: number, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ProbabilisticScoringParameters_set_base_penalty_msat(this_ptr, val);
	// debug statements here
}
	// uint64_t ProbabilisticScoringParameters_get_liquidity_penalty_multiplier_msat(const struct LDKProbabilisticScoringParameters *NONNULL_PTR this_ptr);
/* @internal */
export function ProbabilisticScoringParameters_get_liquidity_penalty_multiplier_msat(this_ptr: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ProbabilisticScoringParameters_get_liquidity_penalty_multiplier_msat(this_ptr);
	return nativeResponseValue;
}
	// void ProbabilisticScoringParameters_set_liquidity_penalty_multiplier_msat(struct LDKProbabilisticScoringParameters *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function ProbabilisticScoringParameters_set_liquidity_penalty_multiplier_msat(this_ptr: number, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ProbabilisticScoringParameters_set_liquidity_penalty_multiplier_msat(this_ptr, val);
	// debug statements here
}
	// uint64_t ProbabilisticScoringParameters_get_liquidity_offset_half_life(const struct LDKProbabilisticScoringParameters *NONNULL_PTR this_ptr);
/* @internal */
export function ProbabilisticScoringParameters_get_liquidity_offset_half_life(this_ptr: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ProbabilisticScoringParameters_get_liquidity_offset_half_life(this_ptr);
	return nativeResponseValue;
}
	// void ProbabilisticScoringParameters_set_liquidity_offset_half_life(struct LDKProbabilisticScoringParameters *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function ProbabilisticScoringParameters_set_liquidity_offset_half_life(this_ptr: number, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ProbabilisticScoringParameters_set_liquidity_offset_half_life(this_ptr, val);
	// debug statements here
}
	// uint64_t ProbabilisticScoringParameters_get_amount_penalty_multiplier_msat(const struct LDKProbabilisticScoringParameters *NONNULL_PTR this_ptr);
/* @internal */
export function ProbabilisticScoringParameters_get_amount_penalty_multiplier_msat(this_ptr: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ProbabilisticScoringParameters_get_amount_penalty_multiplier_msat(this_ptr);
	return nativeResponseValue;
}
	// void ProbabilisticScoringParameters_set_amount_penalty_multiplier_msat(struct LDKProbabilisticScoringParameters *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function ProbabilisticScoringParameters_set_amount_penalty_multiplier_msat(this_ptr: number, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ProbabilisticScoringParameters_set_amount_penalty_multiplier_msat(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKProbabilisticScoringParameters ProbabilisticScoringParameters_new(uint64_t base_penalty_msat_arg, uint64_t liquidity_penalty_multiplier_msat_arg, uint64_t liquidity_offset_half_life_arg, uint64_t amount_penalty_multiplier_msat_arg);
/* @internal */
export function ProbabilisticScoringParameters_new(base_penalty_msat_arg: bigint, liquidity_penalty_multiplier_msat_arg: bigint, liquidity_offset_half_life_arg: bigint, amount_penalty_multiplier_msat_arg: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ProbabilisticScoringParameters_new(base_penalty_msat_arg, liquidity_penalty_multiplier_msat_arg, liquidity_offset_half_life_arg, amount_penalty_multiplier_msat_arg);
	return nativeResponseValue;
}
	// uintptr_t ProbabilisticScoringParameters_clone_ptr(LDKProbabilisticScoringParameters *NONNULL_PTR arg);
/* @internal */
export function ProbabilisticScoringParameters_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ProbabilisticScoringParameters_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKProbabilisticScoringParameters ProbabilisticScoringParameters_clone(const struct LDKProbabilisticScoringParameters *NONNULL_PTR orig);
/* @internal */
export function ProbabilisticScoringParameters_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ProbabilisticScoringParameters_clone(orig);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKProbabilisticScorer ProbabilisticScorer_new(struct LDKProbabilisticScoringParameters params, const struct LDKNetworkGraph *NONNULL_PTR network_graph);
/* @internal */
export function ProbabilisticScorer_new(params: number, network_graph: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ProbabilisticScorer_new(params, network_graph);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKProbabilisticScoringParameters ProbabilisticScoringParameters_default(void);
/* @internal */
export function ProbabilisticScoringParameters_default(): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ProbabilisticScoringParameters_default();
	return nativeResponseValue;
}
	// struct LDKScore ProbabilisticScorer_as_Score(const struct LDKProbabilisticScorer *NONNULL_PTR this_arg);
/* @internal */
export function ProbabilisticScorer_as_Score(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ProbabilisticScorer_as_Score(this_arg);
	return nativeResponseValue;
}
	// struct LDKCVec_u8Z ProbabilisticScorer_write(const struct LDKProbabilisticScorer *NONNULL_PTR obj);
/* @internal */
export function ProbabilisticScorer_write(obj: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ProbabilisticScorer_write(obj);
	return nativeResponseValue;
}
	// struct LDKCResult_ProbabilisticScorerDecodeErrorZ ProbabilisticScorer_read(struct LDKu8slice ser, struct LDKProbabilisticScoringParameters arg_a, const struct LDKNetworkGraph *NONNULL_PTR arg_b);
/* @internal */
export function ProbabilisticScorer_read(ser: number, arg_a: number, arg_b: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ProbabilisticScorer_read(ser, arg_a, arg_b);
	return nativeResponseValue;
}
	// void ParseError_free(struct LDKParseError this_ptr);
/* @internal */
export function ParseError_free(this_ptr: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ParseError_free(this_ptr);
	// debug statements here
}
	// uintptr_t ParseError_clone_ptr(LDKParseError *NONNULL_PTR arg);
/* @internal */
export function ParseError_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ParseError_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKParseError ParseError_clone(const struct LDKParseError *NONNULL_PTR orig);
/* @internal */
export function ParseError_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ParseError_clone(orig);
	return nativeResponseValue;
}
	// struct LDKParseError ParseError_bech32_error(struct LDKBech32Error a);
/* @internal */
export function ParseError_bech32_error(a: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ParseError_bech32_error(a);
	return nativeResponseValue;
}
	// struct LDKParseError ParseError_parse_amount_error(struct LDKError a);
/* @internal */
export function ParseError_parse_amount_error(a: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ParseError_parse_amount_error(a);
	return nativeResponseValue;
}
	// struct LDKParseError ParseError_malformed_signature(enum LDKSecp256k1Error a);
/* @internal */
export function ParseError_malformed_signature(a: Secp256k1Error): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ParseError_malformed_signature(a);
	return nativeResponseValue;
}
	// struct LDKParseError ParseError_bad_prefix(void);
/* @internal */
export function ParseError_bad_prefix(): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ParseError_bad_prefix();
	return nativeResponseValue;
}
	// struct LDKParseError ParseError_unknown_currency(void);
/* @internal */
export function ParseError_unknown_currency(): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ParseError_unknown_currency();
	return nativeResponseValue;
}
	// struct LDKParseError ParseError_unknown_si_prefix(void);
/* @internal */
export function ParseError_unknown_si_prefix(): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ParseError_unknown_si_prefix();
	return nativeResponseValue;
}
	// struct LDKParseError ParseError_malformed_hrp(void);
/* @internal */
export function ParseError_malformed_hrp(): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ParseError_malformed_hrp();
	return nativeResponseValue;
}
	// struct LDKParseError ParseError_too_short_data_part(void);
/* @internal */
export function ParseError_too_short_data_part(): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ParseError_too_short_data_part();
	return nativeResponseValue;
}
	// struct LDKParseError ParseError_unexpected_end_of_tagged_fields(void);
/* @internal */
export function ParseError_unexpected_end_of_tagged_fields(): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ParseError_unexpected_end_of_tagged_fields();
	return nativeResponseValue;
}
	// struct LDKParseError ParseError_description_decode_error(struct LDKError a);
/* @internal */
export function ParseError_description_decode_error(a: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ParseError_description_decode_error(a);
	return nativeResponseValue;
}
	// struct LDKParseError ParseError_padding_error(void);
/* @internal */
export function ParseError_padding_error(): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ParseError_padding_error();
	return nativeResponseValue;
}
	// struct LDKParseError ParseError_integer_overflow_error(void);
/* @internal */
export function ParseError_integer_overflow_error(): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ParseError_integer_overflow_error();
	return nativeResponseValue;
}
	// struct LDKParseError ParseError_invalid_seg_wit_program_length(void);
/* @internal */
export function ParseError_invalid_seg_wit_program_length(): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ParseError_invalid_seg_wit_program_length();
	return nativeResponseValue;
}
	// struct LDKParseError ParseError_invalid_pub_key_hash_length(void);
/* @internal */
export function ParseError_invalid_pub_key_hash_length(): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ParseError_invalid_pub_key_hash_length();
	return nativeResponseValue;
}
	// struct LDKParseError ParseError_invalid_script_hash_length(void);
/* @internal */
export function ParseError_invalid_script_hash_length(): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ParseError_invalid_script_hash_length();
	return nativeResponseValue;
}
	// struct LDKParseError ParseError_invalid_recovery_id(void);
/* @internal */
export function ParseError_invalid_recovery_id(): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ParseError_invalid_recovery_id();
	return nativeResponseValue;
}
	// struct LDKParseError ParseError_invalid_slice_length(struct LDKStr a);
/* @internal */
export function ParseError_invalid_slice_length(a: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ParseError_invalid_slice_length(a);
	return nativeResponseValue;
}
	// struct LDKParseError ParseError_skip(void);
/* @internal */
export function ParseError_skip(): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ParseError_skip();
	return nativeResponseValue;
}
	// void ParseOrSemanticError_free(struct LDKParseOrSemanticError this_ptr);
/* @internal */
export function ParseOrSemanticError_free(this_ptr: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ParseOrSemanticError_free(this_ptr);
	// debug statements here
}
	// uintptr_t ParseOrSemanticError_clone_ptr(LDKParseOrSemanticError *NONNULL_PTR arg);
/* @internal */
export function ParseOrSemanticError_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ParseOrSemanticError_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKParseOrSemanticError ParseOrSemanticError_clone(const struct LDKParseOrSemanticError *NONNULL_PTR orig);
/* @internal */
export function ParseOrSemanticError_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ParseOrSemanticError_clone(orig);
	return nativeResponseValue;
}
	// struct LDKParseOrSemanticError ParseOrSemanticError_parse_error(struct LDKParseError a);
/* @internal */
export function ParseOrSemanticError_parse_error(a: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ParseOrSemanticError_parse_error(a);
	return nativeResponseValue;
}
	// struct LDKParseOrSemanticError ParseOrSemanticError_semantic_error(enum LDKSemanticError a);
/* @internal */
export function ParseOrSemanticError_semantic_error(a: SemanticError): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ParseOrSemanticError_semantic_error(a);
	return nativeResponseValue;
}
	// void Invoice_free(struct LDKInvoice this_obj);
/* @internal */
export function Invoice_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Invoice_free(this_obj);
	// debug statements here
}
	// bool Invoice_eq(const struct LDKInvoice *NONNULL_PTR a, const struct LDKInvoice *NONNULL_PTR b);
/* @internal */
export function Invoice_eq(a: number, b: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Invoice_eq(a, b);
	return nativeResponseValue;
}
	// uintptr_t Invoice_clone_ptr(LDKInvoice *NONNULL_PTR arg);
/* @internal */
export function Invoice_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Invoice_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKInvoice Invoice_clone(const struct LDKInvoice *NONNULL_PTR orig);
/* @internal */
export function Invoice_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Invoice_clone(orig);
	return nativeResponseValue;
}
	// void SignedRawInvoice_free(struct LDKSignedRawInvoice this_obj);
/* @internal */
export function SignedRawInvoice_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SignedRawInvoice_free(this_obj);
	// debug statements here
}
	// bool SignedRawInvoice_eq(const struct LDKSignedRawInvoice *NONNULL_PTR a, const struct LDKSignedRawInvoice *NONNULL_PTR b);
/* @internal */
export function SignedRawInvoice_eq(a: number, b: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SignedRawInvoice_eq(a, b);
	return nativeResponseValue;
}
	// uintptr_t SignedRawInvoice_clone_ptr(LDKSignedRawInvoice *NONNULL_PTR arg);
/* @internal */
export function SignedRawInvoice_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SignedRawInvoice_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKSignedRawInvoice SignedRawInvoice_clone(const struct LDKSignedRawInvoice *NONNULL_PTR orig);
/* @internal */
export function SignedRawInvoice_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SignedRawInvoice_clone(orig);
	return nativeResponseValue;
}
	// void RawInvoice_free(struct LDKRawInvoice this_obj);
/* @internal */
export function RawInvoice_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RawInvoice_free(this_obj);
	// debug statements here
}
	// struct LDKRawDataPart RawInvoice_get_data(const struct LDKRawInvoice *NONNULL_PTR this_ptr);
/* @internal */
export function RawInvoice_get_data(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RawInvoice_get_data(this_ptr);
	return nativeResponseValue;
}
	// void RawInvoice_set_data(struct LDKRawInvoice *NONNULL_PTR this_ptr, struct LDKRawDataPart val);
/* @internal */
export function RawInvoice_set_data(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RawInvoice_set_data(this_ptr, val);
	// debug statements here
}
	// bool RawInvoice_eq(const struct LDKRawInvoice *NONNULL_PTR a, const struct LDKRawInvoice *NONNULL_PTR b);
/* @internal */
export function RawInvoice_eq(a: number, b: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RawInvoice_eq(a, b);
	return nativeResponseValue;
}
	// uintptr_t RawInvoice_clone_ptr(LDKRawInvoice *NONNULL_PTR arg);
/* @internal */
export function RawInvoice_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RawInvoice_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKRawInvoice RawInvoice_clone(const struct LDKRawInvoice *NONNULL_PTR orig);
/* @internal */
export function RawInvoice_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RawInvoice_clone(orig);
	return nativeResponseValue;
}
	// void RawDataPart_free(struct LDKRawDataPart this_obj);
/* @internal */
export function RawDataPart_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RawDataPart_free(this_obj);
	// debug statements here
}
	// struct LDKPositiveTimestamp RawDataPart_get_timestamp(const struct LDKRawDataPart *NONNULL_PTR this_ptr);
/* @internal */
export function RawDataPart_get_timestamp(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RawDataPart_get_timestamp(this_ptr);
	return nativeResponseValue;
}
	// void RawDataPart_set_timestamp(struct LDKRawDataPart *NONNULL_PTR this_ptr, struct LDKPositiveTimestamp val);
/* @internal */
export function RawDataPart_set_timestamp(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RawDataPart_set_timestamp(this_ptr, val);
	// debug statements here
}
	// bool RawDataPart_eq(const struct LDKRawDataPart *NONNULL_PTR a, const struct LDKRawDataPart *NONNULL_PTR b);
/* @internal */
export function RawDataPart_eq(a: number, b: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RawDataPart_eq(a, b);
	return nativeResponseValue;
}
	// uintptr_t RawDataPart_clone_ptr(LDKRawDataPart *NONNULL_PTR arg);
/* @internal */
export function RawDataPart_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RawDataPart_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKRawDataPart RawDataPart_clone(const struct LDKRawDataPart *NONNULL_PTR orig);
/* @internal */
export function RawDataPart_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RawDataPart_clone(orig);
	return nativeResponseValue;
}
	// void PositiveTimestamp_free(struct LDKPositiveTimestamp this_obj);
/* @internal */
export function PositiveTimestamp_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PositiveTimestamp_free(this_obj);
	// debug statements here
}
	// bool PositiveTimestamp_eq(const struct LDKPositiveTimestamp *NONNULL_PTR a, const struct LDKPositiveTimestamp *NONNULL_PTR b);
/* @internal */
export function PositiveTimestamp_eq(a: number, b: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PositiveTimestamp_eq(a, b);
	return nativeResponseValue;
}
	// uintptr_t PositiveTimestamp_clone_ptr(LDKPositiveTimestamp *NONNULL_PTR arg);
/* @internal */
export function PositiveTimestamp_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PositiveTimestamp_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKPositiveTimestamp PositiveTimestamp_clone(const struct LDKPositiveTimestamp *NONNULL_PTR orig);
/* @internal */
export function PositiveTimestamp_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PositiveTimestamp_clone(orig);
	return nativeResponseValue;
}
	// enum LDKSiPrefix SiPrefix_clone(const enum LDKSiPrefix *NONNULL_PTR orig);
/* @internal */
export function SiPrefix_clone(orig: number): SiPrefix {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SiPrefix_clone(orig);
	return nativeResponseValue;
}
	// enum LDKSiPrefix SiPrefix_milli(void);
/* @internal */
export function SiPrefix_milli(): SiPrefix {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SiPrefix_milli();
	return nativeResponseValue;
}
	// enum LDKSiPrefix SiPrefix_micro(void);
/* @internal */
export function SiPrefix_micro(): SiPrefix {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SiPrefix_micro();
	return nativeResponseValue;
}
	// enum LDKSiPrefix SiPrefix_nano(void);
/* @internal */
export function SiPrefix_nano(): SiPrefix {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SiPrefix_nano();
	return nativeResponseValue;
}
	// enum LDKSiPrefix SiPrefix_pico(void);
/* @internal */
export function SiPrefix_pico(): SiPrefix {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SiPrefix_pico();
	return nativeResponseValue;
}
	// bool SiPrefix_eq(const enum LDKSiPrefix *NONNULL_PTR a, const enum LDKSiPrefix *NONNULL_PTR b);
/* @internal */
export function SiPrefix_eq(a: number, b: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SiPrefix_eq(a, b);
	return nativeResponseValue;
}
	// MUST_USE_RES uint64_t SiPrefix_multiplier(const enum LDKSiPrefix *NONNULL_PTR this_arg);
/* @internal */
export function SiPrefix_multiplier(this_arg: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SiPrefix_multiplier(this_arg);
	return nativeResponseValue;
}
	// enum LDKCurrency Currency_clone(const enum LDKCurrency *NONNULL_PTR orig);
/* @internal */
export function Currency_clone(orig: number): Currency {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Currency_clone(orig);
	return nativeResponseValue;
}
	// enum LDKCurrency Currency_bitcoin(void);
/* @internal */
export function Currency_bitcoin(): Currency {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Currency_bitcoin();
	return nativeResponseValue;
}
	// enum LDKCurrency Currency_bitcoin_testnet(void);
/* @internal */
export function Currency_bitcoin_testnet(): Currency {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Currency_bitcoin_testnet();
	return nativeResponseValue;
}
	// enum LDKCurrency Currency_regtest(void);
/* @internal */
export function Currency_regtest(): Currency {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Currency_regtest();
	return nativeResponseValue;
}
	// enum LDKCurrency Currency_simnet(void);
/* @internal */
export function Currency_simnet(): Currency {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Currency_simnet();
	return nativeResponseValue;
}
	// enum LDKCurrency Currency_signet(void);
/* @internal */
export function Currency_signet(): Currency {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Currency_signet();
	return nativeResponseValue;
}
	// uint64_t Currency_hash(const enum LDKCurrency *NONNULL_PTR o);
/* @internal */
export function Currency_hash(o: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Currency_hash(o);
	return nativeResponseValue;
}
	// bool Currency_eq(const enum LDKCurrency *NONNULL_PTR a, const enum LDKCurrency *NONNULL_PTR b);
/* @internal */
export function Currency_eq(a: number, b: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Currency_eq(a, b);
	return nativeResponseValue;
}
	// void Sha256_free(struct LDKSha256 this_obj);
/* @internal */
export function Sha256_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Sha256_free(this_obj);
	// debug statements here
}
	// uintptr_t Sha256_clone_ptr(LDKSha256 *NONNULL_PTR arg);
/* @internal */
export function Sha256_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Sha256_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKSha256 Sha256_clone(const struct LDKSha256 *NONNULL_PTR orig);
/* @internal */
export function Sha256_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Sha256_clone(orig);
	return nativeResponseValue;
}
	// uint64_t Sha256_hash(const struct LDKSha256 *NONNULL_PTR o);
/* @internal */
export function Sha256_hash(o: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Sha256_hash(o);
	return nativeResponseValue;
}
	// bool Sha256_eq(const struct LDKSha256 *NONNULL_PTR a, const struct LDKSha256 *NONNULL_PTR b);
/* @internal */
export function Sha256_eq(a: number, b: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Sha256_eq(a, b);
	return nativeResponseValue;
}
	// void Description_free(struct LDKDescription this_obj);
/* @internal */
export function Description_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Description_free(this_obj);
	// debug statements here
}
	// uintptr_t Description_clone_ptr(LDKDescription *NONNULL_PTR arg);
/* @internal */
export function Description_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Description_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKDescription Description_clone(const struct LDKDescription *NONNULL_PTR orig);
/* @internal */
export function Description_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Description_clone(orig);
	return nativeResponseValue;
}
	// uint64_t Description_hash(const struct LDKDescription *NONNULL_PTR o);
/* @internal */
export function Description_hash(o: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Description_hash(o);
	return nativeResponseValue;
}
	// bool Description_eq(const struct LDKDescription *NONNULL_PTR a, const struct LDKDescription *NONNULL_PTR b);
/* @internal */
export function Description_eq(a: number, b: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Description_eq(a, b);
	return nativeResponseValue;
}
	// void PayeePubKey_free(struct LDKPayeePubKey this_obj);
/* @internal */
export function PayeePubKey_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PayeePubKey_free(this_obj);
	// debug statements here
}
	// struct LDKPublicKey PayeePubKey_get_a(const struct LDKPayeePubKey *NONNULL_PTR this_ptr);
/* @internal */
export function PayeePubKey_get_a(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PayeePubKey_get_a(this_ptr);
	return nativeResponseValue;
}
	// void PayeePubKey_set_a(struct LDKPayeePubKey *NONNULL_PTR this_ptr, struct LDKPublicKey val);
/* @internal */
export function PayeePubKey_set_a(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PayeePubKey_set_a(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKPayeePubKey PayeePubKey_new(struct LDKPublicKey a_arg);
/* @internal */
export function PayeePubKey_new(a_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PayeePubKey_new(a_arg);
	return nativeResponseValue;
}
	// uintptr_t PayeePubKey_clone_ptr(LDKPayeePubKey *NONNULL_PTR arg);
/* @internal */
export function PayeePubKey_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PayeePubKey_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKPayeePubKey PayeePubKey_clone(const struct LDKPayeePubKey *NONNULL_PTR orig);
/* @internal */
export function PayeePubKey_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PayeePubKey_clone(orig);
	return nativeResponseValue;
}
	// uint64_t PayeePubKey_hash(const struct LDKPayeePubKey *NONNULL_PTR o);
/* @internal */
export function PayeePubKey_hash(o: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PayeePubKey_hash(o);
	return nativeResponseValue;
}
	// bool PayeePubKey_eq(const struct LDKPayeePubKey *NONNULL_PTR a, const struct LDKPayeePubKey *NONNULL_PTR b);
/* @internal */
export function PayeePubKey_eq(a: number, b: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PayeePubKey_eq(a, b);
	return nativeResponseValue;
}
	// void ExpiryTime_free(struct LDKExpiryTime this_obj);
/* @internal */
export function ExpiryTime_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ExpiryTime_free(this_obj);
	// debug statements here
}
	// uintptr_t ExpiryTime_clone_ptr(LDKExpiryTime *NONNULL_PTR arg);
/* @internal */
export function ExpiryTime_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ExpiryTime_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKExpiryTime ExpiryTime_clone(const struct LDKExpiryTime *NONNULL_PTR orig);
/* @internal */
export function ExpiryTime_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ExpiryTime_clone(orig);
	return nativeResponseValue;
}
	// uint64_t ExpiryTime_hash(const struct LDKExpiryTime *NONNULL_PTR o);
/* @internal */
export function ExpiryTime_hash(o: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ExpiryTime_hash(o);
	return nativeResponseValue;
}
	// bool ExpiryTime_eq(const struct LDKExpiryTime *NONNULL_PTR a, const struct LDKExpiryTime *NONNULL_PTR b);
/* @internal */
export function ExpiryTime_eq(a: number, b: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ExpiryTime_eq(a, b);
	return nativeResponseValue;
}
	// void MinFinalCltvExpiry_free(struct LDKMinFinalCltvExpiry this_obj);
/* @internal */
export function MinFinalCltvExpiry_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MinFinalCltvExpiry_free(this_obj);
	// debug statements here
}
	// uint64_t MinFinalCltvExpiry_get_a(const struct LDKMinFinalCltvExpiry *NONNULL_PTR this_ptr);
/* @internal */
export function MinFinalCltvExpiry_get_a(this_ptr: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MinFinalCltvExpiry_get_a(this_ptr);
	return nativeResponseValue;
}
	// void MinFinalCltvExpiry_set_a(struct LDKMinFinalCltvExpiry *NONNULL_PTR this_ptr, uint64_t val);
/* @internal */
export function MinFinalCltvExpiry_set_a(this_ptr: number, val: bigint): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MinFinalCltvExpiry_set_a(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKMinFinalCltvExpiry MinFinalCltvExpiry_new(uint64_t a_arg);
/* @internal */
export function MinFinalCltvExpiry_new(a_arg: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MinFinalCltvExpiry_new(a_arg);
	return nativeResponseValue;
}
	// uintptr_t MinFinalCltvExpiry_clone_ptr(LDKMinFinalCltvExpiry *NONNULL_PTR arg);
/* @internal */
export function MinFinalCltvExpiry_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MinFinalCltvExpiry_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKMinFinalCltvExpiry MinFinalCltvExpiry_clone(const struct LDKMinFinalCltvExpiry *NONNULL_PTR orig);
/* @internal */
export function MinFinalCltvExpiry_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MinFinalCltvExpiry_clone(orig);
	return nativeResponseValue;
}
	// uint64_t MinFinalCltvExpiry_hash(const struct LDKMinFinalCltvExpiry *NONNULL_PTR o);
/* @internal */
export function MinFinalCltvExpiry_hash(o: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MinFinalCltvExpiry_hash(o);
	return nativeResponseValue;
}
	// bool MinFinalCltvExpiry_eq(const struct LDKMinFinalCltvExpiry *NONNULL_PTR a, const struct LDKMinFinalCltvExpiry *NONNULL_PTR b);
/* @internal */
export function MinFinalCltvExpiry_eq(a: number, b: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_MinFinalCltvExpiry_eq(a, b);
	return nativeResponseValue;
}
	// void Fallback_free(struct LDKFallback this_ptr);
/* @internal */
export function Fallback_free(this_ptr: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Fallback_free(this_ptr);
	// debug statements here
}
	// uintptr_t Fallback_clone_ptr(LDKFallback *NONNULL_PTR arg);
/* @internal */
export function Fallback_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Fallback_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKFallback Fallback_clone(const struct LDKFallback *NONNULL_PTR orig);
/* @internal */
export function Fallback_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Fallback_clone(orig);
	return nativeResponseValue;
}
	// struct LDKFallback Fallback_seg_wit_program(struct LDKu5 version, struct LDKCVec_u8Z program);
/* @internal */
export function Fallback_seg_wit_program(version: number, program: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Fallback_seg_wit_program(version, program);
	return nativeResponseValue;
}
	// struct LDKFallback Fallback_pub_key_hash(struct LDKTwentyBytes a);
/* @internal */
export function Fallback_pub_key_hash(a: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Fallback_pub_key_hash(a);
	return nativeResponseValue;
}
	// struct LDKFallback Fallback_script_hash(struct LDKTwentyBytes a);
/* @internal */
export function Fallback_script_hash(a: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Fallback_script_hash(a);
	return nativeResponseValue;
}
	// uint64_t Fallback_hash(const struct LDKFallback *NONNULL_PTR o);
/* @internal */
export function Fallback_hash(o: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Fallback_hash(o);
	return nativeResponseValue;
}
	// bool Fallback_eq(const struct LDKFallback *NONNULL_PTR a, const struct LDKFallback *NONNULL_PTR b);
/* @internal */
export function Fallback_eq(a: number, b: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Fallback_eq(a, b);
	return nativeResponseValue;
}
	// void InvoiceSignature_free(struct LDKInvoiceSignature this_obj);
/* @internal */
export function InvoiceSignature_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InvoiceSignature_free(this_obj);
	// debug statements here
}
	// uintptr_t InvoiceSignature_clone_ptr(LDKInvoiceSignature *NONNULL_PTR arg);
/* @internal */
export function InvoiceSignature_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InvoiceSignature_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKInvoiceSignature InvoiceSignature_clone(const struct LDKInvoiceSignature *NONNULL_PTR orig);
/* @internal */
export function InvoiceSignature_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InvoiceSignature_clone(orig);
	return nativeResponseValue;
}
	// bool InvoiceSignature_eq(const struct LDKInvoiceSignature *NONNULL_PTR a, const struct LDKInvoiceSignature *NONNULL_PTR b);
/* @internal */
export function InvoiceSignature_eq(a: number, b: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InvoiceSignature_eq(a, b);
	return nativeResponseValue;
}
	// void PrivateRoute_free(struct LDKPrivateRoute this_obj);
/* @internal */
export function PrivateRoute_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PrivateRoute_free(this_obj);
	// debug statements here
}
	// uintptr_t PrivateRoute_clone_ptr(LDKPrivateRoute *NONNULL_PTR arg);
/* @internal */
export function PrivateRoute_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PrivateRoute_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKPrivateRoute PrivateRoute_clone(const struct LDKPrivateRoute *NONNULL_PTR orig);
/* @internal */
export function PrivateRoute_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PrivateRoute_clone(orig);
	return nativeResponseValue;
}
	// uint64_t PrivateRoute_hash(const struct LDKPrivateRoute *NONNULL_PTR o);
/* @internal */
export function PrivateRoute_hash(o: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PrivateRoute_hash(o);
	return nativeResponseValue;
}
	// bool PrivateRoute_eq(const struct LDKPrivateRoute *NONNULL_PTR a, const struct LDKPrivateRoute *NONNULL_PTR b);
/* @internal */
export function PrivateRoute_eq(a: number, b: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PrivateRoute_eq(a, b);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKC3Tuple_RawInvoice_u832InvoiceSignatureZ SignedRawInvoice_into_parts(struct LDKSignedRawInvoice this_arg);
/* @internal */
export function SignedRawInvoice_into_parts(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SignedRawInvoice_into_parts(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKRawInvoice SignedRawInvoice_raw_invoice(const struct LDKSignedRawInvoice *NONNULL_PTR this_arg);
/* @internal */
export function SignedRawInvoice_raw_invoice(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SignedRawInvoice_raw_invoice(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES const uint8_t (*SignedRawInvoice_hash(const struct LDKSignedRawInvoice *NONNULL_PTR this_arg))[32];
/* @internal */
export function SignedRawInvoice_hash(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SignedRawInvoice_hash(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKInvoiceSignature SignedRawInvoice_signature(const struct LDKSignedRawInvoice *NONNULL_PTR this_arg);
/* @internal */
export function SignedRawInvoice_signature(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SignedRawInvoice_signature(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_PayeePubKeyErrorZ SignedRawInvoice_recover_payee_pub_key(const struct LDKSignedRawInvoice *NONNULL_PTR this_arg);
/* @internal */
export function SignedRawInvoice_recover_payee_pub_key(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SignedRawInvoice_recover_payee_pub_key(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES bool SignedRawInvoice_check_signature(const struct LDKSignedRawInvoice *NONNULL_PTR this_arg);
/* @internal */
export function SignedRawInvoice_check_signature(this_arg: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SignedRawInvoice_check_signature(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKThirtyTwoBytes RawInvoice_hash(const struct LDKRawInvoice *NONNULL_PTR this_arg);
/* @internal */
export function RawInvoice_hash(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RawInvoice_hash(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKSha256 RawInvoice_payment_hash(const struct LDKRawInvoice *NONNULL_PTR this_arg);
/* @internal */
export function RawInvoice_payment_hash(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RawInvoice_payment_hash(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKDescription RawInvoice_description(const struct LDKRawInvoice *NONNULL_PTR this_arg);
/* @internal */
export function RawInvoice_description(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RawInvoice_description(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKPayeePubKey RawInvoice_payee_pub_key(const struct LDKRawInvoice *NONNULL_PTR this_arg);
/* @internal */
export function RawInvoice_payee_pub_key(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RawInvoice_payee_pub_key(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKSha256 RawInvoice_description_hash(const struct LDKRawInvoice *NONNULL_PTR this_arg);
/* @internal */
export function RawInvoice_description_hash(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RawInvoice_description_hash(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKExpiryTime RawInvoice_expiry_time(const struct LDKRawInvoice *NONNULL_PTR this_arg);
/* @internal */
export function RawInvoice_expiry_time(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RawInvoice_expiry_time(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKMinFinalCltvExpiry RawInvoice_min_final_cltv_expiry(const struct LDKRawInvoice *NONNULL_PTR this_arg);
/* @internal */
export function RawInvoice_min_final_cltv_expiry(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RawInvoice_min_final_cltv_expiry(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKThirtyTwoBytes RawInvoice_payment_secret(const struct LDKRawInvoice *NONNULL_PTR this_arg);
/* @internal */
export function RawInvoice_payment_secret(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RawInvoice_payment_secret(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKInvoiceFeatures RawInvoice_features(const struct LDKRawInvoice *NONNULL_PTR this_arg);
/* @internal */
export function RawInvoice_features(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RawInvoice_features(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCVec_PrivateRouteZ RawInvoice_private_routes(const struct LDKRawInvoice *NONNULL_PTR this_arg);
/* @internal */
export function RawInvoice_private_routes(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RawInvoice_private_routes(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCOption_u64Z RawInvoice_amount_pico_btc(const struct LDKRawInvoice *NONNULL_PTR this_arg);
/* @internal */
export function RawInvoice_amount_pico_btc(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RawInvoice_amount_pico_btc(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES enum LDKCurrency RawInvoice_currency(const struct LDKRawInvoice *NONNULL_PTR this_arg);
/* @internal */
export function RawInvoice_currency(this_arg: number): Currency {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RawInvoice_currency(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_PositiveTimestampCreationErrorZ PositiveTimestamp_from_unix_timestamp(uint64_t unix_seconds);
/* @internal */
export function PositiveTimestamp_from_unix_timestamp(unix_seconds: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PositiveTimestamp_from_unix_timestamp(unix_seconds);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_PositiveTimestampCreationErrorZ PositiveTimestamp_from_duration_since_epoch(uint64_t duration);
/* @internal */
export function PositiveTimestamp_from_duration_since_epoch(duration: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PositiveTimestamp_from_duration_since_epoch(duration);
	return nativeResponseValue;
}
	// MUST_USE_RES uint64_t PositiveTimestamp_as_unix_timestamp(const struct LDKPositiveTimestamp *NONNULL_PTR this_arg);
/* @internal */
export function PositiveTimestamp_as_unix_timestamp(this_arg: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PositiveTimestamp_as_unix_timestamp(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES uint64_t PositiveTimestamp_as_duration_since_epoch(const struct LDKPositiveTimestamp *NONNULL_PTR this_arg);
/* @internal */
export function PositiveTimestamp_as_duration_since_epoch(this_arg: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PositiveTimestamp_as_duration_since_epoch(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKSignedRawInvoice Invoice_into_signed_raw(struct LDKInvoice this_arg);
/* @internal */
export function Invoice_into_signed_raw(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Invoice_into_signed_raw(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_NoneSemanticErrorZ Invoice_check_signature(const struct LDKInvoice *NONNULL_PTR this_arg);
/* @internal */
export function Invoice_check_signature(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Invoice_check_signature(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_InvoiceSemanticErrorZ Invoice_from_signed(struct LDKSignedRawInvoice signed_invoice);
/* @internal */
export function Invoice_from_signed(signed_invoice: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Invoice_from_signed(signed_invoice);
	return nativeResponseValue;
}
	// MUST_USE_RES uint64_t Invoice_duration_since_epoch(const struct LDKInvoice *NONNULL_PTR this_arg);
/* @internal */
export function Invoice_duration_since_epoch(this_arg: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Invoice_duration_since_epoch(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES const uint8_t (*Invoice_payment_hash(const struct LDKInvoice *NONNULL_PTR this_arg))[32];
/* @internal */
export function Invoice_payment_hash(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Invoice_payment_hash(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKPublicKey Invoice_payee_pub_key(const struct LDKInvoice *NONNULL_PTR this_arg);
/* @internal */
export function Invoice_payee_pub_key(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Invoice_payee_pub_key(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES const uint8_t (*Invoice_payment_secret(const struct LDKInvoice *NONNULL_PTR this_arg))[32];
/* @internal */
export function Invoice_payment_secret(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Invoice_payment_secret(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKInvoiceFeatures Invoice_features(const struct LDKInvoice *NONNULL_PTR this_arg);
/* @internal */
export function Invoice_features(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Invoice_features(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKPublicKey Invoice_recover_payee_pub_key(const struct LDKInvoice *NONNULL_PTR this_arg);
/* @internal */
export function Invoice_recover_payee_pub_key(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Invoice_recover_payee_pub_key(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES uint64_t Invoice_expiry_time(const struct LDKInvoice *NONNULL_PTR this_arg);
/* @internal */
export function Invoice_expiry_time(this_arg: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Invoice_expiry_time(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES bool Invoice_would_expire(const struct LDKInvoice *NONNULL_PTR this_arg, uint64_t at_time);
/* @internal */
export function Invoice_would_expire(this_arg: number, at_time: bigint): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Invoice_would_expire(this_arg, at_time);
	return nativeResponseValue;
}
	// MUST_USE_RES uint64_t Invoice_min_final_cltv_expiry(const struct LDKInvoice *NONNULL_PTR this_arg);
/* @internal */
export function Invoice_min_final_cltv_expiry(this_arg: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Invoice_min_final_cltv_expiry(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCVec_PrivateRouteZ Invoice_private_routes(const struct LDKInvoice *NONNULL_PTR this_arg);
/* @internal */
export function Invoice_private_routes(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Invoice_private_routes(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCVec_RouteHintZ Invoice_route_hints(const struct LDKInvoice *NONNULL_PTR this_arg);
/* @internal */
export function Invoice_route_hints(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Invoice_route_hints(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES enum LDKCurrency Invoice_currency(const struct LDKInvoice *NONNULL_PTR this_arg);
/* @internal */
export function Invoice_currency(this_arg: number): Currency {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Invoice_currency(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCOption_u64Z Invoice_amount_milli_satoshis(const struct LDKInvoice *NONNULL_PTR this_arg);
/* @internal */
export function Invoice_amount_milli_satoshis(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Invoice_amount_milli_satoshis(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_DescriptionCreationErrorZ Description_new(struct LDKStr description);
/* @internal */
export function Description_new(description: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Description_new(description);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKStr Description_into_inner(struct LDKDescription this_arg);
/* @internal */
export function Description_into_inner(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Description_into_inner(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKExpiryTime ExpiryTime_from_seconds(uint64_t seconds);
/* @internal */
export function ExpiryTime_from_seconds(seconds: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ExpiryTime_from_seconds(seconds);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKExpiryTime ExpiryTime_from_duration(uint64_t duration);
/* @internal */
export function ExpiryTime_from_duration(duration: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ExpiryTime_from_duration(duration);
	return nativeResponseValue;
}
	// MUST_USE_RES uint64_t ExpiryTime_as_seconds(const struct LDKExpiryTime *NONNULL_PTR this_arg);
/* @internal */
export function ExpiryTime_as_seconds(this_arg: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ExpiryTime_as_seconds(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES uint64_t ExpiryTime_as_duration(const struct LDKExpiryTime *NONNULL_PTR this_arg);
/* @internal */
export function ExpiryTime_as_duration(this_arg: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ExpiryTime_as_duration(this_arg);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_PrivateRouteCreationErrorZ PrivateRoute_new(struct LDKRouteHint hops);
/* @internal */
export function PrivateRoute_new(hops: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PrivateRoute_new(hops);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKRouteHint PrivateRoute_into_inner(struct LDKPrivateRoute this_arg);
/* @internal */
export function PrivateRoute_into_inner(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PrivateRoute_into_inner(this_arg);
	return nativeResponseValue;
}
	// enum LDKCreationError CreationError_clone(const enum LDKCreationError *NONNULL_PTR orig);
/* @internal */
export function CreationError_clone(orig: number): CreationError {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CreationError_clone(orig);
	return nativeResponseValue;
}
	// enum LDKCreationError CreationError_description_too_long(void);
/* @internal */
export function CreationError_description_too_long(): CreationError {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CreationError_description_too_long();
	return nativeResponseValue;
}
	// enum LDKCreationError CreationError_route_too_long(void);
/* @internal */
export function CreationError_route_too_long(): CreationError {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CreationError_route_too_long();
	return nativeResponseValue;
}
	// enum LDKCreationError CreationError_timestamp_out_of_bounds(void);
/* @internal */
export function CreationError_timestamp_out_of_bounds(): CreationError {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CreationError_timestamp_out_of_bounds();
	return nativeResponseValue;
}
	// enum LDKCreationError CreationError_invalid_amount(void);
/* @internal */
export function CreationError_invalid_amount(): CreationError {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CreationError_invalid_amount();
	return nativeResponseValue;
}
	// enum LDKCreationError CreationError_missing_route_hints(void);
/* @internal */
export function CreationError_missing_route_hints(): CreationError {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CreationError_missing_route_hints();
	return nativeResponseValue;
}
	// bool CreationError_eq(const enum LDKCreationError *NONNULL_PTR a, const enum LDKCreationError *NONNULL_PTR b);
/* @internal */
export function CreationError_eq(a: number, b: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CreationError_eq(a, b);
	return nativeResponseValue;
}
	// struct LDKStr CreationError_to_str(const enum LDKCreationError *NONNULL_PTR o);
/* @internal */
export function CreationError_to_str(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_CreationError_to_str(o);
	return nativeResponseValue;
}
	// enum LDKSemanticError SemanticError_clone(const enum LDKSemanticError *NONNULL_PTR orig);
/* @internal */
export function SemanticError_clone(orig: number): SemanticError {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SemanticError_clone(orig);
	return nativeResponseValue;
}
	// enum LDKSemanticError SemanticError_no_payment_hash(void);
/* @internal */
export function SemanticError_no_payment_hash(): SemanticError {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SemanticError_no_payment_hash();
	return nativeResponseValue;
}
	// enum LDKSemanticError SemanticError_multiple_payment_hashes(void);
/* @internal */
export function SemanticError_multiple_payment_hashes(): SemanticError {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SemanticError_multiple_payment_hashes();
	return nativeResponseValue;
}
	// enum LDKSemanticError SemanticError_no_description(void);
/* @internal */
export function SemanticError_no_description(): SemanticError {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SemanticError_no_description();
	return nativeResponseValue;
}
	// enum LDKSemanticError SemanticError_multiple_descriptions(void);
/* @internal */
export function SemanticError_multiple_descriptions(): SemanticError {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SemanticError_multiple_descriptions();
	return nativeResponseValue;
}
	// enum LDKSemanticError SemanticError_no_payment_secret(void);
/* @internal */
export function SemanticError_no_payment_secret(): SemanticError {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SemanticError_no_payment_secret();
	return nativeResponseValue;
}
	// enum LDKSemanticError SemanticError_multiple_payment_secrets(void);
/* @internal */
export function SemanticError_multiple_payment_secrets(): SemanticError {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SemanticError_multiple_payment_secrets();
	return nativeResponseValue;
}
	// enum LDKSemanticError SemanticError_invalid_features(void);
/* @internal */
export function SemanticError_invalid_features(): SemanticError {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SemanticError_invalid_features();
	return nativeResponseValue;
}
	// enum LDKSemanticError SemanticError_invalid_recovery_id(void);
/* @internal */
export function SemanticError_invalid_recovery_id(): SemanticError {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SemanticError_invalid_recovery_id();
	return nativeResponseValue;
}
	// enum LDKSemanticError SemanticError_invalid_signature(void);
/* @internal */
export function SemanticError_invalid_signature(): SemanticError {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SemanticError_invalid_signature();
	return nativeResponseValue;
}
	// enum LDKSemanticError SemanticError_imprecise_amount(void);
/* @internal */
export function SemanticError_imprecise_amount(): SemanticError {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SemanticError_imprecise_amount();
	return nativeResponseValue;
}
	// bool SemanticError_eq(const enum LDKSemanticError *NONNULL_PTR a, const enum LDKSemanticError *NONNULL_PTR b);
/* @internal */
export function SemanticError_eq(a: number, b: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SemanticError_eq(a, b);
	return nativeResponseValue;
}
	// struct LDKStr SemanticError_to_str(const enum LDKSemanticError *NONNULL_PTR o);
/* @internal */
export function SemanticError_to_str(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SemanticError_to_str(o);
	return nativeResponseValue;
}
	// void SignOrCreationError_free(struct LDKSignOrCreationError this_ptr);
/* @internal */
export function SignOrCreationError_free(this_ptr: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SignOrCreationError_free(this_ptr);
	// debug statements here
}
	// uintptr_t SignOrCreationError_clone_ptr(LDKSignOrCreationError *NONNULL_PTR arg);
/* @internal */
export function SignOrCreationError_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SignOrCreationError_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKSignOrCreationError SignOrCreationError_clone(const struct LDKSignOrCreationError *NONNULL_PTR orig);
/* @internal */
export function SignOrCreationError_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SignOrCreationError_clone(orig);
	return nativeResponseValue;
}
	// struct LDKSignOrCreationError SignOrCreationError_sign_error(void);
/* @internal */
export function SignOrCreationError_sign_error(): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SignOrCreationError_sign_error();
	return nativeResponseValue;
}
	// struct LDKSignOrCreationError SignOrCreationError_creation_error(enum LDKCreationError a);
/* @internal */
export function SignOrCreationError_creation_error(a: CreationError): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SignOrCreationError_creation_error(a);
	return nativeResponseValue;
}
	// bool SignOrCreationError_eq(const struct LDKSignOrCreationError *NONNULL_PTR a, const struct LDKSignOrCreationError *NONNULL_PTR b);
/* @internal */
export function SignOrCreationError_eq(a: number, b: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SignOrCreationError_eq(a, b);
	return nativeResponseValue;
}
	// struct LDKStr SignOrCreationError_to_str(const struct LDKSignOrCreationError *NONNULL_PTR o);
/* @internal */
export function SignOrCreationError_to_str(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SignOrCreationError_to_str(o);
	return nativeResponseValue;
}
	// void InvoicePayer_free(struct LDKInvoicePayer this_obj);
/* @internal */
export function InvoicePayer_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InvoicePayer_free(this_obj);
	// debug statements here
}
	// void Payer_free(struct LDKPayer this_ptr);
/* @internal */
export function Payer_free(this_ptr: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Payer_free(this_ptr);
	// debug statements here
}
	// void Router_free(struct LDKRouter this_ptr);
/* @internal */
export function Router_free(this_ptr: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Router_free(this_ptr);
	// debug statements here
}
	// void RetryAttempts_free(struct LDKRetryAttempts this_obj);
/* @internal */
export function RetryAttempts_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RetryAttempts_free(this_obj);
	// debug statements here
}
	// uintptr_t RetryAttempts_get_a(const struct LDKRetryAttempts *NONNULL_PTR this_ptr);
/* @internal */
export function RetryAttempts_get_a(this_ptr: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RetryAttempts_get_a(this_ptr);
	return nativeResponseValue;
}
	// void RetryAttempts_set_a(struct LDKRetryAttempts *NONNULL_PTR this_ptr, uintptr_t val);
/* @internal */
export function RetryAttempts_set_a(this_ptr: number, val: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RetryAttempts_set_a(this_ptr, val);
	// debug statements here
}
	// MUST_USE_RES struct LDKRetryAttempts RetryAttempts_new(uintptr_t a_arg);
/* @internal */
export function RetryAttempts_new(a_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RetryAttempts_new(a_arg);
	return nativeResponseValue;
}
	// uintptr_t RetryAttempts_clone_ptr(LDKRetryAttempts *NONNULL_PTR arg);
/* @internal */
export function RetryAttempts_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RetryAttempts_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKRetryAttempts RetryAttempts_clone(const struct LDKRetryAttempts *NONNULL_PTR orig);
/* @internal */
export function RetryAttempts_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RetryAttempts_clone(orig);
	return nativeResponseValue;
}
	// bool RetryAttempts_eq(const struct LDKRetryAttempts *NONNULL_PTR a, const struct LDKRetryAttempts *NONNULL_PTR b);
/* @internal */
export function RetryAttempts_eq(a: number, b: number): boolean {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RetryAttempts_eq(a, b);
	return nativeResponseValue;
}
	// uint64_t RetryAttempts_hash(const struct LDKRetryAttempts *NONNULL_PTR o);
/* @internal */
export function RetryAttempts_hash(o: number): bigint {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_RetryAttempts_hash(o);
	return nativeResponseValue;
}
	// void PaymentError_free(struct LDKPaymentError this_ptr);
/* @internal */
export function PaymentError_free(this_ptr: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentError_free(this_ptr);
	// debug statements here
}
	// uintptr_t PaymentError_clone_ptr(LDKPaymentError *NONNULL_PTR arg);
/* @internal */
export function PaymentError_clone_ptr(arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentError_clone_ptr(arg);
	return nativeResponseValue;
}
	// struct LDKPaymentError PaymentError_clone(const struct LDKPaymentError *NONNULL_PTR orig);
/* @internal */
export function PaymentError_clone(orig: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentError_clone(orig);
	return nativeResponseValue;
}
	// struct LDKPaymentError PaymentError_invoice(struct LDKStr a);
/* @internal */
export function PaymentError_invoice(a: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentError_invoice(a);
	return nativeResponseValue;
}
	// struct LDKPaymentError PaymentError_routing(struct LDKLightningError a);
/* @internal */
export function PaymentError_routing(a: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentError_routing(a);
	return nativeResponseValue;
}
	// struct LDKPaymentError PaymentError_sending(struct LDKPaymentSendFailure a);
/* @internal */
export function PaymentError_sending(a: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_PaymentError_sending(a);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKInvoicePayer InvoicePayer_new(struct LDKPayer payer, struct LDKRouter router, const struct LDKMultiThreadedLockableScore *NONNULL_PTR scorer, struct LDKLogger logger, struct LDKEventHandler event_handler, struct LDKRetryAttempts retry_attempts);
/* @internal */
export function InvoicePayer_new(payer: number, router: number, scorer: number, logger: number, event_handler: number, retry_attempts: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InvoicePayer_new(payer, router, scorer, logger, event_handler, retry_attempts);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_PaymentIdPaymentErrorZ InvoicePayer_pay_invoice(const struct LDKInvoicePayer *NONNULL_PTR this_arg, const struct LDKInvoice *NONNULL_PTR invoice);
/* @internal */
export function InvoicePayer_pay_invoice(this_arg: number, invoice: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InvoicePayer_pay_invoice(this_arg, invoice);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_PaymentIdPaymentErrorZ InvoicePayer_pay_zero_value_invoice(const struct LDKInvoicePayer *NONNULL_PTR this_arg, const struct LDKInvoice *NONNULL_PTR invoice, uint64_t amount_msats);
/* @internal */
export function InvoicePayer_pay_zero_value_invoice(this_arg: number, invoice: number, amount_msats: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InvoicePayer_pay_zero_value_invoice(this_arg, invoice, amount_msats);
	return nativeResponseValue;
}
	// MUST_USE_RES struct LDKCResult_PaymentIdPaymentErrorZ InvoicePayer_pay_pubkey(const struct LDKInvoicePayer *NONNULL_PTR this_arg, struct LDKPublicKey pubkey, struct LDKThirtyTwoBytes payment_preimage, uint64_t amount_msats, uint32_t final_cltv_expiry_delta);
/* @internal */
export function InvoicePayer_pay_pubkey(this_arg: number, pubkey: number, payment_preimage: number, amount_msats: bigint, final_cltv_expiry_delta: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InvoicePayer_pay_pubkey(this_arg, pubkey, payment_preimage, amount_msats, final_cltv_expiry_delta);
	return nativeResponseValue;
}
	// void InvoicePayer_remove_cached_payment(const struct LDKInvoicePayer *NONNULL_PTR this_arg, const uint8_t (*payment_hash)[32]);
/* @internal */
export function InvoicePayer_remove_cached_payment(this_arg: number, payment_hash: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InvoicePayer_remove_cached_payment(this_arg, payment_hash);
	// debug statements here
}
	// struct LDKEventHandler InvoicePayer_as_EventHandler(const struct LDKInvoicePayer *NONNULL_PTR this_arg);
/* @internal */
export function InvoicePayer_as_EventHandler(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_InvoicePayer_as_EventHandler(this_arg);
	return nativeResponseValue;
}
	// struct LDKCResult_InvoiceSignOrCreationErrorZ create_invoice_from_channelmanager_with_description_hash_and_duration_since_epoch(const struct LDKChannelManager *NONNULL_PTR channelmanager, struct LDKKeysInterface keys_manager, enum LDKCurrency network, struct LDKCOption_u64Z amt_msat, struct LDKSha256 description_hash, uint64_t duration_since_epoch);
/* @internal */
export function create_invoice_from_channelmanager_with_description_hash_and_duration_since_epoch(channelmanager: number, keys_manager: number, network: Currency, amt_msat: number, description_hash: number, duration_since_epoch: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_create_invoice_from_channelmanager_with_description_hash_and_duration_since_epoch(channelmanager, keys_manager, network, amt_msat, description_hash, duration_since_epoch);
	return nativeResponseValue;
}
	// struct LDKCResult_InvoiceSignOrCreationErrorZ create_invoice_from_channelmanager_and_duration_since_epoch(const struct LDKChannelManager *NONNULL_PTR channelmanager, struct LDKKeysInterface keys_manager, enum LDKCurrency network, struct LDKCOption_u64Z amt_msat, struct LDKStr description, uint64_t duration_since_epoch);
/* @internal */
export function create_invoice_from_channelmanager_and_duration_since_epoch(channelmanager: number, keys_manager: number, network: Currency, amt_msat: number, description: number, duration_since_epoch: bigint): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_create_invoice_from_channelmanager_and_duration_since_epoch(channelmanager, keys_manager, network, amt_msat, description, duration_since_epoch);
	return nativeResponseValue;
}
	// void DefaultRouter_free(struct LDKDefaultRouter this_obj);
/* @internal */
export function DefaultRouter_free(this_obj: number): void {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DefaultRouter_free(this_obj);
	// debug statements here
}
	// MUST_USE_RES struct LDKDefaultRouter DefaultRouter_new(const struct LDKNetworkGraph *NONNULL_PTR network_graph, struct LDKLogger logger, struct LDKThirtyTwoBytes random_seed_bytes);
/* @internal */
export function DefaultRouter_new(network_graph: number, logger: number, random_seed_bytes: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DefaultRouter_new(network_graph, logger, random_seed_bytes);
	return nativeResponseValue;
}
	// struct LDKRouter DefaultRouter_as_Router(const struct LDKDefaultRouter *NONNULL_PTR this_arg);
/* @internal */
export function DefaultRouter_as_Router(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_DefaultRouter_as_Router(this_arg);
	return nativeResponseValue;
}
	// struct LDKPayer ChannelManager_as_Payer(const struct LDKChannelManager *NONNULL_PTR this_arg);
/* @internal */
export function ChannelManager_as_Payer(this_arg: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ChannelManager_as_Payer(this_arg);
	return nativeResponseValue;
}
	// struct LDKCResult_SiPrefixParseErrorZ SiPrefix_from_str(struct LDKStr s);
/* @internal */
export function SiPrefix_from_str(s: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SiPrefix_from_str(s);
	return nativeResponseValue;
}
	// struct LDKCResult_InvoiceParseOrSemanticErrorZ Invoice_from_str(struct LDKStr s);
/* @internal */
export function Invoice_from_str(s: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Invoice_from_str(s);
	return nativeResponseValue;
}
	// struct LDKCResult_SignedRawInvoiceParseErrorZ SignedRawInvoice_from_str(struct LDKStr s);
/* @internal */
export function SignedRawInvoice_from_str(s: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SignedRawInvoice_from_str(s);
	return nativeResponseValue;
}
	// struct LDKStr ParseError_to_str(const struct LDKParseError *NONNULL_PTR o);
/* @internal */
export function ParseError_to_str(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ParseError_to_str(o);
	return nativeResponseValue;
}
	// struct LDKStr ParseOrSemanticError_to_str(const struct LDKParseOrSemanticError *NONNULL_PTR o);
/* @internal */
export function ParseOrSemanticError_to_str(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_ParseOrSemanticError_to_str(o);
	return nativeResponseValue;
}
	// struct LDKStr Invoice_to_str(const struct LDKInvoice *NONNULL_PTR o);
/* @internal */
export function Invoice_to_str(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Invoice_to_str(o);
	return nativeResponseValue;
}
	// struct LDKStr SignedRawInvoice_to_str(const struct LDKSignedRawInvoice *NONNULL_PTR o);
/* @internal */
export function SignedRawInvoice_to_str(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SignedRawInvoice_to_str(o);
	return nativeResponseValue;
}
	// struct LDKStr Currency_to_str(const enum LDKCurrency *NONNULL_PTR o);
/* @internal */
export function Currency_to_str(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_Currency_to_str(o);
	return nativeResponseValue;
}
	// struct LDKStr SiPrefix_to_str(const enum LDKSiPrefix *NONNULL_PTR o);
/* @internal */
export function SiPrefix_to_str(o: number): number {
	if(!isWasmInitialized) {
		throw new Error("initializeWasm() must be awaited first!");
	}
	const nativeResponseValue = wasm.TS_SiPrefix_to_str(o);
	return nativeResponseValue;
}


js_invoke = function(obj_ptr: number, fn_id: number, arg1: number, arg2: number, arg3: number, arg4: number, arg5: number, arg6: number, arg7: number, arg8: number, arg9: number, arg10: number) {
	const weak: WeakRef<object> = js_objs[obj_ptr];
	if (weak == null || weak == undefined) {
		console.error("Got function call on unknown/free'd JS object!");
		throw new Error("Got function call on unknown/free'd JS object!");
	}
	const obj: object = weak.deref();
	if (obj == null || obj == undefined) {
		console.error("Got function call on GC'd JS object!");
		throw new Error("Got function call on GC'd JS object!");
	}
	var fn;
	switch (fn_id) {
		case 0: fn = Object.getOwnPropertyDescriptor(obj, "get_per_commitment_point"); break;
		case 1: fn = Object.getOwnPropertyDescriptor(obj, "release_commitment_secret"); break;
		case 2: fn = Object.getOwnPropertyDescriptor(obj, "validate_holder_commitment"); break;
		case 3: fn = Object.getOwnPropertyDescriptor(obj, "channel_keys_id"); break;
		case 4: fn = Object.getOwnPropertyDescriptor(obj, "sign_counterparty_commitment"); break;
		case 5: fn = Object.getOwnPropertyDescriptor(obj, "validate_counterparty_revocation"); break;
		case 6: fn = Object.getOwnPropertyDescriptor(obj, "sign_holder_commitment_and_htlcs"); break;
		case 7: fn = Object.getOwnPropertyDescriptor(obj, "sign_justice_revoked_output"); break;
		case 8: fn = Object.getOwnPropertyDescriptor(obj, "sign_justice_revoked_htlc"); break;
		case 9: fn = Object.getOwnPropertyDescriptor(obj, "sign_counterparty_htlc_transaction"); break;
		case 10: fn = Object.getOwnPropertyDescriptor(obj, "sign_closing_transaction"); break;
		case 11: fn = Object.getOwnPropertyDescriptor(obj, "sign_channel_announcement"); break;
		case 12: fn = Object.getOwnPropertyDescriptor(obj, "ready_channel"); break;
		case 13: fn = Object.getOwnPropertyDescriptor(obj, "write"); break;
		case 14: fn = Object.getOwnPropertyDescriptor(obj, "watch_channel"); break;
		case 15: fn = Object.getOwnPropertyDescriptor(obj, "update_channel"); break;
		case 16: fn = Object.getOwnPropertyDescriptor(obj, "release_pending_monitor_events"); break;
		case 17: fn = Object.getOwnPropertyDescriptor(obj, "broadcast_transaction"); break;
		case 18: fn = Object.getOwnPropertyDescriptor(obj, "get_node_secret"); break;
		case 19: fn = Object.getOwnPropertyDescriptor(obj, "get_destination_script"); break;
		case 20: fn = Object.getOwnPropertyDescriptor(obj, "get_shutdown_scriptpubkey"); break;
		case 21: fn = Object.getOwnPropertyDescriptor(obj, "get_channel_signer"); break;
		case 22: fn = Object.getOwnPropertyDescriptor(obj, "get_secure_random_bytes"); break;
		case 23: fn = Object.getOwnPropertyDescriptor(obj, "read_chan_signer"); break;
		case 24: fn = Object.getOwnPropertyDescriptor(obj, "sign_invoice"); break;
		case 25: fn = Object.getOwnPropertyDescriptor(obj, "get_inbound_payment_key_material"); break;
		case 26: fn = Object.getOwnPropertyDescriptor(obj, "get_est_sat_per_1000_weight"); break;
		case 27: fn = Object.getOwnPropertyDescriptor(obj, "log"); break;
		case 28: fn = Object.getOwnPropertyDescriptor(obj, "type_id"); break;
		case 29: fn = Object.getOwnPropertyDescriptor(obj, "debug_str"); break;
		case 30: fn = Object.getOwnPropertyDescriptor(obj, "write"); break;
		case 31: fn = Object.getOwnPropertyDescriptor(obj, "get_utxo"); break;
		case 32: fn = Object.getOwnPropertyDescriptor(obj, "register_tx"); break;
		case 33: fn = Object.getOwnPropertyDescriptor(obj, "register_output"); break;
		case 34: fn = Object.getOwnPropertyDescriptor(obj, "get_and_clear_pending_msg_events"); break;
		case 35: fn = Object.getOwnPropertyDescriptor(obj, "handle_event"); break;
		case 36: fn = Object.getOwnPropertyDescriptor(obj, "process_pending_events"); break;
		case 37: fn = Object.getOwnPropertyDescriptor(obj, "block_connected"); break;
		case 38: fn = Object.getOwnPropertyDescriptor(obj, "block_disconnected"); break;
		case 39: fn = Object.getOwnPropertyDescriptor(obj, "transactions_confirmed"); break;
		case 40: fn = Object.getOwnPropertyDescriptor(obj, "transaction_unconfirmed"); break;
		case 41: fn = Object.getOwnPropertyDescriptor(obj, "best_block_updated"); break;
		case 42: fn = Object.getOwnPropertyDescriptor(obj, "get_relevant_txids"); break;
		case 43: fn = Object.getOwnPropertyDescriptor(obj, "persist_new_channel"); break;
		case 44: fn = Object.getOwnPropertyDescriptor(obj, "update_persisted_channel"); break;
		case 45: fn = Object.getOwnPropertyDescriptor(obj, "handle_open_channel"); break;
		case 46: fn = Object.getOwnPropertyDescriptor(obj, "handle_accept_channel"); break;
		case 47: fn = Object.getOwnPropertyDescriptor(obj, "handle_funding_created"); break;
		case 48: fn = Object.getOwnPropertyDescriptor(obj, "handle_funding_signed"); break;
		case 49: fn = Object.getOwnPropertyDescriptor(obj, "handle_funding_locked"); break;
		case 50: fn = Object.getOwnPropertyDescriptor(obj, "handle_shutdown"); break;
		case 51: fn = Object.getOwnPropertyDescriptor(obj, "handle_closing_signed"); break;
		case 52: fn = Object.getOwnPropertyDescriptor(obj, "handle_update_add_htlc"); break;
		case 53: fn = Object.getOwnPropertyDescriptor(obj, "handle_update_fulfill_htlc"); break;
		case 54: fn = Object.getOwnPropertyDescriptor(obj, "handle_update_fail_htlc"); break;
		case 55: fn = Object.getOwnPropertyDescriptor(obj, "handle_update_fail_malformed_htlc"); break;
		case 56: fn = Object.getOwnPropertyDescriptor(obj, "handle_commitment_signed"); break;
		case 57: fn = Object.getOwnPropertyDescriptor(obj, "handle_revoke_and_ack"); break;
		case 58: fn = Object.getOwnPropertyDescriptor(obj, "handle_update_fee"); break;
		case 59: fn = Object.getOwnPropertyDescriptor(obj, "handle_announcement_signatures"); break;
		case 60: fn = Object.getOwnPropertyDescriptor(obj, "peer_disconnected"); break;
		case 61: fn = Object.getOwnPropertyDescriptor(obj, "peer_connected"); break;
		case 62: fn = Object.getOwnPropertyDescriptor(obj, "handle_channel_reestablish"); break;
		case 63: fn = Object.getOwnPropertyDescriptor(obj, "handle_channel_update"); break;
		case 64: fn = Object.getOwnPropertyDescriptor(obj, "handle_error"); break;
		case 65: fn = Object.getOwnPropertyDescriptor(obj, "handle_node_announcement"); break;
		case 66: fn = Object.getOwnPropertyDescriptor(obj, "handle_channel_announcement"); break;
		case 67: fn = Object.getOwnPropertyDescriptor(obj, "handle_channel_update"); break;
		case 68: fn = Object.getOwnPropertyDescriptor(obj, "get_next_channel_announcements"); break;
		case 69: fn = Object.getOwnPropertyDescriptor(obj, "get_next_node_announcements"); break;
		case 70: fn = Object.getOwnPropertyDescriptor(obj, "peer_connected"); break;
		case 71: fn = Object.getOwnPropertyDescriptor(obj, "handle_reply_channel_range"); break;
		case 72: fn = Object.getOwnPropertyDescriptor(obj, "handle_reply_short_channel_ids_end"); break;
		case 73: fn = Object.getOwnPropertyDescriptor(obj, "handle_query_channel_range"); break;
		case 74: fn = Object.getOwnPropertyDescriptor(obj, "handle_query_short_channel_ids"); break;
		case 75: fn = Object.getOwnPropertyDescriptor(obj, "read"); break;
		case 76: fn = Object.getOwnPropertyDescriptor(obj, "handle_custom_message"); break;
		case 77: fn = Object.getOwnPropertyDescriptor(obj, "get_and_clear_pending_msg"); break;
		case 78: fn = Object.getOwnPropertyDescriptor(obj, "send_data"); break;
		case 79: fn = Object.getOwnPropertyDescriptor(obj, "disconnect_socket"); break;
		case 80: fn = Object.getOwnPropertyDescriptor(obj, "eq"); break;
		case 81: fn = Object.getOwnPropertyDescriptor(obj, "hash"); break;
		case 82: fn = Object.getOwnPropertyDescriptor(obj, "channel_penalty_msat"); break;
		case 83: fn = Object.getOwnPropertyDescriptor(obj, "payment_path_failed"); break;
		case 84: fn = Object.getOwnPropertyDescriptor(obj, "payment_path_successful"); break;
		case 85: fn = Object.getOwnPropertyDescriptor(obj, "write"); break;
		case 86: fn = Object.getOwnPropertyDescriptor(obj, "lock"); break;
		case 87: fn = Object.getOwnPropertyDescriptor(obj, "node_id"); break;
		case 88: fn = Object.getOwnPropertyDescriptor(obj, "first_hops"); break;
		case 89: fn = Object.getOwnPropertyDescriptor(obj, "send_payment"); break;
		case 90: fn = Object.getOwnPropertyDescriptor(obj, "send_spontaneous_payment"); break;
		case 91: fn = Object.getOwnPropertyDescriptor(obj, "retry_payment"); break;
		case 92: fn = Object.getOwnPropertyDescriptor(obj, "abandon_payment"); break;
		case 93: fn = Object.getOwnPropertyDescriptor(obj, "find_route"); break;
		default:
			console.error("Got unknown function call from C!");
			throw new Error("Got unknown function call from C!");
	}
	if (fn == null || fn == undefined) {
		console.error("Got function call on incorrect JS object!");
		throw new Error("Got function call on incorrect JS object!");
	}
	return fn.value.bind(obj)(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
}