#define LDKCVec_C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZZ LDKCVec_TransactionOutputsZ
#define CVec_C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZZ_free CVec_TransactionOutputsZ_free
#include <jni.h>
// On OSX jlong (ie long long) is not equivalent to int64_t, so we override here
#define int64_t jlong
#include "org_ldk_impl_bindings.h"
#include <lightning.h>
#include <string.h>
#include <stdatomic.h>
#include <stdlib.h>

#define DEBUG_PRINT(...) fprintf(stderr, __VA_ARGS__)
#include <assert.h>
// Always run a, then assert it is true:
#define DO_ASSERT(a) do { bool _assert_val = (a); assert(_assert_val); } while(0)
// Assert a is true or do nothing
#define CHECK(a) DO_ASSERT(a)

void __attribute__((constructor)) debug_log_version() {
	if (check_get_ldk_version() == NULL)
		DEBUG_PRINT("LDK version did not match the header we built against\n");
	if (check_get_ldk_bindings_version() == NULL)
		DEBUG_PRINT("LDK C Bindings version did not match the header we built against\n");
	DEBUG_PRINT("Loaded LDK-Java Bindings with LDK %s and LDK-C-Bindings %s\n", check_get_ldk_version(), check_get_ldk_bindings_version());
}

// Running a leak check across all the allocations and frees of the JDK is a mess,
// so instead we implement our own naive leak checker here, relying on the -wrap
// linker option to wrap malloc/calloc/realloc/free, tracking everyhing allocated
// and free'd in Rust or C across the generated bindings shared library.
#include <threads.h>
#include <execinfo.h>

#include <unistd.h>
#include <pthread.h>
static pthread_mutex_t allocation_mtx;

void __attribute__((constructor)) init_mtx() {
	DO_ASSERT(!pthread_mutex_init(&allocation_mtx, NULL));
}

#define BT_MAX 128
typedef struct allocation {
	struct allocation* next;
	void* ptr;
	const char* struct_name;
	void* bt[BT_MAX];
	int bt_len;
	unsigned long alloc_len;
} allocation;
static allocation* allocation_ll = NULL;

void* __real_malloc(size_t len);
void* __real_calloc(size_t nmemb, size_t len);
static void new_allocation(void* res, const char* struct_name, size_t len) {
	allocation* new_alloc = __real_malloc(sizeof(allocation));
	new_alloc->ptr = res;
	new_alloc->struct_name = struct_name;
	new_alloc->bt_len = backtrace(new_alloc->bt, BT_MAX);
	new_alloc->alloc_len = len;
	DO_ASSERT(!pthread_mutex_lock(&allocation_mtx));
	new_alloc->next = allocation_ll;
	allocation_ll = new_alloc;
	DO_ASSERT(!pthread_mutex_unlock(&allocation_mtx));
}
static void* MALLOC(size_t len, const char* struct_name) {
	void* res = __real_malloc(len);
	new_allocation(res, struct_name, len);
	return res;
}
void __real_free(void* ptr);
static void alloc_freed(void* ptr) {
	allocation* p = NULL;
	DO_ASSERT(!pthread_mutex_lock(&allocation_mtx));
	allocation* it = allocation_ll;
	while (it->ptr != ptr) {
		p = it; it = it->next;
		if (it == NULL) {
			DEBUG_PRINT("ERROR: Tried to free unknown pointer %p at:\n", ptr);
			void* bt[BT_MAX];
			int bt_len = backtrace(bt, BT_MAX);
			backtrace_symbols_fd(bt, bt_len, STDERR_FILENO);
			DEBUG_PRINT("\n\n");
			DO_ASSERT(!pthread_mutex_unlock(&allocation_mtx));
			return; // addrsan should catch malloc-unknown and print more info than we have
		}
	}
	if (p) { p->next = it->next; } else { allocation_ll = it->next; }
	DO_ASSERT(!pthread_mutex_unlock(&allocation_mtx));
	DO_ASSERT(it->ptr == ptr);
	__real_free(it);
}
static void FREE(void* ptr) {
	if ((uint64_t)ptr <= 4096) return; // Rust loves to create pointers to the NULL page for dummys
	alloc_freed(ptr);
	__real_free(ptr);
}

void* __wrap_malloc(size_t len) {
	void* res = __real_malloc(len);
	new_allocation(res, "malloc call", len);
	return res;
}
void* __wrap_calloc(size_t nmemb, size_t len) {
	void* res = __real_calloc(nmemb, len);
	new_allocation(res, "calloc call", len);
	return res;
}
void __wrap_free(void* ptr) {
	if (ptr == NULL) return;
	alloc_freed(ptr);
	__real_free(ptr);
}

static void CHECK_ACCESS(void* ptr) {
	DO_ASSERT(!pthread_mutex_lock(&allocation_mtx));
	allocation* it = allocation_ll;
	while (it->ptr != ptr) {
		it = it->next;
		if (it == NULL) {
			DEBUG_PRINT("ERROR: Tried to access unknown pointer %p at:\n", ptr);
			void* bt[BT_MAX];
			int bt_len = backtrace(bt, BT_MAX);
			backtrace_symbols_fd(bt, bt_len, STDERR_FILENO);
			DEBUG_PRINT("\n\n");
			DO_ASSERT(!pthread_mutex_unlock(&allocation_mtx));
			return; // addrsan should catch and print more info than we have
		}
	}
	DO_ASSERT(!pthread_mutex_unlock(&allocation_mtx));
}

void* __real_realloc(void* ptr, size_t newlen);
void* __wrap_realloc(void* ptr, size_t len) {
	if (ptr != NULL) alloc_freed(ptr);
	void* res = __real_realloc(ptr, len);
	new_allocation(res, "realloc call", len);
	return res;
}
void __wrap_reallocarray(void* ptr, size_t new_sz) {
	// Rust doesn't seem to use reallocarray currently
	DO_ASSERT(false);
}

void __attribute__((destructor)) check_leaks() {
	unsigned long alloc_count = 0;
	unsigned long alloc_size = 0;
	DEBUG_PRINT("The following LDK-allocated blocks still remain.\n");
	DEBUG_PRINT("Note that this is only accurate if System.gc(); System.runFinalization()\n");
	DEBUG_PRINT("was called prior to exit after all LDK objects were out of scope.\n");
	for (allocation* a = allocation_ll; a != NULL; a = a->next) {
		DEBUG_PRINT("%s %p (%lu bytes) remains:\n", a->struct_name, a->ptr, a->alloc_len);
		backtrace_symbols_fd(a->bt, a->bt_len, STDERR_FILENO);
		DEBUG_PRINT("\n\n");
		alloc_count++;
		alloc_size += a->alloc_len;
	}
	DEBUG_PRINT("%lu allocations remained for %lu bytes.\n", alloc_count, alloc_size);
	DEBUG_PRINT("Note that this is only accurate if System.gc(); System.runFinalization()\n");
	DEBUG_PRINT("was called prior to exit after all LDK objects were out of scope.\n");
}

static jmethodID ordinal_meth = NULL;
static jmethodID slicedef_meth = NULL;
static jclass slicedef_cls = NULL;
JNIEXPORT void Java_org_ldk_impl_bindings_init(JNIEnv * env, jclass _b, jclass enum_class, jclass slicedef_class) {
	ordinal_meth = (*env)->GetMethodID(env, enum_class, "ordinal", "()I");
	CHECK(ordinal_meth != NULL);
	slicedef_meth = (*env)->GetMethodID(env, slicedef_class, "<init>", "(JJJ)V");
	CHECK(slicedef_meth != NULL);
	slicedef_cls = (*env)->NewGlobalRef(env, slicedef_class);
	CHECK(slicedef_cls != NULL);
}

JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_deref_1bool (JNIEnv * env, jclass _a, jlong ptr) {
	return *((bool*)ptr);
}
JNIEXPORT jlong JNICALL Java_org_ldk_impl_bindings_deref_1long (JNIEnv * env, jclass _a, jlong ptr) {
	return *((long*)ptr);
}
JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_free_1heap_1ptr (JNIEnv * env, jclass _a, jlong ptr) {
	FREE((void*)ptr);
}
JNIEXPORT jbyteArray JNICALL Java_org_ldk_impl_bindings_read_1bytes (JNIEnv * env, jclass _b, jlong ptr, jlong len) {
	jbyteArray ret_arr = (*env)->NewByteArray(env, len);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, len, (unsigned char*)ptr);
	return ret_arr;
}
JNIEXPORT jbyteArray JNICALL Java_org_ldk_impl_bindings_get_1u8_1slice_1bytes (JNIEnv * env, jclass _b, jlong slice_ptr) {
	LDKu8slice *slice = (LDKu8slice*)slice_ptr;
	jbyteArray ret_arr = (*env)->NewByteArray(env, slice->datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, slice->datalen, slice->data);
	return ret_arr;
}
JNIEXPORT int64_t impl_bindings_bytes_1to_1u8_1vec (JNIEnv * env, jclass _b, jbyteArray bytes) {
	LDKCVec_u8Z *vec = (LDKCVec_u8Z*)MALLOC(sizeof(LDKCVec_u8Z), "LDKCVec_u8");
	vec->datalen = (*env)->GetArrayLength(env, bytes);
	vec->data = (uint8_t*)MALLOC(vec->datalen, "LDKCVec_u8Z Bytes");
	(*env)->GetByteArrayRegion (env, bytes, 0, vec->datalen, vec->data);
	return (uint64_t)vec;
}
JNIEXPORT jbyteArray JNICALL Java_org_ldk_impl_bindings_txpointer_1get_1buffer (JNIEnv * env, jclass _b, jlong ptr) {
	LDKTransaction *txdata = (LDKTransaction*)ptr;
	LDKu8slice slice;
	slice.data = txdata->data;
	slice.datalen = txdata->datalen;
	return Java_org_ldk_impl_bindings_get_1u8_1slice_1bytes(env, _b, (uint64_t)&slice);
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_new_1txpointer_1copy_1data (JNIEnv * env, jclass _b, jbyteArray bytes) {
	LDKTransaction *txdata = (LDKTransaction*)MALLOC(sizeof(LDKTransaction), "LDKTransaction");
	txdata->datalen = (*env)->GetArrayLength(env, bytes);
	txdata->data = (uint8_t*)MALLOC(txdata->datalen, "Tx Data Bytes");
	txdata->data_is_owned = false;
	(*env)->GetByteArrayRegion (env, bytes, 0, txdata->datalen, txdata->data);
	return (uint64_t)txdata;
}
JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_txpointer_1free (JNIEnv * env, jclass _b, jlong ptr) {
	LDKTransaction *tx = (LDKTransaction*)ptr;
	tx->data_is_owned = true;
	Transaction_free(*tx);
	FREE((void*)ptr);
}
JNIEXPORT jlong JNICALL Java_org_ldk_impl_bindings_vec_1slice_1len (JNIEnv * env, jclass _a, jlong ptr) {
	// Check offsets of a few Vec types are all consistent as we're meant to be generic across types
	_Static_assert(offsetof(LDKCVec_u8Z, datalen) == offsetof(LDKCVec_SignatureZ, datalen), "Vec<*> needs to be mapped identically");
	_Static_assert(offsetof(LDKCVec_u8Z, datalen) == offsetof(LDKCVec_MessageSendEventZ, datalen), "Vec<*> needs to be mapped identically");
	_Static_assert(offsetof(LDKCVec_u8Z, datalen) == offsetof(LDKCVec_EventZ, datalen), "Vec<*> needs to be mapped identically");
	_Static_assert(offsetof(LDKCVec_u8Z, datalen) == offsetof(LDKCVec_C2Tuple_usizeTransactionZZ, datalen), "Vec<*> needs to be mapped identically");
	LDKCVec_u8Z *vec = (LDKCVec_u8Z*)ptr;
	return (uint64_t)vec->datalen;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_new_1empty_1slice_1vec (JNIEnv * env, jclass _b) {
	// Check sizes of a few Vec types are all consistent as we're meant to be generic across types
	_Static_assert(sizeof(LDKCVec_u8Z) == sizeof(LDKCVec_SignatureZ), "Vec<*> needs to be mapped identically");
	_Static_assert(sizeof(LDKCVec_u8Z) == sizeof(LDKCVec_MessageSendEventZ), "Vec<*> needs to be mapped identically");
	_Static_assert(sizeof(LDKCVec_u8Z) == sizeof(LDKCVec_EventZ), "Vec<*> needs to be mapped identically");
	_Static_assert(sizeof(LDKCVec_u8Z) == sizeof(LDKCVec_C2Tuple_usizeTransactionZZ), "Vec<*> needs to be mapped identically");
	LDKCVec_u8Z *vec = (LDKCVec_u8Z*)MALLOC(sizeof(LDKCVec_u8Z), "Empty LDKCVec");
	vec->data = NULL;
	vec->datalen = 0;
	return (uint64_t)vec;
}

// We assume that CVec_u8Z and u8slice are the same size and layout (and thus pointers to the two can be mixed)
_Static_assert(sizeof(LDKCVec_u8Z) == sizeof(LDKu8slice), "Vec<u8> and [u8] need to have been mapped identically");
_Static_assert(offsetof(LDKCVec_u8Z, data) == offsetof(LDKu8slice, data), "Vec<u8> and [u8] need to have been mapped identically");
_Static_assert(offsetof(LDKCVec_u8Z, datalen) == offsetof(LDKu8slice, datalen), "Vec<u8> and [u8] need to have been mapped identically");

_Static_assert(sizeof(jlong) == sizeof(int64_t), "We assume that j-types are the same as C types");
_Static_assert(sizeof(jbyte) == sizeof(char), "We assume that j-types are the same as C types");
_Static_assert(sizeof(void*) <= 8, "Pointers must fit into 64 bits");

typedef jlongArray int64_tArray;
typedef jbyteArray int8_tArray;

static inline jstring str_ref_to_java(JNIEnv *env, const char* chars, size_t len) {
	// Sadly we need to create a temporary because Java can't accept a char* without a 0-terminator
	char* conv_buf = MALLOC(len + 1, "str conv buf");
	memcpy(conv_buf, chars, len);
	conv_buf[len] = 0;
	jstring ret = (*env)->NewStringUTF(env, conv_buf);
	FREE(conv_buf);
	return ret;
}
static inline LDKStr java_to_owned_str(JNIEnv *env, jstring str) {
	uint64_t str_len = (*env)->GetStringUTFLength(env, str);
	char* newchars = MALLOC(str_len + 1, "String chars");
	const char* jchars = (*env)->GetStringUTFChars(env, str, NULL);
	memcpy(newchars, jchars, str_len);
	newchars[str_len] = 0;
	(*env)->ReleaseStringUTFChars(env, str, jchars);
	LDKStr res = {
		.chars = newchars,
		.len = str_len,
		.chars_is_owned = true
	};
	return res;
}

JNIEXPORT jstring JNICALL Java_org_ldk_impl_bindings_get_1ldk_1c_1bindings_1version(JNIEnv *env, jclass _c) {
	return str_ref_to_java(env, check_get_ldk_bindings_version(), strlen(check_get_ldk_bindings_version()));
}
JNIEXPORT jstring JNICALL Java_org_ldk_impl_bindings_get_1ldk_1version(JNIEnv *env, jclass _c) {
	return str_ref_to_java(env, check_get_ldk_version(), strlen(check_get_ldk_version()));
}
#include "version.c"
static jclass arr_of_B_clz = NULL;
static jclass arr_of_J_clz = NULL;
JNIEXPORT void Java_org_ldk_impl_bindings_init_1class_1cache(JNIEnv * env, jclass clz) {
	arr_of_B_clz = (*env)->FindClass(env, "[B");
	CHECK(arr_of_B_clz != NULL);
	arr_of_B_clz = (*env)->NewGlobalRef(env, arr_of_B_clz);
	arr_of_J_clz = (*env)->FindClass(env, "[J");
	CHECK(arr_of_J_clz != NULL);
	arr_of_J_clz = (*env)->NewGlobalRef(env, arr_of_J_clz);
}
static inline struct LDKThirtyTwoBytes ThirtyTwoBytes_clone(const struct LDKThirtyTwoBytes *orig) { struct LDKThirtyTwoBytes ret; memcpy(ret.data, orig->data, 32); return ret; }
static inline LDKAccessError LDKAccessError_from_java(JNIEnv *env, jclass clz) {
	switch ((*env)->CallIntMethod(env, clz, ordinal_meth)) {
		case 0: return LDKAccessError_UnknownChain;
		case 1: return LDKAccessError_UnknownTx;
	}
	abort();
}
static jclass AccessError_class = NULL;
static jfieldID AccessError_LDKAccessError_UnknownChain = NULL;
static jfieldID AccessError_LDKAccessError_UnknownTx = NULL;
JNIEXPORT void JNICALL Java_org_ldk_enums_AccessError_init (JNIEnv *env, jclass clz) {
	AccessError_class = (*env)->NewGlobalRef(env, clz);
	CHECK(AccessError_class != NULL);
	AccessError_LDKAccessError_UnknownChain = (*env)->GetStaticFieldID(env, AccessError_class, "LDKAccessError_UnknownChain", "Lorg/ldk/enums/AccessError;");
	CHECK(AccessError_LDKAccessError_UnknownChain != NULL);
	AccessError_LDKAccessError_UnknownTx = (*env)->GetStaticFieldID(env, AccessError_class, "LDKAccessError_UnknownTx", "Lorg/ldk/enums/AccessError;");
	CHECK(AccessError_LDKAccessError_UnknownTx != NULL);
}
static inline jclass LDKAccessError_to_java(JNIEnv *env, LDKAccessError val) {
	switch (val) {
		case LDKAccessError_UnknownChain:
			return (*env)->GetStaticObjectField(env, AccessError_class, AccessError_LDKAccessError_UnknownChain);
		case LDKAccessError_UnknownTx:
			return (*env)->GetStaticObjectField(env, AccessError_class, AccessError_LDKAccessError_UnknownTx);
		default: abort();
	}
}

static inline LDKChannelMonitorUpdateErr LDKChannelMonitorUpdateErr_from_java(JNIEnv *env, jclass clz) {
	switch ((*env)->CallIntMethod(env, clz, ordinal_meth)) {
		case 0: return LDKChannelMonitorUpdateErr_TemporaryFailure;
		case 1: return LDKChannelMonitorUpdateErr_PermanentFailure;
	}
	abort();
}
static jclass ChannelMonitorUpdateErr_class = NULL;
static jfieldID ChannelMonitorUpdateErr_LDKChannelMonitorUpdateErr_TemporaryFailure = NULL;
static jfieldID ChannelMonitorUpdateErr_LDKChannelMonitorUpdateErr_PermanentFailure = NULL;
JNIEXPORT void JNICALL Java_org_ldk_enums_ChannelMonitorUpdateErr_init (JNIEnv *env, jclass clz) {
	ChannelMonitorUpdateErr_class = (*env)->NewGlobalRef(env, clz);
	CHECK(ChannelMonitorUpdateErr_class != NULL);
	ChannelMonitorUpdateErr_LDKChannelMonitorUpdateErr_TemporaryFailure = (*env)->GetStaticFieldID(env, ChannelMonitorUpdateErr_class, "LDKChannelMonitorUpdateErr_TemporaryFailure", "Lorg/ldk/enums/ChannelMonitorUpdateErr;");
	CHECK(ChannelMonitorUpdateErr_LDKChannelMonitorUpdateErr_TemporaryFailure != NULL);
	ChannelMonitorUpdateErr_LDKChannelMonitorUpdateErr_PermanentFailure = (*env)->GetStaticFieldID(env, ChannelMonitorUpdateErr_class, "LDKChannelMonitorUpdateErr_PermanentFailure", "Lorg/ldk/enums/ChannelMonitorUpdateErr;");
	CHECK(ChannelMonitorUpdateErr_LDKChannelMonitorUpdateErr_PermanentFailure != NULL);
}
static inline jclass LDKChannelMonitorUpdateErr_to_java(JNIEnv *env, LDKChannelMonitorUpdateErr val) {
	switch (val) {
		case LDKChannelMonitorUpdateErr_TemporaryFailure:
			return (*env)->GetStaticObjectField(env, ChannelMonitorUpdateErr_class, ChannelMonitorUpdateErr_LDKChannelMonitorUpdateErr_TemporaryFailure);
		case LDKChannelMonitorUpdateErr_PermanentFailure:
			return (*env)->GetStaticObjectField(env, ChannelMonitorUpdateErr_class, ChannelMonitorUpdateErr_LDKChannelMonitorUpdateErr_PermanentFailure);
		default: abort();
	}
}

static inline LDKConfirmationTarget LDKConfirmationTarget_from_java(JNIEnv *env, jclass clz) {
	switch ((*env)->CallIntMethod(env, clz, ordinal_meth)) {
		case 0: return LDKConfirmationTarget_Background;
		case 1: return LDKConfirmationTarget_Normal;
		case 2: return LDKConfirmationTarget_HighPriority;
	}
	abort();
}
static jclass ConfirmationTarget_class = NULL;
static jfieldID ConfirmationTarget_LDKConfirmationTarget_Background = NULL;
static jfieldID ConfirmationTarget_LDKConfirmationTarget_Normal = NULL;
static jfieldID ConfirmationTarget_LDKConfirmationTarget_HighPriority = NULL;
JNIEXPORT void JNICALL Java_org_ldk_enums_ConfirmationTarget_init (JNIEnv *env, jclass clz) {
	ConfirmationTarget_class = (*env)->NewGlobalRef(env, clz);
	CHECK(ConfirmationTarget_class != NULL);
	ConfirmationTarget_LDKConfirmationTarget_Background = (*env)->GetStaticFieldID(env, ConfirmationTarget_class, "LDKConfirmationTarget_Background", "Lorg/ldk/enums/ConfirmationTarget;");
	CHECK(ConfirmationTarget_LDKConfirmationTarget_Background != NULL);
	ConfirmationTarget_LDKConfirmationTarget_Normal = (*env)->GetStaticFieldID(env, ConfirmationTarget_class, "LDKConfirmationTarget_Normal", "Lorg/ldk/enums/ConfirmationTarget;");
	CHECK(ConfirmationTarget_LDKConfirmationTarget_Normal != NULL);
	ConfirmationTarget_LDKConfirmationTarget_HighPriority = (*env)->GetStaticFieldID(env, ConfirmationTarget_class, "LDKConfirmationTarget_HighPriority", "Lorg/ldk/enums/ConfirmationTarget;");
	CHECK(ConfirmationTarget_LDKConfirmationTarget_HighPriority != NULL);
}
static inline jclass LDKConfirmationTarget_to_java(JNIEnv *env, LDKConfirmationTarget val) {
	switch (val) {
		case LDKConfirmationTarget_Background:
			return (*env)->GetStaticObjectField(env, ConfirmationTarget_class, ConfirmationTarget_LDKConfirmationTarget_Background);
		case LDKConfirmationTarget_Normal:
			return (*env)->GetStaticObjectField(env, ConfirmationTarget_class, ConfirmationTarget_LDKConfirmationTarget_Normal);
		case LDKConfirmationTarget_HighPriority:
			return (*env)->GetStaticObjectField(env, ConfirmationTarget_class, ConfirmationTarget_LDKConfirmationTarget_HighPriority);
		default: abort();
	}
}

static inline LDKCreationError LDKCreationError_from_java(JNIEnv *env, jclass clz) {
	switch ((*env)->CallIntMethod(env, clz, ordinal_meth)) {
		case 0: return LDKCreationError_DescriptionTooLong;
		case 1: return LDKCreationError_RouteTooLong;
		case 2: return LDKCreationError_TimestampOutOfBounds;
		case 3: return LDKCreationError_ExpiryTimeOutOfBounds;
	}
	abort();
}
static jclass CreationError_class = NULL;
static jfieldID CreationError_LDKCreationError_DescriptionTooLong = NULL;
static jfieldID CreationError_LDKCreationError_RouteTooLong = NULL;
static jfieldID CreationError_LDKCreationError_TimestampOutOfBounds = NULL;
static jfieldID CreationError_LDKCreationError_ExpiryTimeOutOfBounds = NULL;
JNIEXPORT void JNICALL Java_org_ldk_enums_CreationError_init (JNIEnv *env, jclass clz) {
	CreationError_class = (*env)->NewGlobalRef(env, clz);
	CHECK(CreationError_class != NULL);
	CreationError_LDKCreationError_DescriptionTooLong = (*env)->GetStaticFieldID(env, CreationError_class, "LDKCreationError_DescriptionTooLong", "Lorg/ldk/enums/CreationError;");
	CHECK(CreationError_LDKCreationError_DescriptionTooLong != NULL);
	CreationError_LDKCreationError_RouteTooLong = (*env)->GetStaticFieldID(env, CreationError_class, "LDKCreationError_RouteTooLong", "Lorg/ldk/enums/CreationError;");
	CHECK(CreationError_LDKCreationError_RouteTooLong != NULL);
	CreationError_LDKCreationError_TimestampOutOfBounds = (*env)->GetStaticFieldID(env, CreationError_class, "LDKCreationError_TimestampOutOfBounds", "Lorg/ldk/enums/CreationError;");
	CHECK(CreationError_LDKCreationError_TimestampOutOfBounds != NULL);
	CreationError_LDKCreationError_ExpiryTimeOutOfBounds = (*env)->GetStaticFieldID(env, CreationError_class, "LDKCreationError_ExpiryTimeOutOfBounds", "Lorg/ldk/enums/CreationError;");
	CHECK(CreationError_LDKCreationError_ExpiryTimeOutOfBounds != NULL);
}
static inline jclass LDKCreationError_to_java(JNIEnv *env, LDKCreationError val) {
	switch (val) {
		case LDKCreationError_DescriptionTooLong:
			return (*env)->GetStaticObjectField(env, CreationError_class, CreationError_LDKCreationError_DescriptionTooLong);
		case LDKCreationError_RouteTooLong:
			return (*env)->GetStaticObjectField(env, CreationError_class, CreationError_LDKCreationError_RouteTooLong);
		case LDKCreationError_TimestampOutOfBounds:
			return (*env)->GetStaticObjectField(env, CreationError_class, CreationError_LDKCreationError_TimestampOutOfBounds);
		case LDKCreationError_ExpiryTimeOutOfBounds:
			return (*env)->GetStaticObjectField(env, CreationError_class, CreationError_LDKCreationError_ExpiryTimeOutOfBounds);
		default: abort();
	}
}

static inline LDKCurrency LDKCurrency_from_java(JNIEnv *env, jclass clz) {
	switch ((*env)->CallIntMethod(env, clz, ordinal_meth)) {
		case 0: return LDKCurrency_Bitcoin;
		case 1: return LDKCurrency_BitcoinTestnet;
		case 2: return LDKCurrency_Regtest;
		case 3: return LDKCurrency_Simnet;
		case 4: return LDKCurrency_Signet;
	}
	abort();
}
static jclass Currency_class = NULL;
static jfieldID Currency_LDKCurrency_Bitcoin = NULL;
static jfieldID Currency_LDKCurrency_BitcoinTestnet = NULL;
static jfieldID Currency_LDKCurrency_Regtest = NULL;
static jfieldID Currency_LDKCurrency_Simnet = NULL;
static jfieldID Currency_LDKCurrency_Signet = NULL;
JNIEXPORT void JNICALL Java_org_ldk_enums_Currency_init (JNIEnv *env, jclass clz) {
	Currency_class = (*env)->NewGlobalRef(env, clz);
	CHECK(Currency_class != NULL);
	Currency_LDKCurrency_Bitcoin = (*env)->GetStaticFieldID(env, Currency_class, "LDKCurrency_Bitcoin", "Lorg/ldk/enums/Currency;");
	CHECK(Currency_LDKCurrency_Bitcoin != NULL);
	Currency_LDKCurrency_BitcoinTestnet = (*env)->GetStaticFieldID(env, Currency_class, "LDKCurrency_BitcoinTestnet", "Lorg/ldk/enums/Currency;");
	CHECK(Currency_LDKCurrency_BitcoinTestnet != NULL);
	Currency_LDKCurrency_Regtest = (*env)->GetStaticFieldID(env, Currency_class, "LDKCurrency_Regtest", "Lorg/ldk/enums/Currency;");
	CHECK(Currency_LDKCurrency_Regtest != NULL);
	Currency_LDKCurrency_Simnet = (*env)->GetStaticFieldID(env, Currency_class, "LDKCurrency_Simnet", "Lorg/ldk/enums/Currency;");
	CHECK(Currency_LDKCurrency_Simnet != NULL);
	Currency_LDKCurrency_Signet = (*env)->GetStaticFieldID(env, Currency_class, "LDKCurrency_Signet", "Lorg/ldk/enums/Currency;");
	CHECK(Currency_LDKCurrency_Signet != NULL);
}
static inline jclass LDKCurrency_to_java(JNIEnv *env, LDKCurrency val) {
	switch (val) {
		case LDKCurrency_Bitcoin:
			return (*env)->GetStaticObjectField(env, Currency_class, Currency_LDKCurrency_Bitcoin);
		case LDKCurrency_BitcoinTestnet:
			return (*env)->GetStaticObjectField(env, Currency_class, Currency_LDKCurrency_BitcoinTestnet);
		case LDKCurrency_Regtest:
			return (*env)->GetStaticObjectField(env, Currency_class, Currency_LDKCurrency_Regtest);
		case LDKCurrency_Simnet:
			return (*env)->GetStaticObjectField(env, Currency_class, Currency_LDKCurrency_Simnet);
		case LDKCurrency_Signet:
			return (*env)->GetStaticObjectField(env, Currency_class, Currency_LDKCurrency_Signet);
		default: abort();
	}
}

static inline LDKIOError LDKIOError_from_java(JNIEnv *env, jclass clz) {
	switch ((*env)->CallIntMethod(env, clz, ordinal_meth)) {
		case 0: return LDKIOError_NotFound;
		case 1: return LDKIOError_PermissionDenied;
		case 2: return LDKIOError_ConnectionRefused;
		case 3: return LDKIOError_ConnectionReset;
		case 4: return LDKIOError_ConnectionAborted;
		case 5: return LDKIOError_NotConnected;
		case 6: return LDKIOError_AddrInUse;
		case 7: return LDKIOError_AddrNotAvailable;
		case 8: return LDKIOError_BrokenPipe;
		case 9: return LDKIOError_AlreadyExists;
		case 10: return LDKIOError_WouldBlock;
		case 11: return LDKIOError_InvalidInput;
		case 12: return LDKIOError_InvalidData;
		case 13: return LDKIOError_TimedOut;
		case 14: return LDKIOError_WriteZero;
		case 15: return LDKIOError_Interrupted;
		case 16: return LDKIOError_Other;
		case 17: return LDKIOError_UnexpectedEof;
	}
	abort();
}
static jclass IOError_class = NULL;
static jfieldID IOError_LDKIOError_NotFound = NULL;
static jfieldID IOError_LDKIOError_PermissionDenied = NULL;
static jfieldID IOError_LDKIOError_ConnectionRefused = NULL;
static jfieldID IOError_LDKIOError_ConnectionReset = NULL;
static jfieldID IOError_LDKIOError_ConnectionAborted = NULL;
static jfieldID IOError_LDKIOError_NotConnected = NULL;
static jfieldID IOError_LDKIOError_AddrInUse = NULL;
static jfieldID IOError_LDKIOError_AddrNotAvailable = NULL;
static jfieldID IOError_LDKIOError_BrokenPipe = NULL;
static jfieldID IOError_LDKIOError_AlreadyExists = NULL;
static jfieldID IOError_LDKIOError_WouldBlock = NULL;
static jfieldID IOError_LDKIOError_InvalidInput = NULL;
static jfieldID IOError_LDKIOError_InvalidData = NULL;
static jfieldID IOError_LDKIOError_TimedOut = NULL;
static jfieldID IOError_LDKIOError_WriteZero = NULL;
static jfieldID IOError_LDKIOError_Interrupted = NULL;
static jfieldID IOError_LDKIOError_Other = NULL;
static jfieldID IOError_LDKIOError_UnexpectedEof = NULL;
JNIEXPORT void JNICALL Java_org_ldk_enums_IOError_init (JNIEnv *env, jclass clz) {
	IOError_class = (*env)->NewGlobalRef(env, clz);
	CHECK(IOError_class != NULL);
	IOError_LDKIOError_NotFound = (*env)->GetStaticFieldID(env, IOError_class, "LDKIOError_NotFound", "Lorg/ldk/enums/IOError;");
	CHECK(IOError_LDKIOError_NotFound != NULL);
	IOError_LDKIOError_PermissionDenied = (*env)->GetStaticFieldID(env, IOError_class, "LDKIOError_PermissionDenied", "Lorg/ldk/enums/IOError;");
	CHECK(IOError_LDKIOError_PermissionDenied != NULL);
	IOError_LDKIOError_ConnectionRefused = (*env)->GetStaticFieldID(env, IOError_class, "LDKIOError_ConnectionRefused", "Lorg/ldk/enums/IOError;");
	CHECK(IOError_LDKIOError_ConnectionRefused != NULL);
	IOError_LDKIOError_ConnectionReset = (*env)->GetStaticFieldID(env, IOError_class, "LDKIOError_ConnectionReset", "Lorg/ldk/enums/IOError;");
	CHECK(IOError_LDKIOError_ConnectionReset != NULL);
	IOError_LDKIOError_ConnectionAborted = (*env)->GetStaticFieldID(env, IOError_class, "LDKIOError_ConnectionAborted", "Lorg/ldk/enums/IOError;");
	CHECK(IOError_LDKIOError_ConnectionAborted != NULL);
	IOError_LDKIOError_NotConnected = (*env)->GetStaticFieldID(env, IOError_class, "LDKIOError_NotConnected", "Lorg/ldk/enums/IOError;");
	CHECK(IOError_LDKIOError_NotConnected != NULL);
	IOError_LDKIOError_AddrInUse = (*env)->GetStaticFieldID(env, IOError_class, "LDKIOError_AddrInUse", "Lorg/ldk/enums/IOError;");
	CHECK(IOError_LDKIOError_AddrInUse != NULL);
	IOError_LDKIOError_AddrNotAvailable = (*env)->GetStaticFieldID(env, IOError_class, "LDKIOError_AddrNotAvailable", "Lorg/ldk/enums/IOError;");
	CHECK(IOError_LDKIOError_AddrNotAvailable != NULL);
	IOError_LDKIOError_BrokenPipe = (*env)->GetStaticFieldID(env, IOError_class, "LDKIOError_BrokenPipe", "Lorg/ldk/enums/IOError;");
	CHECK(IOError_LDKIOError_BrokenPipe != NULL);
	IOError_LDKIOError_AlreadyExists = (*env)->GetStaticFieldID(env, IOError_class, "LDKIOError_AlreadyExists", "Lorg/ldk/enums/IOError;");
	CHECK(IOError_LDKIOError_AlreadyExists != NULL);
	IOError_LDKIOError_WouldBlock = (*env)->GetStaticFieldID(env, IOError_class, "LDKIOError_WouldBlock", "Lorg/ldk/enums/IOError;");
	CHECK(IOError_LDKIOError_WouldBlock != NULL);
	IOError_LDKIOError_InvalidInput = (*env)->GetStaticFieldID(env, IOError_class, "LDKIOError_InvalidInput", "Lorg/ldk/enums/IOError;");
	CHECK(IOError_LDKIOError_InvalidInput != NULL);
	IOError_LDKIOError_InvalidData = (*env)->GetStaticFieldID(env, IOError_class, "LDKIOError_InvalidData", "Lorg/ldk/enums/IOError;");
	CHECK(IOError_LDKIOError_InvalidData != NULL);
	IOError_LDKIOError_TimedOut = (*env)->GetStaticFieldID(env, IOError_class, "LDKIOError_TimedOut", "Lorg/ldk/enums/IOError;");
	CHECK(IOError_LDKIOError_TimedOut != NULL);
	IOError_LDKIOError_WriteZero = (*env)->GetStaticFieldID(env, IOError_class, "LDKIOError_WriteZero", "Lorg/ldk/enums/IOError;");
	CHECK(IOError_LDKIOError_WriteZero != NULL);
	IOError_LDKIOError_Interrupted = (*env)->GetStaticFieldID(env, IOError_class, "LDKIOError_Interrupted", "Lorg/ldk/enums/IOError;");
	CHECK(IOError_LDKIOError_Interrupted != NULL);
	IOError_LDKIOError_Other = (*env)->GetStaticFieldID(env, IOError_class, "LDKIOError_Other", "Lorg/ldk/enums/IOError;");
	CHECK(IOError_LDKIOError_Other != NULL);
	IOError_LDKIOError_UnexpectedEof = (*env)->GetStaticFieldID(env, IOError_class, "LDKIOError_UnexpectedEof", "Lorg/ldk/enums/IOError;");
	CHECK(IOError_LDKIOError_UnexpectedEof != NULL);
}
static inline jclass LDKIOError_to_java(JNIEnv *env, LDKIOError val) {
	switch (val) {
		case LDKIOError_NotFound:
			return (*env)->GetStaticObjectField(env, IOError_class, IOError_LDKIOError_NotFound);
		case LDKIOError_PermissionDenied:
			return (*env)->GetStaticObjectField(env, IOError_class, IOError_LDKIOError_PermissionDenied);
		case LDKIOError_ConnectionRefused:
			return (*env)->GetStaticObjectField(env, IOError_class, IOError_LDKIOError_ConnectionRefused);
		case LDKIOError_ConnectionReset:
			return (*env)->GetStaticObjectField(env, IOError_class, IOError_LDKIOError_ConnectionReset);
		case LDKIOError_ConnectionAborted:
			return (*env)->GetStaticObjectField(env, IOError_class, IOError_LDKIOError_ConnectionAborted);
		case LDKIOError_NotConnected:
			return (*env)->GetStaticObjectField(env, IOError_class, IOError_LDKIOError_NotConnected);
		case LDKIOError_AddrInUse:
			return (*env)->GetStaticObjectField(env, IOError_class, IOError_LDKIOError_AddrInUse);
		case LDKIOError_AddrNotAvailable:
			return (*env)->GetStaticObjectField(env, IOError_class, IOError_LDKIOError_AddrNotAvailable);
		case LDKIOError_BrokenPipe:
			return (*env)->GetStaticObjectField(env, IOError_class, IOError_LDKIOError_BrokenPipe);
		case LDKIOError_AlreadyExists:
			return (*env)->GetStaticObjectField(env, IOError_class, IOError_LDKIOError_AlreadyExists);
		case LDKIOError_WouldBlock:
			return (*env)->GetStaticObjectField(env, IOError_class, IOError_LDKIOError_WouldBlock);
		case LDKIOError_InvalidInput:
			return (*env)->GetStaticObjectField(env, IOError_class, IOError_LDKIOError_InvalidInput);
		case LDKIOError_InvalidData:
			return (*env)->GetStaticObjectField(env, IOError_class, IOError_LDKIOError_InvalidData);
		case LDKIOError_TimedOut:
			return (*env)->GetStaticObjectField(env, IOError_class, IOError_LDKIOError_TimedOut);
		case LDKIOError_WriteZero:
			return (*env)->GetStaticObjectField(env, IOError_class, IOError_LDKIOError_WriteZero);
		case LDKIOError_Interrupted:
			return (*env)->GetStaticObjectField(env, IOError_class, IOError_LDKIOError_Interrupted);
		case LDKIOError_Other:
			return (*env)->GetStaticObjectField(env, IOError_class, IOError_LDKIOError_Other);
		case LDKIOError_UnexpectedEof:
			return (*env)->GetStaticObjectField(env, IOError_class, IOError_LDKIOError_UnexpectedEof);
		default: abort();
	}
}

static inline LDKLevel LDKLevel_from_java(JNIEnv *env, jclass clz) {
	switch ((*env)->CallIntMethod(env, clz, ordinal_meth)) {
		case 0: return LDKLevel_Trace;
		case 1: return LDKLevel_Debug;
		case 2: return LDKLevel_Info;
		case 3: return LDKLevel_Warn;
		case 4: return LDKLevel_Error;
	}
	abort();
}
static jclass Level_class = NULL;
static jfieldID Level_LDKLevel_Trace = NULL;
static jfieldID Level_LDKLevel_Debug = NULL;
static jfieldID Level_LDKLevel_Info = NULL;
static jfieldID Level_LDKLevel_Warn = NULL;
static jfieldID Level_LDKLevel_Error = NULL;
JNIEXPORT void JNICALL Java_org_ldk_enums_Level_init (JNIEnv *env, jclass clz) {
	Level_class = (*env)->NewGlobalRef(env, clz);
	CHECK(Level_class != NULL);
	Level_LDKLevel_Trace = (*env)->GetStaticFieldID(env, Level_class, "LDKLevel_Trace", "Lorg/ldk/enums/Level;");
	CHECK(Level_LDKLevel_Trace != NULL);
	Level_LDKLevel_Debug = (*env)->GetStaticFieldID(env, Level_class, "LDKLevel_Debug", "Lorg/ldk/enums/Level;");
	CHECK(Level_LDKLevel_Debug != NULL);
	Level_LDKLevel_Info = (*env)->GetStaticFieldID(env, Level_class, "LDKLevel_Info", "Lorg/ldk/enums/Level;");
	CHECK(Level_LDKLevel_Info != NULL);
	Level_LDKLevel_Warn = (*env)->GetStaticFieldID(env, Level_class, "LDKLevel_Warn", "Lorg/ldk/enums/Level;");
	CHECK(Level_LDKLevel_Warn != NULL);
	Level_LDKLevel_Error = (*env)->GetStaticFieldID(env, Level_class, "LDKLevel_Error", "Lorg/ldk/enums/Level;");
	CHECK(Level_LDKLevel_Error != NULL);
}
static inline jclass LDKLevel_to_java(JNIEnv *env, LDKLevel val) {
	switch (val) {
		case LDKLevel_Trace:
			return (*env)->GetStaticObjectField(env, Level_class, Level_LDKLevel_Trace);
		case LDKLevel_Debug:
			return (*env)->GetStaticObjectField(env, Level_class, Level_LDKLevel_Debug);
		case LDKLevel_Info:
			return (*env)->GetStaticObjectField(env, Level_class, Level_LDKLevel_Info);
		case LDKLevel_Warn:
			return (*env)->GetStaticObjectField(env, Level_class, Level_LDKLevel_Warn);
		case LDKLevel_Error:
			return (*env)->GetStaticObjectField(env, Level_class, Level_LDKLevel_Error);
		default: abort();
	}
}

static inline LDKNetwork LDKNetwork_from_java(JNIEnv *env, jclass clz) {
	switch ((*env)->CallIntMethod(env, clz, ordinal_meth)) {
		case 0: return LDKNetwork_Bitcoin;
		case 1: return LDKNetwork_Testnet;
		case 2: return LDKNetwork_Regtest;
		case 3: return LDKNetwork_Signet;
	}
	abort();
}
static jclass Network_class = NULL;
static jfieldID Network_LDKNetwork_Bitcoin = NULL;
static jfieldID Network_LDKNetwork_Testnet = NULL;
static jfieldID Network_LDKNetwork_Regtest = NULL;
static jfieldID Network_LDKNetwork_Signet = NULL;
JNIEXPORT void JNICALL Java_org_ldk_enums_Network_init (JNIEnv *env, jclass clz) {
	Network_class = (*env)->NewGlobalRef(env, clz);
	CHECK(Network_class != NULL);
	Network_LDKNetwork_Bitcoin = (*env)->GetStaticFieldID(env, Network_class, "LDKNetwork_Bitcoin", "Lorg/ldk/enums/Network;");
	CHECK(Network_LDKNetwork_Bitcoin != NULL);
	Network_LDKNetwork_Testnet = (*env)->GetStaticFieldID(env, Network_class, "LDKNetwork_Testnet", "Lorg/ldk/enums/Network;");
	CHECK(Network_LDKNetwork_Testnet != NULL);
	Network_LDKNetwork_Regtest = (*env)->GetStaticFieldID(env, Network_class, "LDKNetwork_Regtest", "Lorg/ldk/enums/Network;");
	CHECK(Network_LDKNetwork_Regtest != NULL);
	Network_LDKNetwork_Signet = (*env)->GetStaticFieldID(env, Network_class, "LDKNetwork_Signet", "Lorg/ldk/enums/Network;");
	CHECK(Network_LDKNetwork_Signet != NULL);
}
static inline jclass LDKNetwork_to_java(JNIEnv *env, LDKNetwork val) {
	switch (val) {
		case LDKNetwork_Bitcoin:
			return (*env)->GetStaticObjectField(env, Network_class, Network_LDKNetwork_Bitcoin);
		case LDKNetwork_Testnet:
			return (*env)->GetStaticObjectField(env, Network_class, Network_LDKNetwork_Testnet);
		case LDKNetwork_Regtest:
			return (*env)->GetStaticObjectField(env, Network_class, Network_LDKNetwork_Regtest);
		case LDKNetwork_Signet:
			return (*env)->GetStaticObjectField(env, Network_class, Network_LDKNetwork_Signet);
		default: abort();
	}
}

static inline LDKSecp256k1Error LDKSecp256k1Error_from_java(JNIEnv *env, jclass clz) {
	switch ((*env)->CallIntMethod(env, clz, ordinal_meth)) {
		case 0: return LDKSecp256k1Error_IncorrectSignature;
		case 1: return LDKSecp256k1Error_InvalidMessage;
		case 2: return LDKSecp256k1Error_InvalidPublicKey;
		case 3: return LDKSecp256k1Error_InvalidSignature;
		case 4: return LDKSecp256k1Error_InvalidSecretKey;
		case 5: return LDKSecp256k1Error_InvalidRecoveryId;
		case 6: return LDKSecp256k1Error_InvalidTweak;
		case 7: return LDKSecp256k1Error_TweakCheckFailed;
		case 8: return LDKSecp256k1Error_NotEnoughMemory;
	}
	abort();
}
static jclass Secp256k1Error_class = NULL;
static jfieldID Secp256k1Error_LDKSecp256k1Error_IncorrectSignature = NULL;
static jfieldID Secp256k1Error_LDKSecp256k1Error_InvalidMessage = NULL;
static jfieldID Secp256k1Error_LDKSecp256k1Error_InvalidPublicKey = NULL;
static jfieldID Secp256k1Error_LDKSecp256k1Error_InvalidSignature = NULL;
static jfieldID Secp256k1Error_LDKSecp256k1Error_InvalidSecretKey = NULL;
static jfieldID Secp256k1Error_LDKSecp256k1Error_InvalidRecoveryId = NULL;
static jfieldID Secp256k1Error_LDKSecp256k1Error_InvalidTweak = NULL;
static jfieldID Secp256k1Error_LDKSecp256k1Error_TweakCheckFailed = NULL;
static jfieldID Secp256k1Error_LDKSecp256k1Error_NotEnoughMemory = NULL;
JNIEXPORT void JNICALL Java_org_ldk_enums_Secp256k1Error_init (JNIEnv *env, jclass clz) {
	Secp256k1Error_class = (*env)->NewGlobalRef(env, clz);
	CHECK(Secp256k1Error_class != NULL);
	Secp256k1Error_LDKSecp256k1Error_IncorrectSignature = (*env)->GetStaticFieldID(env, Secp256k1Error_class, "LDKSecp256k1Error_IncorrectSignature", "Lorg/ldk/enums/Secp256k1Error;");
	CHECK(Secp256k1Error_LDKSecp256k1Error_IncorrectSignature != NULL);
	Secp256k1Error_LDKSecp256k1Error_InvalidMessage = (*env)->GetStaticFieldID(env, Secp256k1Error_class, "LDKSecp256k1Error_InvalidMessage", "Lorg/ldk/enums/Secp256k1Error;");
	CHECK(Secp256k1Error_LDKSecp256k1Error_InvalidMessage != NULL);
	Secp256k1Error_LDKSecp256k1Error_InvalidPublicKey = (*env)->GetStaticFieldID(env, Secp256k1Error_class, "LDKSecp256k1Error_InvalidPublicKey", "Lorg/ldk/enums/Secp256k1Error;");
	CHECK(Secp256k1Error_LDKSecp256k1Error_InvalidPublicKey != NULL);
	Secp256k1Error_LDKSecp256k1Error_InvalidSignature = (*env)->GetStaticFieldID(env, Secp256k1Error_class, "LDKSecp256k1Error_InvalidSignature", "Lorg/ldk/enums/Secp256k1Error;");
	CHECK(Secp256k1Error_LDKSecp256k1Error_InvalidSignature != NULL);
	Secp256k1Error_LDKSecp256k1Error_InvalidSecretKey = (*env)->GetStaticFieldID(env, Secp256k1Error_class, "LDKSecp256k1Error_InvalidSecretKey", "Lorg/ldk/enums/Secp256k1Error;");
	CHECK(Secp256k1Error_LDKSecp256k1Error_InvalidSecretKey != NULL);
	Secp256k1Error_LDKSecp256k1Error_InvalidRecoveryId = (*env)->GetStaticFieldID(env, Secp256k1Error_class, "LDKSecp256k1Error_InvalidRecoveryId", "Lorg/ldk/enums/Secp256k1Error;");
	CHECK(Secp256k1Error_LDKSecp256k1Error_InvalidRecoveryId != NULL);
	Secp256k1Error_LDKSecp256k1Error_InvalidTweak = (*env)->GetStaticFieldID(env, Secp256k1Error_class, "LDKSecp256k1Error_InvalidTweak", "Lorg/ldk/enums/Secp256k1Error;");
	CHECK(Secp256k1Error_LDKSecp256k1Error_InvalidTweak != NULL);
	Secp256k1Error_LDKSecp256k1Error_TweakCheckFailed = (*env)->GetStaticFieldID(env, Secp256k1Error_class, "LDKSecp256k1Error_TweakCheckFailed", "Lorg/ldk/enums/Secp256k1Error;");
	CHECK(Secp256k1Error_LDKSecp256k1Error_TweakCheckFailed != NULL);
	Secp256k1Error_LDKSecp256k1Error_NotEnoughMemory = (*env)->GetStaticFieldID(env, Secp256k1Error_class, "LDKSecp256k1Error_NotEnoughMemory", "Lorg/ldk/enums/Secp256k1Error;");
	CHECK(Secp256k1Error_LDKSecp256k1Error_NotEnoughMemory != NULL);
}
static inline jclass LDKSecp256k1Error_to_java(JNIEnv *env, LDKSecp256k1Error val) {
	switch (val) {
		case LDKSecp256k1Error_IncorrectSignature:
			return (*env)->GetStaticObjectField(env, Secp256k1Error_class, Secp256k1Error_LDKSecp256k1Error_IncorrectSignature);
		case LDKSecp256k1Error_InvalidMessage:
			return (*env)->GetStaticObjectField(env, Secp256k1Error_class, Secp256k1Error_LDKSecp256k1Error_InvalidMessage);
		case LDKSecp256k1Error_InvalidPublicKey:
			return (*env)->GetStaticObjectField(env, Secp256k1Error_class, Secp256k1Error_LDKSecp256k1Error_InvalidPublicKey);
		case LDKSecp256k1Error_InvalidSignature:
			return (*env)->GetStaticObjectField(env, Secp256k1Error_class, Secp256k1Error_LDKSecp256k1Error_InvalidSignature);
		case LDKSecp256k1Error_InvalidSecretKey:
			return (*env)->GetStaticObjectField(env, Secp256k1Error_class, Secp256k1Error_LDKSecp256k1Error_InvalidSecretKey);
		case LDKSecp256k1Error_InvalidRecoveryId:
			return (*env)->GetStaticObjectField(env, Secp256k1Error_class, Secp256k1Error_LDKSecp256k1Error_InvalidRecoveryId);
		case LDKSecp256k1Error_InvalidTweak:
			return (*env)->GetStaticObjectField(env, Secp256k1Error_class, Secp256k1Error_LDKSecp256k1Error_InvalidTweak);
		case LDKSecp256k1Error_TweakCheckFailed:
			return (*env)->GetStaticObjectField(env, Secp256k1Error_class, Secp256k1Error_LDKSecp256k1Error_TweakCheckFailed);
		case LDKSecp256k1Error_NotEnoughMemory:
			return (*env)->GetStaticObjectField(env, Secp256k1Error_class, Secp256k1Error_LDKSecp256k1Error_NotEnoughMemory);
		default: abort();
	}
}

static inline LDKSemanticError LDKSemanticError_from_java(JNIEnv *env, jclass clz) {
	switch ((*env)->CallIntMethod(env, clz, ordinal_meth)) {
		case 0: return LDKSemanticError_NoPaymentHash;
		case 1: return LDKSemanticError_MultiplePaymentHashes;
		case 2: return LDKSemanticError_NoDescription;
		case 3: return LDKSemanticError_MultipleDescriptions;
		case 4: return LDKSemanticError_NoPaymentSecret;
		case 5: return LDKSemanticError_MultiplePaymentSecrets;
		case 6: return LDKSemanticError_InvalidFeatures;
		case 7: return LDKSemanticError_InvalidRecoveryId;
		case 8: return LDKSemanticError_InvalidSignature;
		case 9: return LDKSemanticError_ImpreciseAmount;
	}
	abort();
}
static jclass SemanticError_class = NULL;
static jfieldID SemanticError_LDKSemanticError_NoPaymentHash = NULL;
static jfieldID SemanticError_LDKSemanticError_MultiplePaymentHashes = NULL;
static jfieldID SemanticError_LDKSemanticError_NoDescription = NULL;
static jfieldID SemanticError_LDKSemanticError_MultipleDescriptions = NULL;
static jfieldID SemanticError_LDKSemanticError_NoPaymentSecret = NULL;
static jfieldID SemanticError_LDKSemanticError_MultiplePaymentSecrets = NULL;
static jfieldID SemanticError_LDKSemanticError_InvalidFeatures = NULL;
static jfieldID SemanticError_LDKSemanticError_InvalidRecoveryId = NULL;
static jfieldID SemanticError_LDKSemanticError_InvalidSignature = NULL;
static jfieldID SemanticError_LDKSemanticError_ImpreciseAmount = NULL;
JNIEXPORT void JNICALL Java_org_ldk_enums_SemanticError_init (JNIEnv *env, jclass clz) {
	SemanticError_class = (*env)->NewGlobalRef(env, clz);
	CHECK(SemanticError_class != NULL);
	SemanticError_LDKSemanticError_NoPaymentHash = (*env)->GetStaticFieldID(env, SemanticError_class, "LDKSemanticError_NoPaymentHash", "Lorg/ldk/enums/SemanticError;");
	CHECK(SemanticError_LDKSemanticError_NoPaymentHash != NULL);
	SemanticError_LDKSemanticError_MultiplePaymentHashes = (*env)->GetStaticFieldID(env, SemanticError_class, "LDKSemanticError_MultiplePaymentHashes", "Lorg/ldk/enums/SemanticError;");
	CHECK(SemanticError_LDKSemanticError_MultiplePaymentHashes != NULL);
	SemanticError_LDKSemanticError_NoDescription = (*env)->GetStaticFieldID(env, SemanticError_class, "LDKSemanticError_NoDescription", "Lorg/ldk/enums/SemanticError;");
	CHECK(SemanticError_LDKSemanticError_NoDescription != NULL);
	SemanticError_LDKSemanticError_MultipleDescriptions = (*env)->GetStaticFieldID(env, SemanticError_class, "LDKSemanticError_MultipleDescriptions", "Lorg/ldk/enums/SemanticError;");
	CHECK(SemanticError_LDKSemanticError_MultipleDescriptions != NULL);
	SemanticError_LDKSemanticError_NoPaymentSecret = (*env)->GetStaticFieldID(env, SemanticError_class, "LDKSemanticError_NoPaymentSecret", "Lorg/ldk/enums/SemanticError;");
	CHECK(SemanticError_LDKSemanticError_NoPaymentSecret != NULL);
	SemanticError_LDKSemanticError_MultiplePaymentSecrets = (*env)->GetStaticFieldID(env, SemanticError_class, "LDKSemanticError_MultiplePaymentSecrets", "Lorg/ldk/enums/SemanticError;");
	CHECK(SemanticError_LDKSemanticError_MultiplePaymentSecrets != NULL);
	SemanticError_LDKSemanticError_InvalidFeatures = (*env)->GetStaticFieldID(env, SemanticError_class, "LDKSemanticError_InvalidFeatures", "Lorg/ldk/enums/SemanticError;");
	CHECK(SemanticError_LDKSemanticError_InvalidFeatures != NULL);
	SemanticError_LDKSemanticError_InvalidRecoveryId = (*env)->GetStaticFieldID(env, SemanticError_class, "LDKSemanticError_InvalidRecoveryId", "Lorg/ldk/enums/SemanticError;");
	CHECK(SemanticError_LDKSemanticError_InvalidRecoveryId != NULL);
	SemanticError_LDKSemanticError_InvalidSignature = (*env)->GetStaticFieldID(env, SemanticError_class, "LDKSemanticError_InvalidSignature", "Lorg/ldk/enums/SemanticError;");
	CHECK(SemanticError_LDKSemanticError_InvalidSignature != NULL);
	SemanticError_LDKSemanticError_ImpreciseAmount = (*env)->GetStaticFieldID(env, SemanticError_class, "LDKSemanticError_ImpreciseAmount", "Lorg/ldk/enums/SemanticError;");
	CHECK(SemanticError_LDKSemanticError_ImpreciseAmount != NULL);
}
static inline jclass LDKSemanticError_to_java(JNIEnv *env, LDKSemanticError val) {
	switch (val) {
		case LDKSemanticError_NoPaymentHash:
			return (*env)->GetStaticObjectField(env, SemanticError_class, SemanticError_LDKSemanticError_NoPaymentHash);
		case LDKSemanticError_MultiplePaymentHashes:
			return (*env)->GetStaticObjectField(env, SemanticError_class, SemanticError_LDKSemanticError_MultiplePaymentHashes);
		case LDKSemanticError_NoDescription:
			return (*env)->GetStaticObjectField(env, SemanticError_class, SemanticError_LDKSemanticError_NoDescription);
		case LDKSemanticError_MultipleDescriptions:
			return (*env)->GetStaticObjectField(env, SemanticError_class, SemanticError_LDKSemanticError_MultipleDescriptions);
		case LDKSemanticError_NoPaymentSecret:
			return (*env)->GetStaticObjectField(env, SemanticError_class, SemanticError_LDKSemanticError_NoPaymentSecret);
		case LDKSemanticError_MultiplePaymentSecrets:
			return (*env)->GetStaticObjectField(env, SemanticError_class, SemanticError_LDKSemanticError_MultiplePaymentSecrets);
		case LDKSemanticError_InvalidFeatures:
			return (*env)->GetStaticObjectField(env, SemanticError_class, SemanticError_LDKSemanticError_InvalidFeatures);
		case LDKSemanticError_InvalidRecoveryId:
			return (*env)->GetStaticObjectField(env, SemanticError_class, SemanticError_LDKSemanticError_InvalidRecoveryId);
		case LDKSemanticError_InvalidSignature:
			return (*env)->GetStaticObjectField(env, SemanticError_class, SemanticError_LDKSemanticError_InvalidSignature);
		case LDKSemanticError_ImpreciseAmount:
			return (*env)->GetStaticObjectField(env, SemanticError_class, SemanticError_LDKSemanticError_ImpreciseAmount);
		default: abort();
	}
}

static inline LDKSiPrefix LDKSiPrefix_from_java(JNIEnv *env, jclass clz) {
	switch ((*env)->CallIntMethod(env, clz, ordinal_meth)) {
		case 0: return LDKSiPrefix_Milli;
		case 1: return LDKSiPrefix_Micro;
		case 2: return LDKSiPrefix_Nano;
		case 3: return LDKSiPrefix_Pico;
	}
	abort();
}
static jclass SiPrefix_class = NULL;
static jfieldID SiPrefix_LDKSiPrefix_Milli = NULL;
static jfieldID SiPrefix_LDKSiPrefix_Micro = NULL;
static jfieldID SiPrefix_LDKSiPrefix_Nano = NULL;
static jfieldID SiPrefix_LDKSiPrefix_Pico = NULL;
JNIEXPORT void JNICALL Java_org_ldk_enums_SiPrefix_init (JNIEnv *env, jclass clz) {
	SiPrefix_class = (*env)->NewGlobalRef(env, clz);
	CHECK(SiPrefix_class != NULL);
	SiPrefix_LDKSiPrefix_Milli = (*env)->GetStaticFieldID(env, SiPrefix_class, "LDKSiPrefix_Milli", "Lorg/ldk/enums/SiPrefix;");
	CHECK(SiPrefix_LDKSiPrefix_Milli != NULL);
	SiPrefix_LDKSiPrefix_Micro = (*env)->GetStaticFieldID(env, SiPrefix_class, "LDKSiPrefix_Micro", "Lorg/ldk/enums/SiPrefix;");
	CHECK(SiPrefix_LDKSiPrefix_Micro != NULL);
	SiPrefix_LDKSiPrefix_Nano = (*env)->GetStaticFieldID(env, SiPrefix_class, "LDKSiPrefix_Nano", "Lorg/ldk/enums/SiPrefix;");
	CHECK(SiPrefix_LDKSiPrefix_Nano != NULL);
	SiPrefix_LDKSiPrefix_Pico = (*env)->GetStaticFieldID(env, SiPrefix_class, "LDKSiPrefix_Pico", "Lorg/ldk/enums/SiPrefix;");
	CHECK(SiPrefix_LDKSiPrefix_Pico != NULL);
}
static inline jclass LDKSiPrefix_to_java(JNIEnv *env, LDKSiPrefix val) {
	switch (val) {
		case LDKSiPrefix_Milli:
			return (*env)->GetStaticObjectField(env, SiPrefix_class, SiPrefix_LDKSiPrefix_Milli);
		case LDKSiPrefix_Micro:
			return (*env)->GetStaticObjectField(env, SiPrefix_class, SiPrefix_LDKSiPrefix_Micro);
		case LDKSiPrefix_Nano:
			return (*env)->GetStaticObjectField(env, SiPrefix_class, SiPrefix_LDKSiPrefix_Nano);
		case LDKSiPrefix_Pico:
			return (*env)->GetStaticObjectField(env, SiPrefix_class, SiPrefix_LDKSiPrefix_Pico);
		default: abort();
	}
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCVec_1u8Z_1new(JNIEnv *env, jclass clz, int8_tArray elems) {
	LDKCVec_u8Z *ret = MALLOC(sizeof(LDKCVec_u8Z), "LDKCVec_u8Z");
	ret->datalen = (*env)->GetArrayLength(env, elems);
	if (ret->datalen == 0) {
		ret->data = NULL;
	} else {
		ret->data = MALLOC(sizeof(uint8_t) * ret->datalen, "LDKCVec_u8Z Data");
		int8_t *java_elems = (*env)->GetPrimitiveArrayCritical(env, elems, NULL);
		for (size_t i = 0; i < ret->datalen; i++) {
			ret->data[i] = java_elems[i];
		}
		(*env)->ReleasePrimitiveArrayCritical(env, elems, java_elems, 0);
	}
	return (uint64_t)ret;
}
static inline LDKCVec_u8Z CVec_u8Z_clone(const LDKCVec_u8Z *orig) {
	LDKCVec_u8Z ret = { .data = MALLOC(sizeof(int8_t) * orig->datalen, "LDKCVec_u8Z clone bytes"), .datalen = orig->datalen };
	memcpy(ret.data, orig->data, sizeof(int8_t) * ret.datalen);
	return ret;
}
struct LDKCVec_u8Z TxOut_get_script_pubkey (struct LDKTxOut* thing) {	return CVec_u8Z_clone(&thing->script_pubkey);}JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_TxOut_1get_1script_1pubkey(JNIEnv *env, jclass clz, int64_t thing) {
	LDKTxOut* thing_conv = (LDKTxOut*)(thing & ~1);
	LDKCVec_u8Z ret_var = TxOut_get_script_pubkey(thing_conv);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	CVec_u8Z_free(ret_var);
	return ret_arr;
}

uint64_t TxOut_get_value (struct LDKTxOut* thing) {	return thing->value;}JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_TxOut_1get_1value(JNIEnv *env, jclass clz, int64_t thing) {
	LDKTxOut* thing_conv = (LDKTxOut*)(thing & ~1);
	int64_t ret_val = TxOut_get_value(thing_conv);
	return ret_val;
}

JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1SecretKeyErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_SecretKeyErrorZ*)arg)->result_ok;
}
JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_LDKCResult_1SecretKeyErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_SecretKeyErrorZ *val = (LDKCResult_SecretKeyErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	int8_tArray res_arr = (*env)->NewByteArray(env, 32);
	(*env)->SetByteArrayRegion(env, res_arr, 0, 32, (*val->contents.result).bytes);
	return res_arr;
}
JNIEXPORT jclass JNICALL Java_org_ldk_impl_bindings_LDKCResult_1SecretKeyErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_SecretKeyErrorZ *val = (LDKCResult_SecretKeyErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	jclass err_conv = LDKSecp256k1Error_to_java(env, (*val->contents.err));
	return err_conv;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1PublicKeyErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_PublicKeyErrorZ*)arg)->result_ok;
}
JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_LDKCResult_1PublicKeyErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_PublicKeyErrorZ *val = (LDKCResult_PublicKeyErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	int8_tArray res_arr = (*env)->NewByteArray(env, 33);
	(*env)->SetByteArrayRegion(env, res_arr, 0, 33, (*val->contents.result).compressed_form);
	return res_arr;
}
JNIEXPORT jclass JNICALL Java_org_ldk_impl_bindings_LDKCResult_1PublicKeyErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_PublicKeyErrorZ *val = (LDKCResult_PublicKeyErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	jclass err_conv = LDKSecp256k1Error_to_java(env, (*val->contents.err));
	return err_conv;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1TxCreationKeysDecodeErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_TxCreationKeysDecodeErrorZ*)arg)->result_ok;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1TxCreationKeysDecodeErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_TxCreationKeysDecodeErrorZ *val = (LDKCResult_TxCreationKeysDecodeErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	LDKTxCreationKeys res_var = (*val->contents.result);
	uint64_t res_ref = 0;
	CHECK((((uint64_t)res_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&res_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	res_ref = (uint64_t)res_var.inner & ~1;
	return res_ref;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1TxCreationKeysDecodeErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_TxCreationKeysDecodeErrorZ *val = (LDKCResult_TxCreationKeysDecodeErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	LDKDecodeError err_var = (*val->contents.err);
	uint64_t err_ref = 0;
	CHECK((((uint64_t)err_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&err_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	err_ref = (uint64_t)err_var.inner & ~1;
	return err_ref;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1ChannelPublicKeysDecodeErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_ChannelPublicKeysDecodeErrorZ*)arg)->result_ok;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1ChannelPublicKeysDecodeErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_ChannelPublicKeysDecodeErrorZ *val = (LDKCResult_ChannelPublicKeysDecodeErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	LDKChannelPublicKeys res_var = (*val->contents.result);
	uint64_t res_ref = 0;
	CHECK((((uint64_t)res_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&res_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	res_ref = (uint64_t)res_var.inner & ~1;
	return res_ref;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1ChannelPublicKeysDecodeErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_ChannelPublicKeysDecodeErrorZ *val = (LDKCResult_ChannelPublicKeysDecodeErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	LDKDecodeError err_var = (*val->contents.err);
	uint64_t err_ref = 0;
	CHECK((((uint64_t)err_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&err_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	err_ref = (uint64_t)err_var.inner & ~1;
	return err_ref;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1TxCreationKeysErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_TxCreationKeysErrorZ*)arg)->result_ok;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1TxCreationKeysErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_TxCreationKeysErrorZ *val = (LDKCResult_TxCreationKeysErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	LDKTxCreationKeys res_var = (*val->contents.result);
	uint64_t res_ref = 0;
	CHECK((((uint64_t)res_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&res_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	res_ref = (uint64_t)res_var.inner & ~1;
	return res_ref;
}
JNIEXPORT jclass JNICALL Java_org_ldk_impl_bindings_LDKCResult_1TxCreationKeysErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_TxCreationKeysErrorZ *val = (LDKCResult_TxCreationKeysErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	jclass err_conv = LDKSecp256k1Error_to_java(env, (*val->contents.err));
	return err_conv;
}
static jclass LDKCOption_u32Z_Some_class = NULL;
static jmethodID LDKCOption_u32Z_Some_meth = NULL;
static jclass LDKCOption_u32Z_None_class = NULL;
static jmethodID LDKCOption_u32Z_None_meth = NULL;
JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_00024LDKCOption_1u32Z_init (JNIEnv *env, jclass clz) {
	LDKCOption_u32Z_Some_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKCOption_u32Z$Some;"));
	CHECK(LDKCOption_u32Z_Some_class != NULL);
	LDKCOption_u32Z_Some_meth = (*env)->GetMethodID(env, LDKCOption_u32Z_Some_class, "<init>", "(I)V");
	CHECK(LDKCOption_u32Z_Some_meth != NULL);
	LDKCOption_u32Z_None_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKCOption_u32Z$None;"));
	CHECK(LDKCOption_u32Z_None_class != NULL);
	LDKCOption_u32Z_None_meth = (*env)->GetMethodID(env, LDKCOption_u32Z_None_class, "<init>", "()V");
	CHECK(LDKCOption_u32Z_None_meth != NULL);
}
JNIEXPORT jobject JNICALL Java_org_ldk_impl_bindings_LDKCOption_1u32Z_1ref_1from_1ptr(JNIEnv *env, jclass clz, int64_t ptr) {
	LDKCOption_u32Z *obj = (LDKCOption_u32Z*)(ptr & ~1);
	switch(obj->tag) {
		case LDKCOption_u32Z_Some: {
			return (*env)->NewObject(env, LDKCOption_u32Z_Some_class, LDKCOption_u32Z_Some_meth, obj->some);
		}
		case LDKCOption_u32Z_None: {
			return (*env)->NewObject(env, LDKCOption_u32Z_None_class, LDKCOption_u32Z_None_meth);
		}
		default: abort();
	}
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1HTLCOutputInCommitmentDecodeErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_HTLCOutputInCommitmentDecodeErrorZ*)arg)->result_ok;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1HTLCOutputInCommitmentDecodeErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_HTLCOutputInCommitmentDecodeErrorZ *val = (LDKCResult_HTLCOutputInCommitmentDecodeErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	LDKHTLCOutputInCommitment res_var = (*val->contents.result);
	uint64_t res_ref = 0;
	CHECK((((uint64_t)res_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&res_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	res_ref = (uint64_t)res_var.inner & ~1;
	return res_ref;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1HTLCOutputInCommitmentDecodeErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_HTLCOutputInCommitmentDecodeErrorZ *val = (LDKCResult_HTLCOutputInCommitmentDecodeErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	LDKDecodeError err_var = (*val->contents.err);
	uint64_t err_ref = 0;
	CHECK((((uint64_t)err_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&err_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	err_ref = (uint64_t)err_var.inner & ~1;
	return err_ref;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1CounterpartyChannelTransactionParametersDecodeErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ*)arg)->result_ok;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1CounterpartyChannelTransactionParametersDecodeErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ *val = (LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	LDKCounterpartyChannelTransactionParameters res_var = (*val->contents.result);
	uint64_t res_ref = 0;
	CHECK((((uint64_t)res_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&res_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	res_ref = (uint64_t)res_var.inner & ~1;
	return res_ref;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1CounterpartyChannelTransactionParametersDecodeErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ *val = (LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	LDKDecodeError err_var = (*val->contents.err);
	uint64_t err_ref = 0;
	CHECK((((uint64_t)err_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&err_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	err_ref = (uint64_t)err_var.inner & ~1;
	return err_ref;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1ChannelTransactionParametersDecodeErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_ChannelTransactionParametersDecodeErrorZ*)arg)->result_ok;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1ChannelTransactionParametersDecodeErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_ChannelTransactionParametersDecodeErrorZ *val = (LDKCResult_ChannelTransactionParametersDecodeErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	LDKChannelTransactionParameters res_var = (*val->contents.result);
	uint64_t res_ref = 0;
	CHECK((((uint64_t)res_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&res_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	res_ref = (uint64_t)res_var.inner & ~1;
	return res_ref;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1ChannelTransactionParametersDecodeErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_ChannelTransactionParametersDecodeErrorZ *val = (LDKCResult_ChannelTransactionParametersDecodeErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	LDKDecodeError err_var = (*val->contents.err);
	uint64_t err_ref = 0;
	CHECK((((uint64_t)err_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&err_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	err_ref = (uint64_t)err_var.inner & ~1;
	return err_ref;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1HolderCommitmentTransactionDecodeErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_HolderCommitmentTransactionDecodeErrorZ*)arg)->result_ok;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1HolderCommitmentTransactionDecodeErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_HolderCommitmentTransactionDecodeErrorZ *val = (LDKCResult_HolderCommitmentTransactionDecodeErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	LDKHolderCommitmentTransaction res_var = (*val->contents.result);
	uint64_t res_ref = 0;
	CHECK((((uint64_t)res_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&res_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	res_ref = (uint64_t)res_var.inner & ~1;
	return res_ref;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1HolderCommitmentTransactionDecodeErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_HolderCommitmentTransactionDecodeErrorZ *val = (LDKCResult_HolderCommitmentTransactionDecodeErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	LDKDecodeError err_var = (*val->contents.err);
	uint64_t err_ref = 0;
	CHECK((((uint64_t)err_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&err_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	err_ref = (uint64_t)err_var.inner & ~1;
	return err_ref;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1BuiltCommitmentTransactionDecodeErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_BuiltCommitmentTransactionDecodeErrorZ*)arg)->result_ok;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1BuiltCommitmentTransactionDecodeErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_BuiltCommitmentTransactionDecodeErrorZ *val = (LDKCResult_BuiltCommitmentTransactionDecodeErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	LDKBuiltCommitmentTransaction res_var = (*val->contents.result);
	uint64_t res_ref = 0;
	CHECK((((uint64_t)res_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&res_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	res_ref = (uint64_t)res_var.inner & ~1;
	return res_ref;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1BuiltCommitmentTransactionDecodeErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_BuiltCommitmentTransactionDecodeErrorZ *val = (LDKCResult_BuiltCommitmentTransactionDecodeErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	LDKDecodeError err_var = (*val->contents.err);
	uint64_t err_ref = 0;
	CHECK((((uint64_t)err_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&err_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	err_ref = (uint64_t)err_var.inner & ~1;
	return err_ref;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1TrustedClosingTransactionNoneZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_TrustedClosingTransactionNoneZ*)arg)->result_ok;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1TrustedClosingTransactionNoneZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_TrustedClosingTransactionNoneZ *val = (LDKCResult_TrustedClosingTransactionNoneZ*)(arg & ~1);
	CHECK(val->result_ok);
	LDKTrustedClosingTransaction res_var = (*val->contents.result);
	uint64_t res_ref = 0;
	CHECK((((uint64_t)res_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&res_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	res_ref = (uint64_t)res_var.inner & ~1;
	return res_ref;
}
JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_LDKCResult_1TrustedClosingTransactionNoneZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_TrustedClosingTransactionNoneZ *val = (LDKCResult_TrustedClosingTransactionNoneZ*)(arg & ~1);
	CHECK(!val->result_ok);
	return *val->contents.err;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1CommitmentTransactionDecodeErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_CommitmentTransactionDecodeErrorZ*)arg)->result_ok;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1CommitmentTransactionDecodeErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_CommitmentTransactionDecodeErrorZ *val = (LDKCResult_CommitmentTransactionDecodeErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	LDKCommitmentTransaction res_var = (*val->contents.result);
	uint64_t res_ref = 0;
	CHECK((((uint64_t)res_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&res_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	res_ref = (uint64_t)res_var.inner & ~1;
	return res_ref;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1CommitmentTransactionDecodeErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_CommitmentTransactionDecodeErrorZ *val = (LDKCResult_CommitmentTransactionDecodeErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	LDKDecodeError err_var = (*val->contents.err);
	uint64_t err_ref = 0;
	CHECK((((uint64_t)err_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&err_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	err_ref = (uint64_t)err_var.inner & ~1;
	return err_ref;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1TrustedCommitmentTransactionNoneZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_TrustedCommitmentTransactionNoneZ*)arg)->result_ok;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1TrustedCommitmentTransactionNoneZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_TrustedCommitmentTransactionNoneZ *val = (LDKCResult_TrustedCommitmentTransactionNoneZ*)(arg & ~1);
	CHECK(val->result_ok);
	LDKTrustedCommitmentTransaction res_var = (*val->contents.result);
	uint64_t res_ref = 0;
	CHECK((((uint64_t)res_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&res_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	res_ref = (uint64_t)res_var.inner & ~1;
	return res_ref;
}
JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_LDKCResult_1TrustedCommitmentTransactionNoneZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_TrustedCommitmentTransactionNoneZ *val = (LDKCResult_TrustedCommitmentTransactionNoneZ*)(arg & ~1);
	CHECK(!val->result_ok);
	return *val->contents.err;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1CVec_1SignatureZNoneZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_CVec_SignatureZNoneZ*)arg)->result_ok;
}
JNIEXPORT jobjectArray JNICALL Java_org_ldk_impl_bindings_LDKCResult_1CVec_1SignatureZNoneZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_CVec_SignatureZNoneZ *val = (LDKCResult_CVec_SignatureZNoneZ*)(arg & ~1);
	CHECK(val->result_ok);
	LDKCVec_SignatureZ res_var = (*val->contents.result);
	jobjectArray res_arr = NULL;
	res_arr = (*env)->NewObjectArray(env, res_var.datalen, arr_of_B_clz, NULL);
	;
	for (size_t i = 0; i < res_var.datalen; i++) {
		int8_tArray res_conv_8_arr = (*env)->NewByteArray(env, 64);
		(*env)->SetByteArrayRegion(env, res_conv_8_arr, 0, 64, res_var.data[i].compact_form);
		(*env)->SetObjectArrayElement(env, res_arr, i, res_conv_8_arr);
	}
	
	return res_arr;
}
JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_LDKCResult_1CVec_1SignatureZNoneZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_CVec_SignatureZNoneZ *val = (LDKCResult_CVec_SignatureZNoneZ*)(arg & ~1);
	CHECK(!val->result_ok);
	return *val->contents.err;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1ShutdownScriptDecodeErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_ShutdownScriptDecodeErrorZ*)arg)->result_ok;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1ShutdownScriptDecodeErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_ShutdownScriptDecodeErrorZ *val = (LDKCResult_ShutdownScriptDecodeErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	LDKShutdownScript res_var = (*val->contents.result);
	uint64_t res_ref = 0;
	CHECK((((uint64_t)res_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&res_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	res_ref = (uint64_t)res_var.inner & ~1;
	return res_ref;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1ShutdownScriptDecodeErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_ShutdownScriptDecodeErrorZ *val = (LDKCResult_ShutdownScriptDecodeErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	LDKDecodeError err_var = (*val->contents.err);
	uint64_t err_ref = 0;
	CHECK((((uint64_t)err_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&err_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	err_ref = (uint64_t)err_var.inner & ~1;
	return err_ref;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1ShutdownScriptInvalidShutdownScriptZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_ShutdownScriptInvalidShutdownScriptZ*)arg)->result_ok;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1ShutdownScriptInvalidShutdownScriptZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_ShutdownScriptInvalidShutdownScriptZ *val = (LDKCResult_ShutdownScriptInvalidShutdownScriptZ*)(arg & ~1);
	CHECK(val->result_ok);
	LDKShutdownScript res_var = (*val->contents.result);
	uint64_t res_ref = 0;
	CHECK((((uint64_t)res_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&res_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	res_ref = (uint64_t)res_var.inner & ~1;
	return res_ref;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1ShutdownScriptInvalidShutdownScriptZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_ShutdownScriptInvalidShutdownScriptZ *val = (LDKCResult_ShutdownScriptInvalidShutdownScriptZ*)(arg & ~1);
	CHECK(!val->result_ok);
	LDKInvalidShutdownScript err_var = (*val->contents.err);
	uint64_t err_ref = 0;
	CHECK((((uint64_t)err_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&err_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	err_ref = (uint64_t)err_var.inner & ~1;
	return err_ref;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1NoneErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_NoneErrorZ*)arg)->result_ok;
}
JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_LDKCResult_1NoneErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_NoneErrorZ *val = (LDKCResult_NoneErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	return *val->contents.result;
}
JNIEXPORT jclass JNICALL Java_org_ldk_impl_bindings_LDKCResult_1NoneErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_NoneErrorZ *val = (LDKCResult_NoneErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	jclass err_conv = LDKIOError_to_java(env, (*val->contents.err));
	return err_conv;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1RouteHopDecodeErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_RouteHopDecodeErrorZ*)arg)->result_ok;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1RouteHopDecodeErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_RouteHopDecodeErrorZ *val = (LDKCResult_RouteHopDecodeErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	LDKRouteHop res_var = (*val->contents.result);
	uint64_t res_ref = 0;
	CHECK((((uint64_t)res_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&res_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	res_ref = (uint64_t)res_var.inner & ~1;
	return res_ref;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1RouteHopDecodeErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_RouteHopDecodeErrorZ *val = (LDKCResult_RouteHopDecodeErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	LDKDecodeError err_var = (*val->contents.err);
	uint64_t err_ref = 0;
	CHECK((((uint64_t)err_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&err_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	err_ref = (uint64_t)err_var.inner & ~1;
	return err_ref;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCVec_1RouteHopZ_1new(JNIEnv *env, jclass clz, int64_tArray elems) {
	LDKCVec_RouteHopZ *ret = MALLOC(sizeof(LDKCVec_RouteHopZ), "LDKCVec_RouteHopZ");
	ret->datalen = (*env)->GetArrayLength(env, elems);
	if (ret->datalen == 0) {
		ret->data = NULL;
	} else {
		ret->data = MALLOC(sizeof(LDKRouteHop) * ret->datalen, "LDKCVec_RouteHopZ Data");
		int64_t *java_elems = (*env)->GetPrimitiveArrayCritical(env, elems, NULL);
		for (size_t i = 0; i < ret->datalen; i++) {
			int64_t arr_elem = java_elems[i];
			LDKRouteHop arr_elem_conv;
			arr_elem_conv.inner = (void*)(arr_elem & (~1));
			arr_elem_conv.is_owned = (arr_elem & 1) || (arr_elem == 0);
			arr_elem_conv = RouteHop_clone(&arr_elem_conv);
			ret->data[i] = arr_elem_conv;
		}
		(*env)->ReleasePrimitiveArrayCritical(env, elems, java_elems, 0);
	}
	return (uint64_t)ret;
}
static inline LDKCVec_RouteHopZ CVec_RouteHopZ_clone(const LDKCVec_RouteHopZ *orig) {
	LDKCVec_RouteHopZ ret = { .data = MALLOC(sizeof(LDKRouteHop) * orig->datalen, "LDKCVec_RouteHopZ clone bytes"), .datalen = orig->datalen };
	for (size_t i = 0; i < ret.datalen; i++) {
		ret.data[i] = RouteHop_clone(&orig->data[i]);
	}
	return ret;
}
static inline LDKCVec_CVec_RouteHopZZ CVec_CVec_RouteHopZZ_clone(const LDKCVec_CVec_RouteHopZZ *orig) {
	LDKCVec_CVec_RouteHopZZ ret = { .data = MALLOC(sizeof(LDKCVec_RouteHopZ) * orig->datalen, "LDKCVec_CVec_RouteHopZZ clone bytes"), .datalen = orig->datalen };
	for (size_t i = 0; i < ret.datalen; i++) {
		ret.data[i] = CVec_RouteHopZ_clone(&orig->data[i]);
	}
	return ret;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1RouteDecodeErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_RouteDecodeErrorZ*)arg)->result_ok;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1RouteDecodeErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_RouteDecodeErrorZ *val = (LDKCResult_RouteDecodeErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	LDKRoute res_var = (*val->contents.result);
	uint64_t res_ref = 0;
	CHECK((((uint64_t)res_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&res_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	res_ref = (uint64_t)res_var.inner & ~1;
	return res_ref;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1RouteDecodeErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_RouteDecodeErrorZ *val = (LDKCResult_RouteDecodeErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	LDKDecodeError err_var = (*val->contents.err);
	uint64_t err_ref = 0;
	CHECK((((uint64_t)err_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&err_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	err_ref = (uint64_t)err_var.inner & ~1;
	return err_ref;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1RouteParametersDecodeErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_RouteParametersDecodeErrorZ*)arg)->result_ok;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1RouteParametersDecodeErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_RouteParametersDecodeErrorZ *val = (LDKCResult_RouteParametersDecodeErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	LDKRouteParameters res_var = (*val->contents.result);
	uint64_t res_ref = 0;
	CHECK((((uint64_t)res_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&res_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	res_ref = (uint64_t)res_var.inner & ~1;
	return res_ref;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1RouteParametersDecodeErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_RouteParametersDecodeErrorZ *val = (LDKCResult_RouteParametersDecodeErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	LDKDecodeError err_var = (*val->contents.err);
	uint64_t err_ref = 0;
	CHECK((((uint64_t)err_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&err_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	err_ref = (uint64_t)err_var.inner & ~1;
	return err_ref;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCVec_1RouteHintZ_1new(JNIEnv *env, jclass clz, int64_tArray elems) {
	LDKCVec_RouteHintZ *ret = MALLOC(sizeof(LDKCVec_RouteHintZ), "LDKCVec_RouteHintZ");
	ret->datalen = (*env)->GetArrayLength(env, elems);
	if (ret->datalen == 0) {
		ret->data = NULL;
	} else {
		ret->data = MALLOC(sizeof(LDKRouteHint) * ret->datalen, "LDKCVec_RouteHintZ Data");
		int64_t *java_elems = (*env)->GetPrimitiveArrayCritical(env, elems, NULL);
		for (size_t i = 0; i < ret->datalen; i++) {
			int64_t arr_elem = java_elems[i];
			LDKRouteHint arr_elem_conv;
			arr_elem_conv.inner = (void*)(arr_elem & (~1));
			arr_elem_conv.is_owned = (arr_elem & 1) || (arr_elem == 0);
			arr_elem_conv = RouteHint_clone(&arr_elem_conv);
			ret->data[i] = arr_elem_conv;
		}
		(*env)->ReleasePrimitiveArrayCritical(env, elems, java_elems, 0);
	}
	return (uint64_t)ret;
}
static inline LDKCVec_RouteHintZ CVec_RouteHintZ_clone(const LDKCVec_RouteHintZ *orig) {
	LDKCVec_RouteHintZ ret = { .data = MALLOC(sizeof(LDKRouteHint) * orig->datalen, "LDKCVec_RouteHintZ clone bytes"), .datalen = orig->datalen };
	for (size_t i = 0; i < ret.datalen; i++) {
		ret.data[i] = RouteHint_clone(&orig->data[i]);
	}
	return ret;
}
static jclass LDKCOption_u64Z_Some_class = NULL;
static jmethodID LDKCOption_u64Z_Some_meth = NULL;
static jclass LDKCOption_u64Z_None_class = NULL;
static jmethodID LDKCOption_u64Z_None_meth = NULL;
JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_00024LDKCOption_1u64Z_init (JNIEnv *env, jclass clz) {
	LDKCOption_u64Z_Some_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKCOption_u64Z$Some;"));
	CHECK(LDKCOption_u64Z_Some_class != NULL);
	LDKCOption_u64Z_Some_meth = (*env)->GetMethodID(env, LDKCOption_u64Z_Some_class, "<init>", "(J)V");
	CHECK(LDKCOption_u64Z_Some_meth != NULL);
	LDKCOption_u64Z_None_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKCOption_u64Z$None;"));
	CHECK(LDKCOption_u64Z_None_class != NULL);
	LDKCOption_u64Z_None_meth = (*env)->GetMethodID(env, LDKCOption_u64Z_None_class, "<init>", "()V");
	CHECK(LDKCOption_u64Z_None_meth != NULL);
}
JNIEXPORT jobject JNICALL Java_org_ldk_impl_bindings_LDKCOption_1u64Z_1ref_1from_1ptr(JNIEnv *env, jclass clz, int64_t ptr) {
	LDKCOption_u64Z *obj = (LDKCOption_u64Z*)(ptr & ~1);
	switch(obj->tag) {
		case LDKCOption_u64Z_Some: {
			return (*env)->NewObject(env, LDKCOption_u64Z_Some_class, LDKCOption_u64Z_Some_meth, obj->some);
		}
		case LDKCOption_u64Z_None: {
			return (*env)->NewObject(env, LDKCOption_u64Z_None_class, LDKCOption_u64Z_None_meth);
		}
		default: abort();
	}
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1PayeeDecodeErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_PayeeDecodeErrorZ*)arg)->result_ok;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1PayeeDecodeErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_PayeeDecodeErrorZ *val = (LDKCResult_PayeeDecodeErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	LDKPayee res_var = (*val->contents.result);
	uint64_t res_ref = 0;
	CHECK((((uint64_t)res_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&res_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	res_ref = (uint64_t)res_var.inner & ~1;
	return res_ref;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1PayeeDecodeErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_PayeeDecodeErrorZ *val = (LDKCResult_PayeeDecodeErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	LDKDecodeError err_var = (*val->contents.err);
	uint64_t err_ref = 0;
	CHECK((((uint64_t)err_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&err_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	err_ref = (uint64_t)err_var.inner & ~1;
	return err_ref;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCVec_1RouteHintHopZ_1new(JNIEnv *env, jclass clz, int64_tArray elems) {
	LDKCVec_RouteHintHopZ *ret = MALLOC(sizeof(LDKCVec_RouteHintHopZ), "LDKCVec_RouteHintHopZ");
	ret->datalen = (*env)->GetArrayLength(env, elems);
	if (ret->datalen == 0) {
		ret->data = NULL;
	} else {
		ret->data = MALLOC(sizeof(LDKRouteHintHop) * ret->datalen, "LDKCVec_RouteHintHopZ Data");
		int64_t *java_elems = (*env)->GetPrimitiveArrayCritical(env, elems, NULL);
		for (size_t i = 0; i < ret->datalen; i++) {
			int64_t arr_elem = java_elems[i];
			LDKRouteHintHop arr_elem_conv;
			arr_elem_conv.inner = (void*)(arr_elem & (~1));
			arr_elem_conv.is_owned = (arr_elem & 1) || (arr_elem == 0);
			arr_elem_conv = RouteHintHop_clone(&arr_elem_conv);
			ret->data[i] = arr_elem_conv;
		}
		(*env)->ReleasePrimitiveArrayCritical(env, elems, java_elems, 0);
	}
	return (uint64_t)ret;
}
static inline LDKCVec_RouteHintHopZ CVec_RouteHintHopZ_clone(const LDKCVec_RouteHintHopZ *orig) {
	LDKCVec_RouteHintHopZ ret = { .data = MALLOC(sizeof(LDKRouteHintHop) * orig->datalen, "LDKCVec_RouteHintHopZ clone bytes"), .datalen = orig->datalen };
	for (size_t i = 0; i < ret.datalen; i++) {
		ret.data[i] = RouteHintHop_clone(&orig->data[i]);
	}
	return ret;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1RouteHintDecodeErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_RouteHintDecodeErrorZ*)arg)->result_ok;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1RouteHintDecodeErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_RouteHintDecodeErrorZ *val = (LDKCResult_RouteHintDecodeErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	LDKRouteHint res_var = (*val->contents.result);
	uint64_t res_ref = 0;
	CHECK((((uint64_t)res_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&res_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	res_ref = (uint64_t)res_var.inner & ~1;
	return res_ref;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1RouteHintDecodeErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_RouteHintDecodeErrorZ *val = (LDKCResult_RouteHintDecodeErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	LDKDecodeError err_var = (*val->contents.err);
	uint64_t err_ref = 0;
	CHECK((((uint64_t)err_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&err_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	err_ref = (uint64_t)err_var.inner & ~1;
	return err_ref;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1RouteHintHopDecodeErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_RouteHintHopDecodeErrorZ*)arg)->result_ok;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1RouteHintHopDecodeErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_RouteHintHopDecodeErrorZ *val = (LDKCResult_RouteHintHopDecodeErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	LDKRouteHintHop res_var = (*val->contents.result);
	uint64_t res_ref = 0;
	CHECK((((uint64_t)res_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&res_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	res_ref = (uint64_t)res_var.inner & ~1;
	return res_ref;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1RouteHintHopDecodeErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_RouteHintHopDecodeErrorZ *val = (LDKCResult_RouteHintHopDecodeErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	LDKDecodeError err_var = (*val->contents.err);
	uint64_t err_ref = 0;
	CHECK((((uint64_t)err_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&err_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	err_ref = (uint64_t)err_var.inner & ~1;
	return err_ref;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCVec_1ChannelDetailsZ_1new(JNIEnv *env, jclass clz, int64_tArray elems) {
	LDKCVec_ChannelDetailsZ *ret = MALLOC(sizeof(LDKCVec_ChannelDetailsZ), "LDKCVec_ChannelDetailsZ");
	ret->datalen = (*env)->GetArrayLength(env, elems);
	if (ret->datalen == 0) {
		ret->data = NULL;
	} else {
		ret->data = MALLOC(sizeof(LDKChannelDetails) * ret->datalen, "LDKCVec_ChannelDetailsZ Data");
		int64_t *java_elems = (*env)->GetPrimitiveArrayCritical(env, elems, NULL);
		for (size_t i = 0; i < ret->datalen; i++) {
			int64_t arr_elem = java_elems[i];
			LDKChannelDetails arr_elem_conv;
			arr_elem_conv.inner = (void*)(arr_elem & (~1));
			arr_elem_conv.is_owned = (arr_elem & 1) || (arr_elem == 0);
			arr_elem_conv = ChannelDetails_clone(&arr_elem_conv);
			ret->data[i] = arr_elem_conv;
		}
		(*env)->ReleasePrimitiveArrayCritical(env, elems, java_elems, 0);
	}
	return (uint64_t)ret;
}
static inline LDKCVec_ChannelDetailsZ CVec_ChannelDetailsZ_clone(const LDKCVec_ChannelDetailsZ *orig) {
	LDKCVec_ChannelDetailsZ ret = { .data = MALLOC(sizeof(LDKChannelDetails) * orig->datalen, "LDKCVec_ChannelDetailsZ clone bytes"), .datalen = orig->datalen };
	for (size_t i = 0; i < ret.datalen; i++) {
		ret.data[i] = ChannelDetails_clone(&orig->data[i]);
	}
	return ret;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1RouteLightningErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_RouteLightningErrorZ*)arg)->result_ok;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1RouteLightningErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_RouteLightningErrorZ *val = (LDKCResult_RouteLightningErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	LDKRoute res_var = (*val->contents.result);
	uint64_t res_ref = 0;
	CHECK((((uint64_t)res_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&res_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	res_ref = (uint64_t)res_var.inner & ~1;
	return res_ref;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1RouteLightningErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_RouteLightningErrorZ *val = (LDKCResult_RouteLightningErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	LDKLightningError err_var = (*val->contents.err);
	uint64_t err_ref = 0;
	CHECK((((uint64_t)err_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&err_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	err_ref = (uint64_t)err_var.inner & ~1;
	return err_ref;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1TxOutAccessErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_TxOutAccessErrorZ*)arg)->result_ok;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1TxOutAccessErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_TxOutAccessErrorZ *val = (LDKCResult_TxOutAccessErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	uint64_t res_ref = ((uint64_t)&(*val->contents.result)) | 1;
	return (uint64_t)res_ref;
}
JNIEXPORT jclass JNICALL Java_org_ldk_impl_bindings_LDKCResult_1TxOutAccessErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_TxOutAccessErrorZ *val = (LDKCResult_TxOutAccessErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	jclass err_conv = LDKAccessError_to_java(env, (*val->contents.err));
	return err_conv;
}
static inline uintptr_t C2Tuple_usizeTransactionZ_get_a(LDKC2Tuple_usizeTransactionZ *NONNULL_PTR tuple){
	return tuple->a;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_C2Tuple_1usizeTransactionZ_1get_1a(JNIEnv *env, jclass clz, int64_t tuple) {
	LDKC2Tuple_usizeTransactionZ* tuple_conv = (LDKC2Tuple_usizeTransactionZ*)(tuple & ~1);
	int64_t ret_val = C2Tuple_usizeTransactionZ_get_a(tuple_conv);
	return ret_val;
}

static inline struct LDKTransaction C2Tuple_usizeTransactionZ_get_b(LDKC2Tuple_usizeTransactionZ *NONNULL_PTR tuple){
	return tuple->b;
}
JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_C2Tuple_1usizeTransactionZ_1get_1b(JNIEnv *env, jclass clz, int64_t tuple) {
	LDKC2Tuple_usizeTransactionZ* tuple_conv = (LDKC2Tuple_usizeTransactionZ*)(tuple & ~1);
	LDKTransaction ret_var = C2Tuple_usizeTransactionZ_get_b(tuple_conv);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	Transaction_free(ret_var);
	return ret_arr;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCVec_1C2Tuple_1usizeTransactionZZ_1new(JNIEnv *env, jclass clz, int64_tArray elems) {
	LDKCVec_C2Tuple_usizeTransactionZZ *ret = MALLOC(sizeof(LDKCVec_C2Tuple_usizeTransactionZZ), "LDKCVec_C2Tuple_usizeTransactionZZ");
	ret->datalen = (*env)->GetArrayLength(env, elems);
	if (ret->datalen == 0) {
		ret->data = NULL;
	} else {
		ret->data = MALLOC(sizeof(LDKC2Tuple_usizeTransactionZ) * ret->datalen, "LDKCVec_C2Tuple_usizeTransactionZZ Data");
		int64_t *java_elems = (*env)->GetPrimitiveArrayCritical(env, elems, NULL);
		for (size_t i = 0; i < ret->datalen; i++) {
			int64_t arr_elem = java_elems[i];
			void* arr_elem_ptr = (void*)(((uint64_t)arr_elem) & ~1);
			CHECK_ACCESS(arr_elem_ptr);
			LDKC2Tuple_usizeTransactionZ arr_elem_conv = *(LDKC2Tuple_usizeTransactionZ*)(arr_elem_ptr);
			arr_elem_conv = C2Tuple_usizeTransactionZ_clone((LDKC2Tuple_usizeTransactionZ*)(((uint64_t)arr_elem) & ~1));
			ret->data[i] = arr_elem_conv;
		}
		(*env)->ReleasePrimitiveArrayCritical(env, elems, java_elems, 0);
	}
	return (uint64_t)ret;
}
static inline LDKCVec_C2Tuple_usizeTransactionZZ CVec_C2Tuple_usizeTransactionZZ_clone(const LDKCVec_C2Tuple_usizeTransactionZZ *orig) {
	LDKCVec_C2Tuple_usizeTransactionZZ ret = { .data = MALLOC(sizeof(LDKC2Tuple_usizeTransactionZ) * orig->datalen, "LDKCVec_C2Tuple_usizeTransactionZZ clone bytes"), .datalen = orig->datalen };
	for (size_t i = 0; i < ret.datalen; i++) {
		ret.data[i] = C2Tuple_usizeTransactionZ_clone(&orig->data[i]);
	}
	return ret;
}
static inline LDKCVec_TxidZ CVec_ThirtyTwoBytesZ_clone(const LDKCVec_TxidZ *orig) {
	LDKCVec_TxidZ ret = { .data = MALLOC(sizeof(LDKThirtyTwoBytes) * orig->datalen, "LDKCVec_TxidZ clone bytes"), .datalen = orig->datalen };
	for (size_t i = 0; i < ret.datalen; i++) {
		ret.data[i] = ThirtyTwoBytes_clone(&orig->data[i]);
	}
	return ret;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1NoneChannelMonitorUpdateErrZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_NoneChannelMonitorUpdateErrZ*)arg)->result_ok;
}
JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_LDKCResult_1NoneChannelMonitorUpdateErrZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_NoneChannelMonitorUpdateErrZ *val = (LDKCResult_NoneChannelMonitorUpdateErrZ*)(arg & ~1);
	CHECK(val->result_ok);
	return *val->contents.result;
}
JNIEXPORT jclass JNICALL Java_org_ldk_impl_bindings_LDKCResult_1NoneChannelMonitorUpdateErrZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_NoneChannelMonitorUpdateErrZ *val = (LDKCResult_NoneChannelMonitorUpdateErrZ*)(arg & ~1);
	CHECK(!val->result_ok);
	jclass err_conv = LDKChannelMonitorUpdateErr_to_java(env, (*val->contents.err));
	return err_conv;
}
static jclass LDKMonitorEvent_HTLCEvent_class = NULL;
static jmethodID LDKMonitorEvent_HTLCEvent_meth = NULL;
static jclass LDKMonitorEvent_CommitmentTxConfirmed_class = NULL;
static jmethodID LDKMonitorEvent_CommitmentTxConfirmed_meth = NULL;
static jclass LDKMonitorEvent_UpdateCompleted_class = NULL;
static jmethodID LDKMonitorEvent_UpdateCompleted_meth = NULL;
static jclass LDKMonitorEvent_UpdateFailed_class = NULL;
static jmethodID LDKMonitorEvent_UpdateFailed_meth = NULL;
JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_00024LDKMonitorEvent_init (JNIEnv *env, jclass clz) {
	LDKMonitorEvent_HTLCEvent_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKMonitorEvent$HTLCEvent;"));
	CHECK(LDKMonitorEvent_HTLCEvent_class != NULL);
	LDKMonitorEvent_HTLCEvent_meth = (*env)->GetMethodID(env, LDKMonitorEvent_HTLCEvent_class, "<init>", "(J)V");
	CHECK(LDKMonitorEvent_HTLCEvent_meth != NULL);
	LDKMonitorEvent_CommitmentTxConfirmed_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKMonitorEvent$CommitmentTxConfirmed;"));
	CHECK(LDKMonitorEvent_CommitmentTxConfirmed_class != NULL);
	LDKMonitorEvent_CommitmentTxConfirmed_meth = (*env)->GetMethodID(env, LDKMonitorEvent_CommitmentTxConfirmed_class, "<init>", "(J)V");
	CHECK(LDKMonitorEvent_CommitmentTxConfirmed_meth != NULL);
	LDKMonitorEvent_UpdateCompleted_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKMonitorEvent$UpdateCompleted;"));
	CHECK(LDKMonitorEvent_UpdateCompleted_class != NULL);
	LDKMonitorEvent_UpdateCompleted_meth = (*env)->GetMethodID(env, LDKMonitorEvent_UpdateCompleted_class, "<init>", "(JJ)V");
	CHECK(LDKMonitorEvent_UpdateCompleted_meth != NULL);
	LDKMonitorEvent_UpdateFailed_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKMonitorEvent$UpdateFailed;"));
	CHECK(LDKMonitorEvent_UpdateFailed_class != NULL);
	LDKMonitorEvent_UpdateFailed_meth = (*env)->GetMethodID(env, LDKMonitorEvent_UpdateFailed_class, "<init>", "(J)V");
	CHECK(LDKMonitorEvent_UpdateFailed_meth != NULL);
}
JNIEXPORT jobject JNICALL Java_org_ldk_impl_bindings_LDKMonitorEvent_1ref_1from_1ptr(JNIEnv *env, jclass clz, int64_t ptr) {
	LDKMonitorEvent *obj = (LDKMonitorEvent*)(ptr & ~1);
	switch(obj->tag) {
		case LDKMonitorEvent_HTLCEvent: {
			LDKHTLCUpdate htlc_event_var = obj->htlc_event;
			uint64_t htlc_event_ref = 0;
			CHECK((((uint64_t)htlc_event_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
			CHECK((((uint64_t)&htlc_event_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
			htlc_event_ref = (uint64_t)htlc_event_var.inner & ~1;
			return (*env)->NewObject(env, LDKMonitorEvent_HTLCEvent_class, LDKMonitorEvent_HTLCEvent_meth, htlc_event_ref);
		}
		case LDKMonitorEvent_CommitmentTxConfirmed: {
			LDKOutPoint commitment_tx_confirmed_var = obj->commitment_tx_confirmed;
			uint64_t commitment_tx_confirmed_ref = 0;
			CHECK((((uint64_t)commitment_tx_confirmed_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
			CHECK((((uint64_t)&commitment_tx_confirmed_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
			commitment_tx_confirmed_ref = (uint64_t)commitment_tx_confirmed_var.inner & ~1;
			return (*env)->NewObject(env, LDKMonitorEvent_CommitmentTxConfirmed_class, LDKMonitorEvent_CommitmentTxConfirmed_meth, commitment_tx_confirmed_ref);
		}
		case LDKMonitorEvent_UpdateCompleted: {
			LDKOutPoint funding_txo_var = obj->update_completed.funding_txo;
			uint64_t funding_txo_ref = 0;
			CHECK((((uint64_t)funding_txo_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
			CHECK((((uint64_t)&funding_txo_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
			funding_txo_ref = (uint64_t)funding_txo_var.inner & ~1;
			return (*env)->NewObject(env, LDKMonitorEvent_UpdateCompleted_class, LDKMonitorEvent_UpdateCompleted_meth, funding_txo_ref, obj->update_completed.monitor_update_id);
		}
		case LDKMonitorEvent_UpdateFailed: {
			LDKOutPoint update_failed_var = obj->update_failed;
			uint64_t update_failed_ref = 0;
			CHECK((((uint64_t)update_failed_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
			CHECK((((uint64_t)&update_failed_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
			update_failed_ref = (uint64_t)update_failed_var.inner & ~1;
			return (*env)->NewObject(env, LDKMonitorEvent_UpdateFailed_class, LDKMonitorEvent_UpdateFailed_meth, update_failed_ref);
		}
		default: abort();
	}
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCVec_1MonitorEventZ_1new(JNIEnv *env, jclass clz, int64_tArray elems) {
	LDKCVec_MonitorEventZ *ret = MALLOC(sizeof(LDKCVec_MonitorEventZ), "LDKCVec_MonitorEventZ");
	ret->datalen = (*env)->GetArrayLength(env, elems);
	if (ret->datalen == 0) {
		ret->data = NULL;
	} else {
		ret->data = MALLOC(sizeof(LDKMonitorEvent) * ret->datalen, "LDKCVec_MonitorEventZ Data");
		int64_t *java_elems = (*env)->GetPrimitiveArrayCritical(env, elems, NULL);
		for (size_t i = 0; i < ret->datalen; i++) {
			int64_t arr_elem = java_elems[i];
			void* arr_elem_ptr = (void*)(((uint64_t)arr_elem) & ~1);
			CHECK_ACCESS(arr_elem_ptr);
			LDKMonitorEvent arr_elem_conv = *(LDKMonitorEvent*)(arr_elem_ptr);
			arr_elem_conv = MonitorEvent_clone((LDKMonitorEvent*)(((uint64_t)arr_elem) & ~1));
			ret->data[i] = arr_elem_conv;
		}
		(*env)->ReleasePrimitiveArrayCritical(env, elems, java_elems, 0);
	}
	return (uint64_t)ret;
}
static inline LDKCVec_MonitorEventZ CVec_MonitorEventZ_clone(const LDKCVec_MonitorEventZ *orig) {
	LDKCVec_MonitorEventZ ret = { .data = MALLOC(sizeof(LDKMonitorEvent) * orig->datalen, "LDKCVec_MonitorEventZ clone bytes"), .datalen = orig->datalen };
	for (size_t i = 0; i < ret.datalen; i++) {
		ret.data[i] = MonitorEvent_clone(&orig->data[i]);
	}
	return ret;
}
static jclass LDKCOption_C2Tuple_usizeTransactionZZ_Some_class = NULL;
static jmethodID LDKCOption_C2Tuple_usizeTransactionZZ_Some_meth = NULL;
static jclass LDKCOption_C2Tuple_usizeTransactionZZ_None_class = NULL;
static jmethodID LDKCOption_C2Tuple_usizeTransactionZZ_None_meth = NULL;
JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_00024LDKCOption_1C2Tuple_1usizeTransactionZZ_init (JNIEnv *env, jclass clz) {
	LDKCOption_C2Tuple_usizeTransactionZZ_Some_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKCOption_C2Tuple_usizeTransactionZZ$Some;"));
	CHECK(LDKCOption_C2Tuple_usizeTransactionZZ_Some_class != NULL);
	LDKCOption_C2Tuple_usizeTransactionZZ_Some_meth = (*env)->GetMethodID(env, LDKCOption_C2Tuple_usizeTransactionZZ_Some_class, "<init>", "(J)V");
	CHECK(LDKCOption_C2Tuple_usizeTransactionZZ_Some_meth != NULL);
	LDKCOption_C2Tuple_usizeTransactionZZ_None_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKCOption_C2Tuple_usizeTransactionZZ$None;"));
	CHECK(LDKCOption_C2Tuple_usizeTransactionZZ_None_class != NULL);
	LDKCOption_C2Tuple_usizeTransactionZZ_None_meth = (*env)->GetMethodID(env, LDKCOption_C2Tuple_usizeTransactionZZ_None_class, "<init>", "()V");
	CHECK(LDKCOption_C2Tuple_usizeTransactionZZ_None_meth != NULL);
}
JNIEXPORT jobject JNICALL Java_org_ldk_impl_bindings_LDKCOption_1C2Tuple_1usizeTransactionZZ_1ref_1from_1ptr(JNIEnv *env, jclass clz, int64_t ptr) {
	LDKCOption_C2Tuple_usizeTransactionZZ *obj = (LDKCOption_C2Tuple_usizeTransactionZZ*)(ptr & ~1);
	switch(obj->tag) {
		case LDKCOption_C2Tuple_usizeTransactionZZ_Some: {
			LDKC2Tuple_usizeTransactionZ* some_conv = MALLOC(sizeof(LDKC2Tuple_usizeTransactionZ), "LDKC2Tuple_usizeTransactionZ");
			*some_conv = obj->some;
			*some_conv = C2Tuple_usizeTransactionZ_clone(some_conv);
			return (*env)->NewObject(env, LDKCOption_C2Tuple_usizeTransactionZZ_Some_class, LDKCOption_C2Tuple_usizeTransactionZZ_Some_meth, ((uint64_t)some_conv));
		}
		case LDKCOption_C2Tuple_usizeTransactionZZ_None: {
			return (*env)->NewObject(env, LDKCOption_C2Tuple_usizeTransactionZZ_None_class, LDKCOption_C2Tuple_usizeTransactionZZ_None_meth);
		}
		default: abort();
	}
}
static jclass LDKNetworkUpdate_ChannelUpdateMessage_class = NULL;
static jmethodID LDKNetworkUpdate_ChannelUpdateMessage_meth = NULL;
static jclass LDKNetworkUpdate_ChannelClosed_class = NULL;
static jmethodID LDKNetworkUpdate_ChannelClosed_meth = NULL;
static jclass LDKNetworkUpdate_NodeFailure_class = NULL;
static jmethodID LDKNetworkUpdate_NodeFailure_meth = NULL;
JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_00024LDKNetworkUpdate_init (JNIEnv *env, jclass clz) {
	LDKNetworkUpdate_ChannelUpdateMessage_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKNetworkUpdate$ChannelUpdateMessage;"));
	CHECK(LDKNetworkUpdate_ChannelUpdateMessage_class != NULL);
	LDKNetworkUpdate_ChannelUpdateMessage_meth = (*env)->GetMethodID(env, LDKNetworkUpdate_ChannelUpdateMessage_class, "<init>", "(J)V");
	CHECK(LDKNetworkUpdate_ChannelUpdateMessage_meth != NULL);
	LDKNetworkUpdate_ChannelClosed_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKNetworkUpdate$ChannelClosed;"));
	CHECK(LDKNetworkUpdate_ChannelClosed_class != NULL);
	LDKNetworkUpdate_ChannelClosed_meth = (*env)->GetMethodID(env, LDKNetworkUpdate_ChannelClosed_class, "<init>", "(JZ)V");
	CHECK(LDKNetworkUpdate_ChannelClosed_meth != NULL);
	LDKNetworkUpdate_NodeFailure_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKNetworkUpdate$NodeFailure;"));
	CHECK(LDKNetworkUpdate_NodeFailure_class != NULL);
	LDKNetworkUpdate_NodeFailure_meth = (*env)->GetMethodID(env, LDKNetworkUpdate_NodeFailure_class, "<init>", "([BZ)V");
	CHECK(LDKNetworkUpdate_NodeFailure_meth != NULL);
}
JNIEXPORT jobject JNICALL Java_org_ldk_impl_bindings_LDKNetworkUpdate_1ref_1from_1ptr(JNIEnv *env, jclass clz, int64_t ptr) {
	LDKNetworkUpdate *obj = (LDKNetworkUpdate*)(ptr & ~1);
	switch(obj->tag) {
		case LDKNetworkUpdate_ChannelUpdateMessage: {
			LDKChannelUpdate msg_var = obj->channel_update_message.msg;
			uint64_t msg_ref = 0;
			CHECK((((uint64_t)msg_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
			CHECK((((uint64_t)&msg_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
			msg_ref = (uint64_t)msg_var.inner & ~1;
			return (*env)->NewObject(env, LDKNetworkUpdate_ChannelUpdateMessage_class, LDKNetworkUpdate_ChannelUpdateMessage_meth, msg_ref);
		}
		case LDKNetworkUpdate_ChannelClosed: {
			return (*env)->NewObject(env, LDKNetworkUpdate_ChannelClosed_class, LDKNetworkUpdate_ChannelClosed_meth, obj->channel_closed.short_channel_id, obj->channel_closed.is_permanent);
		}
		case LDKNetworkUpdate_NodeFailure: {
			int8_tArray node_id_arr = (*env)->NewByteArray(env, 33);
			(*env)->SetByteArrayRegion(env, node_id_arr, 0, 33, obj->node_failure.node_id.compressed_form);
			return (*env)->NewObject(env, LDKNetworkUpdate_NodeFailure_class, LDKNetworkUpdate_NodeFailure_meth, node_id_arr, obj->node_failure.is_permanent);
		}
		default: abort();
	}
}
static jclass LDKCOption_NetworkUpdateZ_Some_class = NULL;
static jmethodID LDKCOption_NetworkUpdateZ_Some_meth = NULL;
static jclass LDKCOption_NetworkUpdateZ_None_class = NULL;
static jmethodID LDKCOption_NetworkUpdateZ_None_meth = NULL;
JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_00024LDKCOption_1NetworkUpdateZ_init (JNIEnv *env, jclass clz) {
	LDKCOption_NetworkUpdateZ_Some_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKCOption_NetworkUpdateZ$Some;"));
	CHECK(LDKCOption_NetworkUpdateZ_Some_class != NULL);
	LDKCOption_NetworkUpdateZ_Some_meth = (*env)->GetMethodID(env, LDKCOption_NetworkUpdateZ_Some_class, "<init>", "(J)V");
	CHECK(LDKCOption_NetworkUpdateZ_Some_meth != NULL);
	LDKCOption_NetworkUpdateZ_None_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKCOption_NetworkUpdateZ$None;"));
	CHECK(LDKCOption_NetworkUpdateZ_None_class != NULL);
	LDKCOption_NetworkUpdateZ_None_meth = (*env)->GetMethodID(env, LDKCOption_NetworkUpdateZ_None_class, "<init>", "()V");
	CHECK(LDKCOption_NetworkUpdateZ_None_meth != NULL);
}
JNIEXPORT jobject JNICALL Java_org_ldk_impl_bindings_LDKCOption_1NetworkUpdateZ_1ref_1from_1ptr(JNIEnv *env, jclass clz, int64_t ptr) {
	LDKCOption_NetworkUpdateZ *obj = (LDKCOption_NetworkUpdateZ*)(ptr & ~1);
	switch(obj->tag) {
		case LDKCOption_NetworkUpdateZ_Some: {
			uint64_t some_ref = ((uint64_t)&obj->some) | 1;
			return (*env)->NewObject(env, LDKCOption_NetworkUpdateZ_Some_class, LDKCOption_NetworkUpdateZ_Some_meth, some_ref);
		}
		case LDKCOption_NetworkUpdateZ_None: {
			return (*env)->NewObject(env, LDKCOption_NetworkUpdateZ_None_class, LDKCOption_NetworkUpdateZ_None_meth);
		}
		default: abort();
	}
}
static jclass LDKSpendableOutputDescriptor_StaticOutput_class = NULL;
static jmethodID LDKSpendableOutputDescriptor_StaticOutput_meth = NULL;
static jclass LDKSpendableOutputDescriptor_DelayedPaymentOutput_class = NULL;
static jmethodID LDKSpendableOutputDescriptor_DelayedPaymentOutput_meth = NULL;
static jclass LDKSpendableOutputDescriptor_StaticPaymentOutput_class = NULL;
static jmethodID LDKSpendableOutputDescriptor_StaticPaymentOutput_meth = NULL;
JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_00024LDKSpendableOutputDescriptor_init (JNIEnv *env, jclass clz) {
	LDKSpendableOutputDescriptor_StaticOutput_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKSpendableOutputDescriptor$StaticOutput;"));
	CHECK(LDKSpendableOutputDescriptor_StaticOutput_class != NULL);
	LDKSpendableOutputDescriptor_StaticOutput_meth = (*env)->GetMethodID(env, LDKSpendableOutputDescriptor_StaticOutput_class, "<init>", "(JJ)V");
	CHECK(LDKSpendableOutputDescriptor_StaticOutput_meth != NULL);
	LDKSpendableOutputDescriptor_DelayedPaymentOutput_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKSpendableOutputDescriptor$DelayedPaymentOutput;"));
	CHECK(LDKSpendableOutputDescriptor_DelayedPaymentOutput_class != NULL);
	LDKSpendableOutputDescriptor_DelayedPaymentOutput_meth = (*env)->GetMethodID(env, LDKSpendableOutputDescriptor_DelayedPaymentOutput_class, "<init>", "(J)V");
	CHECK(LDKSpendableOutputDescriptor_DelayedPaymentOutput_meth != NULL);
	LDKSpendableOutputDescriptor_StaticPaymentOutput_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKSpendableOutputDescriptor$StaticPaymentOutput;"));
	CHECK(LDKSpendableOutputDescriptor_StaticPaymentOutput_class != NULL);
	LDKSpendableOutputDescriptor_StaticPaymentOutput_meth = (*env)->GetMethodID(env, LDKSpendableOutputDescriptor_StaticPaymentOutput_class, "<init>", "(J)V");
	CHECK(LDKSpendableOutputDescriptor_StaticPaymentOutput_meth != NULL);
}
JNIEXPORT jobject JNICALL Java_org_ldk_impl_bindings_LDKSpendableOutputDescriptor_1ref_1from_1ptr(JNIEnv *env, jclass clz, int64_t ptr) {
	LDKSpendableOutputDescriptor *obj = (LDKSpendableOutputDescriptor*)(ptr & ~1);
	switch(obj->tag) {
		case LDKSpendableOutputDescriptor_StaticOutput: {
			LDKOutPoint outpoint_var = obj->static_output.outpoint;
			uint64_t outpoint_ref = 0;
			CHECK((((uint64_t)outpoint_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
			CHECK((((uint64_t)&outpoint_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
			outpoint_ref = (uint64_t)outpoint_var.inner & ~1;
			uint64_t output_ref = ((uint64_t)&obj->static_output.output) | 1;
			return (*env)->NewObject(env, LDKSpendableOutputDescriptor_StaticOutput_class, LDKSpendableOutputDescriptor_StaticOutput_meth, outpoint_ref, (uint64_t)output_ref);
		}
		case LDKSpendableOutputDescriptor_DelayedPaymentOutput: {
			LDKDelayedPaymentOutputDescriptor delayed_payment_output_var = obj->delayed_payment_output;
			uint64_t delayed_payment_output_ref = 0;
			CHECK((((uint64_t)delayed_payment_output_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
			CHECK((((uint64_t)&delayed_payment_output_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
			delayed_payment_output_ref = (uint64_t)delayed_payment_output_var.inner & ~1;
			return (*env)->NewObject(env, LDKSpendableOutputDescriptor_DelayedPaymentOutput_class, LDKSpendableOutputDescriptor_DelayedPaymentOutput_meth, delayed_payment_output_ref);
		}
		case LDKSpendableOutputDescriptor_StaticPaymentOutput: {
			LDKStaticPaymentOutputDescriptor static_payment_output_var = obj->static_payment_output;
			uint64_t static_payment_output_ref = 0;
			CHECK((((uint64_t)static_payment_output_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
			CHECK((((uint64_t)&static_payment_output_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
			static_payment_output_ref = (uint64_t)static_payment_output_var.inner & ~1;
			return (*env)->NewObject(env, LDKSpendableOutputDescriptor_StaticPaymentOutput_class, LDKSpendableOutputDescriptor_StaticPaymentOutput_meth, static_payment_output_ref);
		}
		default: abort();
	}
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCVec_1SpendableOutputDescriptorZ_1new(JNIEnv *env, jclass clz, int64_tArray elems) {
	LDKCVec_SpendableOutputDescriptorZ *ret = MALLOC(sizeof(LDKCVec_SpendableOutputDescriptorZ), "LDKCVec_SpendableOutputDescriptorZ");
	ret->datalen = (*env)->GetArrayLength(env, elems);
	if (ret->datalen == 0) {
		ret->data = NULL;
	} else {
		ret->data = MALLOC(sizeof(LDKSpendableOutputDescriptor) * ret->datalen, "LDKCVec_SpendableOutputDescriptorZ Data");
		int64_t *java_elems = (*env)->GetPrimitiveArrayCritical(env, elems, NULL);
		for (size_t i = 0; i < ret->datalen; i++) {
			int64_t arr_elem = java_elems[i];
			void* arr_elem_ptr = (void*)(((uint64_t)arr_elem) & ~1);
			CHECK_ACCESS(arr_elem_ptr);
			LDKSpendableOutputDescriptor arr_elem_conv = *(LDKSpendableOutputDescriptor*)(arr_elem_ptr);
			arr_elem_conv = SpendableOutputDescriptor_clone((LDKSpendableOutputDescriptor*)(((uint64_t)arr_elem) & ~1));
			ret->data[i] = arr_elem_conv;
		}
		(*env)->ReleasePrimitiveArrayCritical(env, elems, java_elems, 0);
	}
	return (uint64_t)ret;
}
static inline LDKCVec_SpendableOutputDescriptorZ CVec_SpendableOutputDescriptorZ_clone(const LDKCVec_SpendableOutputDescriptorZ *orig) {
	LDKCVec_SpendableOutputDescriptorZ ret = { .data = MALLOC(sizeof(LDKSpendableOutputDescriptor) * orig->datalen, "LDKCVec_SpendableOutputDescriptorZ clone bytes"), .datalen = orig->datalen };
	for (size_t i = 0; i < ret.datalen; i++) {
		ret.data[i] = SpendableOutputDescriptor_clone(&orig->data[i]);
	}
	return ret;
}
static jclass LDKErrorAction_DisconnectPeer_class = NULL;
static jmethodID LDKErrorAction_DisconnectPeer_meth = NULL;
static jclass LDKErrorAction_IgnoreError_class = NULL;
static jmethodID LDKErrorAction_IgnoreError_meth = NULL;
static jclass LDKErrorAction_IgnoreAndLog_class = NULL;
static jmethodID LDKErrorAction_IgnoreAndLog_meth = NULL;
static jclass LDKErrorAction_SendErrorMessage_class = NULL;
static jmethodID LDKErrorAction_SendErrorMessage_meth = NULL;
JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_00024LDKErrorAction_init (JNIEnv *env, jclass clz) {
	LDKErrorAction_DisconnectPeer_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKErrorAction$DisconnectPeer;"));
	CHECK(LDKErrorAction_DisconnectPeer_class != NULL);
	LDKErrorAction_DisconnectPeer_meth = (*env)->GetMethodID(env, LDKErrorAction_DisconnectPeer_class, "<init>", "(J)V");
	CHECK(LDKErrorAction_DisconnectPeer_meth != NULL);
	LDKErrorAction_IgnoreError_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKErrorAction$IgnoreError;"));
	CHECK(LDKErrorAction_IgnoreError_class != NULL);
	LDKErrorAction_IgnoreError_meth = (*env)->GetMethodID(env, LDKErrorAction_IgnoreError_class, "<init>", "()V");
	CHECK(LDKErrorAction_IgnoreError_meth != NULL);
	LDKErrorAction_IgnoreAndLog_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKErrorAction$IgnoreAndLog;"));
	CHECK(LDKErrorAction_IgnoreAndLog_class != NULL);
	LDKErrorAction_IgnoreAndLog_meth = (*env)->GetMethodID(env, LDKErrorAction_IgnoreAndLog_class, "<init>", "(Lorg/ldk/enums/Level;)V");
	CHECK(LDKErrorAction_IgnoreAndLog_meth != NULL);
	LDKErrorAction_SendErrorMessage_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKErrorAction$SendErrorMessage;"));
	CHECK(LDKErrorAction_SendErrorMessage_class != NULL);
	LDKErrorAction_SendErrorMessage_meth = (*env)->GetMethodID(env, LDKErrorAction_SendErrorMessage_class, "<init>", "(J)V");
	CHECK(LDKErrorAction_SendErrorMessage_meth != NULL);
}
JNIEXPORT jobject JNICALL Java_org_ldk_impl_bindings_LDKErrorAction_1ref_1from_1ptr(JNIEnv *env, jclass clz, int64_t ptr) {
	LDKErrorAction *obj = (LDKErrorAction*)(ptr & ~1);
	switch(obj->tag) {
		case LDKErrorAction_DisconnectPeer: {
			LDKErrorMessage msg_var = obj->disconnect_peer.msg;
			uint64_t msg_ref = 0;
			CHECK((((uint64_t)msg_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
			CHECK((((uint64_t)&msg_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
			msg_ref = (uint64_t)msg_var.inner & ~1;
			return (*env)->NewObject(env, LDKErrorAction_DisconnectPeer_class, LDKErrorAction_DisconnectPeer_meth, msg_ref);
		}
		case LDKErrorAction_IgnoreError: {
			return (*env)->NewObject(env, LDKErrorAction_IgnoreError_class, LDKErrorAction_IgnoreError_meth);
		}
		case LDKErrorAction_IgnoreAndLog: {
			jclass ignore_and_log_conv = LDKLevel_to_java(env, obj->ignore_and_log);
			return (*env)->NewObject(env, LDKErrorAction_IgnoreAndLog_class, LDKErrorAction_IgnoreAndLog_meth, ignore_and_log_conv);
		}
		case LDKErrorAction_SendErrorMessage: {
			LDKErrorMessage msg_var = obj->send_error_message.msg;
			uint64_t msg_ref = 0;
			CHECK((((uint64_t)msg_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
			CHECK((((uint64_t)&msg_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
			msg_ref = (uint64_t)msg_var.inner & ~1;
			return (*env)->NewObject(env, LDKErrorAction_SendErrorMessage_class, LDKErrorAction_SendErrorMessage_meth, msg_ref);
		}
		default: abort();
	}
}
static jclass LDKMessageSendEvent_SendAcceptChannel_class = NULL;
static jmethodID LDKMessageSendEvent_SendAcceptChannel_meth = NULL;
static jclass LDKMessageSendEvent_SendOpenChannel_class = NULL;
static jmethodID LDKMessageSendEvent_SendOpenChannel_meth = NULL;
static jclass LDKMessageSendEvent_SendFundingCreated_class = NULL;
static jmethodID LDKMessageSendEvent_SendFundingCreated_meth = NULL;
static jclass LDKMessageSendEvent_SendFundingSigned_class = NULL;
static jmethodID LDKMessageSendEvent_SendFundingSigned_meth = NULL;
static jclass LDKMessageSendEvent_SendFundingLocked_class = NULL;
static jmethodID LDKMessageSendEvent_SendFundingLocked_meth = NULL;
static jclass LDKMessageSendEvent_SendAnnouncementSignatures_class = NULL;
static jmethodID LDKMessageSendEvent_SendAnnouncementSignatures_meth = NULL;
static jclass LDKMessageSendEvent_UpdateHTLCs_class = NULL;
static jmethodID LDKMessageSendEvent_UpdateHTLCs_meth = NULL;
static jclass LDKMessageSendEvent_SendRevokeAndACK_class = NULL;
static jmethodID LDKMessageSendEvent_SendRevokeAndACK_meth = NULL;
static jclass LDKMessageSendEvent_SendClosingSigned_class = NULL;
static jmethodID LDKMessageSendEvent_SendClosingSigned_meth = NULL;
static jclass LDKMessageSendEvent_SendShutdown_class = NULL;
static jmethodID LDKMessageSendEvent_SendShutdown_meth = NULL;
static jclass LDKMessageSendEvent_SendChannelReestablish_class = NULL;
static jmethodID LDKMessageSendEvent_SendChannelReestablish_meth = NULL;
static jclass LDKMessageSendEvent_BroadcastChannelAnnouncement_class = NULL;
static jmethodID LDKMessageSendEvent_BroadcastChannelAnnouncement_meth = NULL;
static jclass LDKMessageSendEvent_BroadcastNodeAnnouncement_class = NULL;
static jmethodID LDKMessageSendEvent_BroadcastNodeAnnouncement_meth = NULL;
static jclass LDKMessageSendEvent_BroadcastChannelUpdate_class = NULL;
static jmethodID LDKMessageSendEvent_BroadcastChannelUpdate_meth = NULL;
static jclass LDKMessageSendEvent_SendChannelUpdate_class = NULL;
static jmethodID LDKMessageSendEvent_SendChannelUpdate_meth = NULL;
static jclass LDKMessageSendEvent_HandleError_class = NULL;
static jmethodID LDKMessageSendEvent_HandleError_meth = NULL;
static jclass LDKMessageSendEvent_SendChannelRangeQuery_class = NULL;
static jmethodID LDKMessageSendEvent_SendChannelRangeQuery_meth = NULL;
static jclass LDKMessageSendEvent_SendShortIdsQuery_class = NULL;
static jmethodID LDKMessageSendEvent_SendShortIdsQuery_meth = NULL;
static jclass LDKMessageSendEvent_SendReplyChannelRange_class = NULL;
static jmethodID LDKMessageSendEvent_SendReplyChannelRange_meth = NULL;
JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_00024LDKMessageSendEvent_init (JNIEnv *env, jclass clz) {
	LDKMessageSendEvent_SendAcceptChannel_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKMessageSendEvent$SendAcceptChannel;"));
	CHECK(LDKMessageSendEvent_SendAcceptChannel_class != NULL);
	LDKMessageSendEvent_SendAcceptChannel_meth = (*env)->GetMethodID(env, LDKMessageSendEvent_SendAcceptChannel_class, "<init>", "([BJ)V");
	CHECK(LDKMessageSendEvent_SendAcceptChannel_meth != NULL);
	LDKMessageSendEvent_SendOpenChannel_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKMessageSendEvent$SendOpenChannel;"));
	CHECK(LDKMessageSendEvent_SendOpenChannel_class != NULL);
	LDKMessageSendEvent_SendOpenChannel_meth = (*env)->GetMethodID(env, LDKMessageSendEvent_SendOpenChannel_class, "<init>", "([BJ)V");
	CHECK(LDKMessageSendEvent_SendOpenChannel_meth != NULL);
	LDKMessageSendEvent_SendFundingCreated_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKMessageSendEvent$SendFundingCreated;"));
	CHECK(LDKMessageSendEvent_SendFundingCreated_class != NULL);
	LDKMessageSendEvent_SendFundingCreated_meth = (*env)->GetMethodID(env, LDKMessageSendEvent_SendFundingCreated_class, "<init>", "([BJ)V");
	CHECK(LDKMessageSendEvent_SendFundingCreated_meth != NULL);
	LDKMessageSendEvent_SendFundingSigned_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKMessageSendEvent$SendFundingSigned;"));
	CHECK(LDKMessageSendEvent_SendFundingSigned_class != NULL);
	LDKMessageSendEvent_SendFundingSigned_meth = (*env)->GetMethodID(env, LDKMessageSendEvent_SendFundingSigned_class, "<init>", "([BJ)V");
	CHECK(LDKMessageSendEvent_SendFundingSigned_meth != NULL);
	LDKMessageSendEvent_SendFundingLocked_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKMessageSendEvent$SendFundingLocked;"));
	CHECK(LDKMessageSendEvent_SendFundingLocked_class != NULL);
	LDKMessageSendEvent_SendFundingLocked_meth = (*env)->GetMethodID(env, LDKMessageSendEvent_SendFundingLocked_class, "<init>", "([BJ)V");
	CHECK(LDKMessageSendEvent_SendFundingLocked_meth != NULL);
	LDKMessageSendEvent_SendAnnouncementSignatures_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKMessageSendEvent$SendAnnouncementSignatures;"));
	CHECK(LDKMessageSendEvent_SendAnnouncementSignatures_class != NULL);
	LDKMessageSendEvent_SendAnnouncementSignatures_meth = (*env)->GetMethodID(env, LDKMessageSendEvent_SendAnnouncementSignatures_class, "<init>", "([BJ)V");
	CHECK(LDKMessageSendEvent_SendAnnouncementSignatures_meth != NULL);
	LDKMessageSendEvent_UpdateHTLCs_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKMessageSendEvent$UpdateHTLCs;"));
	CHECK(LDKMessageSendEvent_UpdateHTLCs_class != NULL);
	LDKMessageSendEvent_UpdateHTLCs_meth = (*env)->GetMethodID(env, LDKMessageSendEvent_UpdateHTLCs_class, "<init>", "([BJ)V");
	CHECK(LDKMessageSendEvent_UpdateHTLCs_meth != NULL);
	LDKMessageSendEvent_SendRevokeAndACK_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKMessageSendEvent$SendRevokeAndACK;"));
	CHECK(LDKMessageSendEvent_SendRevokeAndACK_class != NULL);
	LDKMessageSendEvent_SendRevokeAndACK_meth = (*env)->GetMethodID(env, LDKMessageSendEvent_SendRevokeAndACK_class, "<init>", "([BJ)V");
	CHECK(LDKMessageSendEvent_SendRevokeAndACK_meth != NULL);
	LDKMessageSendEvent_SendClosingSigned_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKMessageSendEvent$SendClosingSigned;"));
	CHECK(LDKMessageSendEvent_SendClosingSigned_class != NULL);
	LDKMessageSendEvent_SendClosingSigned_meth = (*env)->GetMethodID(env, LDKMessageSendEvent_SendClosingSigned_class, "<init>", "([BJ)V");
	CHECK(LDKMessageSendEvent_SendClosingSigned_meth != NULL);
	LDKMessageSendEvent_SendShutdown_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKMessageSendEvent$SendShutdown;"));
	CHECK(LDKMessageSendEvent_SendShutdown_class != NULL);
	LDKMessageSendEvent_SendShutdown_meth = (*env)->GetMethodID(env, LDKMessageSendEvent_SendShutdown_class, "<init>", "([BJ)V");
	CHECK(LDKMessageSendEvent_SendShutdown_meth != NULL);
	LDKMessageSendEvent_SendChannelReestablish_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKMessageSendEvent$SendChannelReestablish;"));
	CHECK(LDKMessageSendEvent_SendChannelReestablish_class != NULL);
	LDKMessageSendEvent_SendChannelReestablish_meth = (*env)->GetMethodID(env, LDKMessageSendEvent_SendChannelReestablish_class, "<init>", "([BJ)V");
	CHECK(LDKMessageSendEvent_SendChannelReestablish_meth != NULL);
	LDKMessageSendEvent_BroadcastChannelAnnouncement_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKMessageSendEvent$BroadcastChannelAnnouncement;"));
	CHECK(LDKMessageSendEvent_BroadcastChannelAnnouncement_class != NULL);
	LDKMessageSendEvent_BroadcastChannelAnnouncement_meth = (*env)->GetMethodID(env, LDKMessageSendEvent_BroadcastChannelAnnouncement_class, "<init>", "(JJ)V");
	CHECK(LDKMessageSendEvent_BroadcastChannelAnnouncement_meth != NULL);
	LDKMessageSendEvent_BroadcastNodeAnnouncement_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKMessageSendEvent$BroadcastNodeAnnouncement;"));
	CHECK(LDKMessageSendEvent_BroadcastNodeAnnouncement_class != NULL);
	LDKMessageSendEvent_BroadcastNodeAnnouncement_meth = (*env)->GetMethodID(env, LDKMessageSendEvent_BroadcastNodeAnnouncement_class, "<init>", "(J)V");
	CHECK(LDKMessageSendEvent_BroadcastNodeAnnouncement_meth != NULL);
	LDKMessageSendEvent_BroadcastChannelUpdate_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKMessageSendEvent$BroadcastChannelUpdate;"));
	CHECK(LDKMessageSendEvent_BroadcastChannelUpdate_class != NULL);
	LDKMessageSendEvent_BroadcastChannelUpdate_meth = (*env)->GetMethodID(env, LDKMessageSendEvent_BroadcastChannelUpdate_class, "<init>", "(J)V");
	CHECK(LDKMessageSendEvent_BroadcastChannelUpdate_meth != NULL);
	LDKMessageSendEvent_SendChannelUpdate_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKMessageSendEvent$SendChannelUpdate;"));
	CHECK(LDKMessageSendEvent_SendChannelUpdate_class != NULL);
	LDKMessageSendEvent_SendChannelUpdate_meth = (*env)->GetMethodID(env, LDKMessageSendEvent_SendChannelUpdate_class, "<init>", "([BJ)V");
	CHECK(LDKMessageSendEvent_SendChannelUpdate_meth != NULL);
	LDKMessageSendEvent_HandleError_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKMessageSendEvent$HandleError;"));
	CHECK(LDKMessageSendEvent_HandleError_class != NULL);
	LDKMessageSendEvent_HandleError_meth = (*env)->GetMethodID(env, LDKMessageSendEvent_HandleError_class, "<init>", "([BJ)V");
	CHECK(LDKMessageSendEvent_HandleError_meth != NULL);
	LDKMessageSendEvent_SendChannelRangeQuery_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKMessageSendEvent$SendChannelRangeQuery;"));
	CHECK(LDKMessageSendEvent_SendChannelRangeQuery_class != NULL);
	LDKMessageSendEvent_SendChannelRangeQuery_meth = (*env)->GetMethodID(env, LDKMessageSendEvent_SendChannelRangeQuery_class, "<init>", "([BJ)V");
	CHECK(LDKMessageSendEvent_SendChannelRangeQuery_meth != NULL);
	LDKMessageSendEvent_SendShortIdsQuery_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKMessageSendEvent$SendShortIdsQuery;"));
	CHECK(LDKMessageSendEvent_SendShortIdsQuery_class != NULL);
	LDKMessageSendEvent_SendShortIdsQuery_meth = (*env)->GetMethodID(env, LDKMessageSendEvent_SendShortIdsQuery_class, "<init>", "([BJ)V");
	CHECK(LDKMessageSendEvent_SendShortIdsQuery_meth != NULL);
	LDKMessageSendEvent_SendReplyChannelRange_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKMessageSendEvent$SendReplyChannelRange;"));
	CHECK(LDKMessageSendEvent_SendReplyChannelRange_class != NULL);
	LDKMessageSendEvent_SendReplyChannelRange_meth = (*env)->GetMethodID(env, LDKMessageSendEvent_SendReplyChannelRange_class, "<init>", "([BJ)V");
	CHECK(LDKMessageSendEvent_SendReplyChannelRange_meth != NULL);
}
JNIEXPORT jobject JNICALL Java_org_ldk_impl_bindings_LDKMessageSendEvent_1ref_1from_1ptr(JNIEnv *env, jclass clz, int64_t ptr) {
	LDKMessageSendEvent *obj = (LDKMessageSendEvent*)(ptr & ~1);
	switch(obj->tag) {
		case LDKMessageSendEvent_SendAcceptChannel: {
			int8_tArray node_id_arr = (*env)->NewByteArray(env, 33);
			(*env)->SetByteArrayRegion(env, node_id_arr, 0, 33, obj->send_accept_channel.node_id.compressed_form);
			LDKAcceptChannel msg_var = obj->send_accept_channel.msg;
			uint64_t msg_ref = 0;
			CHECK((((uint64_t)msg_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
			CHECK((((uint64_t)&msg_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
			msg_ref = (uint64_t)msg_var.inner & ~1;
			return (*env)->NewObject(env, LDKMessageSendEvent_SendAcceptChannel_class, LDKMessageSendEvent_SendAcceptChannel_meth, node_id_arr, msg_ref);
		}
		case LDKMessageSendEvent_SendOpenChannel: {
			int8_tArray node_id_arr = (*env)->NewByteArray(env, 33);
			(*env)->SetByteArrayRegion(env, node_id_arr, 0, 33, obj->send_open_channel.node_id.compressed_form);
			LDKOpenChannel msg_var = obj->send_open_channel.msg;
			uint64_t msg_ref = 0;
			CHECK((((uint64_t)msg_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
			CHECK((((uint64_t)&msg_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
			msg_ref = (uint64_t)msg_var.inner & ~1;
			return (*env)->NewObject(env, LDKMessageSendEvent_SendOpenChannel_class, LDKMessageSendEvent_SendOpenChannel_meth, node_id_arr, msg_ref);
		}
		case LDKMessageSendEvent_SendFundingCreated: {
			int8_tArray node_id_arr = (*env)->NewByteArray(env, 33);
			(*env)->SetByteArrayRegion(env, node_id_arr, 0, 33, obj->send_funding_created.node_id.compressed_form);
			LDKFundingCreated msg_var = obj->send_funding_created.msg;
			uint64_t msg_ref = 0;
			CHECK((((uint64_t)msg_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
			CHECK((((uint64_t)&msg_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
			msg_ref = (uint64_t)msg_var.inner & ~1;
			return (*env)->NewObject(env, LDKMessageSendEvent_SendFundingCreated_class, LDKMessageSendEvent_SendFundingCreated_meth, node_id_arr, msg_ref);
		}
		case LDKMessageSendEvent_SendFundingSigned: {
			int8_tArray node_id_arr = (*env)->NewByteArray(env, 33);
			(*env)->SetByteArrayRegion(env, node_id_arr, 0, 33, obj->send_funding_signed.node_id.compressed_form);
			LDKFundingSigned msg_var = obj->send_funding_signed.msg;
			uint64_t msg_ref = 0;
			CHECK((((uint64_t)msg_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
			CHECK((((uint64_t)&msg_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
			msg_ref = (uint64_t)msg_var.inner & ~1;
			return (*env)->NewObject(env, LDKMessageSendEvent_SendFundingSigned_class, LDKMessageSendEvent_SendFundingSigned_meth, node_id_arr, msg_ref);
		}
		case LDKMessageSendEvent_SendFundingLocked: {
			int8_tArray node_id_arr = (*env)->NewByteArray(env, 33);
			(*env)->SetByteArrayRegion(env, node_id_arr, 0, 33, obj->send_funding_locked.node_id.compressed_form);
			LDKFundingLocked msg_var = obj->send_funding_locked.msg;
			uint64_t msg_ref = 0;
			CHECK((((uint64_t)msg_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
			CHECK((((uint64_t)&msg_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
			msg_ref = (uint64_t)msg_var.inner & ~1;
			return (*env)->NewObject(env, LDKMessageSendEvent_SendFundingLocked_class, LDKMessageSendEvent_SendFundingLocked_meth, node_id_arr, msg_ref);
		}
		case LDKMessageSendEvent_SendAnnouncementSignatures: {
			int8_tArray node_id_arr = (*env)->NewByteArray(env, 33);
			(*env)->SetByteArrayRegion(env, node_id_arr, 0, 33, obj->send_announcement_signatures.node_id.compressed_form);
			LDKAnnouncementSignatures msg_var = obj->send_announcement_signatures.msg;
			uint64_t msg_ref = 0;
			CHECK((((uint64_t)msg_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
			CHECK((((uint64_t)&msg_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
			msg_ref = (uint64_t)msg_var.inner & ~1;
			return (*env)->NewObject(env, LDKMessageSendEvent_SendAnnouncementSignatures_class, LDKMessageSendEvent_SendAnnouncementSignatures_meth, node_id_arr, msg_ref);
		}
		case LDKMessageSendEvent_UpdateHTLCs: {
			int8_tArray node_id_arr = (*env)->NewByteArray(env, 33);
			(*env)->SetByteArrayRegion(env, node_id_arr, 0, 33, obj->update_htl_cs.node_id.compressed_form);
			LDKCommitmentUpdate updates_var = obj->update_htl_cs.updates;
			uint64_t updates_ref = 0;
			CHECK((((uint64_t)updates_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
			CHECK((((uint64_t)&updates_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
			updates_ref = (uint64_t)updates_var.inner & ~1;
			return (*env)->NewObject(env, LDKMessageSendEvent_UpdateHTLCs_class, LDKMessageSendEvent_UpdateHTLCs_meth, node_id_arr, updates_ref);
		}
		case LDKMessageSendEvent_SendRevokeAndACK: {
			int8_tArray node_id_arr = (*env)->NewByteArray(env, 33);
			(*env)->SetByteArrayRegion(env, node_id_arr, 0, 33, obj->send_revoke_and_ack.node_id.compressed_form);
			LDKRevokeAndACK msg_var = obj->send_revoke_and_ack.msg;
			uint64_t msg_ref = 0;
			CHECK((((uint64_t)msg_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
			CHECK((((uint64_t)&msg_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
			msg_ref = (uint64_t)msg_var.inner & ~1;
			return (*env)->NewObject(env, LDKMessageSendEvent_SendRevokeAndACK_class, LDKMessageSendEvent_SendRevokeAndACK_meth, node_id_arr, msg_ref);
		}
		case LDKMessageSendEvent_SendClosingSigned: {
			int8_tArray node_id_arr = (*env)->NewByteArray(env, 33);
			(*env)->SetByteArrayRegion(env, node_id_arr, 0, 33, obj->send_closing_signed.node_id.compressed_form);
			LDKClosingSigned msg_var = obj->send_closing_signed.msg;
			uint64_t msg_ref = 0;
			CHECK((((uint64_t)msg_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
			CHECK((((uint64_t)&msg_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
			msg_ref = (uint64_t)msg_var.inner & ~1;
			return (*env)->NewObject(env, LDKMessageSendEvent_SendClosingSigned_class, LDKMessageSendEvent_SendClosingSigned_meth, node_id_arr, msg_ref);
		}
		case LDKMessageSendEvent_SendShutdown: {
			int8_tArray node_id_arr = (*env)->NewByteArray(env, 33);
			(*env)->SetByteArrayRegion(env, node_id_arr, 0, 33, obj->send_shutdown.node_id.compressed_form);
			LDKShutdown msg_var = obj->send_shutdown.msg;
			uint64_t msg_ref = 0;
			CHECK((((uint64_t)msg_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
			CHECK((((uint64_t)&msg_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
			msg_ref = (uint64_t)msg_var.inner & ~1;
			return (*env)->NewObject(env, LDKMessageSendEvent_SendShutdown_class, LDKMessageSendEvent_SendShutdown_meth, node_id_arr, msg_ref);
		}
		case LDKMessageSendEvent_SendChannelReestablish: {
			int8_tArray node_id_arr = (*env)->NewByteArray(env, 33);
			(*env)->SetByteArrayRegion(env, node_id_arr, 0, 33, obj->send_channel_reestablish.node_id.compressed_form);
			LDKChannelReestablish msg_var = obj->send_channel_reestablish.msg;
			uint64_t msg_ref = 0;
			CHECK((((uint64_t)msg_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
			CHECK((((uint64_t)&msg_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
			msg_ref = (uint64_t)msg_var.inner & ~1;
			return (*env)->NewObject(env, LDKMessageSendEvent_SendChannelReestablish_class, LDKMessageSendEvent_SendChannelReestablish_meth, node_id_arr, msg_ref);
		}
		case LDKMessageSendEvent_BroadcastChannelAnnouncement: {
			LDKChannelAnnouncement msg_var = obj->broadcast_channel_announcement.msg;
			uint64_t msg_ref = 0;
			CHECK((((uint64_t)msg_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
			CHECK((((uint64_t)&msg_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
			msg_ref = (uint64_t)msg_var.inner & ~1;
			LDKChannelUpdate update_msg_var = obj->broadcast_channel_announcement.update_msg;
			uint64_t update_msg_ref = 0;
			CHECK((((uint64_t)update_msg_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
			CHECK((((uint64_t)&update_msg_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
			update_msg_ref = (uint64_t)update_msg_var.inner & ~1;
			return (*env)->NewObject(env, LDKMessageSendEvent_BroadcastChannelAnnouncement_class, LDKMessageSendEvent_BroadcastChannelAnnouncement_meth, msg_ref, update_msg_ref);
		}
		case LDKMessageSendEvent_BroadcastNodeAnnouncement: {
			LDKNodeAnnouncement msg_var = obj->broadcast_node_announcement.msg;
			uint64_t msg_ref = 0;
			CHECK((((uint64_t)msg_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
			CHECK((((uint64_t)&msg_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
			msg_ref = (uint64_t)msg_var.inner & ~1;
			return (*env)->NewObject(env, LDKMessageSendEvent_BroadcastNodeAnnouncement_class, LDKMessageSendEvent_BroadcastNodeAnnouncement_meth, msg_ref);
		}
		case LDKMessageSendEvent_BroadcastChannelUpdate: {
			LDKChannelUpdate msg_var = obj->broadcast_channel_update.msg;
			uint64_t msg_ref = 0;
			CHECK((((uint64_t)msg_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
			CHECK((((uint64_t)&msg_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
			msg_ref = (uint64_t)msg_var.inner & ~1;
			return (*env)->NewObject(env, LDKMessageSendEvent_BroadcastChannelUpdate_class, LDKMessageSendEvent_BroadcastChannelUpdate_meth, msg_ref);
		}
		case LDKMessageSendEvent_SendChannelUpdate: {
			int8_tArray node_id_arr = (*env)->NewByteArray(env, 33);
			(*env)->SetByteArrayRegion(env, node_id_arr, 0, 33, obj->send_channel_update.node_id.compressed_form);
			LDKChannelUpdate msg_var = obj->send_channel_update.msg;
			uint64_t msg_ref = 0;
			CHECK((((uint64_t)msg_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
			CHECK((((uint64_t)&msg_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
			msg_ref = (uint64_t)msg_var.inner & ~1;
			return (*env)->NewObject(env, LDKMessageSendEvent_SendChannelUpdate_class, LDKMessageSendEvent_SendChannelUpdate_meth, node_id_arr, msg_ref);
		}
		case LDKMessageSendEvent_HandleError: {
			int8_tArray node_id_arr = (*env)->NewByteArray(env, 33);
			(*env)->SetByteArrayRegion(env, node_id_arr, 0, 33, obj->handle_error.node_id.compressed_form);
			uint64_t action_ref = ((uint64_t)&obj->handle_error.action) | 1;
			return (*env)->NewObject(env, LDKMessageSendEvent_HandleError_class, LDKMessageSendEvent_HandleError_meth, node_id_arr, action_ref);
		}
		case LDKMessageSendEvent_SendChannelRangeQuery: {
			int8_tArray node_id_arr = (*env)->NewByteArray(env, 33);
			(*env)->SetByteArrayRegion(env, node_id_arr, 0, 33, obj->send_channel_range_query.node_id.compressed_form);
			LDKQueryChannelRange msg_var = obj->send_channel_range_query.msg;
			uint64_t msg_ref = 0;
			CHECK((((uint64_t)msg_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
			CHECK((((uint64_t)&msg_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
			msg_ref = (uint64_t)msg_var.inner & ~1;
			return (*env)->NewObject(env, LDKMessageSendEvent_SendChannelRangeQuery_class, LDKMessageSendEvent_SendChannelRangeQuery_meth, node_id_arr, msg_ref);
		}
		case LDKMessageSendEvent_SendShortIdsQuery: {
			int8_tArray node_id_arr = (*env)->NewByteArray(env, 33);
			(*env)->SetByteArrayRegion(env, node_id_arr, 0, 33, obj->send_short_ids_query.node_id.compressed_form);
			LDKQueryShortChannelIds msg_var = obj->send_short_ids_query.msg;
			uint64_t msg_ref = 0;
			CHECK((((uint64_t)msg_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
			CHECK((((uint64_t)&msg_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
			msg_ref = (uint64_t)msg_var.inner & ~1;
			return (*env)->NewObject(env, LDKMessageSendEvent_SendShortIdsQuery_class, LDKMessageSendEvent_SendShortIdsQuery_meth, node_id_arr, msg_ref);
		}
		case LDKMessageSendEvent_SendReplyChannelRange: {
			int8_tArray node_id_arr = (*env)->NewByteArray(env, 33);
			(*env)->SetByteArrayRegion(env, node_id_arr, 0, 33, obj->send_reply_channel_range.node_id.compressed_form);
			LDKReplyChannelRange msg_var = obj->send_reply_channel_range.msg;
			uint64_t msg_ref = 0;
			CHECK((((uint64_t)msg_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
			CHECK((((uint64_t)&msg_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
			msg_ref = (uint64_t)msg_var.inner & ~1;
			return (*env)->NewObject(env, LDKMessageSendEvent_SendReplyChannelRange_class, LDKMessageSendEvent_SendReplyChannelRange_meth, node_id_arr, msg_ref);
		}
		default: abort();
	}
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCVec_1MessageSendEventZ_1new(JNIEnv *env, jclass clz, int64_tArray elems) {
	LDKCVec_MessageSendEventZ *ret = MALLOC(sizeof(LDKCVec_MessageSendEventZ), "LDKCVec_MessageSendEventZ");
	ret->datalen = (*env)->GetArrayLength(env, elems);
	if (ret->datalen == 0) {
		ret->data = NULL;
	} else {
		ret->data = MALLOC(sizeof(LDKMessageSendEvent) * ret->datalen, "LDKCVec_MessageSendEventZ Data");
		int64_t *java_elems = (*env)->GetPrimitiveArrayCritical(env, elems, NULL);
		for (size_t i = 0; i < ret->datalen; i++) {
			int64_t arr_elem = java_elems[i];
			void* arr_elem_ptr = (void*)(((uint64_t)arr_elem) & ~1);
			CHECK_ACCESS(arr_elem_ptr);
			LDKMessageSendEvent arr_elem_conv = *(LDKMessageSendEvent*)(arr_elem_ptr);
			arr_elem_conv = MessageSendEvent_clone((LDKMessageSendEvent*)(((uint64_t)arr_elem) & ~1));
			ret->data[i] = arr_elem_conv;
		}
		(*env)->ReleasePrimitiveArrayCritical(env, elems, java_elems, 0);
	}
	return (uint64_t)ret;
}
static inline LDKCVec_MessageSendEventZ CVec_MessageSendEventZ_clone(const LDKCVec_MessageSendEventZ *orig) {
	LDKCVec_MessageSendEventZ ret = { .data = MALLOC(sizeof(LDKMessageSendEvent) * orig->datalen, "LDKCVec_MessageSendEventZ clone bytes"), .datalen = orig->datalen };
	for (size_t i = 0; i < ret.datalen; i++) {
		ret.data[i] = MessageSendEvent_clone(&orig->data[i]);
	}
	return ret;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1InitFeaturesDecodeErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_InitFeaturesDecodeErrorZ*)arg)->result_ok;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1InitFeaturesDecodeErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_InitFeaturesDecodeErrorZ *val = (LDKCResult_InitFeaturesDecodeErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	LDKInitFeatures res_var = (*val->contents.result);
	uint64_t res_ref = 0;
	CHECK((((uint64_t)res_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&res_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	res_ref = (uint64_t)res_var.inner & ~1;
	return res_ref;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1InitFeaturesDecodeErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_InitFeaturesDecodeErrorZ *val = (LDKCResult_InitFeaturesDecodeErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	LDKDecodeError err_var = (*val->contents.err);
	uint64_t err_ref = 0;
	CHECK((((uint64_t)err_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&err_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	err_ref = (uint64_t)err_var.inner & ~1;
	return err_ref;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1NodeFeaturesDecodeErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_NodeFeaturesDecodeErrorZ*)arg)->result_ok;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1NodeFeaturesDecodeErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_NodeFeaturesDecodeErrorZ *val = (LDKCResult_NodeFeaturesDecodeErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	LDKNodeFeatures res_var = (*val->contents.result);
	uint64_t res_ref = 0;
	CHECK((((uint64_t)res_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&res_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	res_ref = (uint64_t)res_var.inner & ~1;
	return res_ref;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1NodeFeaturesDecodeErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_NodeFeaturesDecodeErrorZ *val = (LDKCResult_NodeFeaturesDecodeErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	LDKDecodeError err_var = (*val->contents.err);
	uint64_t err_ref = 0;
	CHECK((((uint64_t)err_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&err_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	err_ref = (uint64_t)err_var.inner & ~1;
	return err_ref;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1ChannelFeaturesDecodeErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_ChannelFeaturesDecodeErrorZ*)arg)->result_ok;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1ChannelFeaturesDecodeErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_ChannelFeaturesDecodeErrorZ *val = (LDKCResult_ChannelFeaturesDecodeErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	LDKChannelFeatures res_var = (*val->contents.result);
	uint64_t res_ref = 0;
	CHECK((((uint64_t)res_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&res_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	res_ref = (uint64_t)res_var.inner & ~1;
	return res_ref;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1ChannelFeaturesDecodeErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_ChannelFeaturesDecodeErrorZ *val = (LDKCResult_ChannelFeaturesDecodeErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	LDKDecodeError err_var = (*val->contents.err);
	uint64_t err_ref = 0;
	CHECK((((uint64_t)err_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&err_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	err_ref = (uint64_t)err_var.inner & ~1;
	return err_ref;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1InvoiceFeaturesDecodeErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_InvoiceFeaturesDecodeErrorZ*)arg)->result_ok;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1InvoiceFeaturesDecodeErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_InvoiceFeaturesDecodeErrorZ *val = (LDKCResult_InvoiceFeaturesDecodeErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	LDKInvoiceFeatures res_var = (*val->contents.result);
	uint64_t res_ref = 0;
	CHECK((((uint64_t)res_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&res_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	res_ref = (uint64_t)res_var.inner & ~1;
	return res_ref;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1InvoiceFeaturesDecodeErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_InvoiceFeaturesDecodeErrorZ *val = (LDKCResult_InvoiceFeaturesDecodeErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	LDKDecodeError err_var = (*val->contents.err);
	uint64_t err_ref = 0;
	CHECK((((uint64_t)err_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&err_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	err_ref = (uint64_t)err_var.inner & ~1;
	return err_ref;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1DelayedPaymentOutputDescriptorDecodeErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ*)arg)->result_ok;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1DelayedPaymentOutputDescriptorDecodeErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ *val = (LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	LDKDelayedPaymentOutputDescriptor res_var = (*val->contents.result);
	uint64_t res_ref = 0;
	CHECK((((uint64_t)res_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&res_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	res_ref = (uint64_t)res_var.inner & ~1;
	return res_ref;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1DelayedPaymentOutputDescriptorDecodeErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ *val = (LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	LDKDecodeError err_var = (*val->contents.err);
	uint64_t err_ref = 0;
	CHECK((((uint64_t)err_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&err_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	err_ref = (uint64_t)err_var.inner & ~1;
	return err_ref;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1StaticPaymentOutputDescriptorDecodeErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ*)arg)->result_ok;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1StaticPaymentOutputDescriptorDecodeErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ *val = (LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	LDKStaticPaymentOutputDescriptor res_var = (*val->contents.result);
	uint64_t res_ref = 0;
	CHECK((((uint64_t)res_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&res_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	res_ref = (uint64_t)res_var.inner & ~1;
	return res_ref;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1StaticPaymentOutputDescriptorDecodeErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ *val = (LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	LDKDecodeError err_var = (*val->contents.err);
	uint64_t err_ref = 0;
	CHECK((((uint64_t)err_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&err_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	err_ref = (uint64_t)err_var.inner & ~1;
	return err_ref;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1SpendableOutputDescriptorDecodeErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_SpendableOutputDescriptorDecodeErrorZ*)arg)->result_ok;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1SpendableOutputDescriptorDecodeErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_SpendableOutputDescriptorDecodeErrorZ *val = (LDKCResult_SpendableOutputDescriptorDecodeErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	uint64_t res_ref = ((uint64_t)&(*val->contents.result)) | 1;
	return res_ref;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1SpendableOutputDescriptorDecodeErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_SpendableOutputDescriptorDecodeErrorZ *val = (LDKCResult_SpendableOutputDescriptorDecodeErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	LDKDecodeError err_var = (*val->contents.err);
	uint64_t err_ref = 0;
	CHECK((((uint64_t)err_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&err_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	err_ref = (uint64_t)err_var.inner & ~1;
	return err_ref;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1NoneNoneZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_NoneNoneZ*)arg)->result_ok;
}
JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_LDKCResult_1NoneNoneZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_NoneNoneZ *val = (LDKCResult_NoneNoneZ*)(arg & ~1);
	CHECK(val->result_ok);
	return *val->contents.result;
}
JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_LDKCResult_1NoneNoneZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_NoneNoneZ *val = (LDKCResult_NoneNoneZ*)(arg & ~1);
	CHECK(!val->result_ok);
	return *val->contents.err;
}
static inline struct LDKSignature C2Tuple_SignatureCVec_SignatureZZ_get_a(LDKC2Tuple_SignatureCVec_SignatureZZ *NONNULL_PTR tuple){
	return tuple->a;
}
JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_C2Tuple_1SignatureCVec_1SignatureZZ_1get_1a(JNIEnv *env, jclass clz, int64_t tuple) {
	LDKC2Tuple_SignatureCVec_SignatureZZ* tuple_conv = (LDKC2Tuple_SignatureCVec_SignatureZZ*)(tuple & ~1);
	int8_tArray ret_arr = (*env)->NewByteArray(env, 64);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 64, C2Tuple_SignatureCVec_SignatureZZ_get_a(tuple_conv).compact_form);
	return ret_arr;
}

static inline struct LDKCVec_SignatureZ C2Tuple_SignatureCVec_SignatureZZ_get_b(LDKC2Tuple_SignatureCVec_SignatureZZ *NONNULL_PTR tuple){
	return tuple->b;
}
JNIEXPORT jobjectArray JNICALL Java_org_ldk_impl_bindings_C2Tuple_1SignatureCVec_1SignatureZZ_1get_1b(JNIEnv *env, jclass clz, int64_t tuple) {
	LDKC2Tuple_SignatureCVec_SignatureZZ* tuple_conv = (LDKC2Tuple_SignatureCVec_SignatureZZ*)(tuple & ~1);
	LDKCVec_SignatureZ ret_var = C2Tuple_SignatureCVec_SignatureZZ_get_b(tuple_conv);
	jobjectArray ret_arr = NULL;
	ret_arr = (*env)->NewObjectArray(env, ret_var.datalen, arr_of_B_clz, NULL);
	;
	for (size_t i = 0; i < ret_var.datalen; i++) {
		int8_tArray ret_conv_8_arr = (*env)->NewByteArray(env, 64);
		(*env)->SetByteArrayRegion(env, ret_conv_8_arr, 0, 64, ret_var.data[i].compact_form);
		(*env)->SetObjectArrayElement(env, ret_arr, i, ret_conv_8_arr);
	}
	
	FREE(ret_var.data);
	return ret_arr;
}

JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1C2Tuple_1SignatureCVec_1SignatureZZNoneZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ*)arg)->result_ok;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1C2Tuple_1SignatureCVec_1SignatureZZNoneZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ *val = (LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ*)(arg & ~1);
	CHECK(val->result_ok);
	LDKC2Tuple_SignatureCVec_SignatureZZ* res_conv = MALLOC(sizeof(LDKC2Tuple_SignatureCVec_SignatureZZ), "LDKC2Tuple_SignatureCVec_SignatureZZ");
	*res_conv = (*val->contents.result);
	*res_conv = C2Tuple_SignatureCVec_SignatureZZ_clone(res_conv);
	return ((uint64_t)res_conv);
}
JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_LDKCResult_1C2Tuple_1SignatureCVec_1SignatureZZNoneZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ *val = (LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ*)(arg & ~1);
	CHECK(!val->result_ok);
	return *val->contents.err;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1SignatureNoneZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_SignatureNoneZ*)arg)->result_ok;
}
JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_LDKCResult_1SignatureNoneZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_SignatureNoneZ *val = (LDKCResult_SignatureNoneZ*)(arg & ~1);
	CHECK(val->result_ok);
	int8_tArray res_arr = (*env)->NewByteArray(env, 64);
	(*env)->SetByteArrayRegion(env, res_arr, 0, 64, (*val->contents.result).compact_form);
	return res_arr;
}
JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_LDKCResult_1SignatureNoneZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_SignatureNoneZ *val = (LDKCResult_SignatureNoneZ*)(arg & ~1);
	CHECK(!val->result_ok);
	return *val->contents.err;
}
typedef struct LDKBaseSign_JCalls {
	atomic_size_t refcnt;
	JavaVM *vm;
	jweak o;
	jmethodID get_per_commitment_point_meth;
	jmethodID release_commitment_secret_meth;
	jmethodID validate_holder_commitment_meth;
	jmethodID channel_keys_id_meth;
	jmethodID sign_counterparty_commitment_meth;
	jmethodID validate_counterparty_revocation_meth;
	jmethodID sign_holder_commitment_and_htlcs_meth;
	jmethodID sign_justice_revoked_output_meth;
	jmethodID sign_justice_revoked_htlc_meth;
	jmethodID sign_counterparty_htlc_transaction_meth;
	jmethodID sign_closing_transaction_meth;
	jmethodID sign_channel_announcement_meth;
	jmethodID ready_channel_meth;
} LDKBaseSign_JCalls;
static void LDKBaseSign_JCalls_free(void* this_arg) {
	LDKBaseSign_JCalls *j_calls = (LDKBaseSign_JCalls*) this_arg;
	if (atomic_fetch_sub_explicit(&j_calls->refcnt, 1, memory_order_acquire) == 1) {
		JNIEnv *env;
		jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
		if (get_jenv_res == JNI_EDETACHED) {
			DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
		} else {
			DO_ASSERT(get_jenv_res == JNI_OK);
		}
		(*env)->DeleteWeakGlobalRef(env, j_calls->o);
		if (get_jenv_res == JNI_EDETACHED) {
			DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
		}
		FREE(j_calls);
	}
}
LDKPublicKey get_per_commitment_point_LDKBaseSign_jcall(const void* this_arg, uint64_t idx) {
	LDKBaseSign_JCalls *j_calls = (LDKBaseSign_JCalls*) this_arg;
	JNIEnv *env;
	jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
	} else {
		DO_ASSERT(get_jenv_res == JNI_OK);
	}
	jobject obj = (*env)->NewLocalRef(env, j_calls->o);
	CHECK(obj != NULL);
	int8_tArray ret = (*env)->CallObjectMethod(env, obj, j_calls->get_per_commitment_point_meth, idx);
	if ((*env)->ExceptionCheck(env)) {
		(*env)->ExceptionDescribe(env);
		(*env)->FatalError(env, "A call to get_per_commitment_point in LDKBaseSign from rust threw an exception.");
	}
	LDKPublicKey ret_ref;
	CHECK((*env)->GetArrayLength(env, ret) == 33);
	(*env)->GetByteArrayRegion(env, ret, 0, 33, ret_ref.compressed_form);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
	}
	return ret_ref;
}
LDKThirtyTwoBytes release_commitment_secret_LDKBaseSign_jcall(const void* this_arg, uint64_t idx) {
	LDKBaseSign_JCalls *j_calls = (LDKBaseSign_JCalls*) this_arg;
	JNIEnv *env;
	jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
	} else {
		DO_ASSERT(get_jenv_res == JNI_OK);
	}
	jobject obj = (*env)->NewLocalRef(env, j_calls->o);
	CHECK(obj != NULL);
	int8_tArray ret = (*env)->CallObjectMethod(env, obj, j_calls->release_commitment_secret_meth, idx);
	if ((*env)->ExceptionCheck(env)) {
		(*env)->ExceptionDescribe(env);
		(*env)->FatalError(env, "A call to release_commitment_secret in LDKBaseSign from rust threw an exception.");
	}
	LDKThirtyTwoBytes ret_ref;
	CHECK((*env)->GetArrayLength(env, ret) == 32);
	(*env)->GetByteArrayRegion(env, ret, 0, 32, ret_ref.data);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
	}
	return ret_ref;
}
LDKCResult_NoneNoneZ validate_holder_commitment_LDKBaseSign_jcall(const void* this_arg, const LDKHolderCommitmentTransaction * holder_tx) {
	LDKBaseSign_JCalls *j_calls = (LDKBaseSign_JCalls*) this_arg;
	JNIEnv *env;
	jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
	} else {
		DO_ASSERT(get_jenv_res == JNI_OK);
	}
	LDKHolderCommitmentTransaction holder_tx_var = *holder_tx;
	uint64_t holder_tx_ref = 0;
	holder_tx_var = HolderCommitmentTransaction_clone(holder_tx);
	CHECK((((uint64_t)holder_tx_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&holder_tx_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	holder_tx_ref = (uint64_t)holder_tx_var.inner;
	if (holder_tx_var.is_owned) {
		holder_tx_ref |= 1;
	}
	jobject obj = (*env)->NewLocalRef(env, j_calls->o);
	CHECK(obj != NULL);
	uint64_t ret = (*env)->CallLongMethod(env, obj, j_calls->validate_holder_commitment_meth, holder_tx_ref);
	if ((*env)->ExceptionCheck(env)) {
		(*env)->ExceptionDescribe(env);
		(*env)->FatalError(env, "A call to validate_holder_commitment in LDKBaseSign from rust threw an exception.");
	}
	void* ret_ptr = (void*)(((uint64_t)ret) & ~1);
	CHECK_ACCESS(ret_ptr);
	LDKCResult_NoneNoneZ ret_conv = *(LDKCResult_NoneNoneZ*)(ret_ptr);
	ret_conv = CResult_NoneNoneZ_clone((LDKCResult_NoneNoneZ*)(((uint64_t)ret) & ~1));
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
	}
	return ret_conv;
}
LDKThirtyTwoBytes channel_keys_id_LDKBaseSign_jcall(const void* this_arg) {
	LDKBaseSign_JCalls *j_calls = (LDKBaseSign_JCalls*) this_arg;
	JNIEnv *env;
	jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
	} else {
		DO_ASSERT(get_jenv_res == JNI_OK);
	}
	jobject obj = (*env)->NewLocalRef(env, j_calls->o);
	CHECK(obj != NULL);
	int8_tArray ret = (*env)->CallObjectMethod(env, obj, j_calls->channel_keys_id_meth);
	if ((*env)->ExceptionCheck(env)) {
		(*env)->ExceptionDescribe(env);
		(*env)->FatalError(env, "A call to channel_keys_id in LDKBaseSign from rust threw an exception.");
	}
	LDKThirtyTwoBytes ret_ref;
	CHECK((*env)->GetArrayLength(env, ret) == 32);
	(*env)->GetByteArrayRegion(env, ret, 0, 32, ret_ref.data);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
	}
	return ret_ref;
}
LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ sign_counterparty_commitment_LDKBaseSign_jcall(const void* this_arg, const LDKCommitmentTransaction * commitment_tx) {
	LDKBaseSign_JCalls *j_calls = (LDKBaseSign_JCalls*) this_arg;
	JNIEnv *env;
	jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
	} else {
		DO_ASSERT(get_jenv_res == JNI_OK);
	}
	LDKCommitmentTransaction commitment_tx_var = *commitment_tx;
	uint64_t commitment_tx_ref = 0;
	commitment_tx_var = CommitmentTransaction_clone(commitment_tx);
	CHECK((((uint64_t)commitment_tx_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&commitment_tx_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	commitment_tx_ref = (uint64_t)commitment_tx_var.inner;
	if (commitment_tx_var.is_owned) {
		commitment_tx_ref |= 1;
	}
	jobject obj = (*env)->NewLocalRef(env, j_calls->o);
	CHECK(obj != NULL);
	uint64_t ret = (*env)->CallLongMethod(env, obj, j_calls->sign_counterparty_commitment_meth, commitment_tx_ref);
	if ((*env)->ExceptionCheck(env)) {
		(*env)->ExceptionDescribe(env);
		(*env)->FatalError(env, "A call to sign_counterparty_commitment in LDKBaseSign from rust threw an exception.");
	}
	void* ret_ptr = (void*)(((uint64_t)ret) & ~1);
	CHECK_ACCESS(ret_ptr);
	LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ ret_conv = *(LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ*)(ret_ptr);
	ret_conv = CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_clone((LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ*)(((uint64_t)ret) & ~1));
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
	}
	return ret_conv;
}
LDKCResult_NoneNoneZ validate_counterparty_revocation_LDKBaseSign_jcall(const void* this_arg, uint64_t idx, const uint8_t (* secret)[32]) {
	LDKBaseSign_JCalls *j_calls = (LDKBaseSign_JCalls*) this_arg;
	JNIEnv *env;
	jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
	} else {
		DO_ASSERT(get_jenv_res == JNI_OK);
	}
	int8_tArray secret_arr = (*env)->NewByteArray(env, 32);
	(*env)->SetByteArrayRegion(env, secret_arr, 0, 32, *secret);
	jobject obj = (*env)->NewLocalRef(env, j_calls->o);
	CHECK(obj != NULL);
	uint64_t ret = (*env)->CallLongMethod(env, obj, j_calls->validate_counterparty_revocation_meth, idx, secret_arr);
	if ((*env)->ExceptionCheck(env)) {
		(*env)->ExceptionDescribe(env);
		(*env)->FatalError(env, "A call to validate_counterparty_revocation in LDKBaseSign from rust threw an exception.");
	}
	void* ret_ptr = (void*)(((uint64_t)ret) & ~1);
	CHECK_ACCESS(ret_ptr);
	LDKCResult_NoneNoneZ ret_conv = *(LDKCResult_NoneNoneZ*)(ret_ptr);
	ret_conv = CResult_NoneNoneZ_clone((LDKCResult_NoneNoneZ*)(((uint64_t)ret) & ~1));
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
	}
	return ret_conv;
}
LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ sign_holder_commitment_and_htlcs_LDKBaseSign_jcall(const void* this_arg, const LDKHolderCommitmentTransaction * commitment_tx) {
	LDKBaseSign_JCalls *j_calls = (LDKBaseSign_JCalls*) this_arg;
	JNIEnv *env;
	jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
	} else {
		DO_ASSERT(get_jenv_res == JNI_OK);
	}
	LDKHolderCommitmentTransaction commitment_tx_var = *commitment_tx;
	uint64_t commitment_tx_ref = 0;
	commitment_tx_var = HolderCommitmentTransaction_clone(commitment_tx);
	CHECK((((uint64_t)commitment_tx_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&commitment_tx_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	commitment_tx_ref = (uint64_t)commitment_tx_var.inner;
	if (commitment_tx_var.is_owned) {
		commitment_tx_ref |= 1;
	}
	jobject obj = (*env)->NewLocalRef(env, j_calls->o);
	CHECK(obj != NULL);
	uint64_t ret = (*env)->CallLongMethod(env, obj, j_calls->sign_holder_commitment_and_htlcs_meth, commitment_tx_ref);
	if ((*env)->ExceptionCheck(env)) {
		(*env)->ExceptionDescribe(env);
		(*env)->FatalError(env, "A call to sign_holder_commitment_and_htlcs in LDKBaseSign from rust threw an exception.");
	}
	void* ret_ptr = (void*)(((uint64_t)ret) & ~1);
	CHECK_ACCESS(ret_ptr);
	LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ ret_conv = *(LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ*)(ret_ptr);
	ret_conv = CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_clone((LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ*)(((uint64_t)ret) & ~1));
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
	}
	return ret_conv;
}
LDKCResult_SignatureNoneZ sign_justice_revoked_output_LDKBaseSign_jcall(const void* this_arg, LDKTransaction justice_tx, uintptr_t input, uint64_t amount, const uint8_t (* per_commitment_key)[32]) {
	LDKBaseSign_JCalls *j_calls = (LDKBaseSign_JCalls*) this_arg;
	JNIEnv *env;
	jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
	} else {
		DO_ASSERT(get_jenv_res == JNI_OK);
	}
	LDKTransaction justice_tx_var = justice_tx;
	int8_tArray justice_tx_arr = (*env)->NewByteArray(env, justice_tx_var.datalen);
	(*env)->SetByteArrayRegion(env, justice_tx_arr, 0, justice_tx_var.datalen, justice_tx_var.data);
	Transaction_free(justice_tx_var);
	int8_tArray per_commitment_key_arr = (*env)->NewByteArray(env, 32);
	(*env)->SetByteArrayRegion(env, per_commitment_key_arr, 0, 32, *per_commitment_key);
	jobject obj = (*env)->NewLocalRef(env, j_calls->o);
	CHECK(obj != NULL);
	uint64_t ret = (*env)->CallLongMethod(env, obj, j_calls->sign_justice_revoked_output_meth, justice_tx_arr, input, amount, per_commitment_key_arr);
	if ((*env)->ExceptionCheck(env)) {
		(*env)->ExceptionDescribe(env);
		(*env)->FatalError(env, "A call to sign_justice_revoked_output in LDKBaseSign from rust threw an exception.");
	}
	void* ret_ptr = (void*)(((uint64_t)ret) & ~1);
	CHECK_ACCESS(ret_ptr);
	LDKCResult_SignatureNoneZ ret_conv = *(LDKCResult_SignatureNoneZ*)(ret_ptr);
	ret_conv = CResult_SignatureNoneZ_clone((LDKCResult_SignatureNoneZ*)(((uint64_t)ret) & ~1));
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
	}
	return ret_conv;
}
LDKCResult_SignatureNoneZ sign_justice_revoked_htlc_LDKBaseSign_jcall(const void* this_arg, LDKTransaction justice_tx, uintptr_t input, uint64_t amount, const uint8_t (* per_commitment_key)[32], const LDKHTLCOutputInCommitment * htlc) {
	LDKBaseSign_JCalls *j_calls = (LDKBaseSign_JCalls*) this_arg;
	JNIEnv *env;
	jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
	} else {
		DO_ASSERT(get_jenv_res == JNI_OK);
	}
	LDKTransaction justice_tx_var = justice_tx;
	int8_tArray justice_tx_arr = (*env)->NewByteArray(env, justice_tx_var.datalen);
	(*env)->SetByteArrayRegion(env, justice_tx_arr, 0, justice_tx_var.datalen, justice_tx_var.data);
	Transaction_free(justice_tx_var);
	int8_tArray per_commitment_key_arr = (*env)->NewByteArray(env, 32);
	(*env)->SetByteArrayRegion(env, per_commitment_key_arr, 0, 32, *per_commitment_key);
	LDKHTLCOutputInCommitment htlc_var = *htlc;
	uint64_t htlc_ref = 0;
	htlc_var = HTLCOutputInCommitment_clone(htlc);
	CHECK((((uint64_t)htlc_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&htlc_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	htlc_ref = (uint64_t)htlc_var.inner;
	if (htlc_var.is_owned) {
		htlc_ref |= 1;
	}
	jobject obj = (*env)->NewLocalRef(env, j_calls->o);
	CHECK(obj != NULL);
	uint64_t ret = (*env)->CallLongMethod(env, obj, j_calls->sign_justice_revoked_htlc_meth, justice_tx_arr, input, amount, per_commitment_key_arr, htlc_ref);
	if ((*env)->ExceptionCheck(env)) {
		(*env)->ExceptionDescribe(env);
		(*env)->FatalError(env, "A call to sign_justice_revoked_htlc in LDKBaseSign from rust threw an exception.");
	}
	void* ret_ptr = (void*)(((uint64_t)ret) & ~1);
	CHECK_ACCESS(ret_ptr);
	LDKCResult_SignatureNoneZ ret_conv = *(LDKCResult_SignatureNoneZ*)(ret_ptr);
	ret_conv = CResult_SignatureNoneZ_clone((LDKCResult_SignatureNoneZ*)(((uint64_t)ret) & ~1));
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
	}
	return ret_conv;
}
LDKCResult_SignatureNoneZ sign_counterparty_htlc_transaction_LDKBaseSign_jcall(const void* this_arg, LDKTransaction htlc_tx, uintptr_t input, uint64_t amount, LDKPublicKey per_commitment_point, const LDKHTLCOutputInCommitment * htlc) {
	LDKBaseSign_JCalls *j_calls = (LDKBaseSign_JCalls*) this_arg;
	JNIEnv *env;
	jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
	} else {
		DO_ASSERT(get_jenv_res == JNI_OK);
	}
	LDKTransaction htlc_tx_var = htlc_tx;
	int8_tArray htlc_tx_arr = (*env)->NewByteArray(env, htlc_tx_var.datalen);
	(*env)->SetByteArrayRegion(env, htlc_tx_arr, 0, htlc_tx_var.datalen, htlc_tx_var.data);
	Transaction_free(htlc_tx_var);
	int8_tArray per_commitment_point_arr = (*env)->NewByteArray(env, 33);
	(*env)->SetByteArrayRegion(env, per_commitment_point_arr, 0, 33, per_commitment_point.compressed_form);
	LDKHTLCOutputInCommitment htlc_var = *htlc;
	uint64_t htlc_ref = 0;
	htlc_var = HTLCOutputInCommitment_clone(htlc);
	CHECK((((uint64_t)htlc_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&htlc_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	htlc_ref = (uint64_t)htlc_var.inner;
	if (htlc_var.is_owned) {
		htlc_ref |= 1;
	}
	jobject obj = (*env)->NewLocalRef(env, j_calls->o);
	CHECK(obj != NULL);
	uint64_t ret = (*env)->CallLongMethod(env, obj, j_calls->sign_counterparty_htlc_transaction_meth, htlc_tx_arr, input, amount, per_commitment_point_arr, htlc_ref);
	if ((*env)->ExceptionCheck(env)) {
		(*env)->ExceptionDescribe(env);
		(*env)->FatalError(env, "A call to sign_counterparty_htlc_transaction in LDKBaseSign from rust threw an exception.");
	}
	void* ret_ptr = (void*)(((uint64_t)ret) & ~1);
	CHECK_ACCESS(ret_ptr);
	LDKCResult_SignatureNoneZ ret_conv = *(LDKCResult_SignatureNoneZ*)(ret_ptr);
	ret_conv = CResult_SignatureNoneZ_clone((LDKCResult_SignatureNoneZ*)(((uint64_t)ret) & ~1));
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
	}
	return ret_conv;
}
LDKCResult_SignatureNoneZ sign_closing_transaction_LDKBaseSign_jcall(const void* this_arg, const LDKClosingTransaction * closing_tx) {
	LDKBaseSign_JCalls *j_calls = (LDKBaseSign_JCalls*) this_arg;
	JNIEnv *env;
	jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
	} else {
		DO_ASSERT(get_jenv_res == JNI_OK);
	}
	LDKClosingTransaction closing_tx_var = *closing_tx;
	uint64_t closing_tx_ref = 0;
	closing_tx_var = ClosingTransaction_clone(closing_tx);
	CHECK((((uint64_t)closing_tx_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&closing_tx_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	closing_tx_ref = (uint64_t)closing_tx_var.inner;
	if (closing_tx_var.is_owned) {
		closing_tx_ref |= 1;
	}
	jobject obj = (*env)->NewLocalRef(env, j_calls->o);
	CHECK(obj != NULL);
	uint64_t ret = (*env)->CallLongMethod(env, obj, j_calls->sign_closing_transaction_meth, closing_tx_ref);
	if ((*env)->ExceptionCheck(env)) {
		(*env)->ExceptionDescribe(env);
		(*env)->FatalError(env, "A call to sign_closing_transaction in LDKBaseSign from rust threw an exception.");
	}
	void* ret_ptr = (void*)(((uint64_t)ret) & ~1);
	CHECK_ACCESS(ret_ptr);
	LDKCResult_SignatureNoneZ ret_conv = *(LDKCResult_SignatureNoneZ*)(ret_ptr);
	ret_conv = CResult_SignatureNoneZ_clone((LDKCResult_SignatureNoneZ*)(((uint64_t)ret) & ~1));
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
	}
	return ret_conv;
}
LDKCResult_SignatureNoneZ sign_channel_announcement_LDKBaseSign_jcall(const void* this_arg, const LDKUnsignedChannelAnnouncement * msg) {
	LDKBaseSign_JCalls *j_calls = (LDKBaseSign_JCalls*) this_arg;
	JNIEnv *env;
	jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
	} else {
		DO_ASSERT(get_jenv_res == JNI_OK);
	}
	LDKUnsignedChannelAnnouncement msg_var = *msg;
	uint64_t msg_ref = 0;
	msg_var = UnsignedChannelAnnouncement_clone(msg);
	CHECK((((uint64_t)msg_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&msg_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	msg_ref = (uint64_t)msg_var.inner;
	if (msg_var.is_owned) {
		msg_ref |= 1;
	}
	jobject obj = (*env)->NewLocalRef(env, j_calls->o);
	CHECK(obj != NULL);
	uint64_t ret = (*env)->CallLongMethod(env, obj, j_calls->sign_channel_announcement_meth, msg_ref);
	if ((*env)->ExceptionCheck(env)) {
		(*env)->ExceptionDescribe(env);
		(*env)->FatalError(env, "A call to sign_channel_announcement in LDKBaseSign from rust threw an exception.");
	}
	void* ret_ptr = (void*)(((uint64_t)ret) & ~1);
	CHECK_ACCESS(ret_ptr);
	LDKCResult_SignatureNoneZ ret_conv = *(LDKCResult_SignatureNoneZ*)(ret_ptr);
	ret_conv = CResult_SignatureNoneZ_clone((LDKCResult_SignatureNoneZ*)(((uint64_t)ret) & ~1));
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
	}
	return ret_conv;
}
void ready_channel_LDKBaseSign_jcall(void* this_arg, const LDKChannelTransactionParameters * channel_parameters) {
	LDKBaseSign_JCalls *j_calls = (LDKBaseSign_JCalls*) this_arg;
	JNIEnv *env;
	jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
	} else {
		DO_ASSERT(get_jenv_res == JNI_OK);
	}
	LDKChannelTransactionParameters channel_parameters_var = *channel_parameters;
	uint64_t channel_parameters_ref = 0;
	channel_parameters_var = ChannelTransactionParameters_clone(channel_parameters);
	CHECK((((uint64_t)channel_parameters_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&channel_parameters_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	channel_parameters_ref = (uint64_t)channel_parameters_var.inner;
	if (channel_parameters_var.is_owned) {
		channel_parameters_ref |= 1;
	}
	jobject obj = (*env)->NewLocalRef(env, j_calls->o);
	CHECK(obj != NULL);
	(*env)->CallVoidMethod(env, obj, j_calls->ready_channel_meth, channel_parameters_ref);
	if ((*env)->ExceptionCheck(env)) {
		(*env)->ExceptionDescribe(env);
		(*env)->FatalError(env, "A call to ready_channel in LDKBaseSign from rust threw an exception.");
	}
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
	}
}
static inline LDKBaseSign LDKBaseSign_init (JNIEnv *env, jclass clz, jobject o, int64_t pubkeys) {
	jclass c = (*env)->GetObjectClass(env, o);
	CHECK(c != NULL);
	LDKBaseSign_JCalls *calls = MALLOC(sizeof(LDKBaseSign_JCalls), "LDKBaseSign_JCalls");
	atomic_init(&calls->refcnt, 1);
	DO_ASSERT((*env)->GetJavaVM(env, &calls->vm) == 0);
	calls->o = (*env)->NewWeakGlobalRef(env, o);
	calls->get_per_commitment_point_meth = (*env)->GetMethodID(env, c, "get_per_commitment_point", "(J)[B");
	CHECK(calls->get_per_commitment_point_meth != NULL);
	calls->release_commitment_secret_meth = (*env)->GetMethodID(env, c, "release_commitment_secret", "(J)[B");
	CHECK(calls->release_commitment_secret_meth != NULL);
	calls->validate_holder_commitment_meth = (*env)->GetMethodID(env, c, "validate_holder_commitment", "(J)J");
	CHECK(calls->validate_holder_commitment_meth != NULL);
	calls->channel_keys_id_meth = (*env)->GetMethodID(env, c, "channel_keys_id", "()[B");
	CHECK(calls->channel_keys_id_meth != NULL);
	calls->sign_counterparty_commitment_meth = (*env)->GetMethodID(env, c, "sign_counterparty_commitment", "(J)J");
	CHECK(calls->sign_counterparty_commitment_meth != NULL);
	calls->validate_counterparty_revocation_meth = (*env)->GetMethodID(env, c, "validate_counterparty_revocation", "(J[B)J");
	CHECK(calls->validate_counterparty_revocation_meth != NULL);
	calls->sign_holder_commitment_and_htlcs_meth = (*env)->GetMethodID(env, c, "sign_holder_commitment_and_htlcs", "(J)J");
	CHECK(calls->sign_holder_commitment_and_htlcs_meth != NULL);
	calls->sign_justice_revoked_output_meth = (*env)->GetMethodID(env, c, "sign_justice_revoked_output", "([BJJ[B)J");
	CHECK(calls->sign_justice_revoked_output_meth != NULL);
	calls->sign_justice_revoked_htlc_meth = (*env)->GetMethodID(env, c, "sign_justice_revoked_htlc", "([BJJ[BJ)J");
	CHECK(calls->sign_justice_revoked_htlc_meth != NULL);
	calls->sign_counterparty_htlc_transaction_meth = (*env)->GetMethodID(env, c, "sign_counterparty_htlc_transaction", "([BJJ[BJ)J");
	CHECK(calls->sign_counterparty_htlc_transaction_meth != NULL);
	calls->sign_closing_transaction_meth = (*env)->GetMethodID(env, c, "sign_closing_transaction", "(J)J");
	CHECK(calls->sign_closing_transaction_meth != NULL);
	calls->sign_channel_announcement_meth = (*env)->GetMethodID(env, c, "sign_channel_announcement", "(J)J");
	CHECK(calls->sign_channel_announcement_meth != NULL);
	calls->ready_channel_meth = (*env)->GetMethodID(env, c, "ready_channel", "(J)V");
	CHECK(calls->ready_channel_meth != NULL);

	LDKChannelPublicKeys pubkeys_conv;
	pubkeys_conv.inner = (void*)(pubkeys & (~1));
	pubkeys_conv.is_owned = (pubkeys & 1) || (pubkeys == 0);
	pubkeys_conv = ChannelPublicKeys_clone(&pubkeys_conv);

	LDKBaseSign ret = {
		.this_arg = (void*) calls,
		.get_per_commitment_point = get_per_commitment_point_LDKBaseSign_jcall,
		.release_commitment_secret = release_commitment_secret_LDKBaseSign_jcall,
		.validate_holder_commitment = validate_holder_commitment_LDKBaseSign_jcall,
		.channel_keys_id = channel_keys_id_LDKBaseSign_jcall,
		.sign_counterparty_commitment = sign_counterparty_commitment_LDKBaseSign_jcall,
		.validate_counterparty_revocation = validate_counterparty_revocation_LDKBaseSign_jcall,
		.sign_holder_commitment_and_htlcs = sign_holder_commitment_and_htlcs_LDKBaseSign_jcall,
		.sign_justice_revoked_output = sign_justice_revoked_output_LDKBaseSign_jcall,
		.sign_justice_revoked_htlc = sign_justice_revoked_htlc_LDKBaseSign_jcall,
		.sign_counterparty_htlc_transaction = sign_counterparty_htlc_transaction_LDKBaseSign_jcall,
		.sign_closing_transaction = sign_closing_transaction_LDKBaseSign_jcall,
		.sign_channel_announcement = sign_channel_announcement_LDKBaseSign_jcall,
		.ready_channel = ready_channel_LDKBaseSign_jcall,
		.free = LDKBaseSign_JCalls_free,
		.pubkeys = pubkeys_conv,
		.set_pubkeys = NULL,
	};
	return ret;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKBaseSign_1new(JNIEnv *env, jclass clz, jobject o, int64_t pubkeys) {
	LDKBaseSign *res_ptr = MALLOC(sizeof(LDKBaseSign), "LDKBaseSign");
	*res_ptr = LDKBaseSign_init(env, clz, o, pubkeys);
	return (uint64_t)res_ptr;
}
JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_BaseSign_1get_1per_1commitment_1point(JNIEnv *env, jclass clz, int64_t this_arg, int64_t idx) {
	void* this_arg_ptr = (void*)(((uint64_t)this_arg) & ~1);
	if (!(this_arg & 1)) { CHECK_ACCESS(this_arg_ptr); }
	LDKBaseSign* this_arg_conv = (LDKBaseSign*)this_arg_ptr;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 33);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 33, (this_arg_conv->get_per_commitment_point)(this_arg_conv->this_arg, idx).compressed_form);
	return ret_arr;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_BaseSign_1release_1commitment_1secret(JNIEnv *env, jclass clz, int64_t this_arg, int64_t idx) {
	void* this_arg_ptr = (void*)(((uint64_t)this_arg) & ~1);
	if (!(this_arg & 1)) { CHECK_ACCESS(this_arg_ptr); }
	LDKBaseSign* this_arg_conv = (LDKBaseSign*)this_arg_ptr;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 32);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 32, (this_arg_conv->release_commitment_secret)(this_arg_conv->this_arg, idx).data);
	return ret_arr;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_BaseSign_1validate_1holder_1commitment(JNIEnv *env, jclass clz, int64_t this_arg, int64_t holder_tx) {
	void* this_arg_ptr = (void*)(((uint64_t)this_arg) & ~1);
	if (!(this_arg & 1)) { CHECK_ACCESS(this_arg_ptr); }
	LDKBaseSign* this_arg_conv = (LDKBaseSign*)this_arg_ptr;
	LDKHolderCommitmentTransaction holder_tx_conv;
	holder_tx_conv.inner = (void*)(holder_tx & (~1));
	holder_tx_conv.is_owned = false;
	LDKCResult_NoneNoneZ* ret_conv = MALLOC(sizeof(LDKCResult_NoneNoneZ), "LDKCResult_NoneNoneZ");
	*ret_conv = (this_arg_conv->validate_holder_commitment)(this_arg_conv->this_arg, &holder_tx_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_BaseSign_1channel_1keys_1id(JNIEnv *env, jclass clz, int64_t this_arg) {
	void* this_arg_ptr = (void*)(((uint64_t)this_arg) & ~1);
	if (!(this_arg & 1)) { CHECK_ACCESS(this_arg_ptr); }
	LDKBaseSign* this_arg_conv = (LDKBaseSign*)this_arg_ptr;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 32);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 32, (this_arg_conv->channel_keys_id)(this_arg_conv->this_arg).data);
	return ret_arr;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_BaseSign_1sign_1counterparty_1commitment(JNIEnv *env, jclass clz, int64_t this_arg, int64_t commitment_tx) {
	void* this_arg_ptr = (void*)(((uint64_t)this_arg) & ~1);
	if (!(this_arg & 1)) { CHECK_ACCESS(this_arg_ptr); }
	LDKBaseSign* this_arg_conv = (LDKBaseSign*)this_arg_ptr;
	LDKCommitmentTransaction commitment_tx_conv;
	commitment_tx_conv.inner = (void*)(commitment_tx & (~1));
	commitment_tx_conv.is_owned = false;
	LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ* ret_conv = MALLOC(sizeof(LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ), "LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ");
	*ret_conv = (this_arg_conv->sign_counterparty_commitment)(this_arg_conv->this_arg, &commitment_tx_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_BaseSign_1validate_1counterparty_1revocation(JNIEnv *env, jclass clz, int64_t this_arg, int64_t idx, int8_tArray secret) {
	void* this_arg_ptr = (void*)(((uint64_t)this_arg) & ~1);
	if (!(this_arg & 1)) { CHECK_ACCESS(this_arg_ptr); }
	LDKBaseSign* this_arg_conv = (LDKBaseSign*)this_arg_ptr;
	unsigned char secret_arr[32];
	CHECK((*env)->GetArrayLength(env, secret) == 32);
	(*env)->GetByteArrayRegion(env, secret, 0, 32, secret_arr);
	unsigned char (*secret_ref)[32] = &secret_arr;
	LDKCResult_NoneNoneZ* ret_conv = MALLOC(sizeof(LDKCResult_NoneNoneZ), "LDKCResult_NoneNoneZ");
	*ret_conv = (this_arg_conv->validate_counterparty_revocation)(this_arg_conv->this_arg, idx, secret_ref);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_BaseSign_1sign_1holder_1commitment_1and_1htlcs(JNIEnv *env, jclass clz, int64_t this_arg, int64_t commitment_tx) {
	void* this_arg_ptr = (void*)(((uint64_t)this_arg) & ~1);
	if (!(this_arg & 1)) { CHECK_ACCESS(this_arg_ptr); }
	LDKBaseSign* this_arg_conv = (LDKBaseSign*)this_arg_ptr;
	LDKHolderCommitmentTransaction commitment_tx_conv;
	commitment_tx_conv.inner = (void*)(commitment_tx & (~1));
	commitment_tx_conv.is_owned = false;
	LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ* ret_conv = MALLOC(sizeof(LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ), "LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ");
	*ret_conv = (this_arg_conv->sign_holder_commitment_and_htlcs)(this_arg_conv->this_arg, &commitment_tx_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_BaseSign_1sign_1justice_1revoked_1output(JNIEnv *env, jclass clz, int64_t this_arg, int8_tArray justice_tx, int64_t input, int64_t amount, int8_tArray per_commitment_key) {
	void* this_arg_ptr = (void*)(((uint64_t)this_arg) & ~1);
	if (!(this_arg & 1)) { CHECK_ACCESS(this_arg_ptr); }
	LDKBaseSign* this_arg_conv = (LDKBaseSign*)this_arg_ptr;
	LDKTransaction justice_tx_ref;
	justice_tx_ref.datalen = (*env)->GetArrayLength(env, justice_tx);
	justice_tx_ref.data = MALLOC(justice_tx_ref.datalen, "LDKTransaction Bytes");
	(*env)->GetByteArrayRegion(env, justice_tx, 0, justice_tx_ref.datalen, justice_tx_ref.data);
	justice_tx_ref.data_is_owned = true;
	unsigned char per_commitment_key_arr[32];
	CHECK((*env)->GetArrayLength(env, per_commitment_key) == 32);
	(*env)->GetByteArrayRegion(env, per_commitment_key, 0, 32, per_commitment_key_arr);
	unsigned char (*per_commitment_key_ref)[32] = &per_commitment_key_arr;
	LDKCResult_SignatureNoneZ* ret_conv = MALLOC(sizeof(LDKCResult_SignatureNoneZ), "LDKCResult_SignatureNoneZ");
	*ret_conv = (this_arg_conv->sign_justice_revoked_output)(this_arg_conv->this_arg, justice_tx_ref, input, amount, per_commitment_key_ref);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_BaseSign_1sign_1justice_1revoked_1htlc(JNIEnv *env, jclass clz, int64_t this_arg, int8_tArray justice_tx, int64_t input, int64_t amount, int8_tArray per_commitment_key, int64_t htlc) {
	void* this_arg_ptr = (void*)(((uint64_t)this_arg) & ~1);
	if (!(this_arg & 1)) { CHECK_ACCESS(this_arg_ptr); }
	LDKBaseSign* this_arg_conv = (LDKBaseSign*)this_arg_ptr;
	LDKTransaction justice_tx_ref;
	justice_tx_ref.datalen = (*env)->GetArrayLength(env, justice_tx);
	justice_tx_ref.data = MALLOC(justice_tx_ref.datalen, "LDKTransaction Bytes");
	(*env)->GetByteArrayRegion(env, justice_tx, 0, justice_tx_ref.datalen, justice_tx_ref.data);
	justice_tx_ref.data_is_owned = true;
	unsigned char per_commitment_key_arr[32];
	CHECK((*env)->GetArrayLength(env, per_commitment_key) == 32);
	(*env)->GetByteArrayRegion(env, per_commitment_key, 0, 32, per_commitment_key_arr);
	unsigned char (*per_commitment_key_ref)[32] = &per_commitment_key_arr;
	LDKHTLCOutputInCommitment htlc_conv;
	htlc_conv.inner = (void*)(htlc & (~1));
	htlc_conv.is_owned = false;
	LDKCResult_SignatureNoneZ* ret_conv = MALLOC(sizeof(LDKCResult_SignatureNoneZ), "LDKCResult_SignatureNoneZ");
	*ret_conv = (this_arg_conv->sign_justice_revoked_htlc)(this_arg_conv->this_arg, justice_tx_ref, input, amount, per_commitment_key_ref, &htlc_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_BaseSign_1sign_1counterparty_1htlc_1transaction(JNIEnv *env, jclass clz, int64_t this_arg, int8_tArray htlc_tx, int64_t input, int64_t amount, int8_tArray per_commitment_point, int64_t htlc) {
	void* this_arg_ptr = (void*)(((uint64_t)this_arg) & ~1);
	if (!(this_arg & 1)) { CHECK_ACCESS(this_arg_ptr); }
	LDKBaseSign* this_arg_conv = (LDKBaseSign*)this_arg_ptr;
	LDKTransaction htlc_tx_ref;
	htlc_tx_ref.datalen = (*env)->GetArrayLength(env, htlc_tx);
	htlc_tx_ref.data = MALLOC(htlc_tx_ref.datalen, "LDKTransaction Bytes");
	(*env)->GetByteArrayRegion(env, htlc_tx, 0, htlc_tx_ref.datalen, htlc_tx_ref.data);
	htlc_tx_ref.data_is_owned = true;
	LDKPublicKey per_commitment_point_ref;
	CHECK((*env)->GetArrayLength(env, per_commitment_point) == 33);
	(*env)->GetByteArrayRegion(env, per_commitment_point, 0, 33, per_commitment_point_ref.compressed_form);
	LDKHTLCOutputInCommitment htlc_conv;
	htlc_conv.inner = (void*)(htlc & (~1));
	htlc_conv.is_owned = false;
	LDKCResult_SignatureNoneZ* ret_conv = MALLOC(sizeof(LDKCResult_SignatureNoneZ), "LDKCResult_SignatureNoneZ");
	*ret_conv = (this_arg_conv->sign_counterparty_htlc_transaction)(this_arg_conv->this_arg, htlc_tx_ref, input, amount, per_commitment_point_ref, &htlc_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_BaseSign_1sign_1closing_1transaction(JNIEnv *env, jclass clz, int64_t this_arg, int64_t closing_tx) {
	void* this_arg_ptr = (void*)(((uint64_t)this_arg) & ~1);
	if (!(this_arg & 1)) { CHECK_ACCESS(this_arg_ptr); }
	LDKBaseSign* this_arg_conv = (LDKBaseSign*)this_arg_ptr;
	LDKClosingTransaction closing_tx_conv;
	closing_tx_conv.inner = (void*)(closing_tx & (~1));
	closing_tx_conv.is_owned = false;
	LDKCResult_SignatureNoneZ* ret_conv = MALLOC(sizeof(LDKCResult_SignatureNoneZ), "LDKCResult_SignatureNoneZ");
	*ret_conv = (this_arg_conv->sign_closing_transaction)(this_arg_conv->this_arg, &closing_tx_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_BaseSign_1sign_1channel_1announcement(JNIEnv *env, jclass clz, int64_t this_arg, int64_t msg) {
	void* this_arg_ptr = (void*)(((uint64_t)this_arg) & ~1);
	if (!(this_arg & 1)) { CHECK_ACCESS(this_arg_ptr); }
	LDKBaseSign* this_arg_conv = (LDKBaseSign*)this_arg_ptr;
	LDKUnsignedChannelAnnouncement msg_conv;
	msg_conv.inner = (void*)(msg & (~1));
	msg_conv.is_owned = false;
	LDKCResult_SignatureNoneZ* ret_conv = MALLOC(sizeof(LDKCResult_SignatureNoneZ), "LDKCResult_SignatureNoneZ");
	*ret_conv = (this_arg_conv->sign_channel_announcement)(this_arg_conv->this_arg, &msg_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_BaseSign_1ready_1channel(JNIEnv *env, jclass clz, int64_t this_arg, int64_t channel_parameters) {
	void* this_arg_ptr = (void*)(((uint64_t)this_arg) & ~1);
	if (!(this_arg & 1)) { CHECK_ACCESS(this_arg_ptr); }
	LDKBaseSign* this_arg_conv = (LDKBaseSign*)this_arg_ptr;
	LDKChannelTransactionParameters channel_parameters_conv;
	channel_parameters_conv.inner = (void*)(channel_parameters & (~1));
	channel_parameters_conv.is_owned = false;
	(this_arg_conv->ready_channel)(this_arg_conv->this_arg, &channel_parameters_conv);
}

LDKChannelPublicKeys LDKBaseSign_set_get_pubkeys(LDKBaseSign* this_arg) {
	if (this_arg->set_pubkeys != NULL)
		this_arg->set_pubkeys(this_arg);
	return this_arg->pubkeys;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_BaseSign_1get_1pubkeys(JNIEnv *env, jclass clz, int64_t this_arg) {
	void* this_arg_ptr = (void*)(((uint64_t)this_arg) & ~1);
	if (!(this_arg & 1)) { CHECK_ACCESS(this_arg_ptr); }
	LDKBaseSign* this_arg_conv = (LDKBaseSign*)this_arg_ptr;
	LDKChannelPublicKeys ret_var = LDKBaseSign_set_get_pubkeys(this_arg_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

typedef struct LDKSign_JCalls {
	atomic_size_t refcnt;
	JavaVM *vm;
	jweak o;
	LDKBaseSign_JCalls* BaseSign;
	jmethodID write_meth;
} LDKSign_JCalls;
static void LDKSign_JCalls_free(void* this_arg) {
	LDKSign_JCalls *j_calls = (LDKSign_JCalls*) this_arg;
	if (atomic_fetch_sub_explicit(&j_calls->refcnt, 1, memory_order_acquire) == 1) {
		JNIEnv *env;
		jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
		if (get_jenv_res == JNI_EDETACHED) {
			DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
		} else {
			DO_ASSERT(get_jenv_res == JNI_OK);
		}
		(*env)->DeleteWeakGlobalRef(env, j_calls->o);
		if (get_jenv_res == JNI_EDETACHED) {
			DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
		}
		FREE(j_calls);
	}
}
LDKCVec_u8Z write_LDKSign_jcall(const void* this_arg) {
	LDKSign_JCalls *j_calls = (LDKSign_JCalls*) this_arg;
	JNIEnv *env;
	jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
	} else {
		DO_ASSERT(get_jenv_res == JNI_OK);
	}
	jobject obj = (*env)->NewLocalRef(env, j_calls->o);
	CHECK(obj != NULL);
	int8_tArray ret = (*env)->CallObjectMethod(env, obj, j_calls->write_meth);
	if ((*env)->ExceptionCheck(env)) {
		(*env)->ExceptionDescribe(env);
		(*env)->FatalError(env, "A call to write in LDKSign from rust threw an exception.");
	}
	LDKCVec_u8Z ret_ref;
	ret_ref.datalen = (*env)->GetArrayLength(env, ret);
	ret_ref.data = MALLOC(ret_ref.datalen, "LDKCVec_u8Z Bytes");
	(*env)->GetByteArrayRegion(env, ret, 0, ret_ref.datalen, ret_ref.data);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
	}
	return ret_ref;
}
static void LDKSign_JCalls_cloned(LDKSign* new_obj) {
	LDKSign_JCalls *j_calls = (LDKSign_JCalls*) new_obj->this_arg;
	atomic_fetch_add_explicit(&j_calls->refcnt, 1, memory_order_release);
	atomic_fetch_add_explicit(&j_calls->BaseSign->refcnt, 1, memory_order_release);
}
static inline LDKSign LDKSign_init (JNIEnv *env, jclass clz, jobject o, jobject BaseSign, int64_t pubkeys) {
	jclass c = (*env)->GetObjectClass(env, o);
	CHECK(c != NULL);
	LDKSign_JCalls *calls = MALLOC(sizeof(LDKSign_JCalls), "LDKSign_JCalls");
	atomic_init(&calls->refcnt, 1);
	DO_ASSERT((*env)->GetJavaVM(env, &calls->vm) == 0);
	calls->o = (*env)->NewWeakGlobalRef(env, o);
	calls->write_meth = (*env)->GetMethodID(env, c, "write", "()[B");
	CHECK(calls->write_meth != NULL);

	LDKChannelPublicKeys pubkeys_conv;
	pubkeys_conv.inner = (void*)(pubkeys & (~1));
	pubkeys_conv.is_owned = (pubkeys & 1) || (pubkeys == 0);
	pubkeys_conv = ChannelPublicKeys_clone(&pubkeys_conv);

	LDKSign ret = {
		.this_arg = (void*) calls,
		.write = write_LDKSign_jcall,
		.cloned = LDKSign_JCalls_cloned,
		.free = LDKSign_JCalls_free,
		.BaseSign = LDKBaseSign_init(env, clz, BaseSign, pubkeys),
	};
	calls->BaseSign = ret.BaseSign.this_arg;
	return ret;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKSign_1new(JNIEnv *env, jclass clz, jobject o, jobject BaseSign, int64_t pubkeys) {
	LDKSign *res_ptr = MALLOC(sizeof(LDKSign), "LDKSign");
	*res_ptr = LDKSign_init(env, clz, o, BaseSign, pubkeys);
	return (uint64_t)res_ptr;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKSign_1get_1BaseSign(JNIEnv *env, jclass clz, int64_t arg) {
	LDKSign *inp = (LDKSign *)(arg & ~1);
	uint64_t res_ptr = (uint64_t)&inp->BaseSign;
	DO_ASSERT((res_ptr & 1) == 0);
	return (int64_t)(res_ptr | 1);
}
JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_Sign_1write(JNIEnv *env, jclass clz, int64_t this_arg) {
	void* this_arg_ptr = (void*)(((uint64_t)this_arg) & ~1);
	if (!(this_arg & 1)) { CHECK_ACCESS(this_arg_ptr); }
	LDKSign* this_arg_conv = (LDKSign*)this_arg_ptr;
	LDKCVec_u8Z ret_var = (this_arg_conv->write)(this_arg_conv->this_arg);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	CVec_u8Z_free(ret_var);
	return ret_arr;
}

JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1SignDecodeErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_SignDecodeErrorZ*)arg)->result_ok;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1SignDecodeErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_SignDecodeErrorZ *val = (LDKCResult_SignDecodeErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	LDKSign* res_ret = MALLOC(sizeof(LDKSign), "LDKSign");
	*res_ret = Sign_clone(&(*val->contents.result));
	return (uint64_t)res_ret;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1SignDecodeErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_SignDecodeErrorZ *val = (LDKCResult_SignDecodeErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	LDKDecodeError err_var = (*val->contents.err);
	uint64_t err_ref = 0;
	CHECK((((uint64_t)err_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&err_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	err_ref = (uint64_t)err_var.inner & ~1;
	return err_ref;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1RecoverableSignatureNoneZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_RecoverableSignatureNoneZ*)arg)->result_ok;
}
JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_LDKCResult_1RecoverableSignatureNoneZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_RecoverableSignatureNoneZ *val = (LDKCResult_RecoverableSignatureNoneZ*)(arg & ~1);
	CHECK(val->result_ok);
	int8_tArray es_arr = (*env)->NewByteArray(env, 68);
	(*env)->SetByteArrayRegion(env, es_arr, 0, 68, (*val->contents.result).serialized_form);
	return es_arr;
}
JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_LDKCResult_1RecoverableSignatureNoneZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_RecoverableSignatureNoneZ *val = (LDKCResult_RecoverableSignatureNoneZ*)(arg & ~1);
	CHECK(!val->result_ok);
	return *val->contents.err;
}
static inline LDKCVec_CVec_u8ZZ CVec_CVec_u8ZZ_clone(const LDKCVec_CVec_u8ZZ *orig) {
	LDKCVec_CVec_u8ZZ ret = { .data = MALLOC(sizeof(LDKCVec_u8Z) * orig->datalen, "LDKCVec_CVec_u8ZZ clone bytes"), .datalen = orig->datalen };
	for (size_t i = 0; i < ret.datalen; i++) {
		ret.data[i] = CVec_u8Z_clone(&orig->data[i]);
	}
	return ret;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1CVec_1CVec_1u8ZZNoneZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_CVec_CVec_u8ZZNoneZ*)arg)->result_ok;
}
JNIEXPORT jobjectArray JNICALL Java_org_ldk_impl_bindings_LDKCResult_1CVec_1CVec_1u8ZZNoneZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_CVec_CVec_u8ZZNoneZ *val = (LDKCResult_CVec_CVec_u8ZZNoneZ*)(arg & ~1);
	CHECK(val->result_ok);
	LDKCVec_CVec_u8ZZ res_var = (*val->contents.result);
	jobjectArray res_arr = NULL;
	res_arr = (*env)->NewObjectArray(env, res_var.datalen, arr_of_B_clz, NULL);
	;
	for (size_t i = 0; i < res_var.datalen; i++) {
		LDKCVec_u8Z res_conv_8_var = res_var.data[i];
		int8_tArray res_conv_8_arr = (*env)->NewByteArray(env, res_conv_8_var.datalen);
		(*env)->SetByteArrayRegion(env, res_conv_8_arr, 0, res_conv_8_var.datalen, res_conv_8_var.data);
		(*env)->SetObjectArrayElement(env, res_arr, i, res_conv_8_arr);
	}
	
	return res_arr;
}
JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_LDKCResult_1CVec_1CVec_1u8ZZNoneZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_CVec_CVec_u8ZZNoneZ *val = (LDKCResult_CVec_CVec_u8ZZNoneZ*)(arg & ~1);
	CHECK(!val->result_ok);
	return *val->contents.err;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1InMemorySignerDecodeErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_InMemorySignerDecodeErrorZ*)arg)->result_ok;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1InMemorySignerDecodeErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_InMemorySignerDecodeErrorZ *val = (LDKCResult_InMemorySignerDecodeErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	LDKInMemorySigner res_var = (*val->contents.result);
	uint64_t res_ref = 0;
	CHECK((((uint64_t)res_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&res_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	res_ref = (uint64_t)res_var.inner & ~1;
	return res_ref;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1InMemorySignerDecodeErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_InMemorySignerDecodeErrorZ *val = (LDKCResult_InMemorySignerDecodeErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	LDKDecodeError err_var = (*val->contents.err);
	uint64_t err_ref = 0;
	CHECK((((uint64_t)err_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&err_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	err_ref = (uint64_t)err_var.inner & ~1;
	return err_ref;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCVec_1TxOutZ_1new(JNIEnv *env, jclass clz, int64_tArray elems) {
	LDKCVec_TxOutZ *ret = MALLOC(sizeof(LDKCVec_TxOutZ), "LDKCVec_TxOutZ");
	ret->datalen = (*env)->GetArrayLength(env, elems);
	if (ret->datalen == 0) {
		ret->data = NULL;
	} else {
		ret->data = MALLOC(sizeof(LDKTxOut) * ret->datalen, "LDKCVec_TxOutZ Data");
		int64_t *java_elems = (*env)->GetPrimitiveArrayCritical(env, elems, NULL);
		for (size_t i = 0; i < ret->datalen; i++) {
			int64_t arr_elem = java_elems[i];
			void* arr_elem_ptr = (void*)(((uint64_t)arr_elem) & ~1);
			CHECK_ACCESS(arr_elem_ptr);
			LDKTxOut arr_elem_conv = *(LDKTxOut*)(arr_elem_ptr);
			arr_elem_conv = TxOut_clone((LDKTxOut*)(((uint64_t)arr_elem) & ~1));
			ret->data[i] = arr_elem_conv;
		}
		(*env)->ReleasePrimitiveArrayCritical(env, elems, java_elems, 0);
	}
	return (uint64_t)ret;
}
static inline LDKCVec_TxOutZ CVec_TxOutZ_clone(const LDKCVec_TxOutZ *orig) {
	LDKCVec_TxOutZ ret = { .data = MALLOC(sizeof(LDKTxOut) * orig->datalen, "LDKCVec_TxOutZ clone bytes"), .datalen = orig->datalen };
	for (size_t i = 0; i < ret.datalen; i++) {
		ret.data[i] = TxOut_clone(&orig->data[i]);
	}
	return ret;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1TransactionNoneZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_TransactionNoneZ*)arg)->result_ok;
}
JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_LDKCResult_1TransactionNoneZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_TransactionNoneZ *val = (LDKCResult_TransactionNoneZ*)(arg & ~1);
	CHECK(val->result_ok);
	LDKTransaction res_var = (*val->contents.result);
	int8_tArray res_arr = (*env)->NewByteArray(env, res_var.datalen);
	(*env)->SetByteArrayRegion(env, res_arr, 0, res_var.datalen, res_var.data);
	return res_arr;
}
JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_LDKCResult_1TransactionNoneZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_TransactionNoneZ *val = (LDKCResult_TransactionNoneZ*)(arg & ~1);
	CHECK(!val->result_ok);
	return *val->contents.err;
}
static inline struct LDKThirtyTwoBytes C2Tuple_BlockHashChannelMonitorZ_get_a(LDKC2Tuple_BlockHashChannelMonitorZ *NONNULL_PTR tuple){
	return ThirtyTwoBytes_clone(&tuple->a);
}
JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_C2Tuple_1BlockHashChannelMonitorZ_1get_1a(JNIEnv *env, jclass clz, int64_t tuple) {
	LDKC2Tuple_BlockHashChannelMonitorZ* tuple_conv = (LDKC2Tuple_BlockHashChannelMonitorZ*)(tuple & ~1);
	int8_tArray ret_arr = (*env)->NewByteArray(env, 32);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 32, C2Tuple_BlockHashChannelMonitorZ_get_a(tuple_conv).data);
	return ret_arr;
}

static inline struct LDKChannelMonitor C2Tuple_BlockHashChannelMonitorZ_get_b(LDKC2Tuple_BlockHashChannelMonitorZ *NONNULL_PTR tuple){
	return ChannelMonitor_clone(&tuple->b);
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_C2Tuple_1BlockHashChannelMonitorZ_1get_1b(JNIEnv *env, jclass clz, int64_t tuple) {
	LDKC2Tuple_BlockHashChannelMonitorZ* tuple_conv = (LDKC2Tuple_BlockHashChannelMonitorZ*)(tuple & ~1);
	LDKChannelMonitor ret_var = C2Tuple_BlockHashChannelMonitorZ_get_b(tuple_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCVec_1C2Tuple_1BlockHashChannelMonitorZZ_1new(JNIEnv *env, jclass clz, int64_tArray elems) {
	LDKCVec_C2Tuple_BlockHashChannelMonitorZZ *ret = MALLOC(sizeof(LDKCVec_C2Tuple_BlockHashChannelMonitorZZ), "LDKCVec_C2Tuple_BlockHashChannelMonitorZZ");
	ret->datalen = (*env)->GetArrayLength(env, elems);
	if (ret->datalen == 0) {
		ret->data = NULL;
	} else {
		ret->data = MALLOC(sizeof(LDKC2Tuple_BlockHashChannelMonitorZ) * ret->datalen, "LDKCVec_C2Tuple_BlockHashChannelMonitorZZ Data");
		int64_t *java_elems = (*env)->GetPrimitiveArrayCritical(env, elems, NULL);
		for (size_t i = 0; i < ret->datalen; i++) {
			int64_t arr_elem = java_elems[i];
			void* arr_elem_ptr = (void*)(((uint64_t)arr_elem) & ~1);
			CHECK_ACCESS(arr_elem_ptr);
			LDKC2Tuple_BlockHashChannelMonitorZ arr_elem_conv = *(LDKC2Tuple_BlockHashChannelMonitorZ*)(arr_elem_ptr);
			arr_elem_conv = C2Tuple_BlockHashChannelMonitorZ_clone((LDKC2Tuple_BlockHashChannelMonitorZ*)(((uint64_t)arr_elem) & ~1));
			ret->data[i] = arr_elem_conv;
		}
		(*env)->ReleasePrimitiveArrayCritical(env, elems, java_elems, 0);
	}
	return (uint64_t)ret;
}
static inline LDKCVec_C2Tuple_BlockHashChannelMonitorZZ CVec_C2Tuple_BlockHashChannelMonitorZZ_clone(const LDKCVec_C2Tuple_BlockHashChannelMonitorZZ *orig) {
	LDKCVec_C2Tuple_BlockHashChannelMonitorZZ ret = { .data = MALLOC(sizeof(LDKC2Tuple_BlockHashChannelMonitorZ) * orig->datalen, "LDKCVec_C2Tuple_BlockHashChannelMonitorZZ clone bytes"), .datalen = orig->datalen };
	for (size_t i = 0; i < ret.datalen; i++) {
		ret.data[i] = C2Tuple_BlockHashChannelMonitorZ_clone(&orig->data[i]);
	}
	return ret;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1CVec_1C2Tuple_1BlockHashChannelMonitorZZErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ*)arg)->result_ok;
}
JNIEXPORT int64_tArray JNICALL Java_org_ldk_impl_bindings_LDKCResult_1CVec_1C2Tuple_1BlockHashChannelMonitorZZErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ *val = (LDKCResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	LDKCVec_C2Tuple_BlockHashChannelMonitorZZ res_var = (*val->contents.result);
	int64_tArray res_arr = NULL;
	res_arr = (*env)->NewLongArray(env, res_var.datalen);
	int64_t *res_arr_ptr = (*env)->GetPrimitiveArrayCritical(env, res_arr, NULL);
	for (size_t j = 0; j < res_var.datalen; j++) {
		LDKC2Tuple_BlockHashChannelMonitorZ* res_conv_35_conv = MALLOC(sizeof(LDKC2Tuple_BlockHashChannelMonitorZ), "LDKC2Tuple_BlockHashChannelMonitorZ");
		*res_conv_35_conv = res_var.data[j];
		*res_conv_35_conv = C2Tuple_BlockHashChannelMonitorZ_clone(res_conv_35_conv);
		res_arr_ptr[j] = ((uint64_t)res_conv_35_conv);
	}
	(*env)->ReleasePrimitiveArrayCritical(env, res_arr, res_arr_ptr, 0);
	return res_arr;
}
JNIEXPORT jclass JNICALL Java_org_ldk_impl_bindings_LDKCResult_1CVec_1C2Tuple_1BlockHashChannelMonitorZZErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ *val = (LDKCResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	jclass err_conv = LDKIOError_to_java(env, (*val->contents.err));
	return err_conv;
}
static jclass LDKCOption_u16Z_Some_class = NULL;
static jmethodID LDKCOption_u16Z_Some_meth = NULL;
static jclass LDKCOption_u16Z_None_class = NULL;
static jmethodID LDKCOption_u16Z_None_meth = NULL;
JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_00024LDKCOption_1u16Z_init (JNIEnv *env, jclass clz) {
	LDKCOption_u16Z_Some_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKCOption_u16Z$Some;"));
	CHECK(LDKCOption_u16Z_Some_class != NULL);
	LDKCOption_u16Z_Some_meth = (*env)->GetMethodID(env, LDKCOption_u16Z_Some_class, "<init>", "(S)V");
	CHECK(LDKCOption_u16Z_Some_meth != NULL);
	LDKCOption_u16Z_None_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKCOption_u16Z$None;"));
	CHECK(LDKCOption_u16Z_None_class != NULL);
	LDKCOption_u16Z_None_meth = (*env)->GetMethodID(env, LDKCOption_u16Z_None_class, "<init>", "()V");
	CHECK(LDKCOption_u16Z_None_meth != NULL);
}
JNIEXPORT jobject JNICALL Java_org_ldk_impl_bindings_LDKCOption_1u16Z_1ref_1from_1ptr(JNIEnv *env, jclass clz, int64_t ptr) {
	LDKCOption_u16Z *obj = (LDKCOption_u16Z*)(ptr & ~1);
	switch(obj->tag) {
		case LDKCOption_u16Z_Some: {
			return (*env)->NewObject(env, LDKCOption_u16Z_Some_class, LDKCOption_u16Z_Some_meth, obj->some);
		}
		case LDKCOption_u16Z_None: {
			return (*env)->NewObject(env, LDKCOption_u16Z_None_class, LDKCOption_u16Z_None_meth);
		}
		default: abort();
	}
}
static jclass LDKAPIError_APIMisuseError_class = NULL;
static jmethodID LDKAPIError_APIMisuseError_meth = NULL;
static jclass LDKAPIError_FeeRateTooHigh_class = NULL;
static jmethodID LDKAPIError_FeeRateTooHigh_meth = NULL;
static jclass LDKAPIError_RouteError_class = NULL;
static jmethodID LDKAPIError_RouteError_meth = NULL;
static jclass LDKAPIError_ChannelUnavailable_class = NULL;
static jmethodID LDKAPIError_ChannelUnavailable_meth = NULL;
static jclass LDKAPIError_MonitorUpdateFailed_class = NULL;
static jmethodID LDKAPIError_MonitorUpdateFailed_meth = NULL;
static jclass LDKAPIError_IncompatibleShutdownScript_class = NULL;
static jmethodID LDKAPIError_IncompatibleShutdownScript_meth = NULL;
JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_00024LDKAPIError_init (JNIEnv *env, jclass clz) {
	LDKAPIError_APIMisuseError_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKAPIError$APIMisuseError;"));
	CHECK(LDKAPIError_APIMisuseError_class != NULL);
	LDKAPIError_APIMisuseError_meth = (*env)->GetMethodID(env, LDKAPIError_APIMisuseError_class, "<init>", "(Ljava/lang/String;)V");
	CHECK(LDKAPIError_APIMisuseError_meth != NULL);
	LDKAPIError_FeeRateTooHigh_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKAPIError$FeeRateTooHigh;"));
	CHECK(LDKAPIError_FeeRateTooHigh_class != NULL);
	LDKAPIError_FeeRateTooHigh_meth = (*env)->GetMethodID(env, LDKAPIError_FeeRateTooHigh_class, "<init>", "(Ljava/lang/String;I)V");
	CHECK(LDKAPIError_FeeRateTooHigh_meth != NULL);
	LDKAPIError_RouteError_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKAPIError$RouteError;"));
	CHECK(LDKAPIError_RouteError_class != NULL);
	LDKAPIError_RouteError_meth = (*env)->GetMethodID(env, LDKAPIError_RouteError_class, "<init>", "(Ljava/lang/String;)V");
	CHECK(LDKAPIError_RouteError_meth != NULL);
	LDKAPIError_ChannelUnavailable_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKAPIError$ChannelUnavailable;"));
	CHECK(LDKAPIError_ChannelUnavailable_class != NULL);
	LDKAPIError_ChannelUnavailable_meth = (*env)->GetMethodID(env, LDKAPIError_ChannelUnavailable_class, "<init>", "(Ljava/lang/String;)V");
	CHECK(LDKAPIError_ChannelUnavailable_meth != NULL);
	LDKAPIError_MonitorUpdateFailed_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKAPIError$MonitorUpdateFailed;"));
	CHECK(LDKAPIError_MonitorUpdateFailed_class != NULL);
	LDKAPIError_MonitorUpdateFailed_meth = (*env)->GetMethodID(env, LDKAPIError_MonitorUpdateFailed_class, "<init>", "()V");
	CHECK(LDKAPIError_MonitorUpdateFailed_meth != NULL);
	LDKAPIError_IncompatibleShutdownScript_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKAPIError$IncompatibleShutdownScript;"));
	CHECK(LDKAPIError_IncompatibleShutdownScript_class != NULL);
	LDKAPIError_IncompatibleShutdownScript_meth = (*env)->GetMethodID(env, LDKAPIError_IncompatibleShutdownScript_class, "<init>", "(J)V");
	CHECK(LDKAPIError_IncompatibleShutdownScript_meth != NULL);
}
JNIEXPORT jobject JNICALL Java_org_ldk_impl_bindings_LDKAPIError_1ref_1from_1ptr(JNIEnv *env, jclass clz, int64_t ptr) {
	LDKAPIError *obj = (LDKAPIError*)(ptr & ~1);
	switch(obj->tag) {
		case LDKAPIError_APIMisuseError: {
			LDKStr err_str = obj->api_misuse_error.err;
			jstring err_conv = str_ref_to_java(env, err_str.chars, err_str.len);
			return (*env)->NewObject(env, LDKAPIError_APIMisuseError_class, LDKAPIError_APIMisuseError_meth, err_conv);
		}
		case LDKAPIError_FeeRateTooHigh: {
			LDKStr err_str = obj->fee_rate_too_high.err;
			jstring err_conv = str_ref_to_java(env, err_str.chars, err_str.len);
			return (*env)->NewObject(env, LDKAPIError_FeeRateTooHigh_class, LDKAPIError_FeeRateTooHigh_meth, err_conv, obj->fee_rate_too_high.feerate);
		}
		case LDKAPIError_RouteError: {
			LDKStr err_str = obj->route_error.err;
			jstring err_conv = str_ref_to_java(env, err_str.chars, err_str.len);
			return (*env)->NewObject(env, LDKAPIError_RouteError_class, LDKAPIError_RouteError_meth, err_conv);
		}
		case LDKAPIError_ChannelUnavailable: {
			LDKStr err_str = obj->channel_unavailable.err;
			jstring err_conv = str_ref_to_java(env, err_str.chars, err_str.len);
			return (*env)->NewObject(env, LDKAPIError_ChannelUnavailable_class, LDKAPIError_ChannelUnavailable_meth, err_conv);
		}
		case LDKAPIError_MonitorUpdateFailed: {
			return (*env)->NewObject(env, LDKAPIError_MonitorUpdateFailed_class, LDKAPIError_MonitorUpdateFailed_meth);
		}
		case LDKAPIError_IncompatibleShutdownScript: {
			LDKShutdownScript script_var = obj->incompatible_shutdown_script.script;
			uint64_t script_ref = 0;
			CHECK((((uint64_t)script_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
			CHECK((((uint64_t)&script_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
			script_ref = (uint64_t)script_var.inner & ~1;
			return (*env)->NewObject(env, LDKAPIError_IncompatibleShutdownScript_class, LDKAPIError_IncompatibleShutdownScript_meth, script_ref);
		}
		default: abort();
	}
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1NoneAPIErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_NoneAPIErrorZ*)arg)->result_ok;
}
JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_LDKCResult_1NoneAPIErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_NoneAPIErrorZ *val = (LDKCResult_NoneAPIErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	return *val->contents.result;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1NoneAPIErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_NoneAPIErrorZ *val = (LDKCResult_NoneAPIErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	uint64_t err_ref = ((uint64_t)&(*val->contents.err)) | 1;
	return err_ref;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCVec_1CResult_1NoneAPIErrorZZ_1new(JNIEnv *env, jclass clz, int64_tArray elems) {
	LDKCVec_CResult_NoneAPIErrorZZ *ret = MALLOC(sizeof(LDKCVec_CResult_NoneAPIErrorZZ), "LDKCVec_CResult_NoneAPIErrorZZ");
	ret->datalen = (*env)->GetArrayLength(env, elems);
	if (ret->datalen == 0) {
		ret->data = NULL;
	} else {
		ret->data = MALLOC(sizeof(LDKCResult_NoneAPIErrorZ) * ret->datalen, "LDKCVec_CResult_NoneAPIErrorZZ Data");
		int64_t *java_elems = (*env)->GetPrimitiveArrayCritical(env, elems, NULL);
		for (size_t i = 0; i < ret->datalen; i++) {
			int64_t arr_elem = java_elems[i];
			void* arr_elem_ptr = (void*)(((uint64_t)arr_elem) & ~1);
			CHECK_ACCESS(arr_elem_ptr);
			LDKCResult_NoneAPIErrorZ arr_elem_conv = *(LDKCResult_NoneAPIErrorZ*)(arr_elem_ptr);
			arr_elem_conv = CResult_NoneAPIErrorZ_clone((LDKCResult_NoneAPIErrorZ*)(((uint64_t)arr_elem) & ~1));
			ret->data[i] = arr_elem_conv;
		}
		(*env)->ReleasePrimitiveArrayCritical(env, elems, java_elems, 0);
	}
	return (uint64_t)ret;
}
static inline LDKCVec_CResult_NoneAPIErrorZZ CVec_CResult_NoneAPIErrorZZ_clone(const LDKCVec_CResult_NoneAPIErrorZZ *orig) {
	LDKCVec_CResult_NoneAPIErrorZZ ret = { .data = MALLOC(sizeof(LDKCResult_NoneAPIErrorZ) * orig->datalen, "LDKCVec_CResult_NoneAPIErrorZZ clone bytes"), .datalen = orig->datalen };
	for (size_t i = 0; i < ret.datalen; i++) {
		ret.data[i] = CResult_NoneAPIErrorZ_clone(&orig->data[i]);
	}
	return ret;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCVec_1APIErrorZ_1new(JNIEnv *env, jclass clz, int64_tArray elems) {
	LDKCVec_APIErrorZ *ret = MALLOC(sizeof(LDKCVec_APIErrorZ), "LDKCVec_APIErrorZ");
	ret->datalen = (*env)->GetArrayLength(env, elems);
	if (ret->datalen == 0) {
		ret->data = NULL;
	} else {
		ret->data = MALLOC(sizeof(LDKAPIError) * ret->datalen, "LDKCVec_APIErrorZ Data");
		int64_t *java_elems = (*env)->GetPrimitiveArrayCritical(env, elems, NULL);
		for (size_t i = 0; i < ret->datalen; i++) {
			int64_t arr_elem = java_elems[i];
			void* arr_elem_ptr = (void*)(((uint64_t)arr_elem) & ~1);
			CHECK_ACCESS(arr_elem_ptr);
			LDKAPIError arr_elem_conv = *(LDKAPIError*)(arr_elem_ptr);
			arr_elem_conv = APIError_clone((LDKAPIError*)(((uint64_t)arr_elem) & ~1));
			ret->data[i] = arr_elem_conv;
		}
		(*env)->ReleasePrimitiveArrayCritical(env, elems, java_elems, 0);
	}
	return (uint64_t)ret;
}
static inline LDKCVec_APIErrorZ CVec_APIErrorZ_clone(const LDKCVec_APIErrorZ *orig) {
	LDKCVec_APIErrorZ ret = { .data = MALLOC(sizeof(LDKAPIError) * orig->datalen, "LDKCVec_APIErrorZ clone bytes"), .datalen = orig->datalen };
	for (size_t i = 0; i < ret.datalen; i++) {
		ret.data[i] = APIError_clone(&orig->data[i]);
	}
	return ret;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1_1u832APIErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult__u832APIErrorZ*)arg)->result_ok;
}
JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_LDKCResult_1_1u832APIErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult__u832APIErrorZ *val = (LDKCResult__u832APIErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	int8_tArray res_arr = (*env)->NewByteArray(env, 32);
	(*env)->SetByteArrayRegion(env, res_arr, 0, 32, (*val->contents.result).data);
	return res_arr;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1_1u832APIErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult__u832APIErrorZ *val = (LDKCResult__u832APIErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	uint64_t err_ref = ((uint64_t)&(*val->contents.err)) | 1;
	return err_ref;
}
static jclass LDKPaymentSendFailure_ParameterError_class = NULL;
static jmethodID LDKPaymentSendFailure_ParameterError_meth = NULL;
static jclass LDKPaymentSendFailure_PathParameterError_class = NULL;
static jmethodID LDKPaymentSendFailure_PathParameterError_meth = NULL;
static jclass LDKPaymentSendFailure_AllFailedRetrySafe_class = NULL;
static jmethodID LDKPaymentSendFailure_AllFailedRetrySafe_meth = NULL;
static jclass LDKPaymentSendFailure_PartialFailure_class = NULL;
static jmethodID LDKPaymentSendFailure_PartialFailure_meth = NULL;
JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_00024LDKPaymentSendFailure_init (JNIEnv *env, jclass clz) {
	LDKPaymentSendFailure_ParameterError_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKPaymentSendFailure$ParameterError;"));
	CHECK(LDKPaymentSendFailure_ParameterError_class != NULL);
	LDKPaymentSendFailure_ParameterError_meth = (*env)->GetMethodID(env, LDKPaymentSendFailure_ParameterError_class, "<init>", "(J)V");
	CHECK(LDKPaymentSendFailure_ParameterError_meth != NULL);
	LDKPaymentSendFailure_PathParameterError_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKPaymentSendFailure$PathParameterError;"));
	CHECK(LDKPaymentSendFailure_PathParameterError_class != NULL);
	LDKPaymentSendFailure_PathParameterError_meth = (*env)->GetMethodID(env, LDKPaymentSendFailure_PathParameterError_class, "<init>", "([J)V");
	CHECK(LDKPaymentSendFailure_PathParameterError_meth != NULL);
	LDKPaymentSendFailure_AllFailedRetrySafe_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKPaymentSendFailure$AllFailedRetrySafe;"));
	CHECK(LDKPaymentSendFailure_AllFailedRetrySafe_class != NULL);
	LDKPaymentSendFailure_AllFailedRetrySafe_meth = (*env)->GetMethodID(env, LDKPaymentSendFailure_AllFailedRetrySafe_class, "<init>", "([J)V");
	CHECK(LDKPaymentSendFailure_AllFailedRetrySafe_meth != NULL);
	LDKPaymentSendFailure_PartialFailure_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKPaymentSendFailure$PartialFailure;"));
	CHECK(LDKPaymentSendFailure_PartialFailure_class != NULL);
	LDKPaymentSendFailure_PartialFailure_meth = (*env)->GetMethodID(env, LDKPaymentSendFailure_PartialFailure_class, "<init>", "([JJ[B)V");
	CHECK(LDKPaymentSendFailure_PartialFailure_meth != NULL);
}
JNIEXPORT jobject JNICALL Java_org_ldk_impl_bindings_LDKPaymentSendFailure_1ref_1from_1ptr(JNIEnv *env, jclass clz, int64_t ptr) {
	LDKPaymentSendFailure *obj = (LDKPaymentSendFailure*)(ptr & ~1);
	switch(obj->tag) {
		case LDKPaymentSendFailure_ParameterError: {
			uint64_t parameter_error_ref = ((uint64_t)&obj->parameter_error) | 1;
			return (*env)->NewObject(env, LDKPaymentSendFailure_ParameterError_class, LDKPaymentSendFailure_ParameterError_meth, parameter_error_ref);
		}
		case LDKPaymentSendFailure_PathParameterError: {
			LDKCVec_CResult_NoneAPIErrorZZ path_parameter_error_var = obj->path_parameter_error;
			int64_tArray path_parameter_error_arr = NULL;
			path_parameter_error_arr = (*env)->NewLongArray(env, path_parameter_error_var.datalen);
			int64_t *path_parameter_error_arr_ptr = (*env)->GetPrimitiveArrayCritical(env, path_parameter_error_arr, NULL);
			for (size_t w = 0; w < path_parameter_error_var.datalen; w++) {
				LDKCResult_NoneAPIErrorZ* path_parameter_error_conv_22_conv = MALLOC(sizeof(LDKCResult_NoneAPIErrorZ), "LDKCResult_NoneAPIErrorZ");
				*path_parameter_error_conv_22_conv = path_parameter_error_var.data[w];
				*path_parameter_error_conv_22_conv = CResult_NoneAPIErrorZ_clone(path_parameter_error_conv_22_conv);
				path_parameter_error_arr_ptr[w] = (uint64_t)path_parameter_error_conv_22_conv;
			}
			(*env)->ReleasePrimitiveArrayCritical(env, path_parameter_error_arr, path_parameter_error_arr_ptr, 0);
			return (*env)->NewObject(env, LDKPaymentSendFailure_PathParameterError_class, LDKPaymentSendFailure_PathParameterError_meth, path_parameter_error_arr);
		}
		case LDKPaymentSendFailure_AllFailedRetrySafe: {
			LDKCVec_APIErrorZ all_failed_retry_safe_var = obj->all_failed_retry_safe;
			int64_tArray all_failed_retry_safe_arr = NULL;
			all_failed_retry_safe_arr = (*env)->NewLongArray(env, all_failed_retry_safe_var.datalen);
			int64_t *all_failed_retry_safe_arr_ptr = (*env)->GetPrimitiveArrayCritical(env, all_failed_retry_safe_arr, NULL);
			for (size_t k = 0; k < all_failed_retry_safe_var.datalen; k++) {
				uint64_t all_failed_retry_safe_conv_10_ref = ((uint64_t)&all_failed_retry_safe_var.data[k]) | 1;
				all_failed_retry_safe_arr_ptr[k] = all_failed_retry_safe_conv_10_ref;
			}
			(*env)->ReleasePrimitiveArrayCritical(env, all_failed_retry_safe_arr, all_failed_retry_safe_arr_ptr, 0);
			return (*env)->NewObject(env, LDKPaymentSendFailure_AllFailedRetrySafe_class, LDKPaymentSendFailure_AllFailedRetrySafe_meth, all_failed_retry_safe_arr);
		}
		case LDKPaymentSendFailure_PartialFailure: {
			LDKCVec_CResult_NoneAPIErrorZZ results_var = obj->partial_failure.results;
			int64_tArray results_arr = NULL;
			results_arr = (*env)->NewLongArray(env, results_var.datalen);
			int64_t *results_arr_ptr = (*env)->GetPrimitiveArrayCritical(env, results_arr, NULL);
			for (size_t w = 0; w < results_var.datalen; w++) {
				LDKCResult_NoneAPIErrorZ* results_conv_22_conv = MALLOC(sizeof(LDKCResult_NoneAPIErrorZ), "LDKCResult_NoneAPIErrorZ");
				*results_conv_22_conv = results_var.data[w];
				*results_conv_22_conv = CResult_NoneAPIErrorZ_clone(results_conv_22_conv);
				results_arr_ptr[w] = (uint64_t)results_conv_22_conv;
			}
			(*env)->ReleasePrimitiveArrayCritical(env, results_arr, results_arr_ptr, 0);
			LDKRouteParameters failed_paths_retry_var = obj->partial_failure.failed_paths_retry;
			uint64_t failed_paths_retry_ref = 0;
			CHECK((((uint64_t)failed_paths_retry_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
			CHECK((((uint64_t)&failed_paths_retry_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
			failed_paths_retry_ref = (uint64_t)failed_paths_retry_var.inner & ~1;
			int8_tArray payment_id_arr = (*env)->NewByteArray(env, 32);
			(*env)->SetByteArrayRegion(env, payment_id_arr, 0, 32, obj->partial_failure.payment_id.data);
			return (*env)->NewObject(env, LDKPaymentSendFailure_PartialFailure_class, LDKPaymentSendFailure_PartialFailure_meth, results_arr, failed_paths_retry_ref, payment_id_arr);
		}
		default: abort();
	}
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1PaymentIdPaymentSendFailureZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_PaymentIdPaymentSendFailureZ*)arg)->result_ok;
}
JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_LDKCResult_1PaymentIdPaymentSendFailureZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_PaymentIdPaymentSendFailureZ *val = (LDKCResult_PaymentIdPaymentSendFailureZ*)(arg & ~1);
	CHECK(val->result_ok);
	int8_tArray res_arr = (*env)->NewByteArray(env, 32);
	(*env)->SetByteArrayRegion(env, res_arr, 0, 32, (*val->contents.result).data);
	return res_arr;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1PaymentIdPaymentSendFailureZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_PaymentIdPaymentSendFailureZ *val = (LDKCResult_PaymentIdPaymentSendFailureZ*)(arg & ~1);
	CHECK(!val->result_ok);
	uint64_t err_ref = ((uint64_t)&(*val->contents.err)) | 1;
	return err_ref;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1NonePaymentSendFailureZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_NonePaymentSendFailureZ*)arg)->result_ok;
}
JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_LDKCResult_1NonePaymentSendFailureZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_NonePaymentSendFailureZ *val = (LDKCResult_NonePaymentSendFailureZ*)(arg & ~1);
	CHECK(val->result_ok);
	return *val->contents.result;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1NonePaymentSendFailureZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_NonePaymentSendFailureZ *val = (LDKCResult_NonePaymentSendFailureZ*)(arg & ~1);
	CHECK(!val->result_ok);
	uint64_t err_ref = ((uint64_t)&(*val->contents.err)) | 1;
	return err_ref;
}
static inline struct LDKThirtyTwoBytes C2Tuple_PaymentHashPaymentIdZ_get_a(LDKC2Tuple_PaymentHashPaymentIdZ *NONNULL_PTR tuple){
	return ThirtyTwoBytes_clone(&tuple->a);
}
JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_C2Tuple_1PaymentHashPaymentIdZ_1get_1a(JNIEnv *env, jclass clz, int64_t tuple) {
	LDKC2Tuple_PaymentHashPaymentIdZ* tuple_conv = (LDKC2Tuple_PaymentHashPaymentIdZ*)(tuple & ~1);
	int8_tArray ret_arr = (*env)->NewByteArray(env, 32);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 32, C2Tuple_PaymentHashPaymentIdZ_get_a(tuple_conv).data);
	return ret_arr;
}

static inline struct LDKThirtyTwoBytes C2Tuple_PaymentHashPaymentIdZ_get_b(LDKC2Tuple_PaymentHashPaymentIdZ *NONNULL_PTR tuple){
	return ThirtyTwoBytes_clone(&tuple->b);
}
JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_C2Tuple_1PaymentHashPaymentIdZ_1get_1b(JNIEnv *env, jclass clz, int64_t tuple) {
	LDKC2Tuple_PaymentHashPaymentIdZ* tuple_conv = (LDKC2Tuple_PaymentHashPaymentIdZ*)(tuple & ~1);
	int8_tArray ret_arr = (*env)->NewByteArray(env, 32);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 32, C2Tuple_PaymentHashPaymentIdZ_get_b(tuple_conv).data);
	return ret_arr;
}

JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1C2Tuple_1PaymentHashPaymentIdZPaymentSendFailureZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ*)arg)->result_ok;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1C2Tuple_1PaymentHashPaymentIdZPaymentSendFailureZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ *val = (LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ*)(arg & ~1);
	CHECK(val->result_ok);
	LDKC2Tuple_PaymentHashPaymentIdZ* res_conv = MALLOC(sizeof(LDKC2Tuple_PaymentHashPaymentIdZ), "LDKC2Tuple_PaymentHashPaymentIdZ");
	*res_conv = (*val->contents.result);
	*res_conv = C2Tuple_PaymentHashPaymentIdZ_clone(res_conv);
	return ((uint64_t)res_conv);
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1C2Tuple_1PaymentHashPaymentIdZPaymentSendFailureZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ *val = (LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ*)(arg & ~1);
	CHECK(!val->result_ok);
	uint64_t err_ref = ((uint64_t)&(*val->contents.err)) | 1;
	return err_ref;
}
static jclass LDKNetAddress_IPv4_class = NULL;
static jmethodID LDKNetAddress_IPv4_meth = NULL;
static jclass LDKNetAddress_IPv6_class = NULL;
static jmethodID LDKNetAddress_IPv6_meth = NULL;
static jclass LDKNetAddress_OnionV2_class = NULL;
static jmethodID LDKNetAddress_OnionV2_meth = NULL;
static jclass LDKNetAddress_OnionV3_class = NULL;
static jmethodID LDKNetAddress_OnionV3_meth = NULL;
JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_00024LDKNetAddress_init (JNIEnv *env, jclass clz) {
	LDKNetAddress_IPv4_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKNetAddress$IPv4;"));
	CHECK(LDKNetAddress_IPv4_class != NULL);
	LDKNetAddress_IPv4_meth = (*env)->GetMethodID(env, LDKNetAddress_IPv4_class, "<init>", "([BS)V");
	CHECK(LDKNetAddress_IPv4_meth != NULL);
	LDKNetAddress_IPv6_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKNetAddress$IPv6;"));
	CHECK(LDKNetAddress_IPv6_class != NULL);
	LDKNetAddress_IPv6_meth = (*env)->GetMethodID(env, LDKNetAddress_IPv6_class, "<init>", "([BS)V");
	CHECK(LDKNetAddress_IPv6_meth != NULL);
	LDKNetAddress_OnionV2_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKNetAddress$OnionV2;"));
	CHECK(LDKNetAddress_OnionV2_class != NULL);
	LDKNetAddress_OnionV2_meth = (*env)->GetMethodID(env, LDKNetAddress_OnionV2_class, "<init>", "([BS)V");
	CHECK(LDKNetAddress_OnionV2_meth != NULL);
	LDKNetAddress_OnionV3_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKNetAddress$OnionV3;"));
	CHECK(LDKNetAddress_OnionV3_class != NULL);
	LDKNetAddress_OnionV3_meth = (*env)->GetMethodID(env, LDKNetAddress_OnionV3_class, "<init>", "([BSBS)V");
	CHECK(LDKNetAddress_OnionV3_meth != NULL);
}
JNIEXPORT jobject JNICALL Java_org_ldk_impl_bindings_LDKNetAddress_1ref_1from_1ptr(JNIEnv *env, jclass clz, int64_t ptr) {
	LDKNetAddress *obj = (LDKNetAddress*)(ptr & ~1);
	switch(obj->tag) {
		case LDKNetAddress_IPv4: {
			int8_tArray addr_arr = (*env)->NewByteArray(env, 4);
			(*env)->SetByteArrayRegion(env, addr_arr, 0, 4, obj->i_pv4.addr.data);
			return (*env)->NewObject(env, LDKNetAddress_IPv4_class, LDKNetAddress_IPv4_meth, addr_arr, obj->i_pv4.port);
		}
		case LDKNetAddress_IPv6: {
			int8_tArray addr_arr = (*env)->NewByteArray(env, 16);
			(*env)->SetByteArrayRegion(env, addr_arr, 0, 16, obj->i_pv6.addr.data);
			return (*env)->NewObject(env, LDKNetAddress_IPv6_class, LDKNetAddress_IPv6_meth, addr_arr, obj->i_pv6.port);
		}
		case LDKNetAddress_OnionV2: {
			int8_tArray addr_arr = (*env)->NewByteArray(env, 10);
			(*env)->SetByteArrayRegion(env, addr_arr, 0, 10, obj->onion_v2.addr.data);
			return (*env)->NewObject(env, LDKNetAddress_OnionV2_class, LDKNetAddress_OnionV2_meth, addr_arr, obj->onion_v2.port);
		}
		case LDKNetAddress_OnionV3: {
			int8_tArray ed25519_pubkey_arr = (*env)->NewByteArray(env, 32);
			(*env)->SetByteArrayRegion(env, ed25519_pubkey_arr, 0, 32, obj->onion_v3.ed25519_pubkey.data);
			return (*env)->NewObject(env, LDKNetAddress_OnionV3_class, LDKNetAddress_OnionV3_meth, ed25519_pubkey_arr, obj->onion_v3.checksum, obj->onion_v3.version, obj->onion_v3.port);
		}
		default: abort();
	}
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCVec_1NetAddressZ_1new(JNIEnv *env, jclass clz, int64_tArray elems) {
	LDKCVec_NetAddressZ *ret = MALLOC(sizeof(LDKCVec_NetAddressZ), "LDKCVec_NetAddressZ");
	ret->datalen = (*env)->GetArrayLength(env, elems);
	if (ret->datalen == 0) {
		ret->data = NULL;
	} else {
		ret->data = MALLOC(sizeof(LDKNetAddress) * ret->datalen, "LDKCVec_NetAddressZ Data");
		int64_t *java_elems = (*env)->GetPrimitiveArrayCritical(env, elems, NULL);
		for (size_t i = 0; i < ret->datalen; i++) {
			int64_t arr_elem = java_elems[i];
			void* arr_elem_ptr = (void*)(((uint64_t)arr_elem) & ~1);
			CHECK_ACCESS(arr_elem_ptr);
			LDKNetAddress arr_elem_conv = *(LDKNetAddress*)(arr_elem_ptr);
			arr_elem_conv = NetAddress_clone((LDKNetAddress*)(((uint64_t)arr_elem) & ~1));
			ret->data[i] = arr_elem_conv;
		}
		(*env)->ReleasePrimitiveArrayCritical(env, elems, java_elems, 0);
	}
	return (uint64_t)ret;
}
static inline LDKCVec_NetAddressZ CVec_NetAddressZ_clone(const LDKCVec_NetAddressZ *orig) {
	LDKCVec_NetAddressZ ret = { .data = MALLOC(sizeof(LDKNetAddress) * orig->datalen, "LDKCVec_NetAddressZ clone bytes"), .datalen = orig->datalen };
	for (size_t i = 0; i < ret.datalen; i++) {
		ret.data[i] = NetAddress_clone(&orig->data[i]);
	}
	return ret;
}
static inline struct LDKThirtyTwoBytes C2Tuple_PaymentHashPaymentSecretZ_get_a(LDKC2Tuple_PaymentHashPaymentSecretZ *NONNULL_PTR tuple){
	return ThirtyTwoBytes_clone(&tuple->a);
}
JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_C2Tuple_1PaymentHashPaymentSecretZ_1get_1a(JNIEnv *env, jclass clz, int64_t tuple) {
	LDKC2Tuple_PaymentHashPaymentSecretZ* tuple_conv = (LDKC2Tuple_PaymentHashPaymentSecretZ*)(tuple & ~1);
	int8_tArray ret_arr = (*env)->NewByteArray(env, 32);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 32, C2Tuple_PaymentHashPaymentSecretZ_get_a(tuple_conv).data);
	return ret_arr;
}

static inline struct LDKThirtyTwoBytes C2Tuple_PaymentHashPaymentSecretZ_get_b(LDKC2Tuple_PaymentHashPaymentSecretZ *NONNULL_PTR tuple){
	return ThirtyTwoBytes_clone(&tuple->b);
}
JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_C2Tuple_1PaymentHashPaymentSecretZ_1get_1b(JNIEnv *env, jclass clz, int64_t tuple) {
	LDKC2Tuple_PaymentHashPaymentSecretZ* tuple_conv = (LDKC2Tuple_PaymentHashPaymentSecretZ*)(tuple & ~1);
	int8_tArray ret_arr = (*env)->NewByteArray(env, 32);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 32, C2Tuple_PaymentHashPaymentSecretZ_get_b(tuple_conv).data);
	return ret_arr;
}

JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1PaymentSecretAPIErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_PaymentSecretAPIErrorZ*)arg)->result_ok;
}
JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_LDKCResult_1PaymentSecretAPIErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_PaymentSecretAPIErrorZ *val = (LDKCResult_PaymentSecretAPIErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	int8_tArray res_arr = (*env)->NewByteArray(env, 32);
	(*env)->SetByteArrayRegion(env, res_arr, 0, 32, (*val->contents.result).data);
	return res_arr;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1PaymentSecretAPIErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_PaymentSecretAPIErrorZ *val = (LDKCResult_PaymentSecretAPIErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	uint64_t err_ref = ((uint64_t)&(*val->contents.err)) | 1;
	return err_ref;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCVec_1ChannelMonitorZ_1new(JNIEnv *env, jclass clz, int64_tArray elems) {
	LDKCVec_ChannelMonitorZ *ret = MALLOC(sizeof(LDKCVec_ChannelMonitorZ), "LDKCVec_ChannelMonitorZ");
	ret->datalen = (*env)->GetArrayLength(env, elems);
	if (ret->datalen == 0) {
		ret->data = NULL;
	} else {
		ret->data = MALLOC(sizeof(LDKChannelMonitor) * ret->datalen, "LDKCVec_ChannelMonitorZ Data");
		int64_t *java_elems = (*env)->GetPrimitiveArrayCritical(env, elems, NULL);
		for (size_t i = 0; i < ret->datalen; i++) {
			int64_t arr_elem = java_elems[i];
			LDKChannelMonitor arr_elem_conv;
			arr_elem_conv.inner = (void*)(arr_elem & (~1));
			arr_elem_conv.is_owned = (arr_elem & 1) || (arr_elem == 0);
			arr_elem_conv = ChannelMonitor_clone(&arr_elem_conv);
			ret->data[i] = arr_elem_conv;
		}
		(*env)->ReleasePrimitiveArrayCritical(env, elems, java_elems, 0);
	}
	return (uint64_t)ret;
}
static inline LDKCVec_ChannelMonitorZ CVec_ChannelMonitorZ_clone(const LDKCVec_ChannelMonitorZ *orig) {
	LDKCVec_ChannelMonitorZ ret = { .data = MALLOC(sizeof(LDKChannelMonitor) * orig->datalen, "LDKCVec_ChannelMonitorZ clone bytes"), .datalen = orig->datalen };
	for (size_t i = 0; i < ret.datalen; i++) {
		ret.data[i] = ChannelMonitor_clone(&orig->data[i]);
	}
	return ret;
}
typedef struct LDKWatch_JCalls {
	atomic_size_t refcnt;
	JavaVM *vm;
	jweak o;
	jmethodID watch_channel_meth;
	jmethodID update_channel_meth;
	jmethodID release_pending_monitor_events_meth;
} LDKWatch_JCalls;
static void LDKWatch_JCalls_free(void* this_arg) {
	LDKWatch_JCalls *j_calls = (LDKWatch_JCalls*) this_arg;
	if (atomic_fetch_sub_explicit(&j_calls->refcnt, 1, memory_order_acquire) == 1) {
		JNIEnv *env;
		jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
		if (get_jenv_res == JNI_EDETACHED) {
			DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
		} else {
			DO_ASSERT(get_jenv_res == JNI_OK);
		}
		(*env)->DeleteWeakGlobalRef(env, j_calls->o);
		if (get_jenv_res == JNI_EDETACHED) {
			DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
		}
		FREE(j_calls);
	}
}
LDKCResult_NoneChannelMonitorUpdateErrZ watch_channel_LDKWatch_jcall(const void* this_arg, LDKOutPoint funding_txo, LDKChannelMonitor monitor) {
	LDKWatch_JCalls *j_calls = (LDKWatch_JCalls*) this_arg;
	JNIEnv *env;
	jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
	} else {
		DO_ASSERT(get_jenv_res == JNI_OK);
	}
	LDKOutPoint funding_txo_var = funding_txo;
	uint64_t funding_txo_ref = 0;
	CHECK((((uint64_t)funding_txo_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&funding_txo_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	funding_txo_ref = (uint64_t)funding_txo_var.inner;
	if (funding_txo_var.is_owned) {
		funding_txo_ref |= 1;
	}
	LDKChannelMonitor monitor_var = monitor;
	uint64_t monitor_ref = 0;
	CHECK((((uint64_t)monitor_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&monitor_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	monitor_ref = (uint64_t)monitor_var.inner;
	if (monitor_var.is_owned) {
		monitor_ref |= 1;
	}
	jobject obj = (*env)->NewLocalRef(env, j_calls->o);
	CHECK(obj != NULL);
	uint64_t ret = (*env)->CallLongMethod(env, obj, j_calls->watch_channel_meth, funding_txo_ref, monitor_ref);
	if ((*env)->ExceptionCheck(env)) {
		(*env)->ExceptionDescribe(env);
		(*env)->FatalError(env, "A call to watch_channel in LDKWatch from rust threw an exception.");
	}
	void* ret_ptr = (void*)(((uint64_t)ret) & ~1);
	CHECK_ACCESS(ret_ptr);
	LDKCResult_NoneChannelMonitorUpdateErrZ ret_conv = *(LDKCResult_NoneChannelMonitorUpdateErrZ*)(ret_ptr);
	ret_conv = CResult_NoneChannelMonitorUpdateErrZ_clone((LDKCResult_NoneChannelMonitorUpdateErrZ*)(((uint64_t)ret) & ~1));
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
	}
	return ret_conv;
}
LDKCResult_NoneChannelMonitorUpdateErrZ update_channel_LDKWatch_jcall(const void* this_arg, LDKOutPoint funding_txo, LDKChannelMonitorUpdate update) {
	LDKWatch_JCalls *j_calls = (LDKWatch_JCalls*) this_arg;
	JNIEnv *env;
	jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
	} else {
		DO_ASSERT(get_jenv_res == JNI_OK);
	}
	LDKOutPoint funding_txo_var = funding_txo;
	uint64_t funding_txo_ref = 0;
	CHECK((((uint64_t)funding_txo_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&funding_txo_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	funding_txo_ref = (uint64_t)funding_txo_var.inner;
	if (funding_txo_var.is_owned) {
		funding_txo_ref |= 1;
	}
	LDKChannelMonitorUpdate update_var = update;
	uint64_t update_ref = 0;
	CHECK((((uint64_t)update_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&update_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	update_ref = (uint64_t)update_var.inner;
	if (update_var.is_owned) {
		update_ref |= 1;
	}
	jobject obj = (*env)->NewLocalRef(env, j_calls->o);
	CHECK(obj != NULL);
	uint64_t ret = (*env)->CallLongMethod(env, obj, j_calls->update_channel_meth, funding_txo_ref, update_ref);
	if ((*env)->ExceptionCheck(env)) {
		(*env)->ExceptionDescribe(env);
		(*env)->FatalError(env, "A call to update_channel in LDKWatch from rust threw an exception.");
	}
	void* ret_ptr = (void*)(((uint64_t)ret) & ~1);
	CHECK_ACCESS(ret_ptr);
	LDKCResult_NoneChannelMonitorUpdateErrZ ret_conv = *(LDKCResult_NoneChannelMonitorUpdateErrZ*)(ret_ptr);
	ret_conv = CResult_NoneChannelMonitorUpdateErrZ_clone((LDKCResult_NoneChannelMonitorUpdateErrZ*)(((uint64_t)ret) & ~1));
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
	}
	return ret_conv;
}
LDKCVec_MonitorEventZ release_pending_monitor_events_LDKWatch_jcall(const void* this_arg) {
	LDKWatch_JCalls *j_calls = (LDKWatch_JCalls*) this_arg;
	JNIEnv *env;
	jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
	} else {
		DO_ASSERT(get_jenv_res == JNI_OK);
	}
	jobject obj = (*env)->NewLocalRef(env, j_calls->o);
	CHECK(obj != NULL);
	int64_tArray ret = (*env)->CallObjectMethod(env, obj, j_calls->release_pending_monitor_events_meth);
	if ((*env)->ExceptionCheck(env)) {
		(*env)->ExceptionDescribe(env);
		(*env)->FatalError(env, "A call to release_pending_monitor_events in LDKWatch from rust threw an exception.");
	}
	LDKCVec_MonitorEventZ ret_constr;
	ret_constr.datalen = (*env)->GetArrayLength(env, ret);
	if (ret_constr.datalen > 0)
		ret_constr.data = MALLOC(ret_constr.datalen * sizeof(LDKMonitorEvent), "LDKCVec_MonitorEventZ Elements");
	else
		ret_constr.data = NULL;
	int64_t* ret_vals = (*env)->GetLongArrayElements (env, ret, NULL);
	for (size_t o = 0; o < ret_constr.datalen; o++) {
		int64_t ret_conv_14 = ret_vals[o];
		void* ret_conv_14_ptr = (void*)(((uint64_t)ret_conv_14) & ~1);
		CHECK_ACCESS(ret_conv_14_ptr);
		LDKMonitorEvent ret_conv_14_conv = *(LDKMonitorEvent*)(ret_conv_14_ptr);
		ret_conv_14_conv = MonitorEvent_clone((LDKMonitorEvent*)(((uint64_t)ret_conv_14) & ~1));
		ret_constr.data[o] = ret_conv_14_conv;
	}
	(*env)->ReleaseLongArrayElements(env, ret, ret_vals, 0);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
	}
	return ret_constr;
}
static void LDKWatch_JCalls_cloned(LDKWatch* new_obj) {
	LDKWatch_JCalls *j_calls = (LDKWatch_JCalls*) new_obj->this_arg;
	atomic_fetch_add_explicit(&j_calls->refcnt, 1, memory_order_release);
}
static inline LDKWatch LDKWatch_init (JNIEnv *env, jclass clz, jobject o) {
	jclass c = (*env)->GetObjectClass(env, o);
	CHECK(c != NULL);
	LDKWatch_JCalls *calls = MALLOC(sizeof(LDKWatch_JCalls), "LDKWatch_JCalls");
	atomic_init(&calls->refcnt, 1);
	DO_ASSERT((*env)->GetJavaVM(env, &calls->vm) == 0);
	calls->o = (*env)->NewWeakGlobalRef(env, o);
	calls->watch_channel_meth = (*env)->GetMethodID(env, c, "watch_channel", "(JJ)J");
	CHECK(calls->watch_channel_meth != NULL);
	calls->update_channel_meth = (*env)->GetMethodID(env, c, "update_channel", "(JJ)J");
	CHECK(calls->update_channel_meth != NULL);
	calls->release_pending_monitor_events_meth = (*env)->GetMethodID(env, c, "release_pending_monitor_events", "()[J");
	CHECK(calls->release_pending_monitor_events_meth != NULL);

	LDKWatch ret = {
		.this_arg = (void*) calls,
		.watch_channel = watch_channel_LDKWatch_jcall,
		.update_channel = update_channel_LDKWatch_jcall,
		.release_pending_monitor_events = release_pending_monitor_events_LDKWatch_jcall,
		.free = LDKWatch_JCalls_free,
	};
	return ret;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKWatch_1new(JNIEnv *env, jclass clz, jobject o) {
	LDKWatch *res_ptr = MALLOC(sizeof(LDKWatch), "LDKWatch");
	*res_ptr = LDKWatch_init(env, clz, o);
	return (uint64_t)res_ptr;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_Watch_1watch_1channel(JNIEnv *env, jclass clz, int64_t this_arg, int64_t funding_txo, int64_t monitor) {
	void* this_arg_ptr = (void*)(((uint64_t)this_arg) & ~1);
	if (!(this_arg & 1)) { CHECK_ACCESS(this_arg_ptr); }
	LDKWatch* this_arg_conv = (LDKWatch*)this_arg_ptr;
	LDKOutPoint funding_txo_conv;
	funding_txo_conv.inner = (void*)(funding_txo & (~1));
	funding_txo_conv.is_owned = (funding_txo & 1) || (funding_txo == 0);
	funding_txo_conv = OutPoint_clone(&funding_txo_conv);
	LDKChannelMonitor monitor_conv;
	monitor_conv.inner = (void*)(monitor & (~1));
	monitor_conv.is_owned = (monitor & 1) || (monitor == 0);
	monitor_conv = ChannelMonitor_clone(&monitor_conv);
	LDKCResult_NoneChannelMonitorUpdateErrZ* ret_conv = MALLOC(sizeof(LDKCResult_NoneChannelMonitorUpdateErrZ), "LDKCResult_NoneChannelMonitorUpdateErrZ");
	*ret_conv = (this_arg_conv->watch_channel)(this_arg_conv->this_arg, funding_txo_conv, monitor_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_Watch_1update_1channel(JNIEnv *env, jclass clz, int64_t this_arg, int64_t funding_txo, int64_t update) {
	void* this_arg_ptr = (void*)(((uint64_t)this_arg) & ~1);
	if (!(this_arg & 1)) { CHECK_ACCESS(this_arg_ptr); }
	LDKWatch* this_arg_conv = (LDKWatch*)this_arg_ptr;
	LDKOutPoint funding_txo_conv;
	funding_txo_conv.inner = (void*)(funding_txo & (~1));
	funding_txo_conv.is_owned = (funding_txo & 1) || (funding_txo == 0);
	funding_txo_conv = OutPoint_clone(&funding_txo_conv);
	LDKChannelMonitorUpdate update_conv;
	update_conv.inner = (void*)(update & (~1));
	update_conv.is_owned = (update & 1) || (update == 0);
	update_conv = ChannelMonitorUpdate_clone(&update_conv);
	LDKCResult_NoneChannelMonitorUpdateErrZ* ret_conv = MALLOC(sizeof(LDKCResult_NoneChannelMonitorUpdateErrZ), "LDKCResult_NoneChannelMonitorUpdateErrZ");
	*ret_conv = (this_arg_conv->update_channel)(this_arg_conv->this_arg, funding_txo_conv, update_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_tArray JNICALL Java_org_ldk_impl_bindings_Watch_1release_1pending_1monitor_1events(JNIEnv *env, jclass clz, int64_t this_arg) {
	void* this_arg_ptr = (void*)(((uint64_t)this_arg) & ~1);
	if (!(this_arg & 1)) { CHECK_ACCESS(this_arg_ptr); }
	LDKWatch* this_arg_conv = (LDKWatch*)this_arg_ptr;
	LDKCVec_MonitorEventZ ret_var = (this_arg_conv->release_pending_monitor_events)(this_arg_conv->this_arg);
	int64_tArray ret_arr = NULL;
	ret_arr = (*env)->NewLongArray(env, ret_var.datalen);
	int64_t *ret_arr_ptr = (*env)->GetPrimitiveArrayCritical(env, ret_arr, NULL);
	for (size_t o = 0; o < ret_var.datalen; o++) {
		LDKMonitorEvent *ret_conv_14_copy = MALLOC(sizeof(LDKMonitorEvent), "LDKMonitorEvent");
		*ret_conv_14_copy = ret_var.data[o];
		uint64_t ret_conv_14_ref = (uint64_t)ret_conv_14_copy;
		ret_arr_ptr[o] = ret_conv_14_ref;
	}
	(*env)->ReleasePrimitiveArrayCritical(env, ret_arr, ret_arr_ptr, 0);
	FREE(ret_var.data);
	return ret_arr;
}

typedef struct LDKBroadcasterInterface_JCalls {
	atomic_size_t refcnt;
	JavaVM *vm;
	jweak o;
	jmethodID broadcast_transaction_meth;
} LDKBroadcasterInterface_JCalls;
static void LDKBroadcasterInterface_JCalls_free(void* this_arg) {
	LDKBroadcasterInterface_JCalls *j_calls = (LDKBroadcasterInterface_JCalls*) this_arg;
	if (atomic_fetch_sub_explicit(&j_calls->refcnt, 1, memory_order_acquire) == 1) {
		JNIEnv *env;
		jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
		if (get_jenv_res == JNI_EDETACHED) {
			DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
		} else {
			DO_ASSERT(get_jenv_res == JNI_OK);
		}
		(*env)->DeleteWeakGlobalRef(env, j_calls->o);
		if (get_jenv_res == JNI_EDETACHED) {
			DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
		}
		FREE(j_calls);
	}
}
void broadcast_transaction_LDKBroadcasterInterface_jcall(const void* this_arg, LDKTransaction tx) {
	LDKBroadcasterInterface_JCalls *j_calls = (LDKBroadcasterInterface_JCalls*) this_arg;
	JNIEnv *env;
	jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
	} else {
		DO_ASSERT(get_jenv_res == JNI_OK);
	}
	LDKTransaction tx_var = tx;
	int8_tArray tx_arr = (*env)->NewByteArray(env, tx_var.datalen);
	(*env)->SetByteArrayRegion(env, tx_arr, 0, tx_var.datalen, tx_var.data);
	Transaction_free(tx_var);
	jobject obj = (*env)->NewLocalRef(env, j_calls->o);
	CHECK(obj != NULL);
	(*env)->CallVoidMethod(env, obj, j_calls->broadcast_transaction_meth, tx_arr);
	if ((*env)->ExceptionCheck(env)) {
		(*env)->ExceptionDescribe(env);
		(*env)->FatalError(env, "A call to broadcast_transaction in LDKBroadcasterInterface from rust threw an exception.");
	}
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
	}
}
static void LDKBroadcasterInterface_JCalls_cloned(LDKBroadcasterInterface* new_obj) {
	LDKBroadcasterInterface_JCalls *j_calls = (LDKBroadcasterInterface_JCalls*) new_obj->this_arg;
	atomic_fetch_add_explicit(&j_calls->refcnt, 1, memory_order_release);
}
static inline LDKBroadcasterInterface LDKBroadcasterInterface_init (JNIEnv *env, jclass clz, jobject o) {
	jclass c = (*env)->GetObjectClass(env, o);
	CHECK(c != NULL);
	LDKBroadcasterInterface_JCalls *calls = MALLOC(sizeof(LDKBroadcasterInterface_JCalls), "LDKBroadcasterInterface_JCalls");
	atomic_init(&calls->refcnt, 1);
	DO_ASSERT((*env)->GetJavaVM(env, &calls->vm) == 0);
	calls->o = (*env)->NewWeakGlobalRef(env, o);
	calls->broadcast_transaction_meth = (*env)->GetMethodID(env, c, "broadcast_transaction", "([B)V");
	CHECK(calls->broadcast_transaction_meth != NULL);

	LDKBroadcasterInterface ret = {
		.this_arg = (void*) calls,
		.broadcast_transaction = broadcast_transaction_LDKBroadcasterInterface_jcall,
		.free = LDKBroadcasterInterface_JCalls_free,
	};
	return ret;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKBroadcasterInterface_1new(JNIEnv *env, jclass clz, jobject o) {
	LDKBroadcasterInterface *res_ptr = MALLOC(sizeof(LDKBroadcasterInterface), "LDKBroadcasterInterface");
	*res_ptr = LDKBroadcasterInterface_init(env, clz, o);
	return (uint64_t)res_ptr;
}
JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_BroadcasterInterface_1broadcast_1transaction(JNIEnv *env, jclass clz, int64_t this_arg, int8_tArray tx) {
	void* this_arg_ptr = (void*)(((uint64_t)this_arg) & ~1);
	if (!(this_arg & 1)) { CHECK_ACCESS(this_arg_ptr); }
	LDKBroadcasterInterface* this_arg_conv = (LDKBroadcasterInterface*)this_arg_ptr;
	LDKTransaction tx_ref;
	tx_ref.datalen = (*env)->GetArrayLength(env, tx);
	tx_ref.data = MALLOC(tx_ref.datalen, "LDKTransaction Bytes");
	(*env)->GetByteArrayRegion(env, tx, 0, tx_ref.datalen, tx_ref.data);
	tx_ref.data_is_owned = true;
	(this_arg_conv->broadcast_transaction)(this_arg_conv->this_arg, tx_ref);
}

typedef struct LDKKeysInterface_JCalls {
	atomic_size_t refcnt;
	JavaVM *vm;
	jweak o;
	jmethodID get_node_secret_meth;
	jmethodID get_destination_script_meth;
	jmethodID get_shutdown_scriptpubkey_meth;
	jmethodID get_channel_signer_meth;
	jmethodID get_secure_random_bytes_meth;
	jmethodID read_chan_signer_meth;
	jmethodID sign_invoice_meth;
} LDKKeysInterface_JCalls;
static void LDKKeysInterface_JCalls_free(void* this_arg) {
	LDKKeysInterface_JCalls *j_calls = (LDKKeysInterface_JCalls*) this_arg;
	if (atomic_fetch_sub_explicit(&j_calls->refcnt, 1, memory_order_acquire) == 1) {
		JNIEnv *env;
		jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
		if (get_jenv_res == JNI_EDETACHED) {
			DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
		} else {
			DO_ASSERT(get_jenv_res == JNI_OK);
		}
		(*env)->DeleteWeakGlobalRef(env, j_calls->o);
		if (get_jenv_res == JNI_EDETACHED) {
			DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
		}
		FREE(j_calls);
	}
}
LDKSecretKey get_node_secret_LDKKeysInterface_jcall(const void* this_arg) {
	LDKKeysInterface_JCalls *j_calls = (LDKKeysInterface_JCalls*) this_arg;
	JNIEnv *env;
	jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
	} else {
		DO_ASSERT(get_jenv_res == JNI_OK);
	}
	jobject obj = (*env)->NewLocalRef(env, j_calls->o);
	CHECK(obj != NULL);
	int8_tArray ret = (*env)->CallObjectMethod(env, obj, j_calls->get_node_secret_meth);
	if ((*env)->ExceptionCheck(env)) {
		(*env)->ExceptionDescribe(env);
		(*env)->FatalError(env, "A call to get_node_secret in LDKKeysInterface from rust threw an exception.");
	}
	LDKSecretKey ret_ref;
	CHECK((*env)->GetArrayLength(env, ret) == 32);
	(*env)->GetByteArrayRegion(env, ret, 0, 32, ret_ref.bytes);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
	}
	return ret_ref;
}
LDKCVec_u8Z get_destination_script_LDKKeysInterface_jcall(const void* this_arg) {
	LDKKeysInterface_JCalls *j_calls = (LDKKeysInterface_JCalls*) this_arg;
	JNIEnv *env;
	jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
	} else {
		DO_ASSERT(get_jenv_res == JNI_OK);
	}
	jobject obj = (*env)->NewLocalRef(env, j_calls->o);
	CHECK(obj != NULL);
	int8_tArray ret = (*env)->CallObjectMethod(env, obj, j_calls->get_destination_script_meth);
	if ((*env)->ExceptionCheck(env)) {
		(*env)->ExceptionDescribe(env);
		(*env)->FatalError(env, "A call to get_destination_script in LDKKeysInterface from rust threw an exception.");
	}
	LDKCVec_u8Z ret_ref;
	ret_ref.datalen = (*env)->GetArrayLength(env, ret);
	ret_ref.data = MALLOC(ret_ref.datalen, "LDKCVec_u8Z Bytes");
	(*env)->GetByteArrayRegion(env, ret, 0, ret_ref.datalen, ret_ref.data);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
	}
	return ret_ref;
}
LDKShutdownScript get_shutdown_scriptpubkey_LDKKeysInterface_jcall(const void* this_arg) {
	LDKKeysInterface_JCalls *j_calls = (LDKKeysInterface_JCalls*) this_arg;
	JNIEnv *env;
	jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
	} else {
		DO_ASSERT(get_jenv_res == JNI_OK);
	}
	jobject obj = (*env)->NewLocalRef(env, j_calls->o);
	CHECK(obj != NULL);
	uint64_t ret = (*env)->CallLongMethod(env, obj, j_calls->get_shutdown_scriptpubkey_meth);
	if ((*env)->ExceptionCheck(env)) {
		(*env)->ExceptionDescribe(env);
		(*env)->FatalError(env, "A call to get_shutdown_scriptpubkey in LDKKeysInterface from rust threw an exception.");
	}
	LDKShutdownScript ret_conv;
	ret_conv.inner = (void*)(ret & (~1));
	ret_conv.is_owned = (ret & 1) || (ret == 0);
	ret_conv = ShutdownScript_clone(&ret_conv);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
	}
	return ret_conv;
}
LDKSign get_channel_signer_LDKKeysInterface_jcall(const void* this_arg, bool inbound, uint64_t channel_value_satoshis) {
	LDKKeysInterface_JCalls *j_calls = (LDKKeysInterface_JCalls*) this_arg;
	JNIEnv *env;
	jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
	} else {
		DO_ASSERT(get_jenv_res == JNI_OK);
	}
	jobject obj = (*env)->NewLocalRef(env, j_calls->o);
	CHECK(obj != NULL);
	uint64_t ret = (*env)->CallLongMethod(env, obj, j_calls->get_channel_signer_meth, inbound, channel_value_satoshis);
	if ((*env)->ExceptionCheck(env)) {
		(*env)->ExceptionDescribe(env);
		(*env)->FatalError(env, "A call to get_channel_signer in LDKKeysInterface from rust threw an exception.");
	}
	void* ret_ptr = (void*)(((uint64_t)ret) & ~1);
	CHECK_ACCESS(ret_ptr);
	LDKSign ret_conv = *(LDKSign*)(ret_ptr);
	ret_conv = Sign_clone(&ret_conv);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
	}
	return ret_conv;
}
LDKThirtyTwoBytes get_secure_random_bytes_LDKKeysInterface_jcall(const void* this_arg) {
	LDKKeysInterface_JCalls *j_calls = (LDKKeysInterface_JCalls*) this_arg;
	JNIEnv *env;
	jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
	} else {
		DO_ASSERT(get_jenv_res == JNI_OK);
	}
	jobject obj = (*env)->NewLocalRef(env, j_calls->o);
	CHECK(obj != NULL);
	int8_tArray ret = (*env)->CallObjectMethod(env, obj, j_calls->get_secure_random_bytes_meth);
	if ((*env)->ExceptionCheck(env)) {
		(*env)->ExceptionDescribe(env);
		(*env)->FatalError(env, "A call to get_secure_random_bytes in LDKKeysInterface from rust threw an exception.");
	}
	LDKThirtyTwoBytes ret_ref;
	CHECK((*env)->GetArrayLength(env, ret) == 32);
	(*env)->GetByteArrayRegion(env, ret, 0, 32, ret_ref.data);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
	}
	return ret_ref;
}
LDKCResult_SignDecodeErrorZ read_chan_signer_LDKKeysInterface_jcall(const void* this_arg, LDKu8slice reader) {
	LDKKeysInterface_JCalls *j_calls = (LDKKeysInterface_JCalls*) this_arg;
	JNIEnv *env;
	jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
	} else {
		DO_ASSERT(get_jenv_res == JNI_OK);
	}
	LDKu8slice reader_var = reader;
	int8_tArray reader_arr = (*env)->NewByteArray(env, reader_var.datalen);
	(*env)->SetByteArrayRegion(env, reader_arr, 0, reader_var.datalen, reader_var.data);
	jobject obj = (*env)->NewLocalRef(env, j_calls->o);
	CHECK(obj != NULL);
	uint64_t ret = (*env)->CallLongMethod(env, obj, j_calls->read_chan_signer_meth, reader_arr);
	if ((*env)->ExceptionCheck(env)) {
		(*env)->ExceptionDescribe(env);
		(*env)->FatalError(env, "A call to read_chan_signer in LDKKeysInterface from rust threw an exception.");
	}
	void* ret_ptr = (void*)(((uint64_t)ret) & ~1);
	CHECK_ACCESS(ret_ptr);
	LDKCResult_SignDecodeErrorZ ret_conv = *(LDKCResult_SignDecodeErrorZ*)(ret_ptr);
	ret_conv = CResult_SignDecodeErrorZ_clone((LDKCResult_SignDecodeErrorZ*)(((uint64_t)ret) & ~1));
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
	}
	return ret_conv;
}
LDKCResult_RecoverableSignatureNoneZ sign_invoice_LDKKeysInterface_jcall(const void* this_arg, LDKCVec_u8Z invoice_preimage) {
	LDKKeysInterface_JCalls *j_calls = (LDKKeysInterface_JCalls*) this_arg;
	JNIEnv *env;
	jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
	} else {
		DO_ASSERT(get_jenv_res == JNI_OK);
	}
	LDKCVec_u8Z invoice_preimage_var = invoice_preimage;
	int8_tArray invoice_preimage_arr = (*env)->NewByteArray(env, invoice_preimage_var.datalen);
	(*env)->SetByteArrayRegion(env, invoice_preimage_arr, 0, invoice_preimage_var.datalen, invoice_preimage_var.data);
	CVec_u8Z_free(invoice_preimage_var);
	jobject obj = (*env)->NewLocalRef(env, j_calls->o);
	CHECK(obj != NULL);
	uint64_t ret = (*env)->CallLongMethod(env, obj, j_calls->sign_invoice_meth, invoice_preimage_arr);
	if ((*env)->ExceptionCheck(env)) {
		(*env)->ExceptionDescribe(env);
		(*env)->FatalError(env, "A call to sign_invoice in LDKKeysInterface from rust threw an exception.");
	}
	void* ret_ptr = (void*)(((uint64_t)ret) & ~1);
	CHECK_ACCESS(ret_ptr);
	LDKCResult_RecoverableSignatureNoneZ ret_conv = *(LDKCResult_RecoverableSignatureNoneZ*)(ret_ptr);
	ret_conv = CResult_RecoverableSignatureNoneZ_clone((LDKCResult_RecoverableSignatureNoneZ*)(((uint64_t)ret) & ~1));
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
	}
	return ret_conv;
}
static void LDKKeysInterface_JCalls_cloned(LDKKeysInterface* new_obj) {
	LDKKeysInterface_JCalls *j_calls = (LDKKeysInterface_JCalls*) new_obj->this_arg;
	atomic_fetch_add_explicit(&j_calls->refcnt, 1, memory_order_release);
}
static inline LDKKeysInterface LDKKeysInterface_init (JNIEnv *env, jclass clz, jobject o) {
	jclass c = (*env)->GetObjectClass(env, o);
	CHECK(c != NULL);
	LDKKeysInterface_JCalls *calls = MALLOC(sizeof(LDKKeysInterface_JCalls), "LDKKeysInterface_JCalls");
	atomic_init(&calls->refcnt, 1);
	DO_ASSERT((*env)->GetJavaVM(env, &calls->vm) == 0);
	calls->o = (*env)->NewWeakGlobalRef(env, o);
	calls->get_node_secret_meth = (*env)->GetMethodID(env, c, "get_node_secret", "()[B");
	CHECK(calls->get_node_secret_meth != NULL);
	calls->get_destination_script_meth = (*env)->GetMethodID(env, c, "get_destination_script", "()[B");
	CHECK(calls->get_destination_script_meth != NULL);
	calls->get_shutdown_scriptpubkey_meth = (*env)->GetMethodID(env, c, "get_shutdown_scriptpubkey", "()J");
	CHECK(calls->get_shutdown_scriptpubkey_meth != NULL);
	calls->get_channel_signer_meth = (*env)->GetMethodID(env, c, "get_channel_signer", "(ZJ)J");
	CHECK(calls->get_channel_signer_meth != NULL);
	calls->get_secure_random_bytes_meth = (*env)->GetMethodID(env, c, "get_secure_random_bytes", "()[B");
	CHECK(calls->get_secure_random_bytes_meth != NULL);
	calls->read_chan_signer_meth = (*env)->GetMethodID(env, c, "read_chan_signer", "([B)J");
	CHECK(calls->read_chan_signer_meth != NULL);
	calls->sign_invoice_meth = (*env)->GetMethodID(env, c, "sign_invoice", "([B)J");
	CHECK(calls->sign_invoice_meth != NULL);

	LDKKeysInterface ret = {
		.this_arg = (void*) calls,
		.get_node_secret = get_node_secret_LDKKeysInterface_jcall,
		.get_destination_script = get_destination_script_LDKKeysInterface_jcall,
		.get_shutdown_scriptpubkey = get_shutdown_scriptpubkey_LDKKeysInterface_jcall,
		.get_channel_signer = get_channel_signer_LDKKeysInterface_jcall,
		.get_secure_random_bytes = get_secure_random_bytes_LDKKeysInterface_jcall,
		.read_chan_signer = read_chan_signer_LDKKeysInterface_jcall,
		.sign_invoice = sign_invoice_LDKKeysInterface_jcall,
		.free = LDKKeysInterface_JCalls_free,
	};
	return ret;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKKeysInterface_1new(JNIEnv *env, jclass clz, jobject o) {
	LDKKeysInterface *res_ptr = MALLOC(sizeof(LDKKeysInterface), "LDKKeysInterface");
	*res_ptr = LDKKeysInterface_init(env, clz, o);
	return (uint64_t)res_ptr;
}
JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_KeysInterface_1get_1node_1secret(JNIEnv *env, jclass clz, int64_t this_arg) {
	void* this_arg_ptr = (void*)(((uint64_t)this_arg) & ~1);
	if (!(this_arg & 1)) { CHECK_ACCESS(this_arg_ptr); }
	LDKKeysInterface* this_arg_conv = (LDKKeysInterface*)this_arg_ptr;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 32);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 32, (this_arg_conv->get_node_secret)(this_arg_conv->this_arg).bytes);
	return ret_arr;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_KeysInterface_1get_1destination_1script(JNIEnv *env, jclass clz, int64_t this_arg) {
	void* this_arg_ptr = (void*)(((uint64_t)this_arg) & ~1);
	if (!(this_arg & 1)) { CHECK_ACCESS(this_arg_ptr); }
	LDKKeysInterface* this_arg_conv = (LDKKeysInterface*)this_arg_ptr;
	LDKCVec_u8Z ret_var = (this_arg_conv->get_destination_script)(this_arg_conv->this_arg);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	CVec_u8Z_free(ret_var);
	return ret_arr;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_KeysInterface_1get_1shutdown_1scriptpubkey(JNIEnv *env, jclass clz, int64_t this_arg) {
	void* this_arg_ptr = (void*)(((uint64_t)this_arg) & ~1);
	if (!(this_arg & 1)) { CHECK_ACCESS(this_arg_ptr); }
	LDKKeysInterface* this_arg_conv = (LDKKeysInterface*)this_arg_ptr;
	LDKShutdownScript ret_var = (this_arg_conv->get_shutdown_scriptpubkey)(this_arg_conv->this_arg);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_KeysInterface_1get_1channel_1signer(JNIEnv *env, jclass clz, int64_t this_arg, jboolean inbound, int64_t channel_value_satoshis) {
	void* this_arg_ptr = (void*)(((uint64_t)this_arg) & ~1);
	if (!(this_arg & 1)) { CHECK_ACCESS(this_arg_ptr); }
	LDKKeysInterface* this_arg_conv = (LDKKeysInterface*)this_arg_ptr;
	LDKSign* ret_ret = MALLOC(sizeof(LDKSign), "LDKSign");
	*ret_ret = (this_arg_conv->get_channel_signer)(this_arg_conv->this_arg, inbound, channel_value_satoshis);
	return (uint64_t)ret_ret;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_KeysInterface_1get_1secure_1random_1bytes(JNIEnv *env, jclass clz, int64_t this_arg) {
	void* this_arg_ptr = (void*)(((uint64_t)this_arg) & ~1);
	if (!(this_arg & 1)) { CHECK_ACCESS(this_arg_ptr); }
	LDKKeysInterface* this_arg_conv = (LDKKeysInterface*)this_arg_ptr;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 32);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 32, (this_arg_conv->get_secure_random_bytes)(this_arg_conv->this_arg).data);
	return ret_arr;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_KeysInterface_1read_1chan_1signer(JNIEnv *env, jclass clz, int64_t this_arg, int8_tArray reader) {
	void* this_arg_ptr = (void*)(((uint64_t)this_arg) & ~1);
	if (!(this_arg & 1)) { CHECK_ACCESS(this_arg_ptr); }
	LDKKeysInterface* this_arg_conv = (LDKKeysInterface*)this_arg_ptr;
	LDKu8slice reader_ref;
	reader_ref.datalen = (*env)->GetArrayLength(env, reader);
	reader_ref.data = (*env)->GetByteArrayElements (env, reader, NULL);
	LDKCResult_SignDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_SignDecodeErrorZ), "LDKCResult_SignDecodeErrorZ");
	*ret_conv = (this_arg_conv->read_chan_signer)(this_arg_conv->this_arg, reader_ref);
	(*env)->ReleaseByteArrayElements(env, reader, (int8_t*)reader_ref.data, 0);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_KeysInterface_1sign_1invoice(JNIEnv *env, jclass clz, int64_t this_arg, int8_tArray invoice_preimage) {
	void* this_arg_ptr = (void*)(((uint64_t)this_arg) & ~1);
	if (!(this_arg & 1)) { CHECK_ACCESS(this_arg_ptr); }
	LDKKeysInterface* this_arg_conv = (LDKKeysInterface*)this_arg_ptr;
	LDKCVec_u8Z invoice_preimage_ref;
	invoice_preimage_ref.datalen = (*env)->GetArrayLength(env, invoice_preimage);
	invoice_preimage_ref.data = MALLOC(invoice_preimage_ref.datalen, "LDKCVec_u8Z Bytes");
	(*env)->GetByteArrayRegion(env, invoice_preimage, 0, invoice_preimage_ref.datalen, invoice_preimage_ref.data);
	LDKCResult_RecoverableSignatureNoneZ* ret_conv = MALLOC(sizeof(LDKCResult_RecoverableSignatureNoneZ), "LDKCResult_RecoverableSignatureNoneZ");
	*ret_conv = (this_arg_conv->sign_invoice)(this_arg_conv->this_arg, invoice_preimage_ref);
	return (uint64_t)ret_conv;
}

typedef struct LDKFeeEstimator_JCalls {
	atomic_size_t refcnt;
	JavaVM *vm;
	jweak o;
	jmethodID get_est_sat_per_1000_weight_meth;
} LDKFeeEstimator_JCalls;
static void LDKFeeEstimator_JCalls_free(void* this_arg) {
	LDKFeeEstimator_JCalls *j_calls = (LDKFeeEstimator_JCalls*) this_arg;
	if (atomic_fetch_sub_explicit(&j_calls->refcnt, 1, memory_order_acquire) == 1) {
		JNIEnv *env;
		jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
		if (get_jenv_res == JNI_EDETACHED) {
			DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
		} else {
			DO_ASSERT(get_jenv_res == JNI_OK);
		}
		(*env)->DeleteWeakGlobalRef(env, j_calls->o);
		if (get_jenv_res == JNI_EDETACHED) {
			DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
		}
		FREE(j_calls);
	}
}
uint32_t get_est_sat_per_1000_weight_LDKFeeEstimator_jcall(const void* this_arg, LDKConfirmationTarget confirmation_target) {
	LDKFeeEstimator_JCalls *j_calls = (LDKFeeEstimator_JCalls*) this_arg;
	JNIEnv *env;
	jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
	} else {
		DO_ASSERT(get_jenv_res == JNI_OK);
	}
	jclass confirmation_target_conv = LDKConfirmationTarget_to_java(env, confirmation_target);
	jobject obj = (*env)->NewLocalRef(env, j_calls->o);
	CHECK(obj != NULL);
	int32_t ret = (*env)->CallIntMethod(env, obj, j_calls->get_est_sat_per_1000_weight_meth, confirmation_target_conv);
	if ((*env)->ExceptionCheck(env)) {
		(*env)->ExceptionDescribe(env);
		(*env)->FatalError(env, "A call to get_est_sat_per_1000_weight in LDKFeeEstimator from rust threw an exception.");
	}
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
	}
	return ret;
}
static void LDKFeeEstimator_JCalls_cloned(LDKFeeEstimator* new_obj) {
	LDKFeeEstimator_JCalls *j_calls = (LDKFeeEstimator_JCalls*) new_obj->this_arg;
	atomic_fetch_add_explicit(&j_calls->refcnt, 1, memory_order_release);
}
static inline LDKFeeEstimator LDKFeeEstimator_init (JNIEnv *env, jclass clz, jobject o) {
	jclass c = (*env)->GetObjectClass(env, o);
	CHECK(c != NULL);
	LDKFeeEstimator_JCalls *calls = MALLOC(sizeof(LDKFeeEstimator_JCalls), "LDKFeeEstimator_JCalls");
	atomic_init(&calls->refcnt, 1);
	DO_ASSERT((*env)->GetJavaVM(env, &calls->vm) == 0);
	calls->o = (*env)->NewWeakGlobalRef(env, o);
	calls->get_est_sat_per_1000_weight_meth = (*env)->GetMethodID(env, c, "get_est_sat_per_1000_weight", "(Lorg/ldk/enums/ConfirmationTarget;)I");
	CHECK(calls->get_est_sat_per_1000_weight_meth != NULL);

	LDKFeeEstimator ret = {
		.this_arg = (void*) calls,
		.get_est_sat_per_1000_weight = get_est_sat_per_1000_weight_LDKFeeEstimator_jcall,
		.free = LDKFeeEstimator_JCalls_free,
	};
	return ret;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKFeeEstimator_1new(JNIEnv *env, jclass clz, jobject o) {
	LDKFeeEstimator *res_ptr = MALLOC(sizeof(LDKFeeEstimator), "LDKFeeEstimator");
	*res_ptr = LDKFeeEstimator_init(env, clz, o);
	return (uint64_t)res_ptr;
}
JNIEXPORT int32_t JNICALL Java_org_ldk_impl_bindings_FeeEstimator_1get_1est_1sat_1per_11000_1weight(JNIEnv *env, jclass clz, int64_t this_arg, jclass confirmation_target) {
	void* this_arg_ptr = (void*)(((uint64_t)this_arg) & ~1);
	if (!(this_arg & 1)) { CHECK_ACCESS(this_arg_ptr); }
	LDKFeeEstimator* this_arg_conv = (LDKFeeEstimator*)this_arg_ptr;
	LDKConfirmationTarget confirmation_target_conv = LDKConfirmationTarget_from_java(env, confirmation_target);
	int32_t ret_val = (this_arg_conv->get_est_sat_per_1000_weight)(this_arg_conv->this_arg, confirmation_target_conv);
	return ret_val;
}

typedef struct LDKLogger_JCalls {
	atomic_size_t refcnt;
	JavaVM *vm;
	jweak o;
	jmethodID log_meth;
} LDKLogger_JCalls;
static void LDKLogger_JCalls_free(void* this_arg) {
	LDKLogger_JCalls *j_calls = (LDKLogger_JCalls*) this_arg;
	if (atomic_fetch_sub_explicit(&j_calls->refcnt, 1, memory_order_acquire) == 1) {
		JNIEnv *env;
		jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
		if (get_jenv_res == JNI_EDETACHED) {
			DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
		} else {
			DO_ASSERT(get_jenv_res == JNI_OK);
		}
		(*env)->DeleteWeakGlobalRef(env, j_calls->o);
		if (get_jenv_res == JNI_EDETACHED) {
			DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
		}
		FREE(j_calls);
	}
}
void log_LDKLogger_jcall(const void* this_arg, const char* record) {
	LDKLogger_JCalls *j_calls = (LDKLogger_JCalls*) this_arg;
	JNIEnv *env;
	jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
	} else {
		DO_ASSERT(get_jenv_res == JNI_OK);
	}
	const char* record_str = record;
	jstring record_conv = str_ref_to_java(env, record_str, strlen(record_str));
	jobject obj = (*env)->NewLocalRef(env, j_calls->o);
	CHECK(obj != NULL);
	(*env)->CallVoidMethod(env, obj, j_calls->log_meth, record_conv);
	if ((*env)->ExceptionCheck(env)) {
		(*env)->ExceptionDescribe(env);
		(*env)->FatalError(env, "A call to log in LDKLogger from rust threw an exception.");
	}
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
	}
}
static void LDKLogger_JCalls_cloned(LDKLogger* new_obj) {
	LDKLogger_JCalls *j_calls = (LDKLogger_JCalls*) new_obj->this_arg;
	atomic_fetch_add_explicit(&j_calls->refcnt, 1, memory_order_release);
}
static inline LDKLogger LDKLogger_init (JNIEnv *env, jclass clz, jobject o) {
	jclass c = (*env)->GetObjectClass(env, o);
	CHECK(c != NULL);
	LDKLogger_JCalls *calls = MALLOC(sizeof(LDKLogger_JCalls), "LDKLogger_JCalls");
	atomic_init(&calls->refcnt, 1);
	DO_ASSERT((*env)->GetJavaVM(env, &calls->vm) == 0);
	calls->o = (*env)->NewWeakGlobalRef(env, o);
	calls->log_meth = (*env)->GetMethodID(env, c, "log", "(Ljava/lang/String;)V");
	CHECK(calls->log_meth != NULL);

	LDKLogger ret = {
		.this_arg = (void*) calls,
		.log = log_LDKLogger_jcall,
		.free = LDKLogger_JCalls_free,
	};
	return ret;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKLogger_1new(JNIEnv *env, jclass clz, jobject o) {
	LDKLogger *res_ptr = MALLOC(sizeof(LDKLogger), "LDKLogger");
	*res_ptr = LDKLogger_init(env, clz, o);
	return (uint64_t)res_ptr;
}
static inline struct LDKThirtyTwoBytes C2Tuple_BlockHashChannelManagerZ_get_a(LDKC2Tuple_BlockHashChannelManagerZ *NONNULL_PTR tuple){
	return ThirtyTwoBytes_clone(&tuple->a);
}
JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_C2Tuple_1BlockHashChannelManagerZ_1get_1a(JNIEnv *env, jclass clz, int64_t tuple) {
	LDKC2Tuple_BlockHashChannelManagerZ* tuple_conv = (LDKC2Tuple_BlockHashChannelManagerZ*)(tuple & ~1);
	int8_tArray ret_arr = (*env)->NewByteArray(env, 32);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 32, C2Tuple_BlockHashChannelManagerZ_get_a(tuple_conv).data);
	return ret_arr;
}

static inline struct LDKChannelManager *C2Tuple_BlockHashChannelManagerZ_get_b(LDKC2Tuple_BlockHashChannelManagerZ *NONNULL_PTR tuple){
	return &tuple->b;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_C2Tuple_1BlockHashChannelManagerZ_1get_1b(JNIEnv *env, jclass clz, int64_t tuple) {
	LDKC2Tuple_BlockHashChannelManagerZ* tuple_conv = (LDKC2Tuple_BlockHashChannelManagerZ*)(tuple & ~1);
	LDKChannelManager ret_var = *C2Tuple_BlockHashChannelManagerZ_get_b(tuple_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner & ~1;
	return ret_ref;
}

JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1C2Tuple_1BlockHashChannelManagerZDecodeErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ*)arg)->result_ok;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1C2Tuple_1BlockHashChannelManagerZDecodeErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ *val = (LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	LDKC2Tuple_BlockHashChannelManagerZ* res_conv = &(*val->contents.result);
	// Warning: we really need to clone here, but no clone is available for LDKC2Tuple_BlockHashChannelManagerZ
	return ((uint64_t)res_conv) | 1;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1C2Tuple_1BlockHashChannelManagerZDecodeErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ *val = (LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	LDKDecodeError err_var = (*val->contents.err);
	uint64_t err_ref = 0;
	CHECK((((uint64_t)err_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&err_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	err_ref = (uint64_t)err_var.inner & ~1;
	return err_ref;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1ChannelConfigDecodeErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_ChannelConfigDecodeErrorZ*)arg)->result_ok;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1ChannelConfigDecodeErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_ChannelConfigDecodeErrorZ *val = (LDKCResult_ChannelConfigDecodeErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	LDKChannelConfig res_var = (*val->contents.result);
	uint64_t res_ref = 0;
	CHECK((((uint64_t)res_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&res_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	res_ref = (uint64_t)res_var.inner & ~1;
	return res_ref;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1ChannelConfigDecodeErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_ChannelConfigDecodeErrorZ *val = (LDKCResult_ChannelConfigDecodeErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	LDKDecodeError err_var = (*val->contents.err);
	uint64_t err_ref = 0;
	CHECK((((uint64_t)err_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&err_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	err_ref = (uint64_t)err_var.inner & ~1;
	return err_ref;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1OutPointDecodeErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_OutPointDecodeErrorZ*)arg)->result_ok;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1OutPointDecodeErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_OutPointDecodeErrorZ *val = (LDKCResult_OutPointDecodeErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	LDKOutPoint res_var = (*val->contents.result);
	uint64_t res_ref = 0;
	CHECK((((uint64_t)res_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&res_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	res_ref = (uint64_t)res_var.inner & ~1;
	return res_ref;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1OutPointDecodeErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_OutPointDecodeErrorZ *val = (LDKCResult_OutPointDecodeErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	LDKDecodeError err_var = (*val->contents.err);
	uint64_t err_ref = 0;
	CHECK((((uint64_t)err_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&err_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	err_ref = (uint64_t)err_var.inner & ~1;
	return err_ref;
}
typedef struct LDKType_JCalls {
	atomic_size_t refcnt;
	JavaVM *vm;
	jweak o;
	jmethodID type_id_meth;
	jmethodID debug_str_meth;
	jmethodID write_meth;
} LDKType_JCalls;
static void LDKType_JCalls_free(void* this_arg) {
	LDKType_JCalls *j_calls = (LDKType_JCalls*) this_arg;
	if (atomic_fetch_sub_explicit(&j_calls->refcnt, 1, memory_order_acquire) == 1) {
		JNIEnv *env;
		jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
		if (get_jenv_res == JNI_EDETACHED) {
			DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
		} else {
			DO_ASSERT(get_jenv_res == JNI_OK);
		}
		(*env)->DeleteWeakGlobalRef(env, j_calls->o);
		if (get_jenv_res == JNI_EDETACHED) {
			DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
		}
		FREE(j_calls);
	}
}
uint16_t type_id_LDKType_jcall(const void* this_arg) {
	LDKType_JCalls *j_calls = (LDKType_JCalls*) this_arg;
	JNIEnv *env;
	jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
	} else {
		DO_ASSERT(get_jenv_res == JNI_OK);
	}
	jobject obj = (*env)->NewLocalRef(env, j_calls->o);
	CHECK(obj != NULL);
	int16_t ret = (*env)->CallShortMethod(env, obj, j_calls->type_id_meth);
	if ((*env)->ExceptionCheck(env)) {
		(*env)->ExceptionDescribe(env);
		(*env)->FatalError(env, "A call to type_id in LDKType from rust threw an exception.");
	}
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
	}
	return ret;
}
LDKStr debug_str_LDKType_jcall(const void* this_arg) {
	LDKType_JCalls *j_calls = (LDKType_JCalls*) this_arg;
	JNIEnv *env;
	jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
	} else {
		DO_ASSERT(get_jenv_res == JNI_OK);
	}
	jobject obj = (*env)->NewLocalRef(env, j_calls->o);
	CHECK(obj != NULL);
	jstring ret = (*env)->CallObjectMethod(env, obj, j_calls->debug_str_meth);
	if ((*env)->ExceptionCheck(env)) {
		(*env)->ExceptionDescribe(env);
		(*env)->FatalError(env, "A call to debug_str in LDKType from rust threw an exception.");
	}
	LDKStr ret_conv = java_to_owned_str(env, ret);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
	}
	return ret_conv;
}
LDKCVec_u8Z write_LDKType_jcall(const void* this_arg) {
	LDKType_JCalls *j_calls = (LDKType_JCalls*) this_arg;
	JNIEnv *env;
	jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
	} else {
		DO_ASSERT(get_jenv_res == JNI_OK);
	}
	jobject obj = (*env)->NewLocalRef(env, j_calls->o);
	CHECK(obj != NULL);
	int8_tArray ret = (*env)->CallObjectMethod(env, obj, j_calls->write_meth);
	if ((*env)->ExceptionCheck(env)) {
		(*env)->ExceptionDescribe(env);
		(*env)->FatalError(env, "A call to write in LDKType from rust threw an exception.");
	}
	LDKCVec_u8Z ret_ref;
	ret_ref.datalen = (*env)->GetArrayLength(env, ret);
	ret_ref.data = MALLOC(ret_ref.datalen, "LDKCVec_u8Z Bytes");
	(*env)->GetByteArrayRegion(env, ret, 0, ret_ref.datalen, ret_ref.data);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
	}
	return ret_ref;
}
static void LDKType_JCalls_cloned(LDKType* new_obj) {
	LDKType_JCalls *j_calls = (LDKType_JCalls*) new_obj->this_arg;
	atomic_fetch_add_explicit(&j_calls->refcnt, 1, memory_order_release);
}
static inline LDKType LDKType_init (JNIEnv *env, jclass clz, jobject o) {
	jclass c = (*env)->GetObjectClass(env, o);
	CHECK(c != NULL);
	LDKType_JCalls *calls = MALLOC(sizeof(LDKType_JCalls), "LDKType_JCalls");
	atomic_init(&calls->refcnt, 1);
	DO_ASSERT((*env)->GetJavaVM(env, &calls->vm) == 0);
	calls->o = (*env)->NewWeakGlobalRef(env, o);
	calls->type_id_meth = (*env)->GetMethodID(env, c, "type_id", "()S");
	CHECK(calls->type_id_meth != NULL);
	calls->debug_str_meth = (*env)->GetMethodID(env, c, "debug_str", "()Ljava/lang/String;");
	CHECK(calls->debug_str_meth != NULL);
	calls->write_meth = (*env)->GetMethodID(env, c, "write", "()[B");
	CHECK(calls->write_meth != NULL);

	LDKType ret = {
		.this_arg = (void*) calls,
		.type_id = type_id_LDKType_jcall,
		.debug_str = debug_str_LDKType_jcall,
		.write = write_LDKType_jcall,
		.cloned = LDKType_JCalls_cloned,
		.free = LDKType_JCalls_free,
	};
	return ret;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKType_1new(JNIEnv *env, jclass clz, jobject o) {
	LDKType *res_ptr = MALLOC(sizeof(LDKType), "LDKType");
	*res_ptr = LDKType_init(env, clz, o);
	return (uint64_t)res_ptr;
}
JNIEXPORT int16_t JNICALL Java_org_ldk_impl_bindings_Type_1type_1id(JNIEnv *env, jclass clz, int64_t this_arg) {
	void* this_arg_ptr = (void*)(((uint64_t)this_arg) & ~1);
	if (!(this_arg & 1)) { CHECK_ACCESS(this_arg_ptr); }
	LDKType* this_arg_conv = (LDKType*)this_arg_ptr;
	int16_t ret_val = (this_arg_conv->type_id)(this_arg_conv->this_arg);
	return ret_val;
}

JNIEXPORT jstring JNICALL Java_org_ldk_impl_bindings_Type_1debug_1str(JNIEnv *env, jclass clz, int64_t this_arg) {
	void* this_arg_ptr = (void*)(((uint64_t)this_arg) & ~1);
	if (!(this_arg & 1)) { CHECK_ACCESS(this_arg_ptr); }
	LDKType* this_arg_conv = (LDKType*)this_arg_ptr;
	LDKStr ret_str = (this_arg_conv->debug_str)(this_arg_conv->this_arg);
	jstring ret_conv = str_ref_to_java(env, ret_str.chars, ret_str.len);
	Str_free(ret_str);
	return ret_conv;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_Type_1write(JNIEnv *env, jclass clz, int64_t this_arg) {
	void* this_arg_ptr = (void*)(((uint64_t)this_arg) & ~1);
	if (!(this_arg & 1)) { CHECK_ACCESS(this_arg_ptr); }
	LDKType* this_arg_conv = (LDKType*)this_arg_ptr;
	LDKCVec_u8Z ret_var = (this_arg_conv->write)(this_arg_conv->this_arg);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	CVec_u8Z_free(ret_var);
	return ret_arr;
}

static jclass LDKCOption_TypeZ_Some_class = NULL;
static jmethodID LDKCOption_TypeZ_Some_meth = NULL;
static jclass LDKCOption_TypeZ_None_class = NULL;
static jmethodID LDKCOption_TypeZ_None_meth = NULL;
JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_00024LDKCOption_1TypeZ_init (JNIEnv *env, jclass clz) {
	LDKCOption_TypeZ_Some_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKCOption_TypeZ$Some;"));
	CHECK(LDKCOption_TypeZ_Some_class != NULL);
	LDKCOption_TypeZ_Some_meth = (*env)->GetMethodID(env, LDKCOption_TypeZ_Some_class, "<init>", "(J)V");
	CHECK(LDKCOption_TypeZ_Some_meth != NULL);
	LDKCOption_TypeZ_None_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKCOption_TypeZ$None;"));
	CHECK(LDKCOption_TypeZ_None_class != NULL);
	LDKCOption_TypeZ_None_meth = (*env)->GetMethodID(env, LDKCOption_TypeZ_None_class, "<init>", "()V");
	CHECK(LDKCOption_TypeZ_None_meth != NULL);
}
JNIEXPORT jobject JNICALL Java_org_ldk_impl_bindings_LDKCOption_1TypeZ_1ref_1from_1ptr(JNIEnv *env, jclass clz, int64_t ptr) {
	LDKCOption_TypeZ *obj = (LDKCOption_TypeZ*)(ptr & ~1);
	switch(obj->tag) {
		case LDKCOption_TypeZ_Some: {
			LDKType* some_ret = MALLOC(sizeof(LDKType), "LDKType");
			*some_ret = Type_clone(&obj->some);
			return (*env)->NewObject(env, LDKCOption_TypeZ_Some_class, LDKCOption_TypeZ_Some_meth, (uint64_t)some_ret);
		}
		case LDKCOption_TypeZ_None: {
			return (*env)->NewObject(env, LDKCOption_TypeZ_None_class, LDKCOption_TypeZ_None_meth);
		}
		default: abort();
	}
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1COption_1TypeZDecodeErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_COption_TypeZDecodeErrorZ*)arg)->result_ok;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1COption_1TypeZDecodeErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_COption_TypeZDecodeErrorZ *val = (LDKCResult_COption_TypeZDecodeErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	uint64_t res_ref = ((uint64_t)&(*val->contents.result)) | 1;
	return res_ref;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1COption_1TypeZDecodeErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_COption_TypeZDecodeErrorZ *val = (LDKCResult_COption_TypeZDecodeErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	LDKDecodeError err_var = (*val->contents.err);
	uint64_t err_ref = 0;
	CHECK((((uint64_t)err_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&err_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	err_ref = (uint64_t)err_var.inner & ~1;
	return err_ref;
}
static jclass LDKPaymentError_Invoice_class = NULL;
static jmethodID LDKPaymentError_Invoice_meth = NULL;
static jclass LDKPaymentError_Routing_class = NULL;
static jmethodID LDKPaymentError_Routing_meth = NULL;
static jclass LDKPaymentError_Sending_class = NULL;
static jmethodID LDKPaymentError_Sending_meth = NULL;
JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_00024LDKPaymentError_init (JNIEnv *env, jclass clz) {
	LDKPaymentError_Invoice_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKPaymentError$Invoice;"));
	CHECK(LDKPaymentError_Invoice_class != NULL);
	LDKPaymentError_Invoice_meth = (*env)->GetMethodID(env, LDKPaymentError_Invoice_class, "<init>", "(Ljava/lang/String;)V");
	CHECK(LDKPaymentError_Invoice_meth != NULL);
	LDKPaymentError_Routing_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKPaymentError$Routing;"));
	CHECK(LDKPaymentError_Routing_class != NULL);
	LDKPaymentError_Routing_meth = (*env)->GetMethodID(env, LDKPaymentError_Routing_class, "<init>", "(J)V");
	CHECK(LDKPaymentError_Routing_meth != NULL);
	LDKPaymentError_Sending_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKPaymentError$Sending;"));
	CHECK(LDKPaymentError_Sending_class != NULL);
	LDKPaymentError_Sending_meth = (*env)->GetMethodID(env, LDKPaymentError_Sending_class, "<init>", "(J)V");
	CHECK(LDKPaymentError_Sending_meth != NULL);
}
JNIEXPORT jobject JNICALL Java_org_ldk_impl_bindings_LDKPaymentError_1ref_1from_1ptr(JNIEnv *env, jclass clz, int64_t ptr) {
	LDKPaymentError *obj = (LDKPaymentError*)(ptr & ~1);
	switch(obj->tag) {
		case LDKPaymentError_Invoice: {
			LDKStr invoice_str = obj->invoice;
			jstring invoice_conv = str_ref_to_java(env, invoice_str.chars, invoice_str.len);
			return (*env)->NewObject(env, LDKPaymentError_Invoice_class, LDKPaymentError_Invoice_meth, invoice_conv);
		}
		case LDKPaymentError_Routing: {
			LDKLightningError routing_var = obj->routing;
			uint64_t routing_ref = 0;
			CHECK((((uint64_t)routing_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
			CHECK((((uint64_t)&routing_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
			routing_ref = (uint64_t)routing_var.inner & ~1;
			return (*env)->NewObject(env, LDKPaymentError_Routing_class, LDKPaymentError_Routing_meth, routing_ref);
		}
		case LDKPaymentError_Sending: {
			uint64_t sending_ref = ((uint64_t)&obj->sending) | 1;
			return (*env)->NewObject(env, LDKPaymentError_Sending_class, LDKPaymentError_Sending_meth, sending_ref);
		}
		default: abort();
	}
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1PaymentIdPaymentErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_PaymentIdPaymentErrorZ*)arg)->result_ok;
}
JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_LDKCResult_1PaymentIdPaymentErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_PaymentIdPaymentErrorZ *val = (LDKCResult_PaymentIdPaymentErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	int8_tArray res_arr = (*env)->NewByteArray(env, 32);
	(*env)->SetByteArrayRegion(env, res_arr, 0, 32, (*val->contents.result).data);
	return res_arr;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1PaymentIdPaymentErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_PaymentIdPaymentErrorZ *val = (LDKCResult_PaymentIdPaymentErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	uint64_t err_ref = ((uint64_t)&(*val->contents.err)) | 1;
	return err_ref;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1SiPrefixNoneZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_SiPrefixNoneZ*)arg)->result_ok;
}
JNIEXPORT jclass JNICALL Java_org_ldk_impl_bindings_LDKCResult_1SiPrefixNoneZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_SiPrefixNoneZ *val = (LDKCResult_SiPrefixNoneZ*)(arg & ~1);
	CHECK(val->result_ok);
	jclass res_conv = LDKSiPrefix_to_java(env, (*val->contents.result));
	return res_conv;
}
JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_LDKCResult_1SiPrefixNoneZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_SiPrefixNoneZ *val = (LDKCResult_SiPrefixNoneZ*)(arg & ~1);
	CHECK(!val->result_ok);
	return *val->contents.err;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1InvoiceNoneZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_InvoiceNoneZ*)arg)->result_ok;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1InvoiceNoneZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_InvoiceNoneZ *val = (LDKCResult_InvoiceNoneZ*)(arg & ~1);
	CHECK(val->result_ok);
	LDKInvoice res_var = (*val->contents.result);
	uint64_t res_ref = 0;
	CHECK((((uint64_t)res_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&res_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	res_ref = (uint64_t)res_var.inner & ~1;
	return res_ref;
}
JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_LDKCResult_1InvoiceNoneZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_InvoiceNoneZ *val = (LDKCResult_InvoiceNoneZ*)(arg & ~1);
	CHECK(!val->result_ok);
	return *val->contents.err;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1SignedRawInvoiceNoneZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_SignedRawInvoiceNoneZ*)arg)->result_ok;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1SignedRawInvoiceNoneZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_SignedRawInvoiceNoneZ *val = (LDKCResult_SignedRawInvoiceNoneZ*)(arg & ~1);
	CHECK(val->result_ok);
	LDKSignedRawInvoice res_var = (*val->contents.result);
	uint64_t res_ref = 0;
	CHECK((((uint64_t)res_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&res_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	res_ref = (uint64_t)res_var.inner & ~1;
	return res_ref;
}
JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_LDKCResult_1SignedRawInvoiceNoneZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_SignedRawInvoiceNoneZ *val = (LDKCResult_SignedRawInvoiceNoneZ*)(arg & ~1);
	CHECK(!val->result_ok);
	return *val->contents.err;
}
static inline struct LDKRawInvoice C3Tuple_RawInvoice_u832InvoiceSignatureZ_get_a(LDKC3Tuple_RawInvoice_u832InvoiceSignatureZ *NONNULL_PTR tuple){
	return RawInvoice_clone(&tuple->a);
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_C3Tuple_1RawInvoice_1u832InvoiceSignatureZ_1get_1a(JNIEnv *env, jclass clz, int64_t tuple) {
	LDKC3Tuple_RawInvoice_u832InvoiceSignatureZ* tuple_conv = (LDKC3Tuple_RawInvoice_u832InvoiceSignatureZ*)(tuple & ~1);
	LDKRawInvoice ret_var = C3Tuple_RawInvoice_u832InvoiceSignatureZ_get_a(tuple_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

static inline struct LDKThirtyTwoBytes C3Tuple_RawInvoice_u832InvoiceSignatureZ_get_b(LDKC3Tuple_RawInvoice_u832InvoiceSignatureZ *NONNULL_PTR tuple){
	return ThirtyTwoBytes_clone(&tuple->b);
}
JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_C3Tuple_1RawInvoice_1u832InvoiceSignatureZ_1get_1b(JNIEnv *env, jclass clz, int64_t tuple) {
	LDKC3Tuple_RawInvoice_u832InvoiceSignatureZ* tuple_conv = (LDKC3Tuple_RawInvoice_u832InvoiceSignatureZ*)(tuple & ~1);
	int8_tArray ret_arr = (*env)->NewByteArray(env, 32);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 32, C3Tuple_RawInvoice_u832InvoiceSignatureZ_get_b(tuple_conv).data);
	return ret_arr;
}

static inline struct LDKInvoiceSignature C3Tuple_RawInvoice_u832InvoiceSignatureZ_get_c(LDKC3Tuple_RawInvoice_u832InvoiceSignatureZ *NONNULL_PTR tuple){
	return InvoiceSignature_clone(&tuple->c);
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_C3Tuple_1RawInvoice_1u832InvoiceSignatureZ_1get_1c(JNIEnv *env, jclass clz, int64_t tuple) {
	LDKC3Tuple_RawInvoice_u832InvoiceSignatureZ* tuple_conv = (LDKC3Tuple_RawInvoice_u832InvoiceSignatureZ*)(tuple & ~1);
	LDKInvoiceSignature ret_var = C3Tuple_RawInvoice_u832InvoiceSignatureZ_get_c(tuple_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1PayeePubKeyErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_PayeePubKeyErrorZ*)arg)->result_ok;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1PayeePubKeyErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_PayeePubKeyErrorZ *val = (LDKCResult_PayeePubKeyErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	LDKPayeePubKey res_var = (*val->contents.result);
	uint64_t res_ref = 0;
	CHECK((((uint64_t)res_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&res_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	res_ref = (uint64_t)res_var.inner & ~1;
	return res_ref;
}
JNIEXPORT jclass JNICALL Java_org_ldk_impl_bindings_LDKCResult_1PayeePubKeyErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_PayeePubKeyErrorZ *val = (LDKCResult_PayeePubKeyErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	jclass err_conv = LDKSecp256k1Error_to_java(env, (*val->contents.err));
	return err_conv;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCVec_1PrivateRouteZ_1new(JNIEnv *env, jclass clz, int64_tArray elems) {
	LDKCVec_PrivateRouteZ *ret = MALLOC(sizeof(LDKCVec_PrivateRouteZ), "LDKCVec_PrivateRouteZ");
	ret->datalen = (*env)->GetArrayLength(env, elems);
	if (ret->datalen == 0) {
		ret->data = NULL;
	} else {
		ret->data = MALLOC(sizeof(LDKPrivateRoute) * ret->datalen, "LDKCVec_PrivateRouteZ Data");
		int64_t *java_elems = (*env)->GetPrimitiveArrayCritical(env, elems, NULL);
		for (size_t i = 0; i < ret->datalen; i++) {
			int64_t arr_elem = java_elems[i];
			LDKPrivateRoute arr_elem_conv;
			arr_elem_conv.inner = (void*)(arr_elem & (~1));
			arr_elem_conv.is_owned = (arr_elem & 1) || (arr_elem == 0);
			arr_elem_conv = PrivateRoute_clone(&arr_elem_conv);
			ret->data[i] = arr_elem_conv;
		}
		(*env)->ReleasePrimitiveArrayCritical(env, elems, java_elems, 0);
	}
	return (uint64_t)ret;
}
static inline LDKCVec_PrivateRouteZ CVec_PrivateRouteZ_clone(const LDKCVec_PrivateRouteZ *orig) {
	LDKCVec_PrivateRouteZ ret = { .data = MALLOC(sizeof(LDKPrivateRoute) * orig->datalen, "LDKCVec_PrivateRouteZ clone bytes"), .datalen = orig->datalen };
	for (size_t i = 0; i < ret.datalen; i++) {
		ret.data[i] = PrivateRoute_clone(&orig->data[i]);
	}
	return ret;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1PositiveTimestampCreationErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_PositiveTimestampCreationErrorZ*)arg)->result_ok;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1PositiveTimestampCreationErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_PositiveTimestampCreationErrorZ *val = (LDKCResult_PositiveTimestampCreationErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	LDKPositiveTimestamp res_var = (*val->contents.result);
	uint64_t res_ref = 0;
	CHECK((((uint64_t)res_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&res_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	res_ref = (uint64_t)res_var.inner & ~1;
	return res_ref;
}
JNIEXPORT jclass JNICALL Java_org_ldk_impl_bindings_LDKCResult_1PositiveTimestampCreationErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_PositiveTimestampCreationErrorZ *val = (LDKCResult_PositiveTimestampCreationErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	jclass err_conv = LDKCreationError_to_java(env, (*val->contents.err));
	return err_conv;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1NoneSemanticErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_NoneSemanticErrorZ*)arg)->result_ok;
}
JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_LDKCResult_1NoneSemanticErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_NoneSemanticErrorZ *val = (LDKCResult_NoneSemanticErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	return *val->contents.result;
}
JNIEXPORT jclass JNICALL Java_org_ldk_impl_bindings_LDKCResult_1NoneSemanticErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_NoneSemanticErrorZ *val = (LDKCResult_NoneSemanticErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	jclass err_conv = LDKSemanticError_to_java(env, (*val->contents.err));
	return err_conv;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1InvoiceSemanticErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_InvoiceSemanticErrorZ*)arg)->result_ok;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1InvoiceSemanticErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_InvoiceSemanticErrorZ *val = (LDKCResult_InvoiceSemanticErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	LDKInvoice res_var = (*val->contents.result);
	uint64_t res_ref = 0;
	CHECK((((uint64_t)res_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&res_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	res_ref = (uint64_t)res_var.inner & ~1;
	return res_ref;
}
JNIEXPORT jclass JNICALL Java_org_ldk_impl_bindings_LDKCResult_1InvoiceSemanticErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_InvoiceSemanticErrorZ *val = (LDKCResult_InvoiceSemanticErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	jclass err_conv = LDKSemanticError_to_java(env, (*val->contents.err));
	return err_conv;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1DescriptionCreationErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_DescriptionCreationErrorZ*)arg)->result_ok;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1DescriptionCreationErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_DescriptionCreationErrorZ *val = (LDKCResult_DescriptionCreationErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	LDKDescription res_var = (*val->contents.result);
	uint64_t res_ref = 0;
	CHECK((((uint64_t)res_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&res_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	res_ref = (uint64_t)res_var.inner & ~1;
	return res_ref;
}
JNIEXPORT jclass JNICALL Java_org_ldk_impl_bindings_LDKCResult_1DescriptionCreationErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_DescriptionCreationErrorZ *val = (LDKCResult_DescriptionCreationErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	jclass err_conv = LDKCreationError_to_java(env, (*val->contents.err));
	return err_conv;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1ExpiryTimeCreationErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_ExpiryTimeCreationErrorZ*)arg)->result_ok;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1ExpiryTimeCreationErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_ExpiryTimeCreationErrorZ *val = (LDKCResult_ExpiryTimeCreationErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	LDKExpiryTime res_var = (*val->contents.result);
	uint64_t res_ref = 0;
	CHECK((((uint64_t)res_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&res_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	res_ref = (uint64_t)res_var.inner & ~1;
	return res_ref;
}
JNIEXPORT jclass JNICALL Java_org_ldk_impl_bindings_LDKCResult_1ExpiryTimeCreationErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_ExpiryTimeCreationErrorZ *val = (LDKCResult_ExpiryTimeCreationErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	jclass err_conv = LDKCreationError_to_java(env, (*val->contents.err));
	return err_conv;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1PrivateRouteCreationErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_PrivateRouteCreationErrorZ*)arg)->result_ok;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1PrivateRouteCreationErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_PrivateRouteCreationErrorZ *val = (LDKCResult_PrivateRouteCreationErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	LDKPrivateRoute res_var = (*val->contents.result);
	uint64_t res_ref = 0;
	CHECK((((uint64_t)res_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&res_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	res_ref = (uint64_t)res_var.inner & ~1;
	return res_ref;
}
JNIEXPORT jclass JNICALL Java_org_ldk_impl_bindings_LDKCResult_1PrivateRouteCreationErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_PrivateRouteCreationErrorZ *val = (LDKCResult_PrivateRouteCreationErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	jclass err_conv = LDKCreationError_to_java(env, (*val->contents.err));
	return err_conv;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1StringErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_StringErrorZ*)arg)->result_ok;
}
JNIEXPORT jstring JNICALL Java_org_ldk_impl_bindings_LDKCResult_1StringErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_StringErrorZ *val = (LDKCResult_StringErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	LDKStr res_str = (*val->contents.result);
	jstring res_conv = str_ref_to_java(env, res_str.chars, res_str.len);
	return res_conv;
}
JNIEXPORT jclass JNICALL Java_org_ldk_impl_bindings_LDKCResult_1StringErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_StringErrorZ *val = (LDKCResult_StringErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	jclass err_conv = LDKSecp256k1Error_to_java(env, (*val->contents.err));
	return err_conv;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1ChannelMonitorUpdateDecodeErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_ChannelMonitorUpdateDecodeErrorZ*)arg)->result_ok;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1ChannelMonitorUpdateDecodeErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_ChannelMonitorUpdateDecodeErrorZ *val = (LDKCResult_ChannelMonitorUpdateDecodeErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	LDKChannelMonitorUpdate res_var = (*val->contents.result);
	uint64_t res_ref = 0;
	CHECK((((uint64_t)res_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&res_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	res_ref = (uint64_t)res_var.inner & ~1;
	return res_ref;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1ChannelMonitorUpdateDecodeErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_ChannelMonitorUpdateDecodeErrorZ *val = (LDKCResult_ChannelMonitorUpdateDecodeErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	LDKDecodeError err_var = (*val->contents.err);
	uint64_t err_ref = 0;
	CHECK((((uint64_t)err_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&err_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	err_ref = (uint64_t)err_var.inner & ~1;
	return err_ref;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1HTLCUpdateDecodeErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_HTLCUpdateDecodeErrorZ*)arg)->result_ok;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1HTLCUpdateDecodeErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_HTLCUpdateDecodeErrorZ *val = (LDKCResult_HTLCUpdateDecodeErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	LDKHTLCUpdate res_var = (*val->contents.result);
	uint64_t res_ref = 0;
	CHECK((((uint64_t)res_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&res_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	res_ref = (uint64_t)res_var.inner & ~1;
	return res_ref;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1HTLCUpdateDecodeErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_HTLCUpdateDecodeErrorZ *val = (LDKCResult_HTLCUpdateDecodeErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	LDKDecodeError err_var = (*val->contents.err);
	uint64_t err_ref = 0;
	CHECK((((uint64_t)err_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&err_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	err_ref = (uint64_t)err_var.inner & ~1;
	return err_ref;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1NoneMonitorUpdateErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_NoneMonitorUpdateErrorZ*)arg)->result_ok;
}
JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_LDKCResult_1NoneMonitorUpdateErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_NoneMonitorUpdateErrorZ *val = (LDKCResult_NoneMonitorUpdateErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	return *val->contents.result;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1NoneMonitorUpdateErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_NoneMonitorUpdateErrorZ *val = (LDKCResult_NoneMonitorUpdateErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	LDKMonitorUpdateError err_var = (*val->contents.err);
	uint64_t err_ref = 0;
	CHECK((((uint64_t)err_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&err_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	err_ref = (uint64_t)err_var.inner & ~1;
	return err_ref;
}
static inline struct LDKOutPoint C2Tuple_OutPointScriptZ_get_a(LDKC2Tuple_OutPointScriptZ *NONNULL_PTR tuple){
	return OutPoint_clone(&tuple->a);
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_C2Tuple_1OutPointScriptZ_1get_1a(JNIEnv *env, jclass clz, int64_t tuple) {
	LDKC2Tuple_OutPointScriptZ* tuple_conv = (LDKC2Tuple_OutPointScriptZ*)(tuple & ~1);
	LDKOutPoint ret_var = C2Tuple_OutPointScriptZ_get_a(tuple_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

static inline struct LDKCVec_u8Z C2Tuple_OutPointScriptZ_get_b(LDKC2Tuple_OutPointScriptZ *NONNULL_PTR tuple){
	return CVec_u8Z_clone(&tuple->b);
}
JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_C2Tuple_1OutPointScriptZ_1get_1b(JNIEnv *env, jclass clz, int64_t tuple) {
	LDKC2Tuple_OutPointScriptZ* tuple_conv = (LDKC2Tuple_OutPointScriptZ*)(tuple & ~1);
	LDKCVec_u8Z ret_var = C2Tuple_OutPointScriptZ_get_b(tuple_conv);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	CVec_u8Z_free(ret_var);
	return ret_arr;
}

static inline uint32_t C2Tuple_u32ScriptZ_get_a(LDKC2Tuple_u32ScriptZ *NONNULL_PTR tuple){
	return tuple->a;
}
JNIEXPORT int32_t JNICALL Java_org_ldk_impl_bindings_C2Tuple_1u32ScriptZ_1get_1a(JNIEnv *env, jclass clz, int64_t tuple) {
	LDKC2Tuple_u32ScriptZ* tuple_conv = (LDKC2Tuple_u32ScriptZ*)(tuple & ~1);
	int32_t ret_val = C2Tuple_u32ScriptZ_get_a(tuple_conv);
	return ret_val;
}

static inline struct LDKCVec_u8Z C2Tuple_u32ScriptZ_get_b(LDKC2Tuple_u32ScriptZ *NONNULL_PTR tuple){
	return CVec_u8Z_clone(&tuple->b);
}
JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_C2Tuple_1u32ScriptZ_1get_1b(JNIEnv *env, jclass clz, int64_t tuple) {
	LDKC2Tuple_u32ScriptZ* tuple_conv = (LDKC2Tuple_u32ScriptZ*)(tuple & ~1);
	LDKCVec_u8Z ret_var = C2Tuple_u32ScriptZ_get_b(tuple_conv);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	CVec_u8Z_free(ret_var);
	return ret_arr;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCVec_1C2Tuple_1u32ScriptZZ_1new(JNIEnv *env, jclass clz, int64_tArray elems) {
	LDKCVec_C2Tuple_u32ScriptZZ *ret = MALLOC(sizeof(LDKCVec_C2Tuple_u32ScriptZZ), "LDKCVec_C2Tuple_u32ScriptZZ");
	ret->datalen = (*env)->GetArrayLength(env, elems);
	if (ret->datalen == 0) {
		ret->data = NULL;
	} else {
		ret->data = MALLOC(sizeof(LDKC2Tuple_u32ScriptZ) * ret->datalen, "LDKCVec_C2Tuple_u32ScriptZZ Data");
		int64_t *java_elems = (*env)->GetPrimitiveArrayCritical(env, elems, NULL);
		for (size_t i = 0; i < ret->datalen; i++) {
			int64_t arr_elem = java_elems[i];
			void* arr_elem_ptr = (void*)(((uint64_t)arr_elem) & ~1);
			CHECK_ACCESS(arr_elem_ptr);
			LDKC2Tuple_u32ScriptZ arr_elem_conv = *(LDKC2Tuple_u32ScriptZ*)(arr_elem_ptr);
			arr_elem_conv = C2Tuple_u32ScriptZ_clone((LDKC2Tuple_u32ScriptZ*)(((uint64_t)arr_elem) & ~1));
			ret->data[i] = arr_elem_conv;
		}
		(*env)->ReleasePrimitiveArrayCritical(env, elems, java_elems, 0);
	}
	return (uint64_t)ret;
}
static inline LDKCVec_C2Tuple_u32ScriptZZ CVec_C2Tuple_u32ScriptZZ_clone(const LDKCVec_C2Tuple_u32ScriptZZ *orig) {
	LDKCVec_C2Tuple_u32ScriptZZ ret = { .data = MALLOC(sizeof(LDKC2Tuple_u32ScriptZ) * orig->datalen, "LDKCVec_C2Tuple_u32ScriptZZ clone bytes"), .datalen = orig->datalen };
	for (size_t i = 0; i < ret.datalen; i++) {
		ret.data[i] = C2Tuple_u32ScriptZ_clone(&orig->data[i]);
	}
	return ret;
}
static inline struct LDKThirtyTwoBytes C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_get_a(LDKC2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ *NONNULL_PTR tuple){
	return ThirtyTwoBytes_clone(&tuple->a);
}
JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_C2Tuple_1TxidCVec_1C2Tuple_1u32ScriptZZZ_1get_1a(JNIEnv *env, jclass clz, int64_t tuple) {
	LDKC2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ* tuple_conv = (LDKC2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ*)(tuple & ~1);
	int8_tArray ret_arr = (*env)->NewByteArray(env, 32);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 32, C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_get_a(tuple_conv).data);
	return ret_arr;
}

static inline struct LDKCVec_C2Tuple_u32ScriptZZ C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_get_b(LDKC2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ *NONNULL_PTR tuple){
	return CVec_C2Tuple_u32ScriptZZ_clone(&tuple->b);
}
JNIEXPORT int64_tArray JNICALL Java_org_ldk_impl_bindings_C2Tuple_1TxidCVec_1C2Tuple_1u32ScriptZZZ_1get_1b(JNIEnv *env, jclass clz, int64_t tuple) {
	LDKC2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ* tuple_conv = (LDKC2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ*)(tuple & ~1);
	LDKCVec_C2Tuple_u32ScriptZZ ret_var = C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_get_b(tuple_conv);
	int64_tArray ret_arr = NULL;
	ret_arr = (*env)->NewLongArray(env, ret_var.datalen);
	int64_t *ret_arr_ptr = (*env)->GetPrimitiveArrayCritical(env, ret_arr, NULL);
	for (size_t v = 0; v < ret_var.datalen; v++) {
		LDKC2Tuple_u32ScriptZ* ret_conv_21_conv = MALLOC(sizeof(LDKC2Tuple_u32ScriptZ), "LDKC2Tuple_u32ScriptZ");
		*ret_conv_21_conv = ret_var.data[v];
		ret_arr_ptr[v] = ((uint64_t)ret_conv_21_conv);
	}
	(*env)->ReleasePrimitiveArrayCritical(env, ret_arr, ret_arr_ptr, 0);
	FREE(ret_var.data);
	return ret_arr;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCVec_1C2Tuple_1TxidCVec_1C2Tuple_1u32ScriptZZZZ_1new(JNIEnv *env, jclass clz, int64_tArray elems) {
	LDKCVec_C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZZ *ret = MALLOC(sizeof(LDKCVec_C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZZ), "LDKCVec_C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZZ");
	ret->datalen = (*env)->GetArrayLength(env, elems);
	if (ret->datalen == 0) {
		ret->data = NULL;
	} else {
		ret->data = MALLOC(sizeof(LDKC2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ) * ret->datalen, "LDKCVec_C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZZ Data");
		int64_t *java_elems = (*env)->GetPrimitiveArrayCritical(env, elems, NULL);
		for (size_t i = 0; i < ret->datalen; i++) {
			int64_t arr_elem = java_elems[i];
			void* arr_elem_ptr = (void*)(((uint64_t)arr_elem) & ~1);
			CHECK_ACCESS(arr_elem_ptr);
			LDKC2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ arr_elem_conv = *(LDKC2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ*)(arr_elem_ptr);
			arr_elem_conv = C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_clone((LDKC2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ*)(((uint64_t)arr_elem) & ~1));
			ret->data[i] = arr_elem_conv;
		}
		(*env)->ReleasePrimitiveArrayCritical(env, elems, java_elems, 0);
	}
	return (uint64_t)ret;
}
static inline LDKCVec_C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZZ CVec_C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZZ_clone(const LDKCVec_C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZZ *orig) {
	LDKCVec_C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZZ ret = { .data = MALLOC(sizeof(LDKC2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ) * orig->datalen, "LDKCVec_C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZZ clone bytes"), .datalen = orig->datalen };
	for (size_t i = 0; i < ret.datalen; i++) {
		ret.data[i] = C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_clone(&orig->data[i]);
	}
	return ret;
}
static jclass LDKPaymentPurpose_InvoicePayment_class = NULL;
static jmethodID LDKPaymentPurpose_InvoicePayment_meth = NULL;
static jclass LDKPaymentPurpose_SpontaneousPayment_class = NULL;
static jmethodID LDKPaymentPurpose_SpontaneousPayment_meth = NULL;
JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_00024LDKPaymentPurpose_init (JNIEnv *env, jclass clz) {
	LDKPaymentPurpose_InvoicePayment_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKPaymentPurpose$InvoicePayment;"));
	CHECK(LDKPaymentPurpose_InvoicePayment_class != NULL);
	LDKPaymentPurpose_InvoicePayment_meth = (*env)->GetMethodID(env, LDKPaymentPurpose_InvoicePayment_class, "<init>", "([B[BJ)V");
	CHECK(LDKPaymentPurpose_InvoicePayment_meth != NULL);
	LDKPaymentPurpose_SpontaneousPayment_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKPaymentPurpose$SpontaneousPayment;"));
	CHECK(LDKPaymentPurpose_SpontaneousPayment_class != NULL);
	LDKPaymentPurpose_SpontaneousPayment_meth = (*env)->GetMethodID(env, LDKPaymentPurpose_SpontaneousPayment_class, "<init>", "([B)V");
	CHECK(LDKPaymentPurpose_SpontaneousPayment_meth != NULL);
}
JNIEXPORT jobject JNICALL Java_org_ldk_impl_bindings_LDKPaymentPurpose_1ref_1from_1ptr(JNIEnv *env, jclass clz, int64_t ptr) {
	LDKPaymentPurpose *obj = (LDKPaymentPurpose*)(ptr & ~1);
	switch(obj->tag) {
		case LDKPaymentPurpose_InvoicePayment: {
			int8_tArray payment_preimage_arr = (*env)->NewByteArray(env, 32);
			(*env)->SetByteArrayRegion(env, payment_preimage_arr, 0, 32, obj->invoice_payment.payment_preimage.data);
			int8_tArray payment_secret_arr = (*env)->NewByteArray(env, 32);
			(*env)->SetByteArrayRegion(env, payment_secret_arr, 0, 32, obj->invoice_payment.payment_secret.data);
			return (*env)->NewObject(env, LDKPaymentPurpose_InvoicePayment_class, LDKPaymentPurpose_InvoicePayment_meth, payment_preimage_arr, payment_secret_arr, obj->invoice_payment.user_payment_id);
		}
		case LDKPaymentPurpose_SpontaneousPayment: {
			int8_tArray spontaneous_payment_arr = (*env)->NewByteArray(env, 32);
			(*env)->SetByteArrayRegion(env, spontaneous_payment_arr, 0, 32, obj->spontaneous_payment.data);
			return (*env)->NewObject(env, LDKPaymentPurpose_SpontaneousPayment_class, LDKPaymentPurpose_SpontaneousPayment_meth, spontaneous_payment_arr);
		}
		default: abort();
	}
}
static jclass LDKClosureReason_CounterpartyForceClosed_class = NULL;
static jmethodID LDKClosureReason_CounterpartyForceClosed_meth = NULL;
static jclass LDKClosureReason_HolderForceClosed_class = NULL;
static jmethodID LDKClosureReason_HolderForceClosed_meth = NULL;
static jclass LDKClosureReason_CooperativeClosure_class = NULL;
static jmethodID LDKClosureReason_CooperativeClosure_meth = NULL;
static jclass LDKClosureReason_CommitmentTxConfirmed_class = NULL;
static jmethodID LDKClosureReason_CommitmentTxConfirmed_meth = NULL;
static jclass LDKClosureReason_ProcessingError_class = NULL;
static jmethodID LDKClosureReason_ProcessingError_meth = NULL;
static jclass LDKClosureReason_DisconnectedPeer_class = NULL;
static jmethodID LDKClosureReason_DisconnectedPeer_meth = NULL;
static jclass LDKClosureReason_OutdatedChannelManager_class = NULL;
static jmethodID LDKClosureReason_OutdatedChannelManager_meth = NULL;
JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_00024LDKClosureReason_init (JNIEnv *env, jclass clz) {
	LDKClosureReason_CounterpartyForceClosed_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKClosureReason$CounterpartyForceClosed;"));
	CHECK(LDKClosureReason_CounterpartyForceClosed_class != NULL);
	LDKClosureReason_CounterpartyForceClosed_meth = (*env)->GetMethodID(env, LDKClosureReason_CounterpartyForceClosed_class, "<init>", "(Ljava/lang/String;)V");
	CHECK(LDKClosureReason_CounterpartyForceClosed_meth != NULL);
	LDKClosureReason_HolderForceClosed_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKClosureReason$HolderForceClosed;"));
	CHECK(LDKClosureReason_HolderForceClosed_class != NULL);
	LDKClosureReason_HolderForceClosed_meth = (*env)->GetMethodID(env, LDKClosureReason_HolderForceClosed_class, "<init>", "()V");
	CHECK(LDKClosureReason_HolderForceClosed_meth != NULL);
	LDKClosureReason_CooperativeClosure_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKClosureReason$CooperativeClosure;"));
	CHECK(LDKClosureReason_CooperativeClosure_class != NULL);
	LDKClosureReason_CooperativeClosure_meth = (*env)->GetMethodID(env, LDKClosureReason_CooperativeClosure_class, "<init>", "()V");
	CHECK(LDKClosureReason_CooperativeClosure_meth != NULL);
	LDKClosureReason_CommitmentTxConfirmed_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKClosureReason$CommitmentTxConfirmed;"));
	CHECK(LDKClosureReason_CommitmentTxConfirmed_class != NULL);
	LDKClosureReason_CommitmentTxConfirmed_meth = (*env)->GetMethodID(env, LDKClosureReason_CommitmentTxConfirmed_class, "<init>", "()V");
	CHECK(LDKClosureReason_CommitmentTxConfirmed_meth != NULL);
	LDKClosureReason_ProcessingError_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKClosureReason$ProcessingError;"));
	CHECK(LDKClosureReason_ProcessingError_class != NULL);
	LDKClosureReason_ProcessingError_meth = (*env)->GetMethodID(env, LDKClosureReason_ProcessingError_class, "<init>", "(Ljava/lang/String;)V");
	CHECK(LDKClosureReason_ProcessingError_meth != NULL);
	LDKClosureReason_DisconnectedPeer_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKClosureReason$DisconnectedPeer;"));
	CHECK(LDKClosureReason_DisconnectedPeer_class != NULL);
	LDKClosureReason_DisconnectedPeer_meth = (*env)->GetMethodID(env, LDKClosureReason_DisconnectedPeer_class, "<init>", "()V");
	CHECK(LDKClosureReason_DisconnectedPeer_meth != NULL);
	LDKClosureReason_OutdatedChannelManager_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKClosureReason$OutdatedChannelManager;"));
	CHECK(LDKClosureReason_OutdatedChannelManager_class != NULL);
	LDKClosureReason_OutdatedChannelManager_meth = (*env)->GetMethodID(env, LDKClosureReason_OutdatedChannelManager_class, "<init>", "()V");
	CHECK(LDKClosureReason_OutdatedChannelManager_meth != NULL);
}
JNIEXPORT jobject JNICALL Java_org_ldk_impl_bindings_LDKClosureReason_1ref_1from_1ptr(JNIEnv *env, jclass clz, int64_t ptr) {
	LDKClosureReason *obj = (LDKClosureReason*)(ptr & ~1);
	switch(obj->tag) {
		case LDKClosureReason_CounterpartyForceClosed: {
			LDKStr peer_msg_str = obj->counterparty_force_closed.peer_msg;
			jstring peer_msg_conv = str_ref_to_java(env, peer_msg_str.chars, peer_msg_str.len);
			return (*env)->NewObject(env, LDKClosureReason_CounterpartyForceClosed_class, LDKClosureReason_CounterpartyForceClosed_meth, peer_msg_conv);
		}
		case LDKClosureReason_HolderForceClosed: {
			return (*env)->NewObject(env, LDKClosureReason_HolderForceClosed_class, LDKClosureReason_HolderForceClosed_meth);
		}
		case LDKClosureReason_CooperativeClosure: {
			return (*env)->NewObject(env, LDKClosureReason_CooperativeClosure_class, LDKClosureReason_CooperativeClosure_meth);
		}
		case LDKClosureReason_CommitmentTxConfirmed: {
			return (*env)->NewObject(env, LDKClosureReason_CommitmentTxConfirmed_class, LDKClosureReason_CommitmentTxConfirmed_meth);
		}
		case LDKClosureReason_ProcessingError: {
			LDKStr err_str = obj->processing_error.err;
			jstring err_conv = str_ref_to_java(env, err_str.chars, err_str.len);
			return (*env)->NewObject(env, LDKClosureReason_ProcessingError_class, LDKClosureReason_ProcessingError_meth, err_conv);
		}
		case LDKClosureReason_DisconnectedPeer: {
			return (*env)->NewObject(env, LDKClosureReason_DisconnectedPeer_class, LDKClosureReason_DisconnectedPeer_meth);
		}
		case LDKClosureReason_OutdatedChannelManager: {
			return (*env)->NewObject(env, LDKClosureReason_OutdatedChannelManager_class, LDKClosureReason_OutdatedChannelManager_meth);
		}
		default: abort();
	}
}
static jclass LDKEvent_FundingGenerationReady_class = NULL;
static jmethodID LDKEvent_FundingGenerationReady_meth = NULL;
static jclass LDKEvent_PaymentReceived_class = NULL;
static jmethodID LDKEvent_PaymentReceived_meth = NULL;
static jclass LDKEvent_PaymentSent_class = NULL;
static jmethodID LDKEvent_PaymentSent_meth = NULL;
static jclass LDKEvent_PaymentPathFailed_class = NULL;
static jmethodID LDKEvent_PaymentPathFailed_meth = NULL;
static jclass LDKEvent_PendingHTLCsForwardable_class = NULL;
static jmethodID LDKEvent_PendingHTLCsForwardable_meth = NULL;
static jclass LDKEvent_SpendableOutputs_class = NULL;
static jmethodID LDKEvent_SpendableOutputs_meth = NULL;
static jclass LDKEvent_PaymentForwarded_class = NULL;
static jmethodID LDKEvent_PaymentForwarded_meth = NULL;
static jclass LDKEvent_ChannelClosed_class = NULL;
static jmethodID LDKEvent_ChannelClosed_meth = NULL;
static jclass LDKEvent_DiscardFunding_class = NULL;
static jmethodID LDKEvent_DiscardFunding_meth = NULL;
JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_00024LDKEvent_init (JNIEnv *env, jclass clz) {
	LDKEvent_FundingGenerationReady_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKEvent$FundingGenerationReady;"));
	CHECK(LDKEvent_FundingGenerationReady_class != NULL);
	LDKEvent_FundingGenerationReady_meth = (*env)->GetMethodID(env, LDKEvent_FundingGenerationReady_class, "<init>", "([BJ[BJ)V");
	CHECK(LDKEvent_FundingGenerationReady_meth != NULL);
	LDKEvent_PaymentReceived_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKEvent$PaymentReceived;"));
	CHECK(LDKEvent_PaymentReceived_class != NULL);
	LDKEvent_PaymentReceived_meth = (*env)->GetMethodID(env, LDKEvent_PaymentReceived_class, "<init>", "([BJJ)V");
	CHECK(LDKEvent_PaymentReceived_meth != NULL);
	LDKEvent_PaymentSent_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKEvent$PaymentSent;"));
	CHECK(LDKEvent_PaymentSent_class != NULL);
	LDKEvent_PaymentSent_meth = (*env)->GetMethodID(env, LDKEvent_PaymentSent_class, "<init>", "([B[B[BJ)V");
	CHECK(LDKEvent_PaymentSent_meth != NULL);
	LDKEvent_PaymentPathFailed_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKEvent$PaymentPathFailed;"));
	CHECK(LDKEvent_PaymentPathFailed_class != NULL);
	LDKEvent_PaymentPathFailed_meth = (*env)->GetMethodID(env, LDKEvent_PaymentPathFailed_class, "<init>", "([B[BZJZ[JJJ)V");
	CHECK(LDKEvent_PaymentPathFailed_meth != NULL);
	LDKEvent_PendingHTLCsForwardable_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKEvent$PendingHTLCsForwardable;"));
	CHECK(LDKEvent_PendingHTLCsForwardable_class != NULL);
	LDKEvent_PendingHTLCsForwardable_meth = (*env)->GetMethodID(env, LDKEvent_PendingHTLCsForwardable_class, "<init>", "(J)V");
	CHECK(LDKEvent_PendingHTLCsForwardable_meth != NULL);
	LDKEvent_SpendableOutputs_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKEvent$SpendableOutputs;"));
	CHECK(LDKEvent_SpendableOutputs_class != NULL);
	LDKEvent_SpendableOutputs_meth = (*env)->GetMethodID(env, LDKEvent_SpendableOutputs_class, "<init>", "([J)V");
	CHECK(LDKEvent_SpendableOutputs_meth != NULL);
	LDKEvent_PaymentForwarded_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKEvent$PaymentForwarded;"));
	CHECK(LDKEvent_PaymentForwarded_class != NULL);
	LDKEvent_PaymentForwarded_meth = (*env)->GetMethodID(env, LDKEvent_PaymentForwarded_class, "<init>", "(JZ)V");
	CHECK(LDKEvent_PaymentForwarded_meth != NULL);
	LDKEvent_ChannelClosed_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKEvent$ChannelClosed;"));
	CHECK(LDKEvent_ChannelClosed_class != NULL);
	LDKEvent_ChannelClosed_meth = (*env)->GetMethodID(env, LDKEvent_ChannelClosed_class, "<init>", "([BJJ)V");
	CHECK(LDKEvent_ChannelClosed_meth != NULL);
	LDKEvent_DiscardFunding_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKEvent$DiscardFunding;"));
	CHECK(LDKEvent_DiscardFunding_class != NULL);
	LDKEvent_DiscardFunding_meth = (*env)->GetMethodID(env, LDKEvent_DiscardFunding_class, "<init>", "([B[B)V");
	CHECK(LDKEvent_DiscardFunding_meth != NULL);
}
JNIEXPORT jobject JNICALL Java_org_ldk_impl_bindings_LDKEvent_1ref_1from_1ptr(JNIEnv *env, jclass clz, int64_t ptr) {
	LDKEvent *obj = (LDKEvent*)(ptr & ~1);
	switch(obj->tag) {
		case LDKEvent_FundingGenerationReady: {
			int8_tArray temporary_channel_id_arr = (*env)->NewByteArray(env, 32);
			(*env)->SetByteArrayRegion(env, temporary_channel_id_arr, 0, 32, obj->funding_generation_ready.temporary_channel_id.data);
			LDKCVec_u8Z output_script_var = obj->funding_generation_ready.output_script;
			int8_tArray output_script_arr = (*env)->NewByteArray(env, output_script_var.datalen);
			(*env)->SetByteArrayRegion(env, output_script_arr, 0, output_script_var.datalen, output_script_var.data);
			return (*env)->NewObject(env, LDKEvent_FundingGenerationReady_class, LDKEvent_FundingGenerationReady_meth, temporary_channel_id_arr, obj->funding_generation_ready.channel_value_satoshis, output_script_arr, obj->funding_generation_ready.user_channel_id);
		}
		case LDKEvent_PaymentReceived: {
			int8_tArray payment_hash_arr = (*env)->NewByteArray(env, 32);
			(*env)->SetByteArrayRegion(env, payment_hash_arr, 0, 32, obj->payment_received.payment_hash.data);
			uint64_t purpose_ref = ((uint64_t)&obj->payment_received.purpose) | 1;
			return (*env)->NewObject(env, LDKEvent_PaymentReceived_class, LDKEvent_PaymentReceived_meth, payment_hash_arr, obj->payment_received.amt, purpose_ref);
		}
		case LDKEvent_PaymentSent: {
			int8_tArray payment_id_arr = (*env)->NewByteArray(env, 32);
			(*env)->SetByteArrayRegion(env, payment_id_arr, 0, 32, obj->payment_sent.payment_id.data);
			int8_tArray payment_preimage_arr = (*env)->NewByteArray(env, 32);
			(*env)->SetByteArrayRegion(env, payment_preimage_arr, 0, 32, obj->payment_sent.payment_preimage.data);
			int8_tArray payment_hash_arr = (*env)->NewByteArray(env, 32);
			(*env)->SetByteArrayRegion(env, payment_hash_arr, 0, 32, obj->payment_sent.payment_hash.data);
			uint64_t fee_paid_msat_ref = ((uint64_t)&obj->payment_sent.fee_paid_msat) | 1;
			return (*env)->NewObject(env, LDKEvent_PaymentSent_class, LDKEvent_PaymentSent_meth, payment_id_arr, payment_preimage_arr, payment_hash_arr, fee_paid_msat_ref);
		}
		case LDKEvent_PaymentPathFailed: {
			int8_tArray payment_id_arr = (*env)->NewByteArray(env, 32);
			(*env)->SetByteArrayRegion(env, payment_id_arr, 0, 32, obj->payment_path_failed.payment_id.data);
			int8_tArray payment_hash_arr = (*env)->NewByteArray(env, 32);
			(*env)->SetByteArrayRegion(env, payment_hash_arr, 0, 32, obj->payment_path_failed.payment_hash.data);
			uint64_t network_update_ref = ((uint64_t)&obj->payment_path_failed.network_update) | 1;
			LDKCVec_RouteHopZ path_var = obj->payment_path_failed.path;
			int64_tArray path_arr = NULL;
			path_arr = (*env)->NewLongArray(env, path_var.datalen);
			int64_t *path_arr_ptr = (*env)->GetPrimitiveArrayCritical(env, path_arr, NULL);
			for (size_t k = 0; k < path_var.datalen; k++) {
				LDKRouteHop path_conv_10_var = path_var.data[k];
				uint64_t path_conv_10_ref = 0;
				CHECK((((uint64_t)path_conv_10_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
				CHECK((((uint64_t)&path_conv_10_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
				path_conv_10_ref = (uint64_t)path_conv_10_var.inner & ~1;
				path_arr_ptr[k] = path_conv_10_ref;
			}
			(*env)->ReleasePrimitiveArrayCritical(env, path_arr, path_arr_ptr, 0);
			uint64_t short_channel_id_ref = ((uint64_t)&obj->payment_path_failed.short_channel_id) | 1;
			LDKRouteParameters retry_var = obj->payment_path_failed.retry;
			uint64_t retry_ref = 0;
			CHECK((((uint64_t)retry_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
			CHECK((((uint64_t)&retry_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
			retry_ref = (uint64_t)retry_var.inner & ~1;
			return (*env)->NewObject(env, LDKEvent_PaymentPathFailed_class, LDKEvent_PaymentPathFailed_meth, payment_id_arr, payment_hash_arr, obj->payment_path_failed.rejected_by_dest, network_update_ref, obj->payment_path_failed.all_paths_failed, path_arr, short_channel_id_ref, retry_ref);
		}
		case LDKEvent_PendingHTLCsForwardable: {
			return (*env)->NewObject(env, LDKEvent_PendingHTLCsForwardable_class, LDKEvent_PendingHTLCsForwardable_meth, obj->pending_htl_cs_forwardable.time_forwardable);
		}
		case LDKEvent_SpendableOutputs: {
			LDKCVec_SpendableOutputDescriptorZ outputs_var = obj->spendable_outputs.outputs;
			int64_tArray outputs_arr = NULL;
			outputs_arr = (*env)->NewLongArray(env, outputs_var.datalen);
			int64_t *outputs_arr_ptr = (*env)->GetPrimitiveArrayCritical(env, outputs_arr, NULL);
			for (size_t b = 0; b < outputs_var.datalen; b++) {
				uint64_t outputs_conv_27_ref = ((uint64_t)&outputs_var.data[b]) | 1;
				outputs_arr_ptr[b] = outputs_conv_27_ref;
			}
			(*env)->ReleasePrimitiveArrayCritical(env, outputs_arr, outputs_arr_ptr, 0);
			return (*env)->NewObject(env, LDKEvent_SpendableOutputs_class, LDKEvent_SpendableOutputs_meth, outputs_arr);
		}
		case LDKEvent_PaymentForwarded: {
			uint64_t fee_earned_msat_ref = ((uint64_t)&obj->payment_forwarded.fee_earned_msat) | 1;
			return (*env)->NewObject(env, LDKEvent_PaymentForwarded_class, LDKEvent_PaymentForwarded_meth, fee_earned_msat_ref, obj->payment_forwarded.claim_from_onchain_tx);
		}
		case LDKEvent_ChannelClosed: {
			int8_tArray channel_id_arr = (*env)->NewByteArray(env, 32);
			(*env)->SetByteArrayRegion(env, channel_id_arr, 0, 32, obj->channel_closed.channel_id.data);
			uint64_t reason_ref = ((uint64_t)&obj->channel_closed.reason) | 1;
			return (*env)->NewObject(env, LDKEvent_ChannelClosed_class, LDKEvent_ChannelClosed_meth, channel_id_arr, obj->channel_closed.user_channel_id, reason_ref);
		}
		case LDKEvent_DiscardFunding: {
			int8_tArray channel_id_arr = (*env)->NewByteArray(env, 32);
			(*env)->SetByteArrayRegion(env, channel_id_arr, 0, 32, obj->discard_funding.channel_id.data);
			LDKTransaction transaction_var = obj->discard_funding.transaction;
			int8_tArray transaction_arr = (*env)->NewByteArray(env, transaction_var.datalen);
			(*env)->SetByteArrayRegion(env, transaction_arr, 0, transaction_var.datalen, transaction_var.data);
			return (*env)->NewObject(env, LDKEvent_DiscardFunding_class, LDKEvent_DiscardFunding_meth, channel_id_arr, transaction_arr);
		}
		default: abort();
	}
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCVec_1EventZ_1new(JNIEnv *env, jclass clz, int64_tArray elems) {
	LDKCVec_EventZ *ret = MALLOC(sizeof(LDKCVec_EventZ), "LDKCVec_EventZ");
	ret->datalen = (*env)->GetArrayLength(env, elems);
	if (ret->datalen == 0) {
		ret->data = NULL;
	} else {
		ret->data = MALLOC(sizeof(LDKEvent) * ret->datalen, "LDKCVec_EventZ Data");
		int64_t *java_elems = (*env)->GetPrimitiveArrayCritical(env, elems, NULL);
		for (size_t i = 0; i < ret->datalen; i++) {
			int64_t arr_elem = java_elems[i];
			void* arr_elem_ptr = (void*)(((uint64_t)arr_elem) & ~1);
			CHECK_ACCESS(arr_elem_ptr);
			LDKEvent arr_elem_conv = *(LDKEvent*)(arr_elem_ptr);
			arr_elem_conv = Event_clone((LDKEvent*)(((uint64_t)arr_elem) & ~1));
			ret->data[i] = arr_elem_conv;
		}
		(*env)->ReleasePrimitiveArrayCritical(env, elems, java_elems, 0);
	}
	return (uint64_t)ret;
}
static inline LDKCVec_EventZ CVec_EventZ_clone(const LDKCVec_EventZ *orig) {
	LDKCVec_EventZ ret = { .data = MALLOC(sizeof(LDKEvent) * orig->datalen, "LDKCVec_EventZ clone bytes"), .datalen = orig->datalen };
	for (size_t i = 0; i < ret.datalen; i++) {
		ret.data[i] = Event_clone(&orig->data[i]);
	}
	return ret;
}
static inline uint32_t C2Tuple_u32TxOutZ_get_a(LDKC2Tuple_u32TxOutZ *NONNULL_PTR tuple){
	return tuple->a;
}
JNIEXPORT int32_t JNICALL Java_org_ldk_impl_bindings_C2Tuple_1u32TxOutZ_1get_1a(JNIEnv *env, jclass clz, int64_t tuple) {
	LDKC2Tuple_u32TxOutZ* tuple_conv = (LDKC2Tuple_u32TxOutZ*)(tuple & ~1);
	int32_t ret_val = C2Tuple_u32TxOutZ_get_a(tuple_conv);
	return ret_val;
}

static inline struct LDKTxOut C2Tuple_u32TxOutZ_get_b(LDKC2Tuple_u32TxOutZ *NONNULL_PTR tuple){
	return TxOut_clone(&tuple->b);
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_C2Tuple_1u32TxOutZ_1get_1b(JNIEnv *env, jclass clz, int64_t tuple) {
	LDKC2Tuple_u32TxOutZ* tuple_conv = (LDKC2Tuple_u32TxOutZ*)(tuple & ~1);
	LDKTxOut* ret_ref = MALLOC(sizeof(LDKTxOut), "LDKTxOut");
	*ret_ref = C2Tuple_u32TxOutZ_get_b(tuple_conv);
	return (uint64_t)ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCVec_1C2Tuple_1u32TxOutZZ_1new(JNIEnv *env, jclass clz, int64_tArray elems) {
	LDKCVec_C2Tuple_u32TxOutZZ *ret = MALLOC(sizeof(LDKCVec_C2Tuple_u32TxOutZZ), "LDKCVec_C2Tuple_u32TxOutZZ");
	ret->datalen = (*env)->GetArrayLength(env, elems);
	if (ret->datalen == 0) {
		ret->data = NULL;
	} else {
		ret->data = MALLOC(sizeof(LDKC2Tuple_u32TxOutZ) * ret->datalen, "LDKCVec_C2Tuple_u32TxOutZZ Data");
		int64_t *java_elems = (*env)->GetPrimitiveArrayCritical(env, elems, NULL);
		for (size_t i = 0; i < ret->datalen; i++) {
			int64_t arr_elem = java_elems[i];
			void* arr_elem_ptr = (void*)(((uint64_t)arr_elem) & ~1);
			CHECK_ACCESS(arr_elem_ptr);
			LDKC2Tuple_u32TxOutZ arr_elem_conv = *(LDKC2Tuple_u32TxOutZ*)(arr_elem_ptr);
			arr_elem_conv = C2Tuple_u32TxOutZ_clone((LDKC2Tuple_u32TxOutZ*)(((uint64_t)arr_elem) & ~1));
			ret->data[i] = arr_elem_conv;
		}
		(*env)->ReleasePrimitiveArrayCritical(env, elems, java_elems, 0);
	}
	return (uint64_t)ret;
}
static inline LDKCVec_C2Tuple_u32TxOutZZ CVec_C2Tuple_u32TxOutZZ_clone(const LDKCVec_C2Tuple_u32TxOutZZ *orig) {
	LDKCVec_C2Tuple_u32TxOutZZ ret = { .data = MALLOC(sizeof(LDKC2Tuple_u32TxOutZ) * orig->datalen, "LDKCVec_C2Tuple_u32TxOutZZ clone bytes"), .datalen = orig->datalen };
	for (size_t i = 0; i < ret.datalen; i++) {
		ret.data[i] = C2Tuple_u32TxOutZ_clone(&orig->data[i]);
	}
	return ret;
}
static inline struct LDKThirtyTwoBytes C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_get_a(LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ *NONNULL_PTR tuple){
	return ThirtyTwoBytes_clone(&tuple->a);
}
JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_C2Tuple_1TxidCVec_1C2Tuple_1u32TxOutZZZ_1get_1a(JNIEnv *env, jclass clz, int64_t tuple) {
	LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ* tuple_conv = (LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ*)(tuple & ~1);
	int8_tArray ret_arr = (*env)->NewByteArray(env, 32);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 32, C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_get_a(tuple_conv).data);
	return ret_arr;
}

static inline struct LDKCVec_C2Tuple_u32TxOutZZ C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_get_b(LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ *NONNULL_PTR tuple){
	return CVec_C2Tuple_u32TxOutZZ_clone(&tuple->b);
}
JNIEXPORT int64_tArray JNICALL Java_org_ldk_impl_bindings_C2Tuple_1TxidCVec_1C2Tuple_1u32TxOutZZZ_1get_1b(JNIEnv *env, jclass clz, int64_t tuple) {
	LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ* tuple_conv = (LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ*)(tuple & ~1);
	LDKCVec_C2Tuple_u32TxOutZZ ret_var = C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_get_b(tuple_conv);
	int64_tArray ret_arr = NULL;
	ret_arr = (*env)->NewLongArray(env, ret_var.datalen);
	int64_t *ret_arr_ptr = (*env)->GetPrimitiveArrayCritical(env, ret_arr, NULL);
	for (size_t u = 0; u < ret_var.datalen; u++) {
		LDKC2Tuple_u32TxOutZ* ret_conv_20_conv = MALLOC(sizeof(LDKC2Tuple_u32TxOutZ), "LDKC2Tuple_u32TxOutZ");
		*ret_conv_20_conv = ret_var.data[u];
		ret_arr_ptr[u] = ((uint64_t)ret_conv_20_conv);
	}
	(*env)->ReleasePrimitiveArrayCritical(env, ret_arr, ret_arr_ptr, 0);
	FREE(ret_var.data);
	return ret_arr;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCVec_1C2Tuple_1TxidCVec_1C2Tuple_1u32TxOutZZZZ_1new(JNIEnv *env, jclass clz, int64_tArray elems) {
	LDKCVec_C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZZ *ret = MALLOC(sizeof(LDKCVec_C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZZ), "LDKCVec_C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZZ");
	ret->datalen = (*env)->GetArrayLength(env, elems);
	if (ret->datalen == 0) {
		ret->data = NULL;
	} else {
		ret->data = MALLOC(sizeof(LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ) * ret->datalen, "LDKCVec_C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZZ Data");
		int64_t *java_elems = (*env)->GetPrimitiveArrayCritical(env, elems, NULL);
		for (size_t i = 0; i < ret->datalen; i++) {
			int64_t arr_elem = java_elems[i];
			void* arr_elem_ptr = (void*)(((uint64_t)arr_elem) & ~1);
			CHECK_ACCESS(arr_elem_ptr);
			LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ arr_elem_conv = *(LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ*)(arr_elem_ptr);
			arr_elem_conv = C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_clone((LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ*)(((uint64_t)arr_elem) & ~1));
			ret->data[i] = arr_elem_conv;
		}
		(*env)->ReleasePrimitiveArrayCritical(env, elems, java_elems, 0);
	}
	return (uint64_t)ret;
}
static inline LDKCVec_C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZZ CVec_C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZZ_clone(const LDKCVec_C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZZ *orig) {
	LDKCVec_C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZZ ret = { .data = MALLOC(sizeof(LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ) * orig->datalen, "LDKCVec_C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZZ clone bytes"), .datalen = orig->datalen };
	for (size_t i = 0; i < ret.datalen; i++) {
		ret.data[i] = C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_clone(&orig->data[i]);
	}
	return ret;
}
static jclass LDKBalance_ClaimableOnChannelClose_class = NULL;
static jmethodID LDKBalance_ClaimableOnChannelClose_meth = NULL;
static jclass LDKBalance_ClaimableAwaitingConfirmations_class = NULL;
static jmethodID LDKBalance_ClaimableAwaitingConfirmations_meth = NULL;
static jclass LDKBalance_ContentiousClaimable_class = NULL;
static jmethodID LDKBalance_ContentiousClaimable_meth = NULL;
static jclass LDKBalance_MaybeClaimableHTLCAwaitingTimeout_class = NULL;
static jmethodID LDKBalance_MaybeClaimableHTLCAwaitingTimeout_meth = NULL;
JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_00024LDKBalance_init (JNIEnv *env, jclass clz) {
	LDKBalance_ClaimableOnChannelClose_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKBalance$ClaimableOnChannelClose;"));
	CHECK(LDKBalance_ClaimableOnChannelClose_class != NULL);
	LDKBalance_ClaimableOnChannelClose_meth = (*env)->GetMethodID(env, LDKBalance_ClaimableOnChannelClose_class, "<init>", "(J)V");
	CHECK(LDKBalance_ClaimableOnChannelClose_meth != NULL);
	LDKBalance_ClaimableAwaitingConfirmations_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKBalance$ClaimableAwaitingConfirmations;"));
	CHECK(LDKBalance_ClaimableAwaitingConfirmations_class != NULL);
	LDKBalance_ClaimableAwaitingConfirmations_meth = (*env)->GetMethodID(env, LDKBalance_ClaimableAwaitingConfirmations_class, "<init>", "(JI)V");
	CHECK(LDKBalance_ClaimableAwaitingConfirmations_meth != NULL);
	LDKBalance_ContentiousClaimable_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKBalance$ContentiousClaimable;"));
	CHECK(LDKBalance_ContentiousClaimable_class != NULL);
	LDKBalance_ContentiousClaimable_meth = (*env)->GetMethodID(env, LDKBalance_ContentiousClaimable_class, "<init>", "(JI)V");
	CHECK(LDKBalance_ContentiousClaimable_meth != NULL);
	LDKBalance_MaybeClaimableHTLCAwaitingTimeout_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKBalance$MaybeClaimableHTLCAwaitingTimeout;"));
	CHECK(LDKBalance_MaybeClaimableHTLCAwaitingTimeout_class != NULL);
	LDKBalance_MaybeClaimableHTLCAwaitingTimeout_meth = (*env)->GetMethodID(env, LDKBalance_MaybeClaimableHTLCAwaitingTimeout_class, "<init>", "(JI)V");
	CHECK(LDKBalance_MaybeClaimableHTLCAwaitingTimeout_meth != NULL);
}
JNIEXPORT jobject JNICALL Java_org_ldk_impl_bindings_LDKBalance_1ref_1from_1ptr(JNIEnv *env, jclass clz, int64_t ptr) {
	LDKBalance *obj = (LDKBalance*)(ptr & ~1);
	switch(obj->tag) {
		case LDKBalance_ClaimableOnChannelClose: {
			return (*env)->NewObject(env, LDKBalance_ClaimableOnChannelClose_class, LDKBalance_ClaimableOnChannelClose_meth, obj->claimable_on_channel_close.claimable_amount_satoshis);
		}
		case LDKBalance_ClaimableAwaitingConfirmations: {
			return (*env)->NewObject(env, LDKBalance_ClaimableAwaitingConfirmations_class, LDKBalance_ClaimableAwaitingConfirmations_meth, obj->claimable_awaiting_confirmations.claimable_amount_satoshis, obj->claimable_awaiting_confirmations.confirmation_height);
		}
		case LDKBalance_ContentiousClaimable: {
			return (*env)->NewObject(env, LDKBalance_ContentiousClaimable_class, LDKBalance_ContentiousClaimable_meth, obj->contentious_claimable.claimable_amount_satoshis, obj->contentious_claimable.timeout_height);
		}
		case LDKBalance_MaybeClaimableHTLCAwaitingTimeout: {
			return (*env)->NewObject(env, LDKBalance_MaybeClaimableHTLCAwaitingTimeout_class, LDKBalance_MaybeClaimableHTLCAwaitingTimeout_meth, obj->maybe_claimable_htlc_awaiting_timeout.claimable_amount_satoshis, obj->maybe_claimable_htlc_awaiting_timeout.claimable_height);
		}
		default: abort();
	}
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCVec_1BalanceZ_1new(JNIEnv *env, jclass clz, int64_tArray elems) {
	LDKCVec_BalanceZ *ret = MALLOC(sizeof(LDKCVec_BalanceZ), "LDKCVec_BalanceZ");
	ret->datalen = (*env)->GetArrayLength(env, elems);
	if (ret->datalen == 0) {
		ret->data = NULL;
	} else {
		ret->data = MALLOC(sizeof(LDKBalance) * ret->datalen, "LDKCVec_BalanceZ Data");
		int64_t *java_elems = (*env)->GetPrimitiveArrayCritical(env, elems, NULL);
		for (size_t i = 0; i < ret->datalen; i++) {
			int64_t arr_elem = java_elems[i];
			void* arr_elem_ptr = (void*)(((uint64_t)arr_elem) & ~1);
			CHECK_ACCESS(arr_elem_ptr);
			LDKBalance arr_elem_conv = *(LDKBalance*)(arr_elem_ptr);
			arr_elem_conv = Balance_clone((LDKBalance*)(((uint64_t)arr_elem) & ~1));
			ret->data[i] = arr_elem_conv;
		}
		(*env)->ReleasePrimitiveArrayCritical(env, elems, java_elems, 0);
	}
	return (uint64_t)ret;
}
static inline LDKCVec_BalanceZ CVec_BalanceZ_clone(const LDKCVec_BalanceZ *orig) {
	LDKCVec_BalanceZ ret = { .data = MALLOC(sizeof(LDKBalance) * orig->datalen, "LDKCVec_BalanceZ clone bytes"), .datalen = orig->datalen };
	for (size_t i = 0; i < ret.datalen; i++) {
		ret.data[i] = Balance_clone(&orig->data[i]);
	}
	return ret;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1C2Tuple_1BlockHashChannelMonitorZDecodeErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ*)arg)->result_ok;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1C2Tuple_1BlockHashChannelMonitorZDecodeErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ *val = (LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	LDKC2Tuple_BlockHashChannelMonitorZ* res_conv = MALLOC(sizeof(LDKC2Tuple_BlockHashChannelMonitorZ), "LDKC2Tuple_BlockHashChannelMonitorZ");
	*res_conv = (*val->contents.result);
	*res_conv = C2Tuple_BlockHashChannelMonitorZ_clone(res_conv);
	return ((uint64_t)res_conv);
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1C2Tuple_1BlockHashChannelMonitorZDecodeErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ *val = (LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	LDKDecodeError err_var = (*val->contents.err);
	uint64_t err_ref = 0;
	CHECK((((uint64_t)err_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&err_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	err_ref = (uint64_t)err_var.inner & ~1;
	return err_ref;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1NoneLightningErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_NoneLightningErrorZ*)arg)->result_ok;
}
JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_LDKCResult_1NoneLightningErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_NoneLightningErrorZ *val = (LDKCResult_NoneLightningErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	return *val->contents.result;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1NoneLightningErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_NoneLightningErrorZ *val = (LDKCResult_NoneLightningErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	LDKLightningError err_var = (*val->contents.err);
	uint64_t err_ref = 0;
	CHECK((((uint64_t)err_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&err_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	err_ref = (uint64_t)err_var.inner & ~1;
	return err_ref;
}
static inline struct LDKPublicKey C2Tuple_PublicKeyTypeZ_get_a(LDKC2Tuple_PublicKeyTypeZ *NONNULL_PTR tuple){
	return tuple->a;
}
JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_C2Tuple_1PublicKeyTypeZ_1get_1a(JNIEnv *env, jclass clz, int64_t tuple) {
	LDKC2Tuple_PublicKeyTypeZ* tuple_conv = (LDKC2Tuple_PublicKeyTypeZ*)(tuple & ~1);
	int8_tArray ret_arr = (*env)->NewByteArray(env, 33);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 33, C2Tuple_PublicKeyTypeZ_get_a(tuple_conv).compressed_form);
	return ret_arr;
}

static inline struct LDKType C2Tuple_PublicKeyTypeZ_get_b(LDKC2Tuple_PublicKeyTypeZ *NONNULL_PTR tuple){
	return Type_clone(&tuple->b);
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_C2Tuple_1PublicKeyTypeZ_1get_1b(JNIEnv *env, jclass clz, int64_t tuple) {
	LDKC2Tuple_PublicKeyTypeZ* tuple_conv = (LDKC2Tuple_PublicKeyTypeZ*)(tuple & ~1);
	LDKType* ret_ret = MALLOC(sizeof(LDKType), "LDKType");
	*ret_ret = C2Tuple_PublicKeyTypeZ_get_b(tuple_conv);
	return (uint64_t)ret_ret;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCVec_1C2Tuple_1PublicKeyTypeZZ_1new(JNIEnv *env, jclass clz, int64_tArray elems) {
	LDKCVec_C2Tuple_PublicKeyTypeZZ *ret = MALLOC(sizeof(LDKCVec_C2Tuple_PublicKeyTypeZZ), "LDKCVec_C2Tuple_PublicKeyTypeZZ");
	ret->datalen = (*env)->GetArrayLength(env, elems);
	if (ret->datalen == 0) {
		ret->data = NULL;
	} else {
		ret->data = MALLOC(sizeof(LDKC2Tuple_PublicKeyTypeZ) * ret->datalen, "LDKCVec_C2Tuple_PublicKeyTypeZZ Data");
		int64_t *java_elems = (*env)->GetPrimitiveArrayCritical(env, elems, NULL);
		for (size_t i = 0; i < ret->datalen; i++) {
			int64_t arr_elem = java_elems[i];
			void* arr_elem_ptr = (void*)(((uint64_t)arr_elem) & ~1);
			CHECK_ACCESS(arr_elem_ptr);
			LDKC2Tuple_PublicKeyTypeZ arr_elem_conv = *(LDKC2Tuple_PublicKeyTypeZ*)(arr_elem_ptr);
			arr_elem_conv = C2Tuple_PublicKeyTypeZ_clone((LDKC2Tuple_PublicKeyTypeZ*)(((uint64_t)arr_elem) & ~1));
			ret->data[i] = arr_elem_conv;
		}
		(*env)->ReleasePrimitiveArrayCritical(env, elems, java_elems, 0);
	}
	return (uint64_t)ret;
}
static inline LDKCVec_C2Tuple_PublicKeyTypeZZ CVec_C2Tuple_PublicKeyTypeZZ_clone(const LDKCVec_C2Tuple_PublicKeyTypeZZ *orig) {
	LDKCVec_C2Tuple_PublicKeyTypeZZ ret = { .data = MALLOC(sizeof(LDKC2Tuple_PublicKeyTypeZ) * orig->datalen, "LDKCVec_C2Tuple_PublicKeyTypeZZ clone bytes"), .datalen = orig->datalen };
	for (size_t i = 0; i < ret.datalen; i++) {
		ret.data[i] = C2Tuple_PublicKeyTypeZ_clone(&orig->data[i]);
	}
	return ret;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1boolLightningErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_boolLightningErrorZ*)arg)->result_ok;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1boolLightningErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_boolLightningErrorZ *val = (LDKCResult_boolLightningErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	return *val->contents.result;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1boolLightningErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_boolLightningErrorZ *val = (LDKCResult_boolLightningErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	LDKLightningError err_var = (*val->contents.err);
	uint64_t err_ref = 0;
	CHECK((((uint64_t)err_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&err_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	err_ref = (uint64_t)err_var.inner & ~1;
	return err_ref;
}
static inline struct LDKChannelAnnouncement C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_get_a(LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ *NONNULL_PTR tuple){
	return ChannelAnnouncement_clone(&tuple->a);
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_C3Tuple_1ChannelAnnouncementChannelUpdateChannelUpdateZ_1get_1a(JNIEnv *env, jclass clz, int64_t tuple) {
	LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ* tuple_conv = (LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ*)(tuple & ~1);
	LDKChannelAnnouncement ret_var = C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_get_a(tuple_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

static inline struct LDKChannelUpdate C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_get_b(LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ *NONNULL_PTR tuple){
	return ChannelUpdate_clone(&tuple->b);
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_C3Tuple_1ChannelAnnouncementChannelUpdateChannelUpdateZ_1get_1b(JNIEnv *env, jclass clz, int64_t tuple) {
	LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ* tuple_conv = (LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ*)(tuple & ~1);
	LDKChannelUpdate ret_var = C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_get_b(tuple_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

static inline struct LDKChannelUpdate C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_get_c(LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ *NONNULL_PTR tuple){
	return ChannelUpdate_clone(&tuple->c);
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_C3Tuple_1ChannelAnnouncementChannelUpdateChannelUpdateZ_1get_1c(JNIEnv *env, jclass clz, int64_t tuple) {
	LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ* tuple_conv = (LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ*)(tuple & ~1);
	LDKChannelUpdate ret_var = C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_get_c(tuple_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCVec_1C3Tuple_1ChannelAnnouncementChannelUpdateChannelUpdateZZ_1new(JNIEnv *env, jclass clz, int64_tArray elems) {
	LDKCVec_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ *ret = MALLOC(sizeof(LDKCVec_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ), "LDKCVec_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ");
	ret->datalen = (*env)->GetArrayLength(env, elems);
	if (ret->datalen == 0) {
		ret->data = NULL;
	} else {
		ret->data = MALLOC(sizeof(LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ) * ret->datalen, "LDKCVec_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ Data");
		int64_t *java_elems = (*env)->GetPrimitiveArrayCritical(env, elems, NULL);
		for (size_t i = 0; i < ret->datalen; i++) {
			int64_t arr_elem = java_elems[i];
			void* arr_elem_ptr = (void*)(((uint64_t)arr_elem) & ~1);
			CHECK_ACCESS(arr_elem_ptr);
			LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ arr_elem_conv = *(LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ*)(arr_elem_ptr);
			arr_elem_conv = C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_clone((LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ*)(((uint64_t)arr_elem) & ~1));
			ret->data[i] = arr_elem_conv;
		}
		(*env)->ReleasePrimitiveArrayCritical(env, elems, java_elems, 0);
	}
	return (uint64_t)ret;
}
static inline LDKCVec_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ CVec_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ_clone(const LDKCVec_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ *orig) {
	LDKCVec_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ ret = { .data = MALLOC(sizeof(LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ) * orig->datalen, "LDKCVec_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ clone bytes"), .datalen = orig->datalen };
	for (size_t i = 0; i < ret.datalen; i++) {
		ret.data[i] = C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_clone(&orig->data[i]);
	}
	return ret;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCVec_1NodeAnnouncementZ_1new(JNIEnv *env, jclass clz, int64_tArray elems) {
	LDKCVec_NodeAnnouncementZ *ret = MALLOC(sizeof(LDKCVec_NodeAnnouncementZ), "LDKCVec_NodeAnnouncementZ");
	ret->datalen = (*env)->GetArrayLength(env, elems);
	if (ret->datalen == 0) {
		ret->data = NULL;
	} else {
		ret->data = MALLOC(sizeof(LDKNodeAnnouncement) * ret->datalen, "LDKCVec_NodeAnnouncementZ Data");
		int64_t *java_elems = (*env)->GetPrimitiveArrayCritical(env, elems, NULL);
		for (size_t i = 0; i < ret->datalen; i++) {
			int64_t arr_elem = java_elems[i];
			LDKNodeAnnouncement arr_elem_conv;
			arr_elem_conv.inner = (void*)(arr_elem & (~1));
			arr_elem_conv.is_owned = (arr_elem & 1) || (arr_elem == 0);
			arr_elem_conv = NodeAnnouncement_clone(&arr_elem_conv);
			ret->data[i] = arr_elem_conv;
		}
		(*env)->ReleasePrimitiveArrayCritical(env, elems, java_elems, 0);
	}
	return (uint64_t)ret;
}
static inline LDKCVec_NodeAnnouncementZ CVec_NodeAnnouncementZ_clone(const LDKCVec_NodeAnnouncementZ *orig) {
	LDKCVec_NodeAnnouncementZ ret = { .data = MALLOC(sizeof(LDKNodeAnnouncement) * orig->datalen, "LDKCVec_NodeAnnouncementZ clone bytes"), .datalen = orig->datalen };
	for (size_t i = 0; i < ret.datalen; i++) {
		ret.data[i] = NodeAnnouncement_clone(&orig->data[i]);
	}
	return ret;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1CVec_1u8ZPeerHandleErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_CVec_u8ZPeerHandleErrorZ*)arg)->result_ok;
}
JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_LDKCResult_1CVec_1u8ZPeerHandleErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_CVec_u8ZPeerHandleErrorZ *val = (LDKCResult_CVec_u8ZPeerHandleErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	LDKCVec_u8Z res_var = (*val->contents.result);
	int8_tArray res_arr = (*env)->NewByteArray(env, res_var.datalen);
	(*env)->SetByteArrayRegion(env, res_arr, 0, res_var.datalen, res_var.data);
	return res_arr;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1CVec_1u8ZPeerHandleErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_CVec_u8ZPeerHandleErrorZ *val = (LDKCResult_CVec_u8ZPeerHandleErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	LDKPeerHandleError err_var = (*val->contents.err);
	uint64_t err_ref = 0;
	CHECK((((uint64_t)err_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&err_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	err_ref = (uint64_t)err_var.inner & ~1;
	return err_ref;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1NonePeerHandleErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_NonePeerHandleErrorZ*)arg)->result_ok;
}
JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_LDKCResult_1NonePeerHandleErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_NonePeerHandleErrorZ *val = (LDKCResult_NonePeerHandleErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	return *val->contents.result;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1NonePeerHandleErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_NonePeerHandleErrorZ *val = (LDKCResult_NonePeerHandleErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	LDKPeerHandleError err_var = (*val->contents.err);
	uint64_t err_ref = 0;
	CHECK((((uint64_t)err_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&err_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	err_ref = (uint64_t)err_var.inner & ~1;
	return err_ref;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1boolPeerHandleErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_boolPeerHandleErrorZ*)arg)->result_ok;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1boolPeerHandleErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_boolPeerHandleErrorZ *val = (LDKCResult_boolPeerHandleErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	return *val->contents.result;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1boolPeerHandleErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_boolPeerHandleErrorZ *val = (LDKCResult_boolPeerHandleErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	LDKPeerHandleError err_var = (*val->contents.err);
	uint64_t err_ref = 0;
	CHECK((((uint64_t)err_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&err_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	err_ref = (uint64_t)err_var.inner & ~1;
	return err_ref;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1NodeIdDecodeErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_NodeIdDecodeErrorZ*)arg)->result_ok;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1NodeIdDecodeErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_NodeIdDecodeErrorZ *val = (LDKCResult_NodeIdDecodeErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	LDKNodeId res_var = (*val->contents.result);
	uint64_t res_ref = 0;
	CHECK((((uint64_t)res_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&res_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	res_ref = (uint64_t)res_var.inner & ~1;
	return res_ref;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1NodeIdDecodeErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_NodeIdDecodeErrorZ *val = (LDKCResult_NodeIdDecodeErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	LDKDecodeError err_var = (*val->contents.err);
	uint64_t err_ref = 0;
	CHECK((((uint64_t)err_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&err_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	err_ref = (uint64_t)err_var.inner & ~1;
	return err_ref;
}
typedef struct LDKAccess_JCalls {
	atomic_size_t refcnt;
	JavaVM *vm;
	jweak o;
	jmethodID get_utxo_meth;
} LDKAccess_JCalls;
static void LDKAccess_JCalls_free(void* this_arg) {
	LDKAccess_JCalls *j_calls = (LDKAccess_JCalls*) this_arg;
	if (atomic_fetch_sub_explicit(&j_calls->refcnt, 1, memory_order_acquire) == 1) {
		JNIEnv *env;
		jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
		if (get_jenv_res == JNI_EDETACHED) {
			DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
		} else {
			DO_ASSERT(get_jenv_res == JNI_OK);
		}
		(*env)->DeleteWeakGlobalRef(env, j_calls->o);
		if (get_jenv_res == JNI_EDETACHED) {
			DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
		}
		FREE(j_calls);
	}
}
LDKCResult_TxOutAccessErrorZ get_utxo_LDKAccess_jcall(const void* this_arg, const uint8_t (* genesis_hash)[32], uint64_t short_channel_id) {
	LDKAccess_JCalls *j_calls = (LDKAccess_JCalls*) this_arg;
	JNIEnv *env;
	jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
	} else {
		DO_ASSERT(get_jenv_res == JNI_OK);
	}
	int8_tArray genesis_hash_arr = (*env)->NewByteArray(env, 32);
	(*env)->SetByteArrayRegion(env, genesis_hash_arr, 0, 32, *genesis_hash);
	jobject obj = (*env)->NewLocalRef(env, j_calls->o);
	CHECK(obj != NULL);
	uint64_t ret = (*env)->CallLongMethod(env, obj, j_calls->get_utxo_meth, genesis_hash_arr, short_channel_id);
	if ((*env)->ExceptionCheck(env)) {
		(*env)->ExceptionDescribe(env);
		(*env)->FatalError(env, "A call to get_utxo in LDKAccess from rust threw an exception.");
	}
	void* ret_ptr = (void*)(((uint64_t)ret) & ~1);
	CHECK_ACCESS(ret_ptr);
	LDKCResult_TxOutAccessErrorZ ret_conv = *(LDKCResult_TxOutAccessErrorZ*)(ret_ptr);
	ret_conv = CResult_TxOutAccessErrorZ_clone((LDKCResult_TxOutAccessErrorZ*)(((uint64_t)ret) & ~1));
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
	}
	return ret_conv;
}
static void LDKAccess_JCalls_cloned(LDKAccess* new_obj) {
	LDKAccess_JCalls *j_calls = (LDKAccess_JCalls*) new_obj->this_arg;
	atomic_fetch_add_explicit(&j_calls->refcnt, 1, memory_order_release);
}
static inline LDKAccess LDKAccess_init (JNIEnv *env, jclass clz, jobject o) {
	jclass c = (*env)->GetObjectClass(env, o);
	CHECK(c != NULL);
	LDKAccess_JCalls *calls = MALLOC(sizeof(LDKAccess_JCalls), "LDKAccess_JCalls");
	atomic_init(&calls->refcnt, 1);
	DO_ASSERT((*env)->GetJavaVM(env, &calls->vm) == 0);
	calls->o = (*env)->NewWeakGlobalRef(env, o);
	calls->get_utxo_meth = (*env)->GetMethodID(env, c, "get_utxo", "([BJ)J");
	CHECK(calls->get_utxo_meth != NULL);

	LDKAccess ret = {
		.this_arg = (void*) calls,
		.get_utxo = get_utxo_LDKAccess_jcall,
		.free = LDKAccess_JCalls_free,
	};
	return ret;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKAccess_1new(JNIEnv *env, jclass clz, jobject o) {
	LDKAccess *res_ptr = MALLOC(sizeof(LDKAccess), "LDKAccess");
	*res_ptr = LDKAccess_init(env, clz, o);
	return (uint64_t)res_ptr;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_Access_1get_1utxo(JNIEnv *env, jclass clz, int64_t this_arg, int8_tArray genesis_hash, int64_t short_channel_id) {
	void* this_arg_ptr = (void*)(((uint64_t)this_arg) & ~1);
	if (!(this_arg & 1)) { CHECK_ACCESS(this_arg_ptr); }
	LDKAccess* this_arg_conv = (LDKAccess*)this_arg_ptr;
	unsigned char genesis_hash_arr[32];
	CHECK((*env)->GetArrayLength(env, genesis_hash) == 32);
	(*env)->GetByteArrayRegion(env, genesis_hash, 0, 32, genesis_hash_arr);
	unsigned char (*genesis_hash_ref)[32] = &genesis_hash_arr;
	LDKCResult_TxOutAccessErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_TxOutAccessErrorZ), "LDKCResult_TxOutAccessErrorZ");
	*ret_conv = (this_arg_conv->get_utxo)(this_arg_conv->this_arg, genesis_hash_ref, short_channel_id);
	return (uint64_t)ret_conv;
}

static jclass LDKCOption_AccessZ_Some_class = NULL;
static jmethodID LDKCOption_AccessZ_Some_meth = NULL;
static jclass LDKCOption_AccessZ_None_class = NULL;
static jmethodID LDKCOption_AccessZ_None_meth = NULL;
JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_00024LDKCOption_1AccessZ_init (JNIEnv *env, jclass clz) {
	LDKCOption_AccessZ_Some_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKCOption_AccessZ$Some;"));
	CHECK(LDKCOption_AccessZ_Some_class != NULL);
	LDKCOption_AccessZ_Some_meth = (*env)->GetMethodID(env, LDKCOption_AccessZ_Some_class, "<init>", "(J)V");
	CHECK(LDKCOption_AccessZ_Some_meth != NULL);
	LDKCOption_AccessZ_None_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKCOption_AccessZ$None;"));
	CHECK(LDKCOption_AccessZ_None_class != NULL);
	LDKCOption_AccessZ_None_meth = (*env)->GetMethodID(env, LDKCOption_AccessZ_None_class, "<init>", "()V");
	CHECK(LDKCOption_AccessZ_None_meth != NULL);
}
JNIEXPORT jobject JNICALL Java_org_ldk_impl_bindings_LDKCOption_1AccessZ_1ref_1from_1ptr(JNIEnv *env, jclass clz, int64_t ptr) {
	LDKCOption_AccessZ *obj = (LDKCOption_AccessZ*)(ptr & ~1);
	switch(obj->tag) {
		case LDKCOption_AccessZ_Some: {
			LDKAccess* some_ret = MALLOC(sizeof(LDKAccess), "LDKAccess");
			*some_ret = obj->some;
			// Warning: We likely need to clone here, but no clone is available, so we just do it for Java instances
			if ((*some_ret).free == LDKAccess_JCalls_free) {
				// If this_arg is a JCalls struct, then we need to increment the refcnt in it.
				LDKAccess_JCalls_cloned(&(*some_ret));
			}
			return (*env)->NewObject(env, LDKCOption_AccessZ_Some_class, LDKCOption_AccessZ_Some_meth, (uint64_t)some_ret);
		}
		case LDKCOption_AccessZ_None: {
			return (*env)->NewObject(env, LDKCOption_AccessZ_None_class, LDKCOption_AccessZ_None_meth);
		}
		default: abort();
	}
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1DirectionalChannelInfoDecodeErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_DirectionalChannelInfoDecodeErrorZ*)arg)->result_ok;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1DirectionalChannelInfoDecodeErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_DirectionalChannelInfoDecodeErrorZ *val = (LDKCResult_DirectionalChannelInfoDecodeErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	LDKDirectionalChannelInfo res_var = (*val->contents.result);
	uint64_t res_ref = 0;
	CHECK((((uint64_t)res_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&res_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	res_ref = (uint64_t)res_var.inner & ~1;
	return res_ref;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1DirectionalChannelInfoDecodeErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_DirectionalChannelInfoDecodeErrorZ *val = (LDKCResult_DirectionalChannelInfoDecodeErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	LDKDecodeError err_var = (*val->contents.err);
	uint64_t err_ref = 0;
	CHECK((((uint64_t)err_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&err_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	err_ref = (uint64_t)err_var.inner & ~1;
	return err_ref;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1ChannelInfoDecodeErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_ChannelInfoDecodeErrorZ*)arg)->result_ok;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1ChannelInfoDecodeErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_ChannelInfoDecodeErrorZ *val = (LDKCResult_ChannelInfoDecodeErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	LDKChannelInfo res_var = (*val->contents.result);
	uint64_t res_ref = 0;
	CHECK((((uint64_t)res_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&res_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	res_ref = (uint64_t)res_var.inner & ~1;
	return res_ref;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1ChannelInfoDecodeErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_ChannelInfoDecodeErrorZ *val = (LDKCResult_ChannelInfoDecodeErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	LDKDecodeError err_var = (*val->contents.err);
	uint64_t err_ref = 0;
	CHECK((((uint64_t)err_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&err_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	err_ref = (uint64_t)err_var.inner & ~1;
	return err_ref;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1RoutingFeesDecodeErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_RoutingFeesDecodeErrorZ*)arg)->result_ok;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1RoutingFeesDecodeErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_RoutingFeesDecodeErrorZ *val = (LDKCResult_RoutingFeesDecodeErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	LDKRoutingFees res_var = (*val->contents.result);
	uint64_t res_ref = 0;
	CHECK((((uint64_t)res_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&res_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	res_ref = (uint64_t)res_var.inner & ~1;
	return res_ref;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1RoutingFeesDecodeErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_RoutingFeesDecodeErrorZ *val = (LDKCResult_RoutingFeesDecodeErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	LDKDecodeError err_var = (*val->contents.err);
	uint64_t err_ref = 0;
	CHECK((((uint64_t)err_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&err_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	err_ref = (uint64_t)err_var.inner & ~1;
	return err_ref;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1NodeAnnouncementInfoDecodeErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_NodeAnnouncementInfoDecodeErrorZ*)arg)->result_ok;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1NodeAnnouncementInfoDecodeErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_NodeAnnouncementInfoDecodeErrorZ *val = (LDKCResult_NodeAnnouncementInfoDecodeErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	LDKNodeAnnouncementInfo res_var = (*val->contents.result);
	uint64_t res_ref = 0;
	CHECK((((uint64_t)res_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&res_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	res_ref = (uint64_t)res_var.inner & ~1;
	return res_ref;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1NodeAnnouncementInfoDecodeErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_NodeAnnouncementInfoDecodeErrorZ *val = (LDKCResult_NodeAnnouncementInfoDecodeErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	LDKDecodeError err_var = (*val->contents.err);
	uint64_t err_ref = 0;
	CHECK((((uint64_t)err_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&err_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	err_ref = (uint64_t)err_var.inner & ~1;
	return err_ref;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCVec_1u64Z_1new(JNIEnv *env, jclass clz, int64_tArray elems) {
	LDKCVec_u64Z *ret = MALLOC(sizeof(LDKCVec_u64Z), "LDKCVec_u64Z");
	ret->datalen = (*env)->GetArrayLength(env, elems);
	if (ret->datalen == 0) {
		ret->data = NULL;
	} else {
		ret->data = MALLOC(sizeof(uint64_t) * ret->datalen, "LDKCVec_u64Z Data");
		int64_t *java_elems = (*env)->GetPrimitiveArrayCritical(env, elems, NULL);
		for (size_t i = 0; i < ret->datalen; i++) {
			ret->data[i] = java_elems[i];
		}
		(*env)->ReleasePrimitiveArrayCritical(env, elems, java_elems, 0);
	}
	return (uint64_t)ret;
}
static inline LDKCVec_u64Z CVec_u64Z_clone(const LDKCVec_u64Z *orig) {
	LDKCVec_u64Z ret = { .data = MALLOC(sizeof(int64_t) * orig->datalen, "LDKCVec_u64Z clone bytes"), .datalen = orig->datalen };
	memcpy(ret.data, orig->data, sizeof(int64_t) * ret.datalen);
	return ret;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1NodeInfoDecodeErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_NodeInfoDecodeErrorZ*)arg)->result_ok;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1NodeInfoDecodeErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_NodeInfoDecodeErrorZ *val = (LDKCResult_NodeInfoDecodeErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	LDKNodeInfo res_var = (*val->contents.result);
	uint64_t res_ref = 0;
	CHECK((((uint64_t)res_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&res_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	res_ref = (uint64_t)res_var.inner & ~1;
	return res_ref;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1NodeInfoDecodeErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_NodeInfoDecodeErrorZ *val = (LDKCResult_NodeInfoDecodeErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	LDKDecodeError err_var = (*val->contents.err);
	uint64_t err_ref = 0;
	CHECK((((uint64_t)err_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&err_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	err_ref = (uint64_t)err_var.inner & ~1;
	return err_ref;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1NetworkGraphDecodeErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_NetworkGraphDecodeErrorZ*)arg)->result_ok;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1NetworkGraphDecodeErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_NetworkGraphDecodeErrorZ *val = (LDKCResult_NetworkGraphDecodeErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	LDKNetworkGraph res_var = (*val->contents.result);
	uint64_t res_ref = 0;
	CHECK((((uint64_t)res_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&res_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	res_ref = (uint64_t)res_var.inner & ~1;
	return res_ref;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1NetworkGraphDecodeErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_NetworkGraphDecodeErrorZ *val = (LDKCResult_NetworkGraphDecodeErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	LDKDecodeError err_var = (*val->contents.err);
	uint64_t err_ref = 0;
	CHECK((((uint64_t)err_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&err_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	err_ref = (uint64_t)err_var.inner & ~1;
	return err_ref;
}
static jclass LDKCOption_CVec_NetAddressZZ_Some_class = NULL;
static jmethodID LDKCOption_CVec_NetAddressZZ_Some_meth = NULL;
static jclass LDKCOption_CVec_NetAddressZZ_None_class = NULL;
static jmethodID LDKCOption_CVec_NetAddressZZ_None_meth = NULL;
JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_00024LDKCOption_1CVec_1NetAddressZZ_init (JNIEnv *env, jclass clz) {
	LDKCOption_CVec_NetAddressZZ_Some_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKCOption_CVec_NetAddressZZ$Some;"));
	CHECK(LDKCOption_CVec_NetAddressZZ_Some_class != NULL);
	LDKCOption_CVec_NetAddressZZ_Some_meth = (*env)->GetMethodID(env, LDKCOption_CVec_NetAddressZZ_Some_class, "<init>", "([J)V");
	CHECK(LDKCOption_CVec_NetAddressZZ_Some_meth != NULL);
	LDKCOption_CVec_NetAddressZZ_None_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKCOption_CVec_NetAddressZZ$None;"));
	CHECK(LDKCOption_CVec_NetAddressZZ_None_class != NULL);
	LDKCOption_CVec_NetAddressZZ_None_meth = (*env)->GetMethodID(env, LDKCOption_CVec_NetAddressZZ_None_class, "<init>", "()V");
	CHECK(LDKCOption_CVec_NetAddressZZ_None_meth != NULL);
}
JNIEXPORT jobject JNICALL Java_org_ldk_impl_bindings_LDKCOption_1CVec_1NetAddressZZ_1ref_1from_1ptr(JNIEnv *env, jclass clz, int64_t ptr) {
	LDKCOption_CVec_NetAddressZZ *obj = (LDKCOption_CVec_NetAddressZZ*)(ptr & ~1);
	switch(obj->tag) {
		case LDKCOption_CVec_NetAddressZZ_Some: {
			LDKCVec_NetAddressZ some_var = obj->some;
			int64_tArray some_arr = NULL;
			some_arr = (*env)->NewLongArray(env, some_var.datalen);
			int64_t *some_arr_ptr = (*env)->GetPrimitiveArrayCritical(env, some_arr, NULL);
			for (size_t m = 0; m < some_var.datalen; m++) {
				uint64_t some_conv_12_ref = ((uint64_t)&some_var.data[m]) | 1;
				some_arr_ptr[m] = some_conv_12_ref;
			}
			(*env)->ReleasePrimitiveArrayCritical(env, some_arr, some_arr_ptr, 0);
			return (*env)->NewObject(env, LDKCOption_CVec_NetAddressZZ_Some_class, LDKCOption_CVec_NetAddressZZ_Some_meth, some_arr);
		}
		case LDKCOption_CVec_NetAddressZZ_None: {
			return (*env)->NewObject(env, LDKCOption_CVec_NetAddressZZ_None_class, LDKCOption_CVec_NetAddressZZ_None_meth);
		}
		default: abort();
	}
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1NetAddressDecodeErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_NetAddressDecodeErrorZ*)arg)->result_ok;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1NetAddressDecodeErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_NetAddressDecodeErrorZ *val = (LDKCResult_NetAddressDecodeErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	uint64_t res_ref = ((uint64_t)&(*val->contents.result)) | 1;
	return res_ref;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1NetAddressDecodeErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_NetAddressDecodeErrorZ *val = (LDKCResult_NetAddressDecodeErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	LDKDecodeError err_var = (*val->contents.err);
	uint64_t err_ref = 0;
	CHECK((((uint64_t)err_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&err_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	err_ref = (uint64_t)err_var.inner & ~1;
	return err_ref;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCVec_1UpdateAddHTLCZ_1new(JNIEnv *env, jclass clz, int64_tArray elems) {
	LDKCVec_UpdateAddHTLCZ *ret = MALLOC(sizeof(LDKCVec_UpdateAddHTLCZ), "LDKCVec_UpdateAddHTLCZ");
	ret->datalen = (*env)->GetArrayLength(env, elems);
	if (ret->datalen == 0) {
		ret->data = NULL;
	} else {
		ret->data = MALLOC(sizeof(LDKUpdateAddHTLC) * ret->datalen, "LDKCVec_UpdateAddHTLCZ Data");
		int64_t *java_elems = (*env)->GetPrimitiveArrayCritical(env, elems, NULL);
		for (size_t i = 0; i < ret->datalen; i++) {
			int64_t arr_elem = java_elems[i];
			LDKUpdateAddHTLC arr_elem_conv;
			arr_elem_conv.inner = (void*)(arr_elem & (~1));
			arr_elem_conv.is_owned = (arr_elem & 1) || (arr_elem == 0);
			arr_elem_conv = UpdateAddHTLC_clone(&arr_elem_conv);
			ret->data[i] = arr_elem_conv;
		}
		(*env)->ReleasePrimitiveArrayCritical(env, elems, java_elems, 0);
	}
	return (uint64_t)ret;
}
static inline LDKCVec_UpdateAddHTLCZ CVec_UpdateAddHTLCZ_clone(const LDKCVec_UpdateAddHTLCZ *orig) {
	LDKCVec_UpdateAddHTLCZ ret = { .data = MALLOC(sizeof(LDKUpdateAddHTLC) * orig->datalen, "LDKCVec_UpdateAddHTLCZ clone bytes"), .datalen = orig->datalen };
	for (size_t i = 0; i < ret.datalen; i++) {
		ret.data[i] = UpdateAddHTLC_clone(&orig->data[i]);
	}
	return ret;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCVec_1UpdateFulfillHTLCZ_1new(JNIEnv *env, jclass clz, int64_tArray elems) {
	LDKCVec_UpdateFulfillHTLCZ *ret = MALLOC(sizeof(LDKCVec_UpdateFulfillHTLCZ), "LDKCVec_UpdateFulfillHTLCZ");
	ret->datalen = (*env)->GetArrayLength(env, elems);
	if (ret->datalen == 0) {
		ret->data = NULL;
	} else {
		ret->data = MALLOC(sizeof(LDKUpdateFulfillHTLC) * ret->datalen, "LDKCVec_UpdateFulfillHTLCZ Data");
		int64_t *java_elems = (*env)->GetPrimitiveArrayCritical(env, elems, NULL);
		for (size_t i = 0; i < ret->datalen; i++) {
			int64_t arr_elem = java_elems[i];
			LDKUpdateFulfillHTLC arr_elem_conv;
			arr_elem_conv.inner = (void*)(arr_elem & (~1));
			arr_elem_conv.is_owned = (arr_elem & 1) || (arr_elem == 0);
			arr_elem_conv = UpdateFulfillHTLC_clone(&arr_elem_conv);
			ret->data[i] = arr_elem_conv;
		}
		(*env)->ReleasePrimitiveArrayCritical(env, elems, java_elems, 0);
	}
	return (uint64_t)ret;
}
static inline LDKCVec_UpdateFulfillHTLCZ CVec_UpdateFulfillHTLCZ_clone(const LDKCVec_UpdateFulfillHTLCZ *orig) {
	LDKCVec_UpdateFulfillHTLCZ ret = { .data = MALLOC(sizeof(LDKUpdateFulfillHTLC) * orig->datalen, "LDKCVec_UpdateFulfillHTLCZ clone bytes"), .datalen = orig->datalen };
	for (size_t i = 0; i < ret.datalen; i++) {
		ret.data[i] = UpdateFulfillHTLC_clone(&orig->data[i]);
	}
	return ret;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCVec_1UpdateFailHTLCZ_1new(JNIEnv *env, jclass clz, int64_tArray elems) {
	LDKCVec_UpdateFailHTLCZ *ret = MALLOC(sizeof(LDKCVec_UpdateFailHTLCZ), "LDKCVec_UpdateFailHTLCZ");
	ret->datalen = (*env)->GetArrayLength(env, elems);
	if (ret->datalen == 0) {
		ret->data = NULL;
	} else {
		ret->data = MALLOC(sizeof(LDKUpdateFailHTLC) * ret->datalen, "LDKCVec_UpdateFailHTLCZ Data");
		int64_t *java_elems = (*env)->GetPrimitiveArrayCritical(env, elems, NULL);
		for (size_t i = 0; i < ret->datalen; i++) {
			int64_t arr_elem = java_elems[i];
			LDKUpdateFailHTLC arr_elem_conv;
			arr_elem_conv.inner = (void*)(arr_elem & (~1));
			arr_elem_conv.is_owned = (arr_elem & 1) || (arr_elem == 0);
			arr_elem_conv = UpdateFailHTLC_clone(&arr_elem_conv);
			ret->data[i] = arr_elem_conv;
		}
		(*env)->ReleasePrimitiveArrayCritical(env, elems, java_elems, 0);
	}
	return (uint64_t)ret;
}
static inline LDKCVec_UpdateFailHTLCZ CVec_UpdateFailHTLCZ_clone(const LDKCVec_UpdateFailHTLCZ *orig) {
	LDKCVec_UpdateFailHTLCZ ret = { .data = MALLOC(sizeof(LDKUpdateFailHTLC) * orig->datalen, "LDKCVec_UpdateFailHTLCZ clone bytes"), .datalen = orig->datalen };
	for (size_t i = 0; i < ret.datalen; i++) {
		ret.data[i] = UpdateFailHTLC_clone(&orig->data[i]);
	}
	return ret;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCVec_1UpdateFailMalformedHTLCZ_1new(JNIEnv *env, jclass clz, int64_tArray elems) {
	LDKCVec_UpdateFailMalformedHTLCZ *ret = MALLOC(sizeof(LDKCVec_UpdateFailMalformedHTLCZ), "LDKCVec_UpdateFailMalformedHTLCZ");
	ret->datalen = (*env)->GetArrayLength(env, elems);
	if (ret->datalen == 0) {
		ret->data = NULL;
	} else {
		ret->data = MALLOC(sizeof(LDKUpdateFailMalformedHTLC) * ret->datalen, "LDKCVec_UpdateFailMalformedHTLCZ Data");
		int64_t *java_elems = (*env)->GetPrimitiveArrayCritical(env, elems, NULL);
		for (size_t i = 0; i < ret->datalen; i++) {
			int64_t arr_elem = java_elems[i];
			LDKUpdateFailMalformedHTLC arr_elem_conv;
			arr_elem_conv.inner = (void*)(arr_elem & (~1));
			arr_elem_conv.is_owned = (arr_elem & 1) || (arr_elem == 0);
			arr_elem_conv = UpdateFailMalformedHTLC_clone(&arr_elem_conv);
			ret->data[i] = arr_elem_conv;
		}
		(*env)->ReleasePrimitiveArrayCritical(env, elems, java_elems, 0);
	}
	return (uint64_t)ret;
}
static inline LDKCVec_UpdateFailMalformedHTLCZ CVec_UpdateFailMalformedHTLCZ_clone(const LDKCVec_UpdateFailMalformedHTLCZ *orig) {
	LDKCVec_UpdateFailMalformedHTLCZ ret = { .data = MALLOC(sizeof(LDKUpdateFailMalformedHTLC) * orig->datalen, "LDKCVec_UpdateFailMalformedHTLCZ clone bytes"), .datalen = orig->datalen };
	for (size_t i = 0; i < ret.datalen; i++) {
		ret.data[i] = UpdateFailMalformedHTLC_clone(&orig->data[i]);
	}
	return ret;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1AcceptChannelDecodeErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_AcceptChannelDecodeErrorZ*)arg)->result_ok;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1AcceptChannelDecodeErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_AcceptChannelDecodeErrorZ *val = (LDKCResult_AcceptChannelDecodeErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	LDKAcceptChannel res_var = (*val->contents.result);
	uint64_t res_ref = 0;
	CHECK((((uint64_t)res_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&res_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	res_ref = (uint64_t)res_var.inner & ~1;
	return res_ref;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1AcceptChannelDecodeErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_AcceptChannelDecodeErrorZ *val = (LDKCResult_AcceptChannelDecodeErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	LDKDecodeError err_var = (*val->contents.err);
	uint64_t err_ref = 0;
	CHECK((((uint64_t)err_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&err_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	err_ref = (uint64_t)err_var.inner & ~1;
	return err_ref;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1AnnouncementSignaturesDecodeErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_AnnouncementSignaturesDecodeErrorZ*)arg)->result_ok;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1AnnouncementSignaturesDecodeErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_AnnouncementSignaturesDecodeErrorZ *val = (LDKCResult_AnnouncementSignaturesDecodeErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	LDKAnnouncementSignatures res_var = (*val->contents.result);
	uint64_t res_ref = 0;
	CHECK((((uint64_t)res_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&res_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	res_ref = (uint64_t)res_var.inner & ~1;
	return res_ref;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1AnnouncementSignaturesDecodeErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_AnnouncementSignaturesDecodeErrorZ *val = (LDKCResult_AnnouncementSignaturesDecodeErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	LDKDecodeError err_var = (*val->contents.err);
	uint64_t err_ref = 0;
	CHECK((((uint64_t)err_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&err_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	err_ref = (uint64_t)err_var.inner & ~1;
	return err_ref;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1ChannelReestablishDecodeErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_ChannelReestablishDecodeErrorZ*)arg)->result_ok;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1ChannelReestablishDecodeErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_ChannelReestablishDecodeErrorZ *val = (LDKCResult_ChannelReestablishDecodeErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	LDKChannelReestablish res_var = (*val->contents.result);
	uint64_t res_ref = 0;
	CHECK((((uint64_t)res_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&res_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	res_ref = (uint64_t)res_var.inner & ~1;
	return res_ref;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1ChannelReestablishDecodeErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_ChannelReestablishDecodeErrorZ *val = (LDKCResult_ChannelReestablishDecodeErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	LDKDecodeError err_var = (*val->contents.err);
	uint64_t err_ref = 0;
	CHECK((((uint64_t)err_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&err_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	err_ref = (uint64_t)err_var.inner & ~1;
	return err_ref;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1ClosingSignedDecodeErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_ClosingSignedDecodeErrorZ*)arg)->result_ok;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1ClosingSignedDecodeErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_ClosingSignedDecodeErrorZ *val = (LDKCResult_ClosingSignedDecodeErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	LDKClosingSigned res_var = (*val->contents.result);
	uint64_t res_ref = 0;
	CHECK((((uint64_t)res_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&res_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	res_ref = (uint64_t)res_var.inner & ~1;
	return res_ref;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1ClosingSignedDecodeErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_ClosingSignedDecodeErrorZ *val = (LDKCResult_ClosingSignedDecodeErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	LDKDecodeError err_var = (*val->contents.err);
	uint64_t err_ref = 0;
	CHECK((((uint64_t)err_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&err_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	err_ref = (uint64_t)err_var.inner & ~1;
	return err_ref;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1ClosingSignedFeeRangeDecodeErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_ClosingSignedFeeRangeDecodeErrorZ*)arg)->result_ok;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1ClosingSignedFeeRangeDecodeErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_ClosingSignedFeeRangeDecodeErrorZ *val = (LDKCResult_ClosingSignedFeeRangeDecodeErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	LDKClosingSignedFeeRange res_var = (*val->contents.result);
	uint64_t res_ref = 0;
	CHECK((((uint64_t)res_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&res_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	res_ref = (uint64_t)res_var.inner & ~1;
	return res_ref;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1ClosingSignedFeeRangeDecodeErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_ClosingSignedFeeRangeDecodeErrorZ *val = (LDKCResult_ClosingSignedFeeRangeDecodeErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	LDKDecodeError err_var = (*val->contents.err);
	uint64_t err_ref = 0;
	CHECK((((uint64_t)err_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&err_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	err_ref = (uint64_t)err_var.inner & ~1;
	return err_ref;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1CommitmentSignedDecodeErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_CommitmentSignedDecodeErrorZ*)arg)->result_ok;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1CommitmentSignedDecodeErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_CommitmentSignedDecodeErrorZ *val = (LDKCResult_CommitmentSignedDecodeErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	LDKCommitmentSigned res_var = (*val->contents.result);
	uint64_t res_ref = 0;
	CHECK((((uint64_t)res_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&res_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	res_ref = (uint64_t)res_var.inner & ~1;
	return res_ref;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1CommitmentSignedDecodeErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_CommitmentSignedDecodeErrorZ *val = (LDKCResult_CommitmentSignedDecodeErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	LDKDecodeError err_var = (*val->contents.err);
	uint64_t err_ref = 0;
	CHECK((((uint64_t)err_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&err_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	err_ref = (uint64_t)err_var.inner & ~1;
	return err_ref;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1FundingCreatedDecodeErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_FundingCreatedDecodeErrorZ*)arg)->result_ok;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1FundingCreatedDecodeErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_FundingCreatedDecodeErrorZ *val = (LDKCResult_FundingCreatedDecodeErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	LDKFundingCreated res_var = (*val->contents.result);
	uint64_t res_ref = 0;
	CHECK((((uint64_t)res_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&res_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	res_ref = (uint64_t)res_var.inner & ~1;
	return res_ref;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1FundingCreatedDecodeErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_FundingCreatedDecodeErrorZ *val = (LDKCResult_FundingCreatedDecodeErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	LDKDecodeError err_var = (*val->contents.err);
	uint64_t err_ref = 0;
	CHECK((((uint64_t)err_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&err_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	err_ref = (uint64_t)err_var.inner & ~1;
	return err_ref;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1FundingSignedDecodeErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_FundingSignedDecodeErrorZ*)arg)->result_ok;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1FundingSignedDecodeErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_FundingSignedDecodeErrorZ *val = (LDKCResult_FundingSignedDecodeErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	LDKFundingSigned res_var = (*val->contents.result);
	uint64_t res_ref = 0;
	CHECK((((uint64_t)res_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&res_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	res_ref = (uint64_t)res_var.inner & ~1;
	return res_ref;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1FundingSignedDecodeErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_FundingSignedDecodeErrorZ *val = (LDKCResult_FundingSignedDecodeErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	LDKDecodeError err_var = (*val->contents.err);
	uint64_t err_ref = 0;
	CHECK((((uint64_t)err_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&err_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	err_ref = (uint64_t)err_var.inner & ~1;
	return err_ref;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1FundingLockedDecodeErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_FundingLockedDecodeErrorZ*)arg)->result_ok;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1FundingLockedDecodeErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_FundingLockedDecodeErrorZ *val = (LDKCResult_FundingLockedDecodeErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	LDKFundingLocked res_var = (*val->contents.result);
	uint64_t res_ref = 0;
	CHECK((((uint64_t)res_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&res_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	res_ref = (uint64_t)res_var.inner & ~1;
	return res_ref;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1FundingLockedDecodeErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_FundingLockedDecodeErrorZ *val = (LDKCResult_FundingLockedDecodeErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	LDKDecodeError err_var = (*val->contents.err);
	uint64_t err_ref = 0;
	CHECK((((uint64_t)err_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&err_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	err_ref = (uint64_t)err_var.inner & ~1;
	return err_ref;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1InitDecodeErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_InitDecodeErrorZ*)arg)->result_ok;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1InitDecodeErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_InitDecodeErrorZ *val = (LDKCResult_InitDecodeErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	LDKInit res_var = (*val->contents.result);
	uint64_t res_ref = 0;
	CHECK((((uint64_t)res_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&res_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	res_ref = (uint64_t)res_var.inner & ~1;
	return res_ref;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1InitDecodeErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_InitDecodeErrorZ *val = (LDKCResult_InitDecodeErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	LDKDecodeError err_var = (*val->contents.err);
	uint64_t err_ref = 0;
	CHECK((((uint64_t)err_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&err_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	err_ref = (uint64_t)err_var.inner & ~1;
	return err_ref;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1OpenChannelDecodeErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_OpenChannelDecodeErrorZ*)arg)->result_ok;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1OpenChannelDecodeErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_OpenChannelDecodeErrorZ *val = (LDKCResult_OpenChannelDecodeErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	LDKOpenChannel res_var = (*val->contents.result);
	uint64_t res_ref = 0;
	CHECK((((uint64_t)res_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&res_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	res_ref = (uint64_t)res_var.inner & ~1;
	return res_ref;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1OpenChannelDecodeErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_OpenChannelDecodeErrorZ *val = (LDKCResult_OpenChannelDecodeErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	LDKDecodeError err_var = (*val->contents.err);
	uint64_t err_ref = 0;
	CHECK((((uint64_t)err_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&err_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	err_ref = (uint64_t)err_var.inner & ~1;
	return err_ref;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1RevokeAndACKDecodeErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_RevokeAndACKDecodeErrorZ*)arg)->result_ok;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1RevokeAndACKDecodeErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_RevokeAndACKDecodeErrorZ *val = (LDKCResult_RevokeAndACKDecodeErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	LDKRevokeAndACK res_var = (*val->contents.result);
	uint64_t res_ref = 0;
	CHECK((((uint64_t)res_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&res_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	res_ref = (uint64_t)res_var.inner & ~1;
	return res_ref;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1RevokeAndACKDecodeErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_RevokeAndACKDecodeErrorZ *val = (LDKCResult_RevokeAndACKDecodeErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	LDKDecodeError err_var = (*val->contents.err);
	uint64_t err_ref = 0;
	CHECK((((uint64_t)err_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&err_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	err_ref = (uint64_t)err_var.inner & ~1;
	return err_ref;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1ShutdownDecodeErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_ShutdownDecodeErrorZ*)arg)->result_ok;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1ShutdownDecodeErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_ShutdownDecodeErrorZ *val = (LDKCResult_ShutdownDecodeErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	LDKShutdown res_var = (*val->contents.result);
	uint64_t res_ref = 0;
	CHECK((((uint64_t)res_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&res_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	res_ref = (uint64_t)res_var.inner & ~1;
	return res_ref;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1ShutdownDecodeErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_ShutdownDecodeErrorZ *val = (LDKCResult_ShutdownDecodeErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	LDKDecodeError err_var = (*val->contents.err);
	uint64_t err_ref = 0;
	CHECK((((uint64_t)err_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&err_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	err_ref = (uint64_t)err_var.inner & ~1;
	return err_ref;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1UpdateFailHTLCDecodeErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_UpdateFailHTLCDecodeErrorZ*)arg)->result_ok;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1UpdateFailHTLCDecodeErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_UpdateFailHTLCDecodeErrorZ *val = (LDKCResult_UpdateFailHTLCDecodeErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	LDKUpdateFailHTLC res_var = (*val->contents.result);
	uint64_t res_ref = 0;
	CHECK((((uint64_t)res_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&res_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	res_ref = (uint64_t)res_var.inner & ~1;
	return res_ref;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1UpdateFailHTLCDecodeErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_UpdateFailHTLCDecodeErrorZ *val = (LDKCResult_UpdateFailHTLCDecodeErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	LDKDecodeError err_var = (*val->contents.err);
	uint64_t err_ref = 0;
	CHECK((((uint64_t)err_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&err_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	err_ref = (uint64_t)err_var.inner & ~1;
	return err_ref;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1UpdateFailMalformedHTLCDecodeErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ*)arg)->result_ok;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1UpdateFailMalformedHTLCDecodeErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ *val = (LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	LDKUpdateFailMalformedHTLC res_var = (*val->contents.result);
	uint64_t res_ref = 0;
	CHECK((((uint64_t)res_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&res_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	res_ref = (uint64_t)res_var.inner & ~1;
	return res_ref;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1UpdateFailMalformedHTLCDecodeErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ *val = (LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	LDKDecodeError err_var = (*val->contents.err);
	uint64_t err_ref = 0;
	CHECK((((uint64_t)err_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&err_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	err_ref = (uint64_t)err_var.inner & ~1;
	return err_ref;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1UpdateFeeDecodeErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_UpdateFeeDecodeErrorZ*)arg)->result_ok;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1UpdateFeeDecodeErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_UpdateFeeDecodeErrorZ *val = (LDKCResult_UpdateFeeDecodeErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	LDKUpdateFee res_var = (*val->contents.result);
	uint64_t res_ref = 0;
	CHECK((((uint64_t)res_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&res_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	res_ref = (uint64_t)res_var.inner & ~1;
	return res_ref;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1UpdateFeeDecodeErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_UpdateFeeDecodeErrorZ *val = (LDKCResult_UpdateFeeDecodeErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	LDKDecodeError err_var = (*val->contents.err);
	uint64_t err_ref = 0;
	CHECK((((uint64_t)err_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&err_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	err_ref = (uint64_t)err_var.inner & ~1;
	return err_ref;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1UpdateFulfillHTLCDecodeErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_UpdateFulfillHTLCDecodeErrorZ*)arg)->result_ok;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1UpdateFulfillHTLCDecodeErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_UpdateFulfillHTLCDecodeErrorZ *val = (LDKCResult_UpdateFulfillHTLCDecodeErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	LDKUpdateFulfillHTLC res_var = (*val->contents.result);
	uint64_t res_ref = 0;
	CHECK((((uint64_t)res_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&res_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	res_ref = (uint64_t)res_var.inner & ~1;
	return res_ref;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1UpdateFulfillHTLCDecodeErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_UpdateFulfillHTLCDecodeErrorZ *val = (LDKCResult_UpdateFulfillHTLCDecodeErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	LDKDecodeError err_var = (*val->contents.err);
	uint64_t err_ref = 0;
	CHECK((((uint64_t)err_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&err_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	err_ref = (uint64_t)err_var.inner & ~1;
	return err_ref;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1UpdateAddHTLCDecodeErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_UpdateAddHTLCDecodeErrorZ*)arg)->result_ok;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1UpdateAddHTLCDecodeErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_UpdateAddHTLCDecodeErrorZ *val = (LDKCResult_UpdateAddHTLCDecodeErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	LDKUpdateAddHTLC res_var = (*val->contents.result);
	uint64_t res_ref = 0;
	CHECK((((uint64_t)res_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&res_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	res_ref = (uint64_t)res_var.inner & ~1;
	return res_ref;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1UpdateAddHTLCDecodeErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_UpdateAddHTLCDecodeErrorZ *val = (LDKCResult_UpdateAddHTLCDecodeErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	LDKDecodeError err_var = (*val->contents.err);
	uint64_t err_ref = 0;
	CHECK((((uint64_t)err_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&err_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	err_ref = (uint64_t)err_var.inner & ~1;
	return err_ref;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1PingDecodeErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_PingDecodeErrorZ*)arg)->result_ok;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1PingDecodeErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_PingDecodeErrorZ *val = (LDKCResult_PingDecodeErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	LDKPing res_var = (*val->contents.result);
	uint64_t res_ref = 0;
	CHECK((((uint64_t)res_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&res_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	res_ref = (uint64_t)res_var.inner & ~1;
	return res_ref;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1PingDecodeErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_PingDecodeErrorZ *val = (LDKCResult_PingDecodeErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	LDKDecodeError err_var = (*val->contents.err);
	uint64_t err_ref = 0;
	CHECK((((uint64_t)err_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&err_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	err_ref = (uint64_t)err_var.inner & ~1;
	return err_ref;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1PongDecodeErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_PongDecodeErrorZ*)arg)->result_ok;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1PongDecodeErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_PongDecodeErrorZ *val = (LDKCResult_PongDecodeErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	LDKPong res_var = (*val->contents.result);
	uint64_t res_ref = 0;
	CHECK((((uint64_t)res_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&res_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	res_ref = (uint64_t)res_var.inner & ~1;
	return res_ref;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1PongDecodeErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_PongDecodeErrorZ *val = (LDKCResult_PongDecodeErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	LDKDecodeError err_var = (*val->contents.err);
	uint64_t err_ref = 0;
	CHECK((((uint64_t)err_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&err_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	err_ref = (uint64_t)err_var.inner & ~1;
	return err_ref;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1UnsignedChannelAnnouncementDecodeErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ*)arg)->result_ok;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1UnsignedChannelAnnouncementDecodeErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ *val = (LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	LDKUnsignedChannelAnnouncement res_var = (*val->contents.result);
	uint64_t res_ref = 0;
	CHECK((((uint64_t)res_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&res_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	res_ref = (uint64_t)res_var.inner & ~1;
	return res_ref;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1UnsignedChannelAnnouncementDecodeErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ *val = (LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	LDKDecodeError err_var = (*val->contents.err);
	uint64_t err_ref = 0;
	CHECK((((uint64_t)err_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&err_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	err_ref = (uint64_t)err_var.inner & ~1;
	return err_ref;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1ChannelAnnouncementDecodeErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_ChannelAnnouncementDecodeErrorZ*)arg)->result_ok;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1ChannelAnnouncementDecodeErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_ChannelAnnouncementDecodeErrorZ *val = (LDKCResult_ChannelAnnouncementDecodeErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	LDKChannelAnnouncement res_var = (*val->contents.result);
	uint64_t res_ref = 0;
	CHECK((((uint64_t)res_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&res_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	res_ref = (uint64_t)res_var.inner & ~1;
	return res_ref;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1ChannelAnnouncementDecodeErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_ChannelAnnouncementDecodeErrorZ *val = (LDKCResult_ChannelAnnouncementDecodeErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	LDKDecodeError err_var = (*val->contents.err);
	uint64_t err_ref = 0;
	CHECK((((uint64_t)err_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&err_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	err_ref = (uint64_t)err_var.inner & ~1;
	return err_ref;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1UnsignedChannelUpdateDecodeErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_UnsignedChannelUpdateDecodeErrorZ*)arg)->result_ok;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1UnsignedChannelUpdateDecodeErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_UnsignedChannelUpdateDecodeErrorZ *val = (LDKCResult_UnsignedChannelUpdateDecodeErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	LDKUnsignedChannelUpdate res_var = (*val->contents.result);
	uint64_t res_ref = 0;
	CHECK((((uint64_t)res_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&res_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	res_ref = (uint64_t)res_var.inner & ~1;
	return res_ref;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1UnsignedChannelUpdateDecodeErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_UnsignedChannelUpdateDecodeErrorZ *val = (LDKCResult_UnsignedChannelUpdateDecodeErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	LDKDecodeError err_var = (*val->contents.err);
	uint64_t err_ref = 0;
	CHECK((((uint64_t)err_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&err_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	err_ref = (uint64_t)err_var.inner & ~1;
	return err_ref;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1ChannelUpdateDecodeErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_ChannelUpdateDecodeErrorZ*)arg)->result_ok;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1ChannelUpdateDecodeErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_ChannelUpdateDecodeErrorZ *val = (LDKCResult_ChannelUpdateDecodeErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	LDKChannelUpdate res_var = (*val->contents.result);
	uint64_t res_ref = 0;
	CHECK((((uint64_t)res_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&res_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	res_ref = (uint64_t)res_var.inner & ~1;
	return res_ref;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1ChannelUpdateDecodeErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_ChannelUpdateDecodeErrorZ *val = (LDKCResult_ChannelUpdateDecodeErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	LDKDecodeError err_var = (*val->contents.err);
	uint64_t err_ref = 0;
	CHECK((((uint64_t)err_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&err_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	err_ref = (uint64_t)err_var.inner & ~1;
	return err_ref;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1ErrorMessageDecodeErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_ErrorMessageDecodeErrorZ*)arg)->result_ok;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1ErrorMessageDecodeErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_ErrorMessageDecodeErrorZ *val = (LDKCResult_ErrorMessageDecodeErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	LDKErrorMessage res_var = (*val->contents.result);
	uint64_t res_ref = 0;
	CHECK((((uint64_t)res_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&res_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	res_ref = (uint64_t)res_var.inner & ~1;
	return res_ref;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1ErrorMessageDecodeErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_ErrorMessageDecodeErrorZ *val = (LDKCResult_ErrorMessageDecodeErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	LDKDecodeError err_var = (*val->contents.err);
	uint64_t err_ref = 0;
	CHECK((((uint64_t)err_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&err_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	err_ref = (uint64_t)err_var.inner & ~1;
	return err_ref;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1UnsignedNodeAnnouncementDecodeErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ*)arg)->result_ok;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1UnsignedNodeAnnouncementDecodeErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ *val = (LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	LDKUnsignedNodeAnnouncement res_var = (*val->contents.result);
	uint64_t res_ref = 0;
	CHECK((((uint64_t)res_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&res_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	res_ref = (uint64_t)res_var.inner & ~1;
	return res_ref;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1UnsignedNodeAnnouncementDecodeErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ *val = (LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	LDKDecodeError err_var = (*val->contents.err);
	uint64_t err_ref = 0;
	CHECK((((uint64_t)err_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&err_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	err_ref = (uint64_t)err_var.inner & ~1;
	return err_ref;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1NodeAnnouncementDecodeErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_NodeAnnouncementDecodeErrorZ*)arg)->result_ok;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1NodeAnnouncementDecodeErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_NodeAnnouncementDecodeErrorZ *val = (LDKCResult_NodeAnnouncementDecodeErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	LDKNodeAnnouncement res_var = (*val->contents.result);
	uint64_t res_ref = 0;
	CHECK((((uint64_t)res_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&res_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	res_ref = (uint64_t)res_var.inner & ~1;
	return res_ref;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1NodeAnnouncementDecodeErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_NodeAnnouncementDecodeErrorZ *val = (LDKCResult_NodeAnnouncementDecodeErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	LDKDecodeError err_var = (*val->contents.err);
	uint64_t err_ref = 0;
	CHECK((((uint64_t)err_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&err_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	err_ref = (uint64_t)err_var.inner & ~1;
	return err_ref;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1QueryShortChannelIdsDecodeErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_QueryShortChannelIdsDecodeErrorZ*)arg)->result_ok;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1QueryShortChannelIdsDecodeErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_QueryShortChannelIdsDecodeErrorZ *val = (LDKCResult_QueryShortChannelIdsDecodeErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	LDKQueryShortChannelIds res_var = (*val->contents.result);
	uint64_t res_ref = 0;
	CHECK((((uint64_t)res_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&res_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	res_ref = (uint64_t)res_var.inner & ~1;
	return res_ref;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1QueryShortChannelIdsDecodeErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_QueryShortChannelIdsDecodeErrorZ *val = (LDKCResult_QueryShortChannelIdsDecodeErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	LDKDecodeError err_var = (*val->contents.err);
	uint64_t err_ref = 0;
	CHECK((((uint64_t)err_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&err_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	err_ref = (uint64_t)err_var.inner & ~1;
	return err_ref;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1ReplyShortChannelIdsEndDecodeErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ*)arg)->result_ok;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1ReplyShortChannelIdsEndDecodeErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ *val = (LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	LDKReplyShortChannelIdsEnd res_var = (*val->contents.result);
	uint64_t res_ref = 0;
	CHECK((((uint64_t)res_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&res_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	res_ref = (uint64_t)res_var.inner & ~1;
	return res_ref;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1ReplyShortChannelIdsEndDecodeErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ *val = (LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	LDKDecodeError err_var = (*val->contents.err);
	uint64_t err_ref = 0;
	CHECK((((uint64_t)err_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&err_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	err_ref = (uint64_t)err_var.inner & ~1;
	return err_ref;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1QueryChannelRangeDecodeErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_QueryChannelRangeDecodeErrorZ*)arg)->result_ok;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1QueryChannelRangeDecodeErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_QueryChannelRangeDecodeErrorZ *val = (LDKCResult_QueryChannelRangeDecodeErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	LDKQueryChannelRange res_var = (*val->contents.result);
	uint64_t res_ref = 0;
	CHECK((((uint64_t)res_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&res_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	res_ref = (uint64_t)res_var.inner & ~1;
	return res_ref;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1QueryChannelRangeDecodeErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_QueryChannelRangeDecodeErrorZ *val = (LDKCResult_QueryChannelRangeDecodeErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	LDKDecodeError err_var = (*val->contents.err);
	uint64_t err_ref = 0;
	CHECK((((uint64_t)err_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&err_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	err_ref = (uint64_t)err_var.inner & ~1;
	return err_ref;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1ReplyChannelRangeDecodeErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_ReplyChannelRangeDecodeErrorZ*)arg)->result_ok;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1ReplyChannelRangeDecodeErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_ReplyChannelRangeDecodeErrorZ *val = (LDKCResult_ReplyChannelRangeDecodeErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	LDKReplyChannelRange res_var = (*val->contents.result);
	uint64_t res_ref = 0;
	CHECK((((uint64_t)res_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&res_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	res_ref = (uint64_t)res_var.inner & ~1;
	return res_ref;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1ReplyChannelRangeDecodeErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_ReplyChannelRangeDecodeErrorZ *val = (LDKCResult_ReplyChannelRangeDecodeErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	LDKDecodeError err_var = (*val->contents.err);
	uint64_t err_ref = 0;
	CHECK((((uint64_t)err_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&err_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	err_ref = (uint64_t)err_var.inner & ~1;
	return err_ref;
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1GossipTimestampFilterDecodeErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_GossipTimestampFilterDecodeErrorZ*)arg)->result_ok;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1GossipTimestampFilterDecodeErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_GossipTimestampFilterDecodeErrorZ *val = (LDKCResult_GossipTimestampFilterDecodeErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	LDKGossipTimestampFilter res_var = (*val->contents.result);
	uint64_t res_ref = 0;
	CHECK((((uint64_t)res_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&res_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	res_ref = (uint64_t)res_var.inner & ~1;
	return res_ref;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1GossipTimestampFilterDecodeErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_GossipTimestampFilterDecodeErrorZ *val = (LDKCResult_GossipTimestampFilterDecodeErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	LDKDecodeError err_var = (*val->contents.err);
	uint64_t err_ref = 0;
	CHECK((((uint64_t)err_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&err_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	err_ref = (uint64_t)err_var.inner & ~1;
	return err_ref;
}
static jclass LDKSignOrCreationError_SignError_class = NULL;
static jmethodID LDKSignOrCreationError_SignError_meth = NULL;
static jclass LDKSignOrCreationError_CreationError_class = NULL;
static jmethodID LDKSignOrCreationError_CreationError_meth = NULL;
JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_00024LDKSignOrCreationError_init (JNIEnv *env, jclass clz) {
	LDKSignOrCreationError_SignError_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKSignOrCreationError$SignError;"));
	CHECK(LDKSignOrCreationError_SignError_class != NULL);
	LDKSignOrCreationError_SignError_meth = (*env)->GetMethodID(env, LDKSignOrCreationError_SignError_class, "<init>", "()V");
	CHECK(LDKSignOrCreationError_SignError_meth != NULL);
	LDKSignOrCreationError_CreationError_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKSignOrCreationError$CreationError;"));
	CHECK(LDKSignOrCreationError_CreationError_class != NULL);
	LDKSignOrCreationError_CreationError_meth = (*env)->GetMethodID(env, LDKSignOrCreationError_CreationError_class, "<init>", "(Lorg/ldk/enums/CreationError;)V");
	CHECK(LDKSignOrCreationError_CreationError_meth != NULL);
}
JNIEXPORT jobject JNICALL Java_org_ldk_impl_bindings_LDKSignOrCreationError_1ref_1from_1ptr(JNIEnv *env, jclass clz, int64_t ptr) {
	LDKSignOrCreationError *obj = (LDKSignOrCreationError*)(ptr & ~1);
	switch(obj->tag) {
		case LDKSignOrCreationError_SignError: {
			return (*env)->NewObject(env, LDKSignOrCreationError_SignError_class, LDKSignOrCreationError_SignError_meth);
		}
		case LDKSignOrCreationError_CreationError: {
			jclass creation_error_conv = LDKCreationError_to_java(env, obj->creation_error);
			return (*env)->NewObject(env, LDKSignOrCreationError_CreationError_class, LDKSignOrCreationError_CreationError_meth, creation_error_conv);
		}
		default: abort();
	}
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1InvoiceSignOrCreationErrorZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_InvoiceSignOrCreationErrorZ*)arg)->result_ok;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1InvoiceSignOrCreationErrorZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_InvoiceSignOrCreationErrorZ *val = (LDKCResult_InvoiceSignOrCreationErrorZ*)(arg & ~1);
	CHECK(val->result_ok);
	LDKInvoice res_var = (*val->contents.result);
	uint64_t res_ref = 0;
	CHECK((((uint64_t)res_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&res_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	res_ref = (uint64_t)res_var.inner & ~1;
	return res_ref;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1InvoiceSignOrCreationErrorZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_InvoiceSignOrCreationErrorZ *val = (LDKCResult_InvoiceSignOrCreationErrorZ*)(arg & ~1);
	CHECK(!val->result_ok);
	uint64_t err_ref = ((uint64_t)&(*val->contents.err)) | 1;
	return err_ref;
}
typedef struct LDKFilter_JCalls {
	atomic_size_t refcnt;
	JavaVM *vm;
	jweak o;
	jmethodID register_tx_meth;
	jmethodID register_output_meth;
} LDKFilter_JCalls;
static void LDKFilter_JCalls_free(void* this_arg) {
	LDKFilter_JCalls *j_calls = (LDKFilter_JCalls*) this_arg;
	if (atomic_fetch_sub_explicit(&j_calls->refcnt, 1, memory_order_acquire) == 1) {
		JNIEnv *env;
		jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
		if (get_jenv_res == JNI_EDETACHED) {
			DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
		} else {
			DO_ASSERT(get_jenv_res == JNI_OK);
		}
		(*env)->DeleteWeakGlobalRef(env, j_calls->o);
		if (get_jenv_res == JNI_EDETACHED) {
			DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
		}
		FREE(j_calls);
	}
}
void register_tx_LDKFilter_jcall(const void* this_arg, const uint8_t (* txid)[32], LDKu8slice script_pubkey) {
	LDKFilter_JCalls *j_calls = (LDKFilter_JCalls*) this_arg;
	JNIEnv *env;
	jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
	} else {
		DO_ASSERT(get_jenv_res == JNI_OK);
	}
	int8_tArray txid_arr = (*env)->NewByteArray(env, 32);
	(*env)->SetByteArrayRegion(env, txid_arr, 0, 32, *txid);
	LDKu8slice script_pubkey_var = script_pubkey;
	int8_tArray script_pubkey_arr = (*env)->NewByteArray(env, script_pubkey_var.datalen);
	(*env)->SetByteArrayRegion(env, script_pubkey_arr, 0, script_pubkey_var.datalen, script_pubkey_var.data);
	jobject obj = (*env)->NewLocalRef(env, j_calls->o);
	CHECK(obj != NULL);
	(*env)->CallVoidMethod(env, obj, j_calls->register_tx_meth, txid_arr, script_pubkey_arr);
	if ((*env)->ExceptionCheck(env)) {
		(*env)->ExceptionDescribe(env);
		(*env)->FatalError(env, "A call to register_tx in LDKFilter from rust threw an exception.");
	}
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
	}
}
LDKCOption_C2Tuple_usizeTransactionZZ register_output_LDKFilter_jcall(const void* this_arg, LDKWatchedOutput output) {
	LDKFilter_JCalls *j_calls = (LDKFilter_JCalls*) this_arg;
	JNIEnv *env;
	jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
	} else {
		DO_ASSERT(get_jenv_res == JNI_OK);
	}
	LDKWatchedOutput output_var = output;
	uint64_t output_ref = 0;
	CHECK((((uint64_t)output_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&output_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	output_ref = (uint64_t)output_var.inner;
	if (output_var.is_owned) {
		output_ref |= 1;
	}
	jobject obj = (*env)->NewLocalRef(env, j_calls->o);
	CHECK(obj != NULL);
	uint64_t ret = (*env)->CallLongMethod(env, obj, j_calls->register_output_meth, output_ref);
	if ((*env)->ExceptionCheck(env)) {
		(*env)->ExceptionDescribe(env);
		(*env)->FatalError(env, "A call to register_output in LDKFilter from rust threw an exception.");
	}
	void* ret_ptr = (void*)(((uint64_t)ret) & ~1);
	CHECK_ACCESS(ret_ptr);
	LDKCOption_C2Tuple_usizeTransactionZZ ret_conv = *(LDKCOption_C2Tuple_usizeTransactionZZ*)(ret_ptr);
	ret_conv = COption_C2Tuple_usizeTransactionZZ_clone((LDKCOption_C2Tuple_usizeTransactionZZ*)(((uint64_t)ret) & ~1));
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
	}
	return ret_conv;
}
static void LDKFilter_JCalls_cloned(LDKFilter* new_obj) {
	LDKFilter_JCalls *j_calls = (LDKFilter_JCalls*) new_obj->this_arg;
	atomic_fetch_add_explicit(&j_calls->refcnt, 1, memory_order_release);
}
static inline LDKFilter LDKFilter_init (JNIEnv *env, jclass clz, jobject o) {
	jclass c = (*env)->GetObjectClass(env, o);
	CHECK(c != NULL);
	LDKFilter_JCalls *calls = MALLOC(sizeof(LDKFilter_JCalls), "LDKFilter_JCalls");
	atomic_init(&calls->refcnt, 1);
	DO_ASSERT((*env)->GetJavaVM(env, &calls->vm) == 0);
	calls->o = (*env)->NewWeakGlobalRef(env, o);
	calls->register_tx_meth = (*env)->GetMethodID(env, c, "register_tx", "([B[B)V");
	CHECK(calls->register_tx_meth != NULL);
	calls->register_output_meth = (*env)->GetMethodID(env, c, "register_output", "(J)J");
	CHECK(calls->register_output_meth != NULL);

	LDKFilter ret = {
		.this_arg = (void*) calls,
		.register_tx = register_tx_LDKFilter_jcall,
		.register_output = register_output_LDKFilter_jcall,
		.free = LDKFilter_JCalls_free,
	};
	return ret;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKFilter_1new(JNIEnv *env, jclass clz, jobject o) {
	LDKFilter *res_ptr = MALLOC(sizeof(LDKFilter), "LDKFilter");
	*res_ptr = LDKFilter_init(env, clz, o);
	return (uint64_t)res_ptr;
}
JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_Filter_1register_1tx(JNIEnv *env, jclass clz, int64_t this_arg, int8_tArray txid, int8_tArray script_pubkey) {
	void* this_arg_ptr = (void*)(((uint64_t)this_arg) & ~1);
	if (!(this_arg & 1)) { CHECK_ACCESS(this_arg_ptr); }
	LDKFilter* this_arg_conv = (LDKFilter*)this_arg_ptr;
	unsigned char txid_arr[32];
	CHECK((*env)->GetArrayLength(env, txid) == 32);
	(*env)->GetByteArrayRegion(env, txid, 0, 32, txid_arr);
	unsigned char (*txid_ref)[32] = &txid_arr;
	LDKu8slice script_pubkey_ref;
	script_pubkey_ref.datalen = (*env)->GetArrayLength(env, script_pubkey);
	script_pubkey_ref.data = (*env)->GetByteArrayElements (env, script_pubkey, NULL);
	(this_arg_conv->register_tx)(this_arg_conv->this_arg, txid_ref, script_pubkey_ref);
	(*env)->ReleaseByteArrayElements(env, script_pubkey, (int8_t*)script_pubkey_ref.data, 0);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_Filter_1register_1output(JNIEnv *env, jclass clz, int64_t this_arg, int64_t output) {
	void* this_arg_ptr = (void*)(((uint64_t)this_arg) & ~1);
	if (!(this_arg & 1)) { CHECK_ACCESS(this_arg_ptr); }
	LDKFilter* this_arg_conv = (LDKFilter*)this_arg_ptr;
	LDKWatchedOutput output_conv;
	output_conv.inner = (void*)(output & (~1));
	output_conv.is_owned = (output & 1) || (output == 0);
	output_conv = WatchedOutput_clone(&output_conv);
	LDKCOption_C2Tuple_usizeTransactionZZ *ret_copy = MALLOC(sizeof(LDKCOption_C2Tuple_usizeTransactionZZ), "LDKCOption_C2Tuple_usizeTransactionZZ");
	*ret_copy = (this_arg_conv->register_output)(this_arg_conv->this_arg, output_conv);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

static jclass LDKCOption_FilterZ_Some_class = NULL;
static jmethodID LDKCOption_FilterZ_Some_meth = NULL;
static jclass LDKCOption_FilterZ_None_class = NULL;
static jmethodID LDKCOption_FilterZ_None_meth = NULL;
JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_00024LDKCOption_1FilterZ_init (JNIEnv *env, jclass clz) {
	LDKCOption_FilterZ_Some_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKCOption_FilterZ$Some;"));
	CHECK(LDKCOption_FilterZ_Some_class != NULL);
	LDKCOption_FilterZ_Some_meth = (*env)->GetMethodID(env, LDKCOption_FilterZ_Some_class, "<init>", "(J)V");
	CHECK(LDKCOption_FilterZ_Some_meth != NULL);
	LDKCOption_FilterZ_None_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKCOption_FilterZ$None;"));
	CHECK(LDKCOption_FilterZ_None_class != NULL);
	LDKCOption_FilterZ_None_meth = (*env)->GetMethodID(env, LDKCOption_FilterZ_None_class, "<init>", "()V");
	CHECK(LDKCOption_FilterZ_None_meth != NULL);
}
JNIEXPORT jobject JNICALL Java_org_ldk_impl_bindings_LDKCOption_1FilterZ_1ref_1from_1ptr(JNIEnv *env, jclass clz, int64_t ptr) {
	LDKCOption_FilterZ *obj = (LDKCOption_FilterZ*)(ptr & ~1);
	switch(obj->tag) {
		case LDKCOption_FilterZ_Some: {
			LDKFilter* some_ret = MALLOC(sizeof(LDKFilter), "LDKFilter");
			*some_ret = obj->some;
			// Warning: We likely need to clone here, but no clone is available, so we just do it for Java instances
			if ((*some_ret).free == LDKFilter_JCalls_free) {
				// If this_arg is a JCalls struct, then we need to increment the refcnt in it.
				LDKFilter_JCalls_cloned(&(*some_ret));
			}
			return (*env)->NewObject(env, LDKCOption_FilterZ_Some_class, LDKCOption_FilterZ_Some_meth, (uint64_t)some_ret);
		}
		case LDKCOption_FilterZ_None: {
			return (*env)->NewObject(env, LDKCOption_FilterZ_None_class, LDKCOption_FilterZ_None_meth);
		}
		default: abort();
	}
}
JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_LDKCResult_1LockedChannelMonitorNoneZ_1result_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	return ((LDKCResult_LockedChannelMonitorNoneZ*)arg)->result_ok;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCResult_1LockedChannelMonitorNoneZ_1get_1ok(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_LockedChannelMonitorNoneZ *val = (LDKCResult_LockedChannelMonitorNoneZ*)(arg & ~1);
	CHECK(val->result_ok);
	LDKLockedChannelMonitor res_var = (*val->contents.result);
	uint64_t res_ref = 0;
	CHECK((((uint64_t)res_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&res_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	res_ref = (uint64_t)res_var.inner & ~1;
	return res_ref;
}
JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_LDKCResult_1LockedChannelMonitorNoneZ_1get_1err(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCResult_LockedChannelMonitorNoneZ *val = (LDKCResult_LockedChannelMonitorNoneZ*)(arg & ~1);
	CHECK(!val->result_ok);
	return *val->contents.err;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCVec_1OutPointZ_1new(JNIEnv *env, jclass clz, int64_tArray elems) {
	LDKCVec_OutPointZ *ret = MALLOC(sizeof(LDKCVec_OutPointZ), "LDKCVec_OutPointZ");
	ret->datalen = (*env)->GetArrayLength(env, elems);
	if (ret->datalen == 0) {
		ret->data = NULL;
	} else {
		ret->data = MALLOC(sizeof(LDKOutPoint) * ret->datalen, "LDKCVec_OutPointZ Data");
		int64_t *java_elems = (*env)->GetPrimitiveArrayCritical(env, elems, NULL);
		for (size_t i = 0; i < ret->datalen; i++) {
			int64_t arr_elem = java_elems[i];
			LDKOutPoint arr_elem_conv;
			arr_elem_conv.inner = (void*)(arr_elem & (~1));
			arr_elem_conv.is_owned = (arr_elem & 1) || (arr_elem == 0);
			arr_elem_conv = OutPoint_clone(&arr_elem_conv);
			ret->data[i] = arr_elem_conv;
		}
		(*env)->ReleasePrimitiveArrayCritical(env, elems, java_elems, 0);
	}
	return (uint64_t)ret;
}
static inline LDKCVec_OutPointZ CVec_OutPointZ_clone(const LDKCVec_OutPointZ *orig) {
	LDKCVec_OutPointZ ret = { .data = MALLOC(sizeof(LDKOutPoint) * orig->datalen, "LDKCVec_OutPointZ clone bytes"), .datalen = orig->datalen };
	for (size_t i = 0; i < ret.datalen; i++) {
		ret.data[i] = OutPoint_clone(&orig->data[i]);
	}
	return ret;
}
typedef struct LDKMessageSendEventsProvider_JCalls {
	atomic_size_t refcnt;
	JavaVM *vm;
	jweak o;
	jmethodID get_and_clear_pending_msg_events_meth;
} LDKMessageSendEventsProvider_JCalls;
static void LDKMessageSendEventsProvider_JCalls_free(void* this_arg) {
	LDKMessageSendEventsProvider_JCalls *j_calls = (LDKMessageSendEventsProvider_JCalls*) this_arg;
	if (atomic_fetch_sub_explicit(&j_calls->refcnt, 1, memory_order_acquire) == 1) {
		JNIEnv *env;
		jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
		if (get_jenv_res == JNI_EDETACHED) {
			DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
		} else {
			DO_ASSERT(get_jenv_res == JNI_OK);
		}
		(*env)->DeleteWeakGlobalRef(env, j_calls->o);
		if (get_jenv_res == JNI_EDETACHED) {
			DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
		}
		FREE(j_calls);
	}
}
LDKCVec_MessageSendEventZ get_and_clear_pending_msg_events_LDKMessageSendEventsProvider_jcall(const void* this_arg) {
	LDKMessageSendEventsProvider_JCalls *j_calls = (LDKMessageSendEventsProvider_JCalls*) this_arg;
	JNIEnv *env;
	jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
	} else {
		DO_ASSERT(get_jenv_res == JNI_OK);
	}
	jobject obj = (*env)->NewLocalRef(env, j_calls->o);
	CHECK(obj != NULL);
	int64_tArray ret = (*env)->CallObjectMethod(env, obj, j_calls->get_and_clear_pending_msg_events_meth);
	if ((*env)->ExceptionCheck(env)) {
		(*env)->ExceptionDescribe(env);
		(*env)->FatalError(env, "A call to get_and_clear_pending_msg_events in LDKMessageSendEventsProvider from rust threw an exception.");
	}
	LDKCVec_MessageSendEventZ ret_constr;
	ret_constr.datalen = (*env)->GetArrayLength(env, ret);
	if (ret_constr.datalen > 0)
		ret_constr.data = MALLOC(ret_constr.datalen * sizeof(LDKMessageSendEvent), "LDKCVec_MessageSendEventZ Elements");
	else
		ret_constr.data = NULL;
	int64_t* ret_vals = (*env)->GetLongArrayElements (env, ret, NULL);
	for (size_t s = 0; s < ret_constr.datalen; s++) {
		int64_t ret_conv_18 = ret_vals[s];
		void* ret_conv_18_ptr = (void*)(((uint64_t)ret_conv_18) & ~1);
		CHECK_ACCESS(ret_conv_18_ptr);
		LDKMessageSendEvent ret_conv_18_conv = *(LDKMessageSendEvent*)(ret_conv_18_ptr);
		ret_conv_18_conv = MessageSendEvent_clone((LDKMessageSendEvent*)(((uint64_t)ret_conv_18) & ~1));
		ret_constr.data[s] = ret_conv_18_conv;
	}
	(*env)->ReleaseLongArrayElements(env, ret, ret_vals, 0);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
	}
	return ret_constr;
}
static void LDKMessageSendEventsProvider_JCalls_cloned(LDKMessageSendEventsProvider* new_obj) {
	LDKMessageSendEventsProvider_JCalls *j_calls = (LDKMessageSendEventsProvider_JCalls*) new_obj->this_arg;
	atomic_fetch_add_explicit(&j_calls->refcnt, 1, memory_order_release);
}
static inline LDKMessageSendEventsProvider LDKMessageSendEventsProvider_init (JNIEnv *env, jclass clz, jobject o) {
	jclass c = (*env)->GetObjectClass(env, o);
	CHECK(c != NULL);
	LDKMessageSendEventsProvider_JCalls *calls = MALLOC(sizeof(LDKMessageSendEventsProvider_JCalls), "LDKMessageSendEventsProvider_JCalls");
	atomic_init(&calls->refcnt, 1);
	DO_ASSERT((*env)->GetJavaVM(env, &calls->vm) == 0);
	calls->o = (*env)->NewWeakGlobalRef(env, o);
	calls->get_and_clear_pending_msg_events_meth = (*env)->GetMethodID(env, c, "get_and_clear_pending_msg_events", "()[J");
	CHECK(calls->get_and_clear_pending_msg_events_meth != NULL);

	LDKMessageSendEventsProvider ret = {
		.this_arg = (void*) calls,
		.get_and_clear_pending_msg_events = get_and_clear_pending_msg_events_LDKMessageSendEventsProvider_jcall,
		.free = LDKMessageSendEventsProvider_JCalls_free,
	};
	return ret;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKMessageSendEventsProvider_1new(JNIEnv *env, jclass clz, jobject o) {
	LDKMessageSendEventsProvider *res_ptr = MALLOC(sizeof(LDKMessageSendEventsProvider), "LDKMessageSendEventsProvider");
	*res_ptr = LDKMessageSendEventsProvider_init(env, clz, o);
	return (uint64_t)res_ptr;
}
JNIEXPORT int64_tArray JNICALL Java_org_ldk_impl_bindings_MessageSendEventsProvider_1get_1and_1clear_1pending_1msg_1events(JNIEnv *env, jclass clz, int64_t this_arg) {
	void* this_arg_ptr = (void*)(((uint64_t)this_arg) & ~1);
	if (!(this_arg & 1)) { CHECK_ACCESS(this_arg_ptr); }
	LDKMessageSendEventsProvider* this_arg_conv = (LDKMessageSendEventsProvider*)this_arg_ptr;
	LDKCVec_MessageSendEventZ ret_var = (this_arg_conv->get_and_clear_pending_msg_events)(this_arg_conv->this_arg);
	int64_tArray ret_arr = NULL;
	ret_arr = (*env)->NewLongArray(env, ret_var.datalen);
	int64_t *ret_arr_ptr = (*env)->GetPrimitiveArrayCritical(env, ret_arr, NULL);
	for (size_t s = 0; s < ret_var.datalen; s++) {
		LDKMessageSendEvent *ret_conv_18_copy = MALLOC(sizeof(LDKMessageSendEvent), "LDKMessageSendEvent");
		*ret_conv_18_copy = ret_var.data[s];
		uint64_t ret_conv_18_ref = (uint64_t)ret_conv_18_copy;
		ret_arr_ptr[s] = ret_conv_18_ref;
	}
	(*env)->ReleasePrimitiveArrayCritical(env, ret_arr, ret_arr_ptr, 0);
	FREE(ret_var.data);
	return ret_arr;
}

typedef struct LDKEventHandler_JCalls {
	atomic_size_t refcnt;
	JavaVM *vm;
	jweak o;
	jmethodID handle_event_meth;
} LDKEventHandler_JCalls;
static void LDKEventHandler_JCalls_free(void* this_arg) {
	LDKEventHandler_JCalls *j_calls = (LDKEventHandler_JCalls*) this_arg;
	if (atomic_fetch_sub_explicit(&j_calls->refcnt, 1, memory_order_acquire) == 1) {
		JNIEnv *env;
		jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
		if (get_jenv_res == JNI_EDETACHED) {
			DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
		} else {
			DO_ASSERT(get_jenv_res == JNI_OK);
		}
		(*env)->DeleteWeakGlobalRef(env, j_calls->o);
		if (get_jenv_res == JNI_EDETACHED) {
			DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
		}
		FREE(j_calls);
	}
}
void handle_event_LDKEventHandler_jcall(const void* this_arg, const LDKEvent * event) {
	LDKEventHandler_JCalls *j_calls = (LDKEventHandler_JCalls*) this_arg;
	JNIEnv *env;
	jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
	} else {
		DO_ASSERT(get_jenv_res == JNI_OK);
	}
	LDKEvent *ret_event = MALLOC(sizeof(LDKEvent), "LDKEvent ret conversion");
	*ret_event = Event_clone(event);
	jobject obj = (*env)->NewLocalRef(env, j_calls->o);
	CHECK(obj != NULL);
	(*env)->CallVoidMethod(env, obj, j_calls->handle_event_meth, (uint64_t)ret_event);
	if ((*env)->ExceptionCheck(env)) {
		(*env)->ExceptionDescribe(env);
		(*env)->FatalError(env, "A call to handle_event in LDKEventHandler from rust threw an exception.");
	}
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
	}
}
static void LDKEventHandler_JCalls_cloned(LDKEventHandler* new_obj) {
	LDKEventHandler_JCalls *j_calls = (LDKEventHandler_JCalls*) new_obj->this_arg;
	atomic_fetch_add_explicit(&j_calls->refcnt, 1, memory_order_release);
}
static inline LDKEventHandler LDKEventHandler_init (JNIEnv *env, jclass clz, jobject o) {
	jclass c = (*env)->GetObjectClass(env, o);
	CHECK(c != NULL);
	LDKEventHandler_JCalls *calls = MALLOC(sizeof(LDKEventHandler_JCalls), "LDKEventHandler_JCalls");
	atomic_init(&calls->refcnt, 1);
	DO_ASSERT((*env)->GetJavaVM(env, &calls->vm) == 0);
	calls->o = (*env)->NewWeakGlobalRef(env, o);
	calls->handle_event_meth = (*env)->GetMethodID(env, c, "handle_event", "(J)V");
	CHECK(calls->handle_event_meth != NULL);

	LDKEventHandler ret = {
		.this_arg = (void*) calls,
		.handle_event = handle_event_LDKEventHandler_jcall,
		.free = LDKEventHandler_JCalls_free,
	};
	return ret;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKEventHandler_1new(JNIEnv *env, jclass clz, jobject o) {
	LDKEventHandler *res_ptr = MALLOC(sizeof(LDKEventHandler), "LDKEventHandler");
	*res_ptr = LDKEventHandler_init(env, clz, o);
	return (uint64_t)res_ptr;
}
JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_EventHandler_1handle_1event(JNIEnv *env, jclass clz, int64_t this_arg, int64_t event) {
	void* this_arg_ptr = (void*)(((uint64_t)this_arg) & ~1);
	if (!(this_arg & 1)) { CHECK_ACCESS(this_arg_ptr); }
	LDKEventHandler* this_arg_conv = (LDKEventHandler*)this_arg_ptr;
	LDKEvent* event_conv = (LDKEvent*)event;
	(this_arg_conv->handle_event)(this_arg_conv->this_arg, event_conv);
}

typedef struct LDKEventsProvider_JCalls {
	atomic_size_t refcnt;
	JavaVM *vm;
	jweak o;
	jmethodID process_pending_events_meth;
} LDKEventsProvider_JCalls;
static void LDKEventsProvider_JCalls_free(void* this_arg) {
	LDKEventsProvider_JCalls *j_calls = (LDKEventsProvider_JCalls*) this_arg;
	if (atomic_fetch_sub_explicit(&j_calls->refcnt, 1, memory_order_acquire) == 1) {
		JNIEnv *env;
		jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
		if (get_jenv_res == JNI_EDETACHED) {
			DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
		} else {
			DO_ASSERT(get_jenv_res == JNI_OK);
		}
		(*env)->DeleteWeakGlobalRef(env, j_calls->o);
		if (get_jenv_res == JNI_EDETACHED) {
			DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
		}
		FREE(j_calls);
	}
}
void process_pending_events_LDKEventsProvider_jcall(const void* this_arg, LDKEventHandler handler) {
	LDKEventsProvider_JCalls *j_calls = (LDKEventsProvider_JCalls*) this_arg;
	JNIEnv *env;
	jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
	} else {
		DO_ASSERT(get_jenv_res == JNI_OK);
	}
	LDKEventHandler* handler_ret = MALLOC(sizeof(LDKEventHandler), "LDKEventHandler");
	*handler_ret = handler;
	jobject obj = (*env)->NewLocalRef(env, j_calls->o);
	CHECK(obj != NULL);
	(*env)->CallVoidMethod(env, obj, j_calls->process_pending_events_meth, (uint64_t)handler_ret);
	if ((*env)->ExceptionCheck(env)) {
		(*env)->ExceptionDescribe(env);
		(*env)->FatalError(env, "A call to process_pending_events in LDKEventsProvider from rust threw an exception.");
	}
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
	}
}
static void LDKEventsProvider_JCalls_cloned(LDKEventsProvider* new_obj) {
	LDKEventsProvider_JCalls *j_calls = (LDKEventsProvider_JCalls*) new_obj->this_arg;
	atomic_fetch_add_explicit(&j_calls->refcnt, 1, memory_order_release);
}
static inline LDKEventsProvider LDKEventsProvider_init (JNIEnv *env, jclass clz, jobject o) {
	jclass c = (*env)->GetObjectClass(env, o);
	CHECK(c != NULL);
	LDKEventsProvider_JCalls *calls = MALLOC(sizeof(LDKEventsProvider_JCalls), "LDKEventsProvider_JCalls");
	atomic_init(&calls->refcnt, 1);
	DO_ASSERT((*env)->GetJavaVM(env, &calls->vm) == 0);
	calls->o = (*env)->NewWeakGlobalRef(env, o);
	calls->process_pending_events_meth = (*env)->GetMethodID(env, c, "process_pending_events", "(J)V");
	CHECK(calls->process_pending_events_meth != NULL);

	LDKEventsProvider ret = {
		.this_arg = (void*) calls,
		.process_pending_events = process_pending_events_LDKEventsProvider_jcall,
		.free = LDKEventsProvider_JCalls_free,
	};
	return ret;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKEventsProvider_1new(JNIEnv *env, jclass clz, jobject o) {
	LDKEventsProvider *res_ptr = MALLOC(sizeof(LDKEventsProvider), "LDKEventsProvider");
	*res_ptr = LDKEventsProvider_init(env, clz, o);
	return (uint64_t)res_ptr;
}
JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_EventsProvider_1process_1pending_1events(JNIEnv *env, jclass clz, int64_t this_arg, int64_t handler) {
	void* this_arg_ptr = (void*)(((uint64_t)this_arg) & ~1);
	if (!(this_arg & 1)) { CHECK_ACCESS(this_arg_ptr); }
	LDKEventsProvider* this_arg_conv = (LDKEventsProvider*)this_arg_ptr;
	void* handler_ptr = (void*)(((uint64_t)handler) & ~1);
	CHECK_ACCESS(handler_ptr);
	LDKEventHandler handler_conv = *(LDKEventHandler*)(handler_ptr);
	if (handler_conv.free == LDKEventHandler_JCalls_free) {
		// If this_arg is a JCalls struct, then we need to increment the refcnt in it.
		LDKEventHandler_JCalls_cloned(&handler_conv);
	}
	(this_arg_conv->process_pending_events)(this_arg_conv->this_arg, handler_conv);
}

typedef struct LDKListen_JCalls {
	atomic_size_t refcnt;
	JavaVM *vm;
	jweak o;
	jmethodID block_connected_meth;
	jmethodID block_disconnected_meth;
} LDKListen_JCalls;
static void LDKListen_JCalls_free(void* this_arg) {
	LDKListen_JCalls *j_calls = (LDKListen_JCalls*) this_arg;
	if (atomic_fetch_sub_explicit(&j_calls->refcnt, 1, memory_order_acquire) == 1) {
		JNIEnv *env;
		jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
		if (get_jenv_res == JNI_EDETACHED) {
			DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
		} else {
			DO_ASSERT(get_jenv_res == JNI_OK);
		}
		(*env)->DeleteWeakGlobalRef(env, j_calls->o);
		if (get_jenv_res == JNI_EDETACHED) {
			DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
		}
		FREE(j_calls);
	}
}
void block_connected_LDKListen_jcall(const void* this_arg, LDKu8slice block, uint32_t height) {
	LDKListen_JCalls *j_calls = (LDKListen_JCalls*) this_arg;
	JNIEnv *env;
	jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
	} else {
		DO_ASSERT(get_jenv_res == JNI_OK);
	}
	LDKu8slice block_var = block;
	int8_tArray block_arr = (*env)->NewByteArray(env, block_var.datalen);
	(*env)->SetByteArrayRegion(env, block_arr, 0, block_var.datalen, block_var.data);
	jobject obj = (*env)->NewLocalRef(env, j_calls->o);
	CHECK(obj != NULL);
	(*env)->CallVoidMethod(env, obj, j_calls->block_connected_meth, block_arr, height);
	if ((*env)->ExceptionCheck(env)) {
		(*env)->ExceptionDescribe(env);
		(*env)->FatalError(env, "A call to block_connected in LDKListen from rust threw an exception.");
	}
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
	}
}
void block_disconnected_LDKListen_jcall(const void* this_arg, const uint8_t (* header)[80], uint32_t height) {
	LDKListen_JCalls *j_calls = (LDKListen_JCalls*) this_arg;
	JNIEnv *env;
	jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
	} else {
		DO_ASSERT(get_jenv_res == JNI_OK);
	}
	int8_tArray header_arr = (*env)->NewByteArray(env, 80);
	(*env)->SetByteArrayRegion(env, header_arr, 0, 80, *header);
	jobject obj = (*env)->NewLocalRef(env, j_calls->o);
	CHECK(obj != NULL);
	(*env)->CallVoidMethod(env, obj, j_calls->block_disconnected_meth, header_arr, height);
	if ((*env)->ExceptionCheck(env)) {
		(*env)->ExceptionDescribe(env);
		(*env)->FatalError(env, "A call to block_disconnected in LDKListen from rust threw an exception.");
	}
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
	}
}
static void LDKListen_JCalls_cloned(LDKListen* new_obj) {
	LDKListen_JCalls *j_calls = (LDKListen_JCalls*) new_obj->this_arg;
	atomic_fetch_add_explicit(&j_calls->refcnt, 1, memory_order_release);
}
static inline LDKListen LDKListen_init (JNIEnv *env, jclass clz, jobject o) {
	jclass c = (*env)->GetObjectClass(env, o);
	CHECK(c != NULL);
	LDKListen_JCalls *calls = MALLOC(sizeof(LDKListen_JCalls), "LDKListen_JCalls");
	atomic_init(&calls->refcnt, 1);
	DO_ASSERT((*env)->GetJavaVM(env, &calls->vm) == 0);
	calls->o = (*env)->NewWeakGlobalRef(env, o);
	calls->block_connected_meth = (*env)->GetMethodID(env, c, "block_connected", "([BI)V");
	CHECK(calls->block_connected_meth != NULL);
	calls->block_disconnected_meth = (*env)->GetMethodID(env, c, "block_disconnected", "([BI)V");
	CHECK(calls->block_disconnected_meth != NULL);

	LDKListen ret = {
		.this_arg = (void*) calls,
		.block_connected = block_connected_LDKListen_jcall,
		.block_disconnected = block_disconnected_LDKListen_jcall,
		.free = LDKListen_JCalls_free,
	};
	return ret;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKListen_1new(JNIEnv *env, jclass clz, jobject o) {
	LDKListen *res_ptr = MALLOC(sizeof(LDKListen), "LDKListen");
	*res_ptr = LDKListen_init(env, clz, o);
	return (uint64_t)res_ptr;
}
JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_Listen_1block_1connected(JNIEnv *env, jclass clz, int64_t this_arg, int8_tArray block, int32_t height) {
	void* this_arg_ptr = (void*)(((uint64_t)this_arg) & ~1);
	if (!(this_arg & 1)) { CHECK_ACCESS(this_arg_ptr); }
	LDKListen* this_arg_conv = (LDKListen*)this_arg_ptr;
	LDKu8slice block_ref;
	block_ref.datalen = (*env)->GetArrayLength(env, block);
	block_ref.data = (*env)->GetByteArrayElements (env, block, NULL);
	(this_arg_conv->block_connected)(this_arg_conv->this_arg, block_ref, height);
	(*env)->ReleaseByteArrayElements(env, block, (int8_t*)block_ref.data, 0);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_Listen_1block_1disconnected(JNIEnv *env, jclass clz, int64_t this_arg, int8_tArray header, int32_t height) {
	void* this_arg_ptr = (void*)(((uint64_t)this_arg) & ~1);
	if (!(this_arg & 1)) { CHECK_ACCESS(this_arg_ptr); }
	LDKListen* this_arg_conv = (LDKListen*)this_arg_ptr;
	unsigned char header_arr[80];
	CHECK((*env)->GetArrayLength(env, header) == 80);
	(*env)->GetByteArrayRegion(env, header, 0, 80, header_arr);
	unsigned char (*header_ref)[80] = &header_arr;
	(this_arg_conv->block_disconnected)(this_arg_conv->this_arg, header_ref, height);
}

typedef struct LDKConfirm_JCalls {
	atomic_size_t refcnt;
	JavaVM *vm;
	jweak o;
	jmethodID transactions_confirmed_meth;
	jmethodID transaction_unconfirmed_meth;
	jmethodID best_block_updated_meth;
	jmethodID get_relevant_txids_meth;
} LDKConfirm_JCalls;
static void LDKConfirm_JCalls_free(void* this_arg) {
	LDKConfirm_JCalls *j_calls = (LDKConfirm_JCalls*) this_arg;
	if (atomic_fetch_sub_explicit(&j_calls->refcnt, 1, memory_order_acquire) == 1) {
		JNIEnv *env;
		jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
		if (get_jenv_res == JNI_EDETACHED) {
			DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
		} else {
			DO_ASSERT(get_jenv_res == JNI_OK);
		}
		(*env)->DeleteWeakGlobalRef(env, j_calls->o);
		if (get_jenv_res == JNI_EDETACHED) {
			DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
		}
		FREE(j_calls);
	}
}
void transactions_confirmed_LDKConfirm_jcall(const void* this_arg, const uint8_t (* header)[80], LDKCVec_C2Tuple_usizeTransactionZZ txdata, uint32_t height) {
	LDKConfirm_JCalls *j_calls = (LDKConfirm_JCalls*) this_arg;
	JNIEnv *env;
	jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
	} else {
		DO_ASSERT(get_jenv_res == JNI_OK);
	}
	int8_tArray header_arr = (*env)->NewByteArray(env, 80);
	(*env)->SetByteArrayRegion(env, header_arr, 0, 80, *header);
	LDKCVec_C2Tuple_usizeTransactionZZ txdata_var = txdata;
	int64_tArray txdata_arr = NULL;
	txdata_arr = (*env)->NewLongArray(env, txdata_var.datalen);
	int64_t *txdata_arr_ptr = (*env)->GetPrimitiveArrayCritical(env, txdata_arr, NULL);
	for (size_t c = 0; c < txdata_var.datalen; c++) {
		LDKC2Tuple_usizeTransactionZ* txdata_conv_28_conv = MALLOC(sizeof(LDKC2Tuple_usizeTransactionZ), "LDKC2Tuple_usizeTransactionZ");
		*txdata_conv_28_conv = txdata_var.data[c];
		txdata_arr_ptr[c] = ((uint64_t)txdata_conv_28_conv);
	}
	(*env)->ReleasePrimitiveArrayCritical(env, txdata_arr, txdata_arr_ptr, 0);
	FREE(txdata_var.data);
	jobject obj = (*env)->NewLocalRef(env, j_calls->o);
	CHECK(obj != NULL);
	(*env)->CallVoidMethod(env, obj, j_calls->transactions_confirmed_meth, header_arr, txdata_arr, height);
	if ((*env)->ExceptionCheck(env)) {
		(*env)->ExceptionDescribe(env);
		(*env)->FatalError(env, "A call to transactions_confirmed in LDKConfirm from rust threw an exception.");
	}
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
	}
}
void transaction_unconfirmed_LDKConfirm_jcall(const void* this_arg, const uint8_t (* txid)[32]) {
	LDKConfirm_JCalls *j_calls = (LDKConfirm_JCalls*) this_arg;
	JNIEnv *env;
	jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
	} else {
		DO_ASSERT(get_jenv_res == JNI_OK);
	}
	int8_tArray txid_arr = (*env)->NewByteArray(env, 32);
	(*env)->SetByteArrayRegion(env, txid_arr, 0, 32, *txid);
	jobject obj = (*env)->NewLocalRef(env, j_calls->o);
	CHECK(obj != NULL);
	(*env)->CallVoidMethod(env, obj, j_calls->transaction_unconfirmed_meth, txid_arr);
	if ((*env)->ExceptionCheck(env)) {
		(*env)->ExceptionDescribe(env);
		(*env)->FatalError(env, "A call to transaction_unconfirmed in LDKConfirm from rust threw an exception.");
	}
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
	}
}
void best_block_updated_LDKConfirm_jcall(const void* this_arg, const uint8_t (* header)[80], uint32_t height) {
	LDKConfirm_JCalls *j_calls = (LDKConfirm_JCalls*) this_arg;
	JNIEnv *env;
	jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
	} else {
		DO_ASSERT(get_jenv_res == JNI_OK);
	}
	int8_tArray header_arr = (*env)->NewByteArray(env, 80);
	(*env)->SetByteArrayRegion(env, header_arr, 0, 80, *header);
	jobject obj = (*env)->NewLocalRef(env, j_calls->o);
	CHECK(obj != NULL);
	(*env)->CallVoidMethod(env, obj, j_calls->best_block_updated_meth, header_arr, height);
	if ((*env)->ExceptionCheck(env)) {
		(*env)->ExceptionDescribe(env);
		(*env)->FatalError(env, "A call to best_block_updated in LDKConfirm from rust threw an exception.");
	}
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
	}
}
LDKCVec_TxidZ get_relevant_txids_LDKConfirm_jcall(const void* this_arg) {
	LDKConfirm_JCalls *j_calls = (LDKConfirm_JCalls*) this_arg;
	JNIEnv *env;
	jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
	} else {
		DO_ASSERT(get_jenv_res == JNI_OK);
	}
	jobject obj = (*env)->NewLocalRef(env, j_calls->o);
	CHECK(obj != NULL);
	jobjectArray ret = (*env)->CallObjectMethod(env, obj, j_calls->get_relevant_txids_meth);
	if ((*env)->ExceptionCheck(env)) {
		(*env)->ExceptionDescribe(env);
		(*env)->FatalError(env, "A call to get_relevant_txids in LDKConfirm from rust threw an exception.");
	}
	LDKCVec_TxidZ ret_constr;
	ret_constr.datalen = (*env)->GetArrayLength(env, ret);
	if (ret_constr.datalen > 0)
		ret_constr.data = MALLOC(ret_constr.datalen * sizeof(LDKThirtyTwoBytes), "LDKCVec_TxidZ Elements");
	else
		ret_constr.data = NULL;
	for (size_t i = 0; i < ret_constr.datalen; i++) {
		int8_tArray ret_conv_8 = (*env)->GetObjectArrayElement(env, ret, i);
		LDKThirtyTwoBytes ret_conv_8_ref;
		CHECK((*env)->GetArrayLength(env, ret_conv_8) == 32);
		(*env)->GetByteArrayRegion(env, ret_conv_8, 0, 32, ret_conv_8_ref.data);
		ret_constr.data[i] = ret_conv_8_ref;
	}
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
	}
	return ret_constr;
}
static void LDKConfirm_JCalls_cloned(LDKConfirm* new_obj) {
	LDKConfirm_JCalls *j_calls = (LDKConfirm_JCalls*) new_obj->this_arg;
	atomic_fetch_add_explicit(&j_calls->refcnt, 1, memory_order_release);
}
static inline LDKConfirm LDKConfirm_init (JNIEnv *env, jclass clz, jobject o) {
	jclass c = (*env)->GetObjectClass(env, o);
	CHECK(c != NULL);
	LDKConfirm_JCalls *calls = MALLOC(sizeof(LDKConfirm_JCalls), "LDKConfirm_JCalls");
	atomic_init(&calls->refcnt, 1);
	DO_ASSERT((*env)->GetJavaVM(env, &calls->vm) == 0);
	calls->o = (*env)->NewWeakGlobalRef(env, o);
	calls->transactions_confirmed_meth = (*env)->GetMethodID(env, c, "transactions_confirmed", "([B[JI)V");
	CHECK(calls->transactions_confirmed_meth != NULL);
	calls->transaction_unconfirmed_meth = (*env)->GetMethodID(env, c, "transaction_unconfirmed", "([B)V");
	CHECK(calls->transaction_unconfirmed_meth != NULL);
	calls->best_block_updated_meth = (*env)->GetMethodID(env, c, "best_block_updated", "([BI)V");
	CHECK(calls->best_block_updated_meth != NULL);
	calls->get_relevant_txids_meth = (*env)->GetMethodID(env, c, "get_relevant_txids", "()[[B");
	CHECK(calls->get_relevant_txids_meth != NULL);

	LDKConfirm ret = {
		.this_arg = (void*) calls,
		.transactions_confirmed = transactions_confirmed_LDKConfirm_jcall,
		.transaction_unconfirmed = transaction_unconfirmed_LDKConfirm_jcall,
		.best_block_updated = best_block_updated_LDKConfirm_jcall,
		.get_relevant_txids = get_relevant_txids_LDKConfirm_jcall,
		.free = LDKConfirm_JCalls_free,
	};
	return ret;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKConfirm_1new(JNIEnv *env, jclass clz, jobject o) {
	LDKConfirm *res_ptr = MALLOC(sizeof(LDKConfirm), "LDKConfirm");
	*res_ptr = LDKConfirm_init(env, clz, o);
	return (uint64_t)res_ptr;
}
JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_Confirm_1transactions_1confirmed(JNIEnv *env, jclass clz, int64_t this_arg, int8_tArray header, int64_tArray txdata, int32_t height) {
	void* this_arg_ptr = (void*)(((uint64_t)this_arg) & ~1);
	if (!(this_arg & 1)) { CHECK_ACCESS(this_arg_ptr); }
	LDKConfirm* this_arg_conv = (LDKConfirm*)this_arg_ptr;
	unsigned char header_arr[80];
	CHECK((*env)->GetArrayLength(env, header) == 80);
	(*env)->GetByteArrayRegion(env, header, 0, 80, header_arr);
	unsigned char (*header_ref)[80] = &header_arr;
	LDKCVec_C2Tuple_usizeTransactionZZ txdata_constr;
	txdata_constr.datalen = (*env)->GetArrayLength(env, txdata);
	if (txdata_constr.datalen > 0)
		txdata_constr.data = MALLOC(txdata_constr.datalen * sizeof(LDKC2Tuple_usizeTransactionZ), "LDKCVec_C2Tuple_usizeTransactionZZ Elements");
	else
		txdata_constr.data = NULL;
	int64_t* txdata_vals = (*env)->GetLongArrayElements (env, txdata, NULL);
	for (size_t c = 0; c < txdata_constr.datalen; c++) {
		int64_t txdata_conv_28 = txdata_vals[c];
		void* txdata_conv_28_ptr = (void*)(((uint64_t)txdata_conv_28) & ~1);
		CHECK_ACCESS(txdata_conv_28_ptr);
		LDKC2Tuple_usizeTransactionZ txdata_conv_28_conv = *(LDKC2Tuple_usizeTransactionZ*)(txdata_conv_28_ptr);
		txdata_conv_28_conv = C2Tuple_usizeTransactionZ_clone((LDKC2Tuple_usizeTransactionZ*)(((uint64_t)txdata_conv_28) & ~1));
		txdata_constr.data[c] = txdata_conv_28_conv;
	}
	(*env)->ReleaseLongArrayElements(env, txdata, txdata_vals, 0);
	(this_arg_conv->transactions_confirmed)(this_arg_conv->this_arg, header_ref, txdata_constr, height);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_Confirm_1transaction_1unconfirmed(JNIEnv *env, jclass clz, int64_t this_arg, int8_tArray txid) {
	void* this_arg_ptr = (void*)(((uint64_t)this_arg) & ~1);
	if (!(this_arg & 1)) { CHECK_ACCESS(this_arg_ptr); }
	LDKConfirm* this_arg_conv = (LDKConfirm*)this_arg_ptr;
	unsigned char txid_arr[32];
	CHECK((*env)->GetArrayLength(env, txid) == 32);
	(*env)->GetByteArrayRegion(env, txid, 0, 32, txid_arr);
	unsigned char (*txid_ref)[32] = &txid_arr;
	(this_arg_conv->transaction_unconfirmed)(this_arg_conv->this_arg, txid_ref);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_Confirm_1best_1block_1updated(JNIEnv *env, jclass clz, int64_t this_arg, int8_tArray header, int32_t height) {
	void* this_arg_ptr = (void*)(((uint64_t)this_arg) & ~1);
	if (!(this_arg & 1)) { CHECK_ACCESS(this_arg_ptr); }
	LDKConfirm* this_arg_conv = (LDKConfirm*)this_arg_ptr;
	unsigned char header_arr[80];
	CHECK((*env)->GetArrayLength(env, header) == 80);
	(*env)->GetByteArrayRegion(env, header, 0, 80, header_arr);
	unsigned char (*header_ref)[80] = &header_arr;
	(this_arg_conv->best_block_updated)(this_arg_conv->this_arg, header_ref, height);
}

JNIEXPORT jobjectArray JNICALL Java_org_ldk_impl_bindings_Confirm_1get_1relevant_1txids(JNIEnv *env, jclass clz, int64_t this_arg) {
	void* this_arg_ptr = (void*)(((uint64_t)this_arg) & ~1);
	if (!(this_arg & 1)) { CHECK_ACCESS(this_arg_ptr); }
	LDKConfirm* this_arg_conv = (LDKConfirm*)this_arg_ptr;
	LDKCVec_TxidZ ret_var = (this_arg_conv->get_relevant_txids)(this_arg_conv->this_arg);
	jobjectArray ret_arr = NULL;
	ret_arr = (*env)->NewObjectArray(env, ret_var.datalen, arr_of_B_clz, NULL);
	;
	for (size_t i = 0; i < ret_var.datalen; i++) {
		int8_tArray ret_conv_8_arr = (*env)->NewByteArray(env, 32);
		(*env)->SetByteArrayRegion(env, ret_conv_8_arr, 0, 32, ret_var.data[i].data);
		(*env)->SetObjectArrayElement(env, ret_arr, i, ret_conv_8_arr);
	}
	
	FREE(ret_var.data);
	return ret_arr;
}

typedef struct LDKPersist_JCalls {
	atomic_size_t refcnt;
	JavaVM *vm;
	jweak o;
	jmethodID persist_new_channel_meth;
	jmethodID update_persisted_channel_meth;
} LDKPersist_JCalls;
static void LDKPersist_JCalls_free(void* this_arg) {
	LDKPersist_JCalls *j_calls = (LDKPersist_JCalls*) this_arg;
	if (atomic_fetch_sub_explicit(&j_calls->refcnt, 1, memory_order_acquire) == 1) {
		JNIEnv *env;
		jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
		if (get_jenv_res == JNI_EDETACHED) {
			DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
		} else {
			DO_ASSERT(get_jenv_res == JNI_OK);
		}
		(*env)->DeleteWeakGlobalRef(env, j_calls->o);
		if (get_jenv_res == JNI_EDETACHED) {
			DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
		}
		FREE(j_calls);
	}
}
LDKCResult_NoneChannelMonitorUpdateErrZ persist_new_channel_LDKPersist_jcall(const void* this_arg, LDKOutPoint channel_id, const LDKChannelMonitor * data, LDKMonitorUpdateId update_id) {
	LDKPersist_JCalls *j_calls = (LDKPersist_JCalls*) this_arg;
	JNIEnv *env;
	jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
	} else {
		DO_ASSERT(get_jenv_res == JNI_OK);
	}
	LDKOutPoint channel_id_var = channel_id;
	uint64_t channel_id_ref = 0;
	CHECK((((uint64_t)channel_id_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&channel_id_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	channel_id_ref = (uint64_t)channel_id_var.inner;
	if (channel_id_var.is_owned) {
		channel_id_ref |= 1;
	}
	LDKChannelMonitor data_var = *data;
	uint64_t data_ref = 0;
	data_var = ChannelMonitor_clone(data);
	CHECK((((uint64_t)data_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&data_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	data_ref = (uint64_t)data_var.inner;
	if (data_var.is_owned) {
		data_ref |= 1;
	}
	LDKMonitorUpdateId update_id_var = update_id;
	uint64_t update_id_ref = 0;
	CHECK((((uint64_t)update_id_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&update_id_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	update_id_ref = (uint64_t)update_id_var.inner;
	if (update_id_var.is_owned) {
		update_id_ref |= 1;
	}
	jobject obj = (*env)->NewLocalRef(env, j_calls->o);
	CHECK(obj != NULL);
	uint64_t ret = (*env)->CallLongMethod(env, obj, j_calls->persist_new_channel_meth, channel_id_ref, data_ref, update_id_ref);
	if ((*env)->ExceptionCheck(env)) {
		(*env)->ExceptionDescribe(env);
		(*env)->FatalError(env, "A call to persist_new_channel in LDKPersist from rust threw an exception.");
	}
	void* ret_ptr = (void*)(((uint64_t)ret) & ~1);
	CHECK_ACCESS(ret_ptr);
	LDKCResult_NoneChannelMonitorUpdateErrZ ret_conv = *(LDKCResult_NoneChannelMonitorUpdateErrZ*)(ret_ptr);
	ret_conv = CResult_NoneChannelMonitorUpdateErrZ_clone((LDKCResult_NoneChannelMonitorUpdateErrZ*)(((uint64_t)ret) & ~1));
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
	}
	return ret_conv;
}
LDKCResult_NoneChannelMonitorUpdateErrZ update_persisted_channel_LDKPersist_jcall(const void* this_arg, LDKOutPoint channel_id, const LDKChannelMonitorUpdate * update, const LDKChannelMonitor * data, LDKMonitorUpdateId update_id) {
	LDKPersist_JCalls *j_calls = (LDKPersist_JCalls*) this_arg;
	JNIEnv *env;
	jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
	} else {
		DO_ASSERT(get_jenv_res == JNI_OK);
	}
	LDKOutPoint channel_id_var = channel_id;
	uint64_t channel_id_ref = 0;
	CHECK((((uint64_t)channel_id_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&channel_id_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	channel_id_ref = (uint64_t)channel_id_var.inner;
	if (channel_id_var.is_owned) {
		channel_id_ref |= 1;
	}
	LDKChannelMonitorUpdate update_var = *update;
	uint64_t update_ref = 0;
	if ((uint64_t)update_var.inner > 4096) {
		update_var = ChannelMonitorUpdate_clone(update);
		CHECK((((uint64_t)update_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
		CHECK((((uint64_t)&update_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
		update_ref = (uint64_t)update_var.inner;
		if (update_var.is_owned) {
			update_ref |= 1;
		}
	}
	LDKChannelMonitor data_var = *data;
	uint64_t data_ref = 0;
	data_var = ChannelMonitor_clone(data);
	CHECK((((uint64_t)data_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&data_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	data_ref = (uint64_t)data_var.inner;
	if (data_var.is_owned) {
		data_ref |= 1;
	}
	LDKMonitorUpdateId update_id_var = update_id;
	uint64_t update_id_ref = 0;
	CHECK((((uint64_t)update_id_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&update_id_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	update_id_ref = (uint64_t)update_id_var.inner;
	if (update_id_var.is_owned) {
		update_id_ref |= 1;
	}
	jobject obj = (*env)->NewLocalRef(env, j_calls->o);
	CHECK(obj != NULL);
	uint64_t ret = (*env)->CallLongMethod(env, obj, j_calls->update_persisted_channel_meth, channel_id_ref, update_ref, data_ref, update_id_ref);
	if ((*env)->ExceptionCheck(env)) {
		(*env)->ExceptionDescribe(env);
		(*env)->FatalError(env, "A call to update_persisted_channel in LDKPersist from rust threw an exception.");
	}
	void* ret_ptr = (void*)(((uint64_t)ret) & ~1);
	CHECK_ACCESS(ret_ptr);
	LDKCResult_NoneChannelMonitorUpdateErrZ ret_conv = *(LDKCResult_NoneChannelMonitorUpdateErrZ*)(ret_ptr);
	ret_conv = CResult_NoneChannelMonitorUpdateErrZ_clone((LDKCResult_NoneChannelMonitorUpdateErrZ*)(((uint64_t)ret) & ~1));
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
	}
	return ret_conv;
}
static void LDKPersist_JCalls_cloned(LDKPersist* new_obj) {
	LDKPersist_JCalls *j_calls = (LDKPersist_JCalls*) new_obj->this_arg;
	atomic_fetch_add_explicit(&j_calls->refcnt, 1, memory_order_release);
}
static inline LDKPersist LDKPersist_init (JNIEnv *env, jclass clz, jobject o) {
	jclass c = (*env)->GetObjectClass(env, o);
	CHECK(c != NULL);
	LDKPersist_JCalls *calls = MALLOC(sizeof(LDKPersist_JCalls), "LDKPersist_JCalls");
	atomic_init(&calls->refcnt, 1);
	DO_ASSERT((*env)->GetJavaVM(env, &calls->vm) == 0);
	calls->o = (*env)->NewWeakGlobalRef(env, o);
	calls->persist_new_channel_meth = (*env)->GetMethodID(env, c, "persist_new_channel", "(JJJ)J");
	CHECK(calls->persist_new_channel_meth != NULL);
	calls->update_persisted_channel_meth = (*env)->GetMethodID(env, c, "update_persisted_channel", "(JJJJ)J");
	CHECK(calls->update_persisted_channel_meth != NULL);

	LDKPersist ret = {
		.this_arg = (void*) calls,
		.persist_new_channel = persist_new_channel_LDKPersist_jcall,
		.update_persisted_channel = update_persisted_channel_LDKPersist_jcall,
		.free = LDKPersist_JCalls_free,
	};
	return ret;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKPersist_1new(JNIEnv *env, jclass clz, jobject o) {
	LDKPersist *res_ptr = MALLOC(sizeof(LDKPersist), "LDKPersist");
	*res_ptr = LDKPersist_init(env, clz, o);
	return (uint64_t)res_ptr;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_Persist_1persist_1new_1channel(JNIEnv *env, jclass clz, int64_t this_arg, int64_t channel_id, int64_t data, int64_t update_id) {
	void* this_arg_ptr = (void*)(((uint64_t)this_arg) & ~1);
	if (!(this_arg & 1)) { CHECK_ACCESS(this_arg_ptr); }
	LDKPersist* this_arg_conv = (LDKPersist*)this_arg_ptr;
	LDKOutPoint channel_id_conv;
	channel_id_conv.inner = (void*)(channel_id & (~1));
	channel_id_conv.is_owned = (channel_id & 1) || (channel_id == 0);
	channel_id_conv = OutPoint_clone(&channel_id_conv);
	LDKChannelMonitor data_conv;
	data_conv.inner = (void*)(data & (~1));
	data_conv.is_owned = false;
	LDKMonitorUpdateId update_id_conv;
	update_id_conv.inner = (void*)(update_id & (~1));
	update_id_conv.is_owned = (update_id & 1) || (update_id == 0);
	update_id_conv = MonitorUpdateId_clone(&update_id_conv);
	LDKCResult_NoneChannelMonitorUpdateErrZ* ret_conv = MALLOC(sizeof(LDKCResult_NoneChannelMonitorUpdateErrZ), "LDKCResult_NoneChannelMonitorUpdateErrZ");
	*ret_conv = (this_arg_conv->persist_new_channel)(this_arg_conv->this_arg, channel_id_conv, &data_conv, update_id_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_Persist_1update_1persisted_1channel(JNIEnv *env, jclass clz, int64_t this_arg, int64_t channel_id, int64_t update, int64_t data, int64_t update_id) {
	void* this_arg_ptr = (void*)(((uint64_t)this_arg) & ~1);
	if (!(this_arg & 1)) { CHECK_ACCESS(this_arg_ptr); }
	LDKPersist* this_arg_conv = (LDKPersist*)this_arg_ptr;
	LDKOutPoint channel_id_conv;
	channel_id_conv.inner = (void*)(channel_id & (~1));
	channel_id_conv.is_owned = (channel_id & 1) || (channel_id == 0);
	channel_id_conv = OutPoint_clone(&channel_id_conv);
	LDKChannelMonitorUpdate update_conv;
	update_conv.inner = (void*)(update & (~1));
	update_conv.is_owned = false;
	LDKChannelMonitor data_conv;
	data_conv.inner = (void*)(data & (~1));
	data_conv.is_owned = false;
	LDKMonitorUpdateId update_id_conv;
	update_id_conv.inner = (void*)(update_id & (~1));
	update_id_conv.is_owned = (update_id & 1) || (update_id == 0);
	update_id_conv = MonitorUpdateId_clone(&update_id_conv);
	LDKCResult_NoneChannelMonitorUpdateErrZ* ret_conv = MALLOC(sizeof(LDKCResult_NoneChannelMonitorUpdateErrZ), "LDKCResult_NoneChannelMonitorUpdateErrZ");
	*ret_conv = (this_arg_conv->update_persisted_channel)(this_arg_conv->this_arg, channel_id_conv, &update_conv, &data_conv, update_id_conv);
	return (uint64_t)ret_conv;
}

typedef struct LDKChannelMessageHandler_JCalls {
	atomic_size_t refcnt;
	JavaVM *vm;
	jweak o;
	LDKMessageSendEventsProvider_JCalls* MessageSendEventsProvider;
	jmethodID handle_open_channel_meth;
	jmethodID handle_accept_channel_meth;
	jmethodID handle_funding_created_meth;
	jmethodID handle_funding_signed_meth;
	jmethodID handle_funding_locked_meth;
	jmethodID handle_shutdown_meth;
	jmethodID handle_closing_signed_meth;
	jmethodID handle_update_add_htlc_meth;
	jmethodID handle_update_fulfill_htlc_meth;
	jmethodID handle_update_fail_htlc_meth;
	jmethodID handle_update_fail_malformed_htlc_meth;
	jmethodID handle_commitment_signed_meth;
	jmethodID handle_revoke_and_ack_meth;
	jmethodID handle_update_fee_meth;
	jmethodID handle_announcement_signatures_meth;
	jmethodID peer_disconnected_meth;
	jmethodID peer_connected_meth;
	jmethodID handle_channel_reestablish_meth;
	jmethodID handle_channel_update_meth;
	jmethodID handle_error_meth;
} LDKChannelMessageHandler_JCalls;
static void LDKChannelMessageHandler_JCalls_free(void* this_arg) {
	LDKChannelMessageHandler_JCalls *j_calls = (LDKChannelMessageHandler_JCalls*) this_arg;
	if (atomic_fetch_sub_explicit(&j_calls->refcnt, 1, memory_order_acquire) == 1) {
		JNIEnv *env;
		jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
		if (get_jenv_res == JNI_EDETACHED) {
			DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
		} else {
			DO_ASSERT(get_jenv_res == JNI_OK);
		}
		(*env)->DeleteWeakGlobalRef(env, j_calls->o);
		if (get_jenv_res == JNI_EDETACHED) {
			DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
		}
		FREE(j_calls);
	}
}
void handle_open_channel_LDKChannelMessageHandler_jcall(const void* this_arg, LDKPublicKey their_node_id, LDKInitFeatures their_features, const LDKOpenChannel * msg) {
	LDKChannelMessageHandler_JCalls *j_calls = (LDKChannelMessageHandler_JCalls*) this_arg;
	JNIEnv *env;
	jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
	} else {
		DO_ASSERT(get_jenv_res == JNI_OK);
	}
	int8_tArray their_node_id_arr = (*env)->NewByteArray(env, 33);
	(*env)->SetByteArrayRegion(env, their_node_id_arr, 0, 33, their_node_id.compressed_form);
	LDKInitFeatures their_features_var = their_features;
	uint64_t their_features_ref = 0;
	CHECK((((uint64_t)their_features_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&their_features_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	their_features_ref = (uint64_t)their_features_var.inner;
	if (their_features_var.is_owned) {
		their_features_ref |= 1;
	}
	LDKOpenChannel msg_var = *msg;
	uint64_t msg_ref = 0;
	msg_var = OpenChannel_clone(msg);
	CHECK((((uint64_t)msg_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&msg_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	msg_ref = (uint64_t)msg_var.inner;
	if (msg_var.is_owned) {
		msg_ref |= 1;
	}
	jobject obj = (*env)->NewLocalRef(env, j_calls->o);
	CHECK(obj != NULL);
	(*env)->CallVoidMethod(env, obj, j_calls->handle_open_channel_meth, their_node_id_arr, their_features_ref, msg_ref);
	if ((*env)->ExceptionCheck(env)) {
		(*env)->ExceptionDescribe(env);
		(*env)->FatalError(env, "A call to handle_open_channel in LDKChannelMessageHandler from rust threw an exception.");
	}
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
	}
}
void handle_accept_channel_LDKChannelMessageHandler_jcall(const void* this_arg, LDKPublicKey their_node_id, LDKInitFeatures their_features, const LDKAcceptChannel * msg) {
	LDKChannelMessageHandler_JCalls *j_calls = (LDKChannelMessageHandler_JCalls*) this_arg;
	JNIEnv *env;
	jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
	} else {
		DO_ASSERT(get_jenv_res == JNI_OK);
	}
	int8_tArray their_node_id_arr = (*env)->NewByteArray(env, 33);
	(*env)->SetByteArrayRegion(env, their_node_id_arr, 0, 33, their_node_id.compressed_form);
	LDKInitFeatures their_features_var = their_features;
	uint64_t their_features_ref = 0;
	CHECK((((uint64_t)their_features_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&their_features_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	their_features_ref = (uint64_t)their_features_var.inner;
	if (their_features_var.is_owned) {
		their_features_ref |= 1;
	}
	LDKAcceptChannel msg_var = *msg;
	uint64_t msg_ref = 0;
	msg_var = AcceptChannel_clone(msg);
	CHECK((((uint64_t)msg_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&msg_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	msg_ref = (uint64_t)msg_var.inner;
	if (msg_var.is_owned) {
		msg_ref |= 1;
	}
	jobject obj = (*env)->NewLocalRef(env, j_calls->o);
	CHECK(obj != NULL);
	(*env)->CallVoidMethod(env, obj, j_calls->handle_accept_channel_meth, their_node_id_arr, their_features_ref, msg_ref);
	if ((*env)->ExceptionCheck(env)) {
		(*env)->ExceptionDescribe(env);
		(*env)->FatalError(env, "A call to handle_accept_channel in LDKChannelMessageHandler from rust threw an exception.");
	}
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
	}
}
void handle_funding_created_LDKChannelMessageHandler_jcall(const void* this_arg, LDKPublicKey their_node_id, const LDKFundingCreated * msg) {
	LDKChannelMessageHandler_JCalls *j_calls = (LDKChannelMessageHandler_JCalls*) this_arg;
	JNIEnv *env;
	jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
	} else {
		DO_ASSERT(get_jenv_res == JNI_OK);
	}
	int8_tArray their_node_id_arr = (*env)->NewByteArray(env, 33);
	(*env)->SetByteArrayRegion(env, their_node_id_arr, 0, 33, their_node_id.compressed_form);
	LDKFundingCreated msg_var = *msg;
	uint64_t msg_ref = 0;
	msg_var = FundingCreated_clone(msg);
	CHECK((((uint64_t)msg_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&msg_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	msg_ref = (uint64_t)msg_var.inner;
	if (msg_var.is_owned) {
		msg_ref |= 1;
	}
	jobject obj = (*env)->NewLocalRef(env, j_calls->o);
	CHECK(obj != NULL);
	(*env)->CallVoidMethod(env, obj, j_calls->handle_funding_created_meth, their_node_id_arr, msg_ref);
	if ((*env)->ExceptionCheck(env)) {
		(*env)->ExceptionDescribe(env);
		(*env)->FatalError(env, "A call to handle_funding_created in LDKChannelMessageHandler from rust threw an exception.");
	}
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
	}
}
void handle_funding_signed_LDKChannelMessageHandler_jcall(const void* this_arg, LDKPublicKey their_node_id, const LDKFundingSigned * msg) {
	LDKChannelMessageHandler_JCalls *j_calls = (LDKChannelMessageHandler_JCalls*) this_arg;
	JNIEnv *env;
	jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
	} else {
		DO_ASSERT(get_jenv_res == JNI_OK);
	}
	int8_tArray their_node_id_arr = (*env)->NewByteArray(env, 33);
	(*env)->SetByteArrayRegion(env, their_node_id_arr, 0, 33, their_node_id.compressed_form);
	LDKFundingSigned msg_var = *msg;
	uint64_t msg_ref = 0;
	msg_var = FundingSigned_clone(msg);
	CHECK((((uint64_t)msg_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&msg_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	msg_ref = (uint64_t)msg_var.inner;
	if (msg_var.is_owned) {
		msg_ref |= 1;
	}
	jobject obj = (*env)->NewLocalRef(env, j_calls->o);
	CHECK(obj != NULL);
	(*env)->CallVoidMethod(env, obj, j_calls->handle_funding_signed_meth, their_node_id_arr, msg_ref);
	if ((*env)->ExceptionCheck(env)) {
		(*env)->ExceptionDescribe(env);
		(*env)->FatalError(env, "A call to handle_funding_signed in LDKChannelMessageHandler from rust threw an exception.");
	}
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
	}
}
void handle_funding_locked_LDKChannelMessageHandler_jcall(const void* this_arg, LDKPublicKey their_node_id, const LDKFundingLocked * msg) {
	LDKChannelMessageHandler_JCalls *j_calls = (LDKChannelMessageHandler_JCalls*) this_arg;
	JNIEnv *env;
	jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
	} else {
		DO_ASSERT(get_jenv_res == JNI_OK);
	}
	int8_tArray their_node_id_arr = (*env)->NewByteArray(env, 33);
	(*env)->SetByteArrayRegion(env, their_node_id_arr, 0, 33, their_node_id.compressed_form);
	LDKFundingLocked msg_var = *msg;
	uint64_t msg_ref = 0;
	msg_var = FundingLocked_clone(msg);
	CHECK((((uint64_t)msg_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&msg_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	msg_ref = (uint64_t)msg_var.inner;
	if (msg_var.is_owned) {
		msg_ref |= 1;
	}
	jobject obj = (*env)->NewLocalRef(env, j_calls->o);
	CHECK(obj != NULL);
	(*env)->CallVoidMethod(env, obj, j_calls->handle_funding_locked_meth, their_node_id_arr, msg_ref);
	if ((*env)->ExceptionCheck(env)) {
		(*env)->ExceptionDescribe(env);
		(*env)->FatalError(env, "A call to handle_funding_locked in LDKChannelMessageHandler from rust threw an exception.");
	}
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
	}
}
void handle_shutdown_LDKChannelMessageHandler_jcall(const void* this_arg, LDKPublicKey their_node_id, const LDKInitFeatures * their_features, const LDKShutdown * msg) {
	LDKChannelMessageHandler_JCalls *j_calls = (LDKChannelMessageHandler_JCalls*) this_arg;
	JNIEnv *env;
	jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
	} else {
		DO_ASSERT(get_jenv_res == JNI_OK);
	}
	int8_tArray their_node_id_arr = (*env)->NewByteArray(env, 33);
	(*env)->SetByteArrayRegion(env, their_node_id_arr, 0, 33, their_node_id.compressed_form);
	LDKInitFeatures their_features_var = *their_features;
	uint64_t their_features_ref = 0;
	their_features_var = InitFeatures_clone(their_features);
	CHECK((((uint64_t)their_features_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&their_features_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	their_features_ref = (uint64_t)their_features_var.inner;
	if (their_features_var.is_owned) {
		their_features_ref |= 1;
	}
	LDKShutdown msg_var = *msg;
	uint64_t msg_ref = 0;
	msg_var = Shutdown_clone(msg);
	CHECK((((uint64_t)msg_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&msg_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	msg_ref = (uint64_t)msg_var.inner;
	if (msg_var.is_owned) {
		msg_ref |= 1;
	}
	jobject obj = (*env)->NewLocalRef(env, j_calls->o);
	CHECK(obj != NULL);
	(*env)->CallVoidMethod(env, obj, j_calls->handle_shutdown_meth, their_node_id_arr, their_features_ref, msg_ref);
	if ((*env)->ExceptionCheck(env)) {
		(*env)->ExceptionDescribe(env);
		(*env)->FatalError(env, "A call to handle_shutdown in LDKChannelMessageHandler from rust threw an exception.");
	}
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
	}
}
void handle_closing_signed_LDKChannelMessageHandler_jcall(const void* this_arg, LDKPublicKey their_node_id, const LDKClosingSigned * msg) {
	LDKChannelMessageHandler_JCalls *j_calls = (LDKChannelMessageHandler_JCalls*) this_arg;
	JNIEnv *env;
	jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
	} else {
		DO_ASSERT(get_jenv_res == JNI_OK);
	}
	int8_tArray their_node_id_arr = (*env)->NewByteArray(env, 33);
	(*env)->SetByteArrayRegion(env, their_node_id_arr, 0, 33, their_node_id.compressed_form);
	LDKClosingSigned msg_var = *msg;
	uint64_t msg_ref = 0;
	msg_var = ClosingSigned_clone(msg);
	CHECK((((uint64_t)msg_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&msg_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	msg_ref = (uint64_t)msg_var.inner;
	if (msg_var.is_owned) {
		msg_ref |= 1;
	}
	jobject obj = (*env)->NewLocalRef(env, j_calls->o);
	CHECK(obj != NULL);
	(*env)->CallVoidMethod(env, obj, j_calls->handle_closing_signed_meth, their_node_id_arr, msg_ref);
	if ((*env)->ExceptionCheck(env)) {
		(*env)->ExceptionDescribe(env);
		(*env)->FatalError(env, "A call to handle_closing_signed in LDKChannelMessageHandler from rust threw an exception.");
	}
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
	}
}
void handle_update_add_htlc_LDKChannelMessageHandler_jcall(const void* this_arg, LDKPublicKey their_node_id, const LDKUpdateAddHTLC * msg) {
	LDKChannelMessageHandler_JCalls *j_calls = (LDKChannelMessageHandler_JCalls*) this_arg;
	JNIEnv *env;
	jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
	} else {
		DO_ASSERT(get_jenv_res == JNI_OK);
	}
	int8_tArray their_node_id_arr = (*env)->NewByteArray(env, 33);
	(*env)->SetByteArrayRegion(env, their_node_id_arr, 0, 33, their_node_id.compressed_form);
	LDKUpdateAddHTLC msg_var = *msg;
	uint64_t msg_ref = 0;
	msg_var = UpdateAddHTLC_clone(msg);
	CHECK((((uint64_t)msg_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&msg_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	msg_ref = (uint64_t)msg_var.inner;
	if (msg_var.is_owned) {
		msg_ref |= 1;
	}
	jobject obj = (*env)->NewLocalRef(env, j_calls->o);
	CHECK(obj != NULL);
	(*env)->CallVoidMethod(env, obj, j_calls->handle_update_add_htlc_meth, their_node_id_arr, msg_ref);
	if ((*env)->ExceptionCheck(env)) {
		(*env)->ExceptionDescribe(env);
		(*env)->FatalError(env, "A call to handle_update_add_htlc in LDKChannelMessageHandler from rust threw an exception.");
	}
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
	}
}
void handle_update_fulfill_htlc_LDKChannelMessageHandler_jcall(const void* this_arg, LDKPublicKey their_node_id, const LDKUpdateFulfillHTLC * msg) {
	LDKChannelMessageHandler_JCalls *j_calls = (LDKChannelMessageHandler_JCalls*) this_arg;
	JNIEnv *env;
	jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
	} else {
		DO_ASSERT(get_jenv_res == JNI_OK);
	}
	int8_tArray their_node_id_arr = (*env)->NewByteArray(env, 33);
	(*env)->SetByteArrayRegion(env, their_node_id_arr, 0, 33, their_node_id.compressed_form);
	LDKUpdateFulfillHTLC msg_var = *msg;
	uint64_t msg_ref = 0;
	msg_var = UpdateFulfillHTLC_clone(msg);
	CHECK((((uint64_t)msg_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&msg_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	msg_ref = (uint64_t)msg_var.inner;
	if (msg_var.is_owned) {
		msg_ref |= 1;
	}
	jobject obj = (*env)->NewLocalRef(env, j_calls->o);
	CHECK(obj != NULL);
	(*env)->CallVoidMethod(env, obj, j_calls->handle_update_fulfill_htlc_meth, their_node_id_arr, msg_ref);
	if ((*env)->ExceptionCheck(env)) {
		(*env)->ExceptionDescribe(env);
		(*env)->FatalError(env, "A call to handle_update_fulfill_htlc in LDKChannelMessageHandler from rust threw an exception.");
	}
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
	}
}
void handle_update_fail_htlc_LDKChannelMessageHandler_jcall(const void* this_arg, LDKPublicKey their_node_id, const LDKUpdateFailHTLC * msg) {
	LDKChannelMessageHandler_JCalls *j_calls = (LDKChannelMessageHandler_JCalls*) this_arg;
	JNIEnv *env;
	jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
	} else {
		DO_ASSERT(get_jenv_res == JNI_OK);
	}
	int8_tArray their_node_id_arr = (*env)->NewByteArray(env, 33);
	(*env)->SetByteArrayRegion(env, their_node_id_arr, 0, 33, their_node_id.compressed_form);
	LDKUpdateFailHTLC msg_var = *msg;
	uint64_t msg_ref = 0;
	msg_var = UpdateFailHTLC_clone(msg);
	CHECK((((uint64_t)msg_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&msg_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	msg_ref = (uint64_t)msg_var.inner;
	if (msg_var.is_owned) {
		msg_ref |= 1;
	}
	jobject obj = (*env)->NewLocalRef(env, j_calls->o);
	CHECK(obj != NULL);
	(*env)->CallVoidMethod(env, obj, j_calls->handle_update_fail_htlc_meth, their_node_id_arr, msg_ref);
	if ((*env)->ExceptionCheck(env)) {
		(*env)->ExceptionDescribe(env);
		(*env)->FatalError(env, "A call to handle_update_fail_htlc in LDKChannelMessageHandler from rust threw an exception.");
	}
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
	}
}
void handle_update_fail_malformed_htlc_LDKChannelMessageHandler_jcall(const void* this_arg, LDKPublicKey their_node_id, const LDKUpdateFailMalformedHTLC * msg) {
	LDKChannelMessageHandler_JCalls *j_calls = (LDKChannelMessageHandler_JCalls*) this_arg;
	JNIEnv *env;
	jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
	} else {
		DO_ASSERT(get_jenv_res == JNI_OK);
	}
	int8_tArray their_node_id_arr = (*env)->NewByteArray(env, 33);
	(*env)->SetByteArrayRegion(env, their_node_id_arr, 0, 33, their_node_id.compressed_form);
	LDKUpdateFailMalformedHTLC msg_var = *msg;
	uint64_t msg_ref = 0;
	msg_var = UpdateFailMalformedHTLC_clone(msg);
	CHECK((((uint64_t)msg_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&msg_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	msg_ref = (uint64_t)msg_var.inner;
	if (msg_var.is_owned) {
		msg_ref |= 1;
	}
	jobject obj = (*env)->NewLocalRef(env, j_calls->o);
	CHECK(obj != NULL);
	(*env)->CallVoidMethod(env, obj, j_calls->handle_update_fail_malformed_htlc_meth, their_node_id_arr, msg_ref);
	if ((*env)->ExceptionCheck(env)) {
		(*env)->ExceptionDescribe(env);
		(*env)->FatalError(env, "A call to handle_update_fail_malformed_htlc in LDKChannelMessageHandler from rust threw an exception.");
	}
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
	}
}
void handle_commitment_signed_LDKChannelMessageHandler_jcall(const void* this_arg, LDKPublicKey their_node_id, const LDKCommitmentSigned * msg) {
	LDKChannelMessageHandler_JCalls *j_calls = (LDKChannelMessageHandler_JCalls*) this_arg;
	JNIEnv *env;
	jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
	} else {
		DO_ASSERT(get_jenv_res == JNI_OK);
	}
	int8_tArray their_node_id_arr = (*env)->NewByteArray(env, 33);
	(*env)->SetByteArrayRegion(env, their_node_id_arr, 0, 33, their_node_id.compressed_form);
	LDKCommitmentSigned msg_var = *msg;
	uint64_t msg_ref = 0;
	msg_var = CommitmentSigned_clone(msg);
	CHECK((((uint64_t)msg_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&msg_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	msg_ref = (uint64_t)msg_var.inner;
	if (msg_var.is_owned) {
		msg_ref |= 1;
	}
	jobject obj = (*env)->NewLocalRef(env, j_calls->o);
	CHECK(obj != NULL);
	(*env)->CallVoidMethod(env, obj, j_calls->handle_commitment_signed_meth, their_node_id_arr, msg_ref);
	if ((*env)->ExceptionCheck(env)) {
		(*env)->ExceptionDescribe(env);
		(*env)->FatalError(env, "A call to handle_commitment_signed in LDKChannelMessageHandler from rust threw an exception.");
	}
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
	}
}
void handle_revoke_and_ack_LDKChannelMessageHandler_jcall(const void* this_arg, LDKPublicKey their_node_id, const LDKRevokeAndACK * msg) {
	LDKChannelMessageHandler_JCalls *j_calls = (LDKChannelMessageHandler_JCalls*) this_arg;
	JNIEnv *env;
	jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
	} else {
		DO_ASSERT(get_jenv_res == JNI_OK);
	}
	int8_tArray their_node_id_arr = (*env)->NewByteArray(env, 33);
	(*env)->SetByteArrayRegion(env, their_node_id_arr, 0, 33, their_node_id.compressed_form);
	LDKRevokeAndACK msg_var = *msg;
	uint64_t msg_ref = 0;
	msg_var = RevokeAndACK_clone(msg);
	CHECK((((uint64_t)msg_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&msg_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	msg_ref = (uint64_t)msg_var.inner;
	if (msg_var.is_owned) {
		msg_ref |= 1;
	}
	jobject obj = (*env)->NewLocalRef(env, j_calls->o);
	CHECK(obj != NULL);
	(*env)->CallVoidMethod(env, obj, j_calls->handle_revoke_and_ack_meth, their_node_id_arr, msg_ref);
	if ((*env)->ExceptionCheck(env)) {
		(*env)->ExceptionDescribe(env);
		(*env)->FatalError(env, "A call to handle_revoke_and_ack in LDKChannelMessageHandler from rust threw an exception.");
	}
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
	}
}
void handle_update_fee_LDKChannelMessageHandler_jcall(const void* this_arg, LDKPublicKey their_node_id, const LDKUpdateFee * msg) {
	LDKChannelMessageHandler_JCalls *j_calls = (LDKChannelMessageHandler_JCalls*) this_arg;
	JNIEnv *env;
	jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
	} else {
		DO_ASSERT(get_jenv_res == JNI_OK);
	}
	int8_tArray their_node_id_arr = (*env)->NewByteArray(env, 33);
	(*env)->SetByteArrayRegion(env, their_node_id_arr, 0, 33, their_node_id.compressed_form);
	LDKUpdateFee msg_var = *msg;
	uint64_t msg_ref = 0;
	msg_var = UpdateFee_clone(msg);
	CHECK((((uint64_t)msg_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&msg_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	msg_ref = (uint64_t)msg_var.inner;
	if (msg_var.is_owned) {
		msg_ref |= 1;
	}
	jobject obj = (*env)->NewLocalRef(env, j_calls->o);
	CHECK(obj != NULL);
	(*env)->CallVoidMethod(env, obj, j_calls->handle_update_fee_meth, their_node_id_arr, msg_ref);
	if ((*env)->ExceptionCheck(env)) {
		(*env)->ExceptionDescribe(env);
		(*env)->FatalError(env, "A call to handle_update_fee in LDKChannelMessageHandler from rust threw an exception.");
	}
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
	}
}
void handle_announcement_signatures_LDKChannelMessageHandler_jcall(const void* this_arg, LDKPublicKey their_node_id, const LDKAnnouncementSignatures * msg) {
	LDKChannelMessageHandler_JCalls *j_calls = (LDKChannelMessageHandler_JCalls*) this_arg;
	JNIEnv *env;
	jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
	} else {
		DO_ASSERT(get_jenv_res == JNI_OK);
	}
	int8_tArray their_node_id_arr = (*env)->NewByteArray(env, 33);
	(*env)->SetByteArrayRegion(env, their_node_id_arr, 0, 33, their_node_id.compressed_form);
	LDKAnnouncementSignatures msg_var = *msg;
	uint64_t msg_ref = 0;
	msg_var = AnnouncementSignatures_clone(msg);
	CHECK((((uint64_t)msg_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&msg_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	msg_ref = (uint64_t)msg_var.inner;
	if (msg_var.is_owned) {
		msg_ref |= 1;
	}
	jobject obj = (*env)->NewLocalRef(env, j_calls->o);
	CHECK(obj != NULL);
	(*env)->CallVoidMethod(env, obj, j_calls->handle_announcement_signatures_meth, their_node_id_arr, msg_ref);
	if ((*env)->ExceptionCheck(env)) {
		(*env)->ExceptionDescribe(env);
		(*env)->FatalError(env, "A call to handle_announcement_signatures in LDKChannelMessageHandler from rust threw an exception.");
	}
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
	}
}
void peer_disconnected_LDKChannelMessageHandler_jcall(const void* this_arg, LDKPublicKey their_node_id, bool no_connection_possible) {
	LDKChannelMessageHandler_JCalls *j_calls = (LDKChannelMessageHandler_JCalls*) this_arg;
	JNIEnv *env;
	jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
	} else {
		DO_ASSERT(get_jenv_res == JNI_OK);
	}
	int8_tArray their_node_id_arr = (*env)->NewByteArray(env, 33);
	(*env)->SetByteArrayRegion(env, their_node_id_arr, 0, 33, their_node_id.compressed_form);
	jobject obj = (*env)->NewLocalRef(env, j_calls->o);
	CHECK(obj != NULL);
	(*env)->CallVoidMethod(env, obj, j_calls->peer_disconnected_meth, their_node_id_arr, no_connection_possible);
	if ((*env)->ExceptionCheck(env)) {
		(*env)->ExceptionDescribe(env);
		(*env)->FatalError(env, "A call to peer_disconnected in LDKChannelMessageHandler from rust threw an exception.");
	}
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
	}
}
void peer_connected_LDKChannelMessageHandler_jcall(const void* this_arg, LDKPublicKey their_node_id, const LDKInit * msg) {
	LDKChannelMessageHandler_JCalls *j_calls = (LDKChannelMessageHandler_JCalls*) this_arg;
	JNIEnv *env;
	jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
	} else {
		DO_ASSERT(get_jenv_res == JNI_OK);
	}
	int8_tArray their_node_id_arr = (*env)->NewByteArray(env, 33);
	(*env)->SetByteArrayRegion(env, their_node_id_arr, 0, 33, their_node_id.compressed_form);
	LDKInit msg_var = *msg;
	uint64_t msg_ref = 0;
	msg_var = Init_clone(msg);
	CHECK((((uint64_t)msg_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&msg_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	msg_ref = (uint64_t)msg_var.inner;
	if (msg_var.is_owned) {
		msg_ref |= 1;
	}
	jobject obj = (*env)->NewLocalRef(env, j_calls->o);
	CHECK(obj != NULL);
	(*env)->CallVoidMethod(env, obj, j_calls->peer_connected_meth, their_node_id_arr, msg_ref);
	if ((*env)->ExceptionCheck(env)) {
		(*env)->ExceptionDescribe(env);
		(*env)->FatalError(env, "A call to peer_connected in LDKChannelMessageHandler from rust threw an exception.");
	}
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
	}
}
void handle_channel_reestablish_LDKChannelMessageHandler_jcall(const void* this_arg, LDKPublicKey their_node_id, const LDKChannelReestablish * msg) {
	LDKChannelMessageHandler_JCalls *j_calls = (LDKChannelMessageHandler_JCalls*) this_arg;
	JNIEnv *env;
	jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
	} else {
		DO_ASSERT(get_jenv_res == JNI_OK);
	}
	int8_tArray their_node_id_arr = (*env)->NewByteArray(env, 33);
	(*env)->SetByteArrayRegion(env, their_node_id_arr, 0, 33, their_node_id.compressed_form);
	LDKChannelReestablish msg_var = *msg;
	uint64_t msg_ref = 0;
	msg_var = ChannelReestablish_clone(msg);
	CHECK((((uint64_t)msg_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&msg_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	msg_ref = (uint64_t)msg_var.inner;
	if (msg_var.is_owned) {
		msg_ref |= 1;
	}
	jobject obj = (*env)->NewLocalRef(env, j_calls->o);
	CHECK(obj != NULL);
	(*env)->CallVoidMethod(env, obj, j_calls->handle_channel_reestablish_meth, their_node_id_arr, msg_ref);
	if ((*env)->ExceptionCheck(env)) {
		(*env)->ExceptionDescribe(env);
		(*env)->FatalError(env, "A call to handle_channel_reestablish in LDKChannelMessageHandler from rust threw an exception.");
	}
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
	}
}
void handle_channel_update_LDKChannelMessageHandler_jcall(const void* this_arg, LDKPublicKey their_node_id, const LDKChannelUpdate * msg) {
	LDKChannelMessageHandler_JCalls *j_calls = (LDKChannelMessageHandler_JCalls*) this_arg;
	JNIEnv *env;
	jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
	} else {
		DO_ASSERT(get_jenv_res == JNI_OK);
	}
	int8_tArray their_node_id_arr = (*env)->NewByteArray(env, 33);
	(*env)->SetByteArrayRegion(env, their_node_id_arr, 0, 33, their_node_id.compressed_form);
	LDKChannelUpdate msg_var = *msg;
	uint64_t msg_ref = 0;
	msg_var = ChannelUpdate_clone(msg);
	CHECK((((uint64_t)msg_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&msg_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	msg_ref = (uint64_t)msg_var.inner;
	if (msg_var.is_owned) {
		msg_ref |= 1;
	}
	jobject obj = (*env)->NewLocalRef(env, j_calls->o);
	CHECK(obj != NULL);
	(*env)->CallVoidMethod(env, obj, j_calls->handle_channel_update_meth, their_node_id_arr, msg_ref);
	if ((*env)->ExceptionCheck(env)) {
		(*env)->ExceptionDescribe(env);
		(*env)->FatalError(env, "A call to handle_channel_update in LDKChannelMessageHandler from rust threw an exception.");
	}
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
	}
}
void handle_error_LDKChannelMessageHandler_jcall(const void* this_arg, LDKPublicKey their_node_id, const LDKErrorMessage * msg) {
	LDKChannelMessageHandler_JCalls *j_calls = (LDKChannelMessageHandler_JCalls*) this_arg;
	JNIEnv *env;
	jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
	} else {
		DO_ASSERT(get_jenv_res == JNI_OK);
	}
	int8_tArray their_node_id_arr = (*env)->NewByteArray(env, 33);
	(*env)->SetByteArrayRegion(env, their_node_id_arr, 0, 33, their_node_id.compressed_form);
	LDKErrorMessage msg_var = *msg;
	uint64_t msg_ref = 0;
	msg_var = ErrorMessage_clone(msg);
	CHECK((((uint64_t)msg_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&msg_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	msg_ref = (uint64_t)msg_var.inner;
	if (msg_var.is_owned) {
		msg_ref |= 1;
	}
	jobject obj = (*env)->NewLocalRef(env, j_calls->o);
	CHECK(obj != NULL);
	(*env)->CallVoidMethod(env, obj, j_calls->handle_error_meth, their_node_id_arr, msg_ref);
	if ((*env)->ExceptionCheck(env)) {
		(*env)->ExceptionDescribe(env);
		(*env)->FatalError(env, "A call to handle_error in LDKChannelMessageHandler from rust threw an exception.");
	}
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
	}
}
static void LDKChannelMessageHandler_JCalls_cloned(LDKChannelMessageHandler* new_obj) {
	LDKChannelMessageHandler_JCalls *j_calls = (LDKChannelMessageHandler_JCalls*) new_obj->this_arg;
	atomic_fetch_add_explicit(&j_calls->refcnt, 1, memory_order_release);
	atomic_fetch_add_explicit(&j_calls->MessageSendEventsProvider->refcnt, 1, memory_order_release);
}
static inline LDKChannelMessageHandler LDKChannelMessageHandler_init (JNIEnv *env, jclass clz, jobject o, jobject MessageSendEventsProvider) {
	jclass c = (*env)->GetObjectClass(env, o);
	CHECK(c != NULL);
	LDKChannelMessageHandler_JCalls *calls = MALLOC(sizeof(LDKChannelMessageHandler_JCalls), "LDKChannelMessageHandler_JCalls");
	atomic_init(&calls->refcnt, 1);
	DO_ASSERT((*env)->GetJavaVM(env, &calls->vm) == 0);
	calls->o = (*env)->NewWeakGlobalRef(env, o);
	calls->handle_open_channel_meth = (*env)->GetMethodID(env, c, "handle_open_channel", "([BJJ)V");
	CHECK(calls->handle_open_channel_meth != NULL);
	calls->handle_accept_channel_meth = (*env)->GetMethodID(env, c, "handle_accept_channel", "([BJJ)V");
	CHECK(calls->handle_accept_channel_meth != NULL);
	calls->handle_funding_created_meth = (*env)->GetMethodID(env, c, "handle_funding_created", "([BJ)V");
	CHECK(calls->handle_funding_created_meth != NULL);
	calls->handle_funding_signed_meth = (*env)->GetMethodID(env, c, "handle_funding_signed", "([BJ)V");
	CHECK(calls->handle_funding_signed_meth != NULL);
	calls->handle_funding_locked_meth = (*env)->GetMethodID(env, c, "handle_funding_locked", "([BJ)V");
	CHECK(calls->handle_funding_locked_meth != NULL);
	calls->handle_shutdown_meth = (*env)->GetMethodID(env, c, "handle_shutdown", "([BJJ)V");
	CHECK(calls->handle_shutdown_meth != NULL);
	calls->handle_closing_signed_meth = (*env)->GetMethodID(env, c, "handle_closing_signed", "([BJ)V");
	CHECK(calls->handle_closing_signed_meth != NULL);
	calls->handle_update_add_htlc_meth = (*env)->GetMethodID(env, c, "handle_update_add_htlc", "([BJ)V");
	CHECK(calls->handle_update_add_htlc_meth != NULL);
	calls->handle_update_fulfill_htlc_meth = (*env)->GetMethodID(env, c, "handle_update_fulfill_htlc", "([BJ)V");
	CHECK(calls->handle_update_fulfill_htlc_meth != NULL);
	calls->handle_update_fail_htlc_meth = (*env)->GetMethodID(env, c, "handle_update_fail_htlc", "([BJ)V");
	CHECK(calls->handle_update_fail_htlc_meth != NULL);
	calls->handle_update_fail_malformed_htlc_meth = (*env)->GetMethodID(env, c, "handle_update_fail_malformed_htlc", "([BJ)V");
	CHECK(calls->handle_update_fail_malformed_htlc_meth != NULL);
	calls->handle_commitment_signed_meth = (*env)->GetMethodID(env, c, "handle_commitment_signed", "([BJ)V");
	CHECK(calls->handle_commitment_signed_meth != NULL);
	calls->handle_revoke_and_ack_meth = (*env)->GetMethodID(env, c, "handle_revoke_and_ack", "([BJ)V");
	CHECK(calls->handle_revoke_and_ack_meth != NULL);
	calls->handle_update_fee_meth = (*env)->GetMethodID(env, c, "handle_update_fee", "([BJ)V");
	CHECK(calls->handle_update_fee_meth != NULL);
	calls->handle_announcement_signatures_meth = (*env)->GetMethodID(env, c, "handle_announcement_signatures", "([BJ)V");
	CHECK(calls->handle_announcement_signatures_meth != NULL);
	calls->peer_disconnected_meth = (*env)->GetMethodID(env, c, "peer_disconnected", "([BZ)V");
	CHECK(calls->peer_disconnected_meth != NULL);
	calls->peer_connected_meth = (*env)->GetMethodID(env, c, "peer_connected", "([BJ)V");
	CHECK(calls->peer_connected_meth != NULL);
	calls->handle_channel_reestablish_meth = (*env)->GetMethodID(env, c, "handle_channel_reestablish", "([BJ)V");
	CHECK(calls->handle_channel_reestablish_meth != NULL);
	calls->handle_channel_update_meth = (*env)->GetMethodID(env, c, "handle_channel_update", "([BJ)V");
	CHECK(calls->handle_channel_update_meth != NULL);
	calls->handle_error_meth = (*env)->GetMethodID(env, c, "handle_error", "([BJ)V");
	CHECK(calls->handle_error_meth != NULL);

	LDKChannelMessageHandler ret = {
		.this_arg = (void*) calls,
		.handle_open_channel = handle_open_channel_LDKChannelMessageHandler_jcall,
		.handle_accept_channel = handle_accept_channel_LDKChannelMessageHandler_jcall,
		.handle_funding_created = handle_funding_created_LDKChannelMessageHandler_jcall,
		.handle_funding_signed = handle_funding_signed_LDKChannelMessageHandler_jcall,
		.handle_funding_locked = handle_funding_locked_LDKChannelMessageHandler_jcall,
		.handle_shutdown = handle_shutdown_LDKChannelMessageHandler_jcall,
		.handle_closing_signed = handle_closing_signed_LDKChannelMessageHandler_jcall,
		.handle_update_add_htlc = handle_update_add_htlc_LDKChannelMessageHandler_jcall,
		.handle_update_fulfill_htlc = handle_update_fulfill_htlc_LDKChannelMessageHandler_jcall,
		.handle_update_fail_htlc = handle_update_fail_htlc_LDKChannelMessageHandler_jcall,
		.handle_update_fail_malformed_htlc = handle_update_fail_malformed_htlc_LDKChannelMessageHandler_jcall,
		.handle_commitment_signed = handle_commitment_signed_LDKChannelMessageHandler_jcall,
		.handle_revoke_and_ack = handle_revoke_and_ack_LDKChannelMessageHandler_jcall,
		.handle_update_fee = handle_update_fee_LDKChannelMessageHandler_jcall,
		.handle_announcement_signatures = handle_announcement_signatures_LDKChannelMessageHandler_jcall,
		.peer_disconnected = peer_disconnected_LDKChannelMessageHandler_jcall,
		.peer_connected = peer_connected_LDKChannelMessageHandler_jcall,
		.handle_channel_reestablish = handle_channel_reestablish_LDKChannelMessageHandler_jcall,
		.handle_channel_update = handle_channel_update_LDKChannelMessageHandler_jcall,
		.handle_error = handle_error_LDKChannelMessageHandler_jcall,
		.free = LDKChannelMessageHandler_JCalls_free,
		.MessageSendEventsProvider = LDKMessageSendEventsProvider_init(env, clz, MessageSendEventsProvider),
	};
	calls->MessageSendEventsProvider = ret.MessageSendEventsProvider.this_arg;
	return ret;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKChannelMessageHandler_1new(JNIEnv *env, jclass clz, jobject o, jobject MessageSendEventsProvider) {
	LDKChannelMessageHandler *res_ptr = MALLOC(sizeof(LDKChannelMessageHandler), "LDKChannelMessageHandler");
	*res_ptr = LDKChannelMessageHandler_init(env, clz, o, MessageSendEventsProvider);
	return (uint64_t)res_ptr;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKChannelMessageHandler_1get_1MessageSendEventsProvider(JNIEnv *env, jclass clz, int64_t arg) {
	LDKChannelMessageHandler *inp = (LDKChannelMessageHandler *)(arg & ~1);
	uint64_t res_ptr = (uint64_t)&inp->MessageSendEventsProvider;
	DO_ASSERT((res_ptr & 1) == 0);
	return (int64_t)(res_ptr | 1);
}
JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelMessageHandler_1handle_1open_1channel(JNIEnv *env, jclass clz, int64_t this_arg, int8_tArray their_node_id, int64_t their_features, int64_t msg) {
	void* this_arg_ptr = (void*)(((uint64_t)this_arg) & ~1);
	if (!(this_arg & 1)) { CHECK_ACCESS(this_arg_ptr); }
	LDKChannelMessageHandler* this_arg_conv = (LDKChannelMessageHandler*)this_arg_ptr;
	LDKPublicKey their_node_id_ref;
	CHECK((*env)->GetArrayLength(env, their_node_id) == 33);
	(*env)->GetByteArrayRegion(env, their_node_id, 0, 33, their_node_id_ref.compressed_form);
	LDKInitFeatures their_features_conv;
	their_features_conv.inner = (void*)(their_features & (~1));
	their_features_conv.is_owned = (their_features & 1) || (their_features == 0);
	their_features_conv = InitFeatures_clone(&their_features_conv);
	LDKOpenChannel msg_conv;
	msg_conv.inner = (void*)(msg & (~1));
	msg_conv.is_owned = false;
	(this_arg_conv->handle_open_channel)(this_arg_conv->this_arg, their_node_id_ref, their_features_conv, &msg_conv);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelMessageHandler_1handle_1accept_1channel(JNIEnv *env, jclass clz, int64_t this_arg, int8_tArray their_node_id, int64_t their_features, int64_t msg) {
	void* this_arg_ptr = (void*)(((uint64_t)this_arg) & ~1);
	if (!(this_arg & 1)) { CHECK_ACCESS(this_arg_ptr); }
	LDKChannelMessageHandler* this_arg_conv = (LDKChannelMessageHandler*)this_arg_ptr;
	LDKPublicKey their_node_id_ref;
	CHECK((*env)->GetArrayLength(env, their_node_id) == 33);
	(*env)->GetByteArrayRegion(env, their_node_id, 0, 33, their_node_id_ref.compressed_form);
	LDKInitFeatures their_features_conv;
	their_features_conv.inner = (void*)(their_features & (~1));
	their_features_conv.is_owned = (their_features & 1) || (their_features == 0);
	their_features_conv = InitFeatures_clone(&their_features_conv);
	LDKAcceptChannel msg_conv;
	msg_conv.inner = (void*)(msg & (~1));
	msg_conv.is_owned = false;
	(this_arg_conv->handle_accept_channel)(this_arg_conv->this_arg, their_node_id_ref, their_features_conv, &msg_conv);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelMessageHandler_1handle_1funding_1created(JNIEnv *env, jclass clz, int64_t this_arg, int8_tArray their_node_id, int64_t msg) {
	void* this_arg_ptr = (void*)(((uint64_t)this_arg) & ~1);
	if (!(this_arg & 1)) { CHECK_ACCESS(this_arg_ptr); }
	LDKChannelMessageHandler* this_arg_conv = (LDKChannelMessageHandler*)this_arg_ptr;
	LDKPublicKey their_node_id_ref;
	CHECK((*env)->GetArrayLength(env, their_node_id) == 33);
	(*env)->GetByteArrayRegion(env, their_node_id, 0, 33, their_node_id_ref.compressed_form);
	LDKFundingCreated msg_conv;
	msg_conv.inner = (void*)(msg & (~1));
	msg_conv.is_owned = false;
	(this_arg_conv->handle_funding_created)(this_arg_conv->this_arg, their_node_id_ref, &msg_conv);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelMessageHandler_1handle_1funding_1signed(JNIEnv *env, jclass clz, int64_t this_arg, int8_tArray their_node_id, int64_t msg) {
	void* this_arg_ptr = (void*)(((uint64_t)this_arg) & ~1);
	if (!(this_arg & 1)) { CHECK_ACCESS(this_arg_ptr); }
	LDKChannelMessageHandler* this_arg_conv = (LDKChannelMessageHandler*)this_arg_ptr;
	LDKPublicKey their_node_id_ref;
	CHECK((*env)->GetArrayLength(env, their_node_id) == 33);
	(*env)->GetByteArrayRegion(env, their_node_id, 0, 33, their_node_id_ref.compressed_form);
	LDKFundingSigned msg_conv;
	msg_conv.inner = (void*)(msg & (~1));
	msg_conv.is_owned = false;
	(this_arg_conv->handle_funding_signed)(this_arg_conv->this_arg, their_node_id_ref, &msg_conv);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelMessageHandler_1handle_1funding_1locked(JNIEnv *env, jclass clz, int64_t this_arg, int8_tArray their_node_id, int64_t msg) {
	void* this_arg_ptr = (void*)(((uint64_t)this_arg) & ~1);
	if (!(this_arg & 1)) { CHECK_ACCESS(this_arg_ptr); }
	LDKChannelMessageHandler* this_arg_conv = (LDKChannelMessageHandler*)this_arg_ptr;
	LDKPublicKey their_node_id_ref;
	CHECK((*env)->GetArrayLength(env, their_node_id) == 33);
	(*env)->GetByteArrayRegion(env, their_node_id, 0, 33, their_node_id_ref.compressed_form);
	LDKFundingLocked msg_conv;
	msg_conv.inner = (void*)(msg & (~1));
	msg_conv.is_owned = false;
	(this_arg_conv->handle_funding_locked)(this_arg_conv->this_arg, their_node_id_ref, &msg_conv);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelMessageHandler_1handle_1shutdown(JNIEnv *env, jclass clz, int64_t this_arg, int8_tArray their_node_id, int64_t their_features, int64_t msg) {
	void* this_arg_ptr = (void*)(((uint64_t)this_arg) & ~1);
	if (!(this_arg & 1)) { CHECK_ACCESS(this_arg_ptr); }
	LDKChannelMessageHandler* this_arg_conv = (LDKChannelMessageHandler*)this_arg_ptr;
	LDKPublicKey their_node_id_ref;
	CHECK((*env)->GetArrayLength(env, their_node_id) == 33);
	(*env)->GetByteArrayRegion(env, their_node_id, 0, 33, their_node_id_ref.compressed_form);
	LDKInitFeatures their_features_conv;
	their_features_conv.inner = (void*)(their_features & (~1));
	their_features_conv.is_owned = false;
	LDKShutdown msg_conv;
	msg_conv.inner = (void*)(msg & (~1));
	msg_conv.is_owned = false;
	(this_arg_conv->handle_shutdown)(this_arg_conv->this_arg, their_node_id_ref, &their_features_conv, &msg_conv);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelMessageHandler_1handle_1closing_1signed(JNIEnv *env, jclass clz, int64_t this_arg, int8_tArray their_node_id, int64_t msg) {
	void* this_arg_ptr = (void*)(((uint64_t)this_arg) & ~1);
	if (!(this_arg & 1)) { CHECK_ACCESS(this_arg_ptr); }
	LDKChannelMessageHandler* this_arg_conv = (LDKChannelMessageHandler*)this_arg_ptr;
	LDKPublicKey their_node_id_ref;
	CHECK((*env)->GetArrayLength(env, their_node_id) == 33);
	(*env)->GetByteArrayRegion(env, their_node_id, 0, 33, their_node_id_ref.compressed_form);
	LDKClosingSigned msg_conv;
	msg_conv.inner = (void*)(msg & (~1));
	msg_conv.is_owned = false;
	(this_arg_conv->handle_closing_signed)(this_arg_conv->this_arg, their_node_id_ref, &msg_conv);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelMessageHandler_1handle_1update_1add_1htlc(JNIEnv *env, jclass clz, int64_t this_arg, int8_tArray their_node_id, int64_t msg) {
	void* this_arg_ptr = (void*)(((uint64_t)this_arg) & ~1);
	if (!(this_arg & 1)) { CHECK_ACCESS(this_arg_ptr); }
	LDKChannelMessageHandler* this_arg_conv = (LDKChannelMessageHandler*)this_arg_ptr;
	LDKPublicKey their_node_id_ref;
	CHECK((*env)->GetArrayLength(env, their_node_id) == 33);
	(*env)->GetByteArrayRegion(env, their_node_id, 0, 33, their_node_id_ref.compressed_form);
	LDKUpdateAddHTLC msg_conv;
	msg_conv.inner = (void*)(msg & (~1));
	msg_conv.is_owned = false;
	(this_arg_conv->handle_update_add_htlc)(this_arg_conv->this_arg, their_node_id_ref, &msg_conv);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelMessageHandler_1handle_1update_1fulfill_1htlc(JNIEnv *env, jclass clz, int64_t this_arg, int8_tArray their_node_id, int64_t msg) {
	void* this_arg_ptr = (void*)(((uint64_t)this_arg) & ~1);
	if (!(this_arg & 1)) { CHECK_ACCESS(this_arg_ptr); }
	LDKChannelMessageHandler* this_arg_conv = (LDKChannelMessageHandler*)this_arg_ptr;
	LDKPublicKey their_node_id_ref;
	CHECK((*env)->GetArrayLength(env, their_node_id) == 33);
	(*env)->GetByteArrayRegion(env, their_node_id, 0, 33, their_node_id_ref.compressed_form);
	LDKUpdateFulfillHTLC msg_conv;
	msg_conv.inner = (void*)(msg & (~1));
	msg_conv.is_owned = false;
	(this_arg_conv->handle_update_fulfill_htlc)(this_arg_conv->this_arg, their_node_id_ref, &msg_conv);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelMessageHandler_1handle_1update_1fail_1htlc(JNIEnv *env, jclass clz, int64_t this_arg, int8_tArray their_node_id, int64_t msg) {
	void* this_arg_ptr = (void*)(((uint64_t)this_arg) & ~1);
	if (!(this_arg & 1)) { CHECK_ACCESS(this_arg_ptr); }
	LDKChannelMessageHandler* this_arg_conv = (LDKChannelMessageHandler*)this_arg_ptr;
	LDKPublicKey their_node_id_ref;
	CHECK((*env)->GetArrayLength(env, their_node_id) == 33);
	(*env)->GetByteArrayRegion(env, their_node_id, 0, 33, their_node_id_ref.compressed_form);
	LDKUpdateFailHTLC msg_conv;
	msg_conv.inner = (void*)(msg & (~1));
	msg_conv.is_owned = false;
	(this_arg_conv->handle_update_fail_htlc)(this_arg_conv->this_arg, their_node_id_ref, &msg_conv);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelMessageHandler_1handle_1update_1fail_1malformed_1htlc(JNIEnv *env, jclass clz, int64_t this_arg, int8_tArray their_node_id, int64_t msg) {
	void* this_arg_ptr = (void*)(((uint64_t)this_arg) & ~1);
	if (!(this_arg & 1)) { CHECK_ACCESS(this_arg_ptr); }
	LDKChannelMessageHandler* this_arg_conv = (LDKChannelMessageHandler*)this_arg_ptr;
	LDKPublicKey their_node_id_ref;
	CHECK((*env)->GetArrayLength(env, their_node_id) == 33);
	(*env)->GetByteArrayRegion(env, their_node_id, 0, 33, their_node_id_ref.compressed_form);
	LDKUpdateFailMalformedHTLC msg_conv;
	msg_conv.inner = (void*)(msg & (~1));
	msg_conv.is_owned = false;
	(this_arg_conv->handle_update_fail_malformed_htlc)(this_arg_conv->this_arg, their_node_id_ref, &msg_conv);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelMessageHandler_1handle_1commitment_1signed(JNIEnv *env, jclass clz, int64_t this_arg, int8_tArray their_node_id, int64_t msg) {
	void* this_arg_ptr = (void*)(((uint64_t)this_arg) & ~1);
	if (!(this_arg & 1)) { CHECK_ACCESS(this_arg_ptr); }
	LDKChannelMessageHandler* this_arg_conv = (LDKChannelMessageHandler*)this_arg_ptr;
	LDKPublicKey their_node_id_ref;
	CHECK((*env)->GetArrayLength(env, their_node_id) == 33);
	(*env)->GetByteArrayRegion(env, their_node_id, 0, 33, their_node_id_ref.compressed_form);
	LDKCommitmentSigned msg_conv;
	msg_conv.inner = (void*)(msg & (~1));
	msg_conv.is_owned = false;
	(this_arg_conv->handle_commitment_signed)(this_arg_conv->this_arg, their_node_id_ref, &msg_conv);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelMessageHandler_1handle_1revoke_1and_1ack(JNIEnv *env, jclass clz, int64_t this_arg, int8_tArray their_node_id, int64_t msg) {
	void* this_arg_ptr = (void*)(((uint64_t)this_arg) & ~1);
	if (!(this_arg & 1)) { CHECK_ACCESS(this_arg_ptr); }
	LDKChannelMessageHandler* this_arg_conv = (LDKChannelMessageHandler*)this_arg_ptr;
	LDKPublicKey their_node_id_ref;
	CHECK((*env)->GetArrayLength(env, their_node_id) == 33);
	(*env)->GetByteArrayRegion(env, their_node_id, 0, 33, their_node_id_ref.compressed_form);
	LDKRevokeAndACK msg_conv;
	msg_conv.inner = (void*)(msg & (~1));
	msg_conv.is_owned = false;
	(this_arg_conv->handle_revoke_and_ack)(this_arg_conv->this_arg, their_node_id_ref, &msg_conv);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelMessageHandler_1handle_1update_1fee(JNIEnv *env, jclass clz, int64_t this_arg, int8_tArray their_node_id, int64_t msg) {
	void* this_arg_ptr = (void*)(((uint64_t)this_arg) & ~1);
	if (!(this_arg & 1)) { CHECK_ACCESS(this_arg_ptr); }
	LDKChannelMessageHandler* this_arg_conv = (LDKChannelMessageHandler*)this_arg_ptr;
	LDKPublicKey their_node_id_ref;
	CHECK((*env)->GetArrayLength(env, their_node_id) == 33);
	(*env)->GetByteArrayRegion(env, their_node_id, 0, 33, their_node_id_ref.compressed_form);
	LDKUpdateFee msg_conv;
	msg_conv.inner = (void*)(msg & (~1));
	msg_conv.is_owned = false;
	(this_arg_conv->handle_update_fee)(this_arg_conv->this_arg, their_node_id_ref, &msg_conv);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelMessageHandler_1handle_1announcement_1signatures(JNIEnv *env, jclass clz, int64_t this_arg, int8_tArray their_node_id, int64_t msg) {
	void* this_arg_ptr = (void*)(((uint64_t)this_arg) & ~1);
	if (!(this_arg & 1)) { CHECK_ACCESS(this_arg_ptr); }
	LDKChannelMessageHandler* this_arg_conv = (LDKChannelMessageHandler*)this_arg_ptr;
	LDKPublicKey their_node_id_ref;
	CHECK((*env)->GetArrayLength(env, their_node_id) == 33);
	(*env)->GetByteArrayRegion(env, their_node_id, 0, 33, their_node_id_ref.compressed_form);
	LDKAnnouncementSignatures msg_conv;
	msg_conv.inner = (void*)(msg & (~1));
	msg_conv.is_owned = false;
	(this_arg_conv->handle_announcement_signatures)(this_arg_conv->this_arg, their_node_id_ref, &msg_conv);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelMessageHandler_1peer_1disconnected(JNIEnv *env, jclass clz, int64_t this_arg, int8_tArray their_node_id, jboolean no_connection_possible) {
	void* this_arg_ptr = (void*)(((uint64_t)this_arg) & ~1);
	if (!(this_arg & 1)) { CHECK_ACCESS(this_arg_ptr); }
	LDKChannelMessageHandler* this_arg_conv = (LDKChannelMessageHandler*)this_arg_ptr;
	LDKPublicKey their_node_id_ref;
	CHECK((*env)->GetArrayLength(env, their_node_id) == 33);
	(*env)->GetByteArrayRegion(env, their_node_id, 0, 33, their_node_id_ref.compressed_form);
	(this_arg_conv->peer_disconnected)(this_arg_conv->this_arg, their_node_id_ref, no_connection_possible);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelMessageHandler_1peer_1connected(JNIEnv *env, jclass clz, int64_t this_arg, int8_tArray their_node_id, int64_t msg) {
	void* this_arg_ptr = (void*)(((uint64_t)this_arg) & ~1);
	if (!(this_arg & 1)) { CHECK_ACCESS(this_arg_ptr); }
	LDKChannelMessageHandler* this_arg_conv = (LDKChannelMessageHandler*)this_arg_ptr;
	LDKPublicKey their_node_id_ref;
	CHECK((*env)->GetArrayLength(env, their_node_id) == 33);
	(*env)->GetByteArrayRegion(env, their_node_id, 0, 33, their_node_id_ref.compressed_form);
	LDKInit msg_conv;
	msg_conv.inner = (void*)(msg & (~1));
	msg_conv.is_owned = false;
	(this_arg_conv->peer_connected)(this_arg_conv->this_arg, their_node_id_ref, &msg_conv);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelMessageHandler_1handle_1channel_1reestablish(JNIEnv *env, jclass clz, int64_t this_arg, int8_tArray their_node_id, int64_t msg) {
	void* this_arg_ptr = (void*)(((uint64_t)this_arg) & ~1);
	if (!(this_arg & 1)) { CHECK_ACCESS(this_arg_ptr); }
	LDKChannelMessageHandler* this_arg_conv = (LDKChannelMessageHandler*)this_arg_ptr;
	LDKPublicKey their_node_id_ref;
	CHECK((*env)->GetArrayLength(env, their_node_id) == 33);
	(*env)->GetByteArrayRegion(env, their_node_id, 0, 33, their_node_id_ref.compressed_form);
	LDKChannelReestablish msg_conv;
	msg_conv.inner = (void*)(msg & (~1));
	msg_conv.is_owned = false;
	(this_arg_conv->handle_channel_reestablish)(this_arg_conv->this_arg, their_node_id_ref, &msg_conv);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelMessageHandler_1handle_1channel_1update(JNIEnv *env, jclass clz, int64_t this_arg, int8_tArray their_node_id, int64_t msg) {
	void* this_arg_ptr = (void*)(((uint64_t)this_arg) & ~1);
	if (!(this_arg & 1)) { CHECK_ACCESS(this_arg_ptr); }
	LDKChannelMessageHandler* this_arg_conv = (LDKChannelMessageHandler*)this_arg_ptr;
	LDKPublicKey their_node_id_ref;
	CHECK((*env)->GetArrayLength(env, their_node_id) == 33);
	(*env)->GetByteArrayRegion(env, their_node_id, 0, 33, their_node_id_ref.compressed_form);
	LDKChannelUpdate msg_conv;
	msg_conv.inner = (void*)(msg & (~1));
	msg_conv.is_owned = false;
	(this_arg_conv->handle_channel_update)(this_arg_conv->this_arg, their_node_id_ref, &msg_conv);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelMessageHandler_1handle_1error(JNIEnv *env, jclass clz, int64_t this_arg, int8_tArray their_node_id, int64_t msg) {
	void* this_arg_ptr = (void*)(((uint64_t)this_arg) & ~1);
	if (!(this_arg & 1)) { CHECK_ACCESS(this_arg_ptr); }
	LDKChannelMessageHandler* this_arg_conv = (LDKChannelMessageHandler*)this_arg_ptr;
	LDKPublicKey their_node_id_ref;
	CHECK((*env)->GetArrayLength(env, their_node_id) == 33);
	(*env)->GetByteArrayRegion(env, their_node_id, 0, 33, their_node_id_ref.compressed_form);
	LDKErrorMessage msg_conv;
	msg_conv.inner = (void*)(msg & (~1));
	msg_conv.is_owned = false;
	(this_arg_conv->handle_error)(this_arg_conv->this_arg, their_node_id_ref, &msg_conv);
}

typedef struct LDKRoutingMessageHandler_JCalls {
	atomic_size_t refcnt;
	JavaVM *vm;
	jweak o;
	LDKMessageSendEventsProvider_JCalls* MessageSendEventsProvider;
	jmethodID handle_node_announcement_meth;
	jmethodID handle_channel_announcement_meth;
	jmethodID handle_channel_update_meth;
	jmethodID get_next_channel_announcements_meth;
	jmethodID get_next_node_announcements_meth;
	jmethodID sync_routing_table_meth;
	jmethodID handle_reply_channel_range_meth;
	jmethodID handle_reply_short_channel_ids_end_meth;
	jmethodID handle_query_channel_range_meth;
	jmethodID handle_query_short_channel_ids_meth;
} LDKRoutingMessageHandler_JCalls;
static void LDKRoutingMessageHandler_JCalls_free(void* this_arg) {
	LDKRoutingMessageHandler_JCalls *j_calls = (LDKRoutingMessageHandler_JCalls*) this_arg;
	if (atomic_fetch_sub_explicit(&j_calls->refcnt, 1, memory_order_acquire) == 1) {
		JNIEnv *env;
		jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
		if (get_jenv_res == JNI_EDETACHED) {
			DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
		} else {
			DO_ASSERT(get_jenv_res == JNI_OK);
		}
		(*env)->DeleteWeakGlobalRef(env, j_calls->o);
		if (get_jenv_res == JNI_EDETACHED) {
			DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
		}
		FREE(j_calls);
	}
}
LDKCResult_boolLightningErrorZ handle_node_announcement_LDKRoutingMessageHandler_jcall(const void* this_arg, const LDKNodeAnnouncement * msg) {
	LDKRoutingMessageHandler_JCalls *j_calls = (LDKRoutingMessageHandler_JCalls*) this_arg;
	JNIEnv *env;
	jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
	} else {
		DO_ASSERT(get_jenv_res == JNI_OK);
	}
	LDKNodeAnnouncement msg_var = *msg;
	uint64_t msg_ref = 0;
	msg_var = NodeAnnouncement_clone(msg);
	CHECK((((uint64_t)msg_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&msg_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	msg_ref = (uint64_t)msg_var.inner;
	if (msg_var.is_owned) {
		msg_ref |= 1;
	}
	jobject obj = (*env)->NewLocalRef(env, j_calls->o);
	CHECK(obj != NULL);
	uint64_t ret = (*env)->CallLongMethod(env, obj, j_calls->handle_node_announcement_meth, msg_ref);
	if ((*env)->ExceptionCheck(env)) {
		(*env)->ExceptionDescribe(env);
		(*env)->FatalError(env, "A call to handle_node_announcement in LDKRoutingMessageHandler from rust threw an exception.");
	}
	void* ret_ptr = (void*)(((uint64_t)ret) & ~1);
	CHECK_ACCESS(ret_ptr);
	LDKCResult_boolLightningErrorZ ret_conv = *(LDKCResult_boolLightningErrorZ*)(ret_ptr);
	ret_conv = CResult_boolLightningErrorZ_clone((LDKCResult_boolLightningErrorZ*)(((uint64_t)ret) & ~1));
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
	}
	return ret_conv;
}
LDKCResult_boolLightningErrorZ handle_channel_announcement_LDKRoutingMessageHandler_jcall(const void* this_arg, const LDKChannelAnnouncement * msg) {
	LDKRoutingMessageHandler_JCalls *j_calls = (LDKRoutingMessageHandler_JCalls*) this_arg;
	JNIEnv *env;
	jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
	} else {
		DO_ASSERT(get_jenv_res == JNI_OK);
	}
	LDKChannelAnnouncement msg_var = *msg;
	uint64_t msg_ref = 0;
	msg_var = ChannelAnnouncement_clone(msg);
	CHECK((((uint64_t)msg_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&msg_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	msg_ref = (uint64_t)msg_var.inner;
	if (msg_var.is_owned) {
		msg_ref |= 1;
	}
	jobject obj = (*env)->NewLocalRef(env, j_calls->o);
	CHECK(obj != NULL);
	uint64_t ret = (*env)->CallLongMethod(env, obj, j_calls->handle_channel_announcement_meth, msg_ref);
	if ((*env)->ExceptionCheck(env)) {
		(*env)->ExceptionDescribe(env);
		(*env)->FatalError(env, "A call to handle_channel_announcement in LDKRoutingMessageHandler from rust threw an exception.");
	}
	void* ret_ptr = (void*)(((uint64_t)ret) & ~1);
	CHECK_ACCESS(ret_ptr);
	LDKCResult_boolLightningErrorZ ret_conv = *(LDKCResult_boolLightningErrorZ*)(ret_ptr);
	ret_conv = CResult_boolLightningErrorZ_clone((LDKCResult_boolLightningErrorZ*)(((uint64_t)ret) & ~1));
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
	}
	return ret_conv;
}
LDKCResult_boolLightningErrorZ handle_channel_update_LDKRoutingMessageHandler_jcall(const void* this_arg, const LDKChannelUpdate * msg) {
	LDKRoutingMessageHandler_JCalls *j_calls = (LDKRoutingMessageHandler_JCalls*) this_arg;
	JNIEnv *env;
	jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
	} else {
		DO_ASSERT(get_jenv_res == JNI_OK);
	}
	LDKChannelUpdate msg_var = *msg;
	uint64_t msg_ref = 0;
	msg_var = ChannelUpdate_clone(msg);
	CHECK((((uint64_t)msg_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&msg_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	msg_ref = (uint64_t)msg_var.inner;
	if (msg_var.is_owned) {
		msg_ref |= 1;
	}
	jobject obj = (*env)->NewLocalRef(env, j_calls->o);
	CHECK(obj != NULL);
	uint64_t ret = (*env)->CallLongMethod(env, obj, j_calls->handle_channel_update_meth, msg_ref);
	if ((*env)->ExceptionCheck(env)) {
		(*env)->ExceptionDescribe(env);
		(*env)->FatalError(env, "A call to handle_channel_update in LDKRoutingMessageHandler from rust threw an exception.");
	}
	void* ret_ptr = (void*)(((uint64_t)ret) & ~1);
	CHECK_ACCESS(ret_ptr);
	LDKCResult_boolLightningErrorZ ret_conv = *(LDKCResult_boolLightningErrorZ*)(ret_ptr);
	ret_conv = CResult_boolLightningErrorZ_clone((LDKCResult_boolLightningErrorZ*)(((uint64_t)ret) & ~1));
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
	}
	return ret_conv;
}
LDKCVec_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ get_next_channel_announcements_LDKRoutingMessageHandler_jcall(const void* this_arg, uint64_t starting_point, uint8_t batch_amount) {
	LDKRoutingMessageHandler_JCalls *j_calls = (LDKRoutingMessageHandler_JCalls*) this_arg;
	JNIEnv *env;
	jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
	} else {
		DO_ASSERT(get_jenv_res == JNI_OK);
	}
	jobject obj = (*env)->NewLocalRef(env, j_calls->o);
	CHECK(obj != NULL);
	int64_tArray ret = (*env)->CallObjectMethod(env, obj, j_calls->get_next_channel_announcements_meth, starting_point, batch_amount);
	if ((*env)->ExceptionCheck(env)) {
		(*env)->ExceptionDescribe(env);
		(*env)->FatalError(env, "A call to get_next_channel_announcements in LDKRoutingMessageHandler from rust threw an exception.");
	}
	LDKCVec_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ ret_constr;
	ret_constr.datalen = (*env)->GetArrayLength(env, ret);
	if (ret_constr.datalen > 0)
		ret_constr.data = MALLOC(ret_constr.datalen * sizeof(LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ), "LDKCVec_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ Elements");
	else
		ret_constr.data = NULL;
	int64_t* ret_vals = (*env)->GetLongArrayElements (env, ret, NULL);
	for (size_t h = 0; h < ret_constr.datalen; h++) {
		int64_t ret_conv_59 = ret_vals[h];
		void* ret_conv_59_ptr = (void*)(((uint64_t)ret_conv_59) & ~1);
		CHECK_ACCESS(ret_conv_59_ptr);
		LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ ret_conv_59_conv = *(LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ*)(ret_conv_59_ptr);
		ret_conv_59_conv = C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_clone((LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ*)(((uint64_t)ret_conv_59) & ~1));
		ret_constr.data[h] = ret_conv_59_conv;
	}
	(*env)->ReleaseLongArrayElements(env, ret, ret_vals, 0);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
	}
	return ret_constr;
}
LDKCVec_NodeAnnouncementZ get_next_node_announcements_LDKRoutingMessageHandler_jcall(const void* this_arg, LDKPublicKey starting_point, uint8_t batch_amount) {
	LDKRoutingMessageHandler_JCalls *j_calls = (LDKRoutingMessageHandler_JCalls*) this_arg;
	JNIEnv *env;
	jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
	} else {
		DO_ASSERT(get_jenv_res == JNI_OK);
	}
	int8_tArray starting_point_arr = (*env)->NewByteArray(env, 33);
	(*env)->SetByteArrayRegion(env, starting_point_arr, 0, 33, starting_point.compressed_form);
	jobject obj = (*env)->NewLocalRef(env, j_calls->o);
	CHECK(obj != NULL);
	int64_tArray ret = (*env)->CallObjectMethod(env, obj, j_calls->get_next_node_announcements_meth, starting_point_arr, batch_amount);
	if ((*env)->ExceptionCheck(env)) {
		(*env)->ExceptionDescribe(env);
		(*env)->FatalError(env, "A call to get_next_node_announcements in LDKRoutingMessageHandler from rust threw an exception.");
	}
	LDKCVec_NodeAnnouncementZ ret_constr;
	ret_constr.datalen = (*env)->GetArrayLength(env, ret);
	if (ret_constr.datalen > 0)
		ret_constr.data = MALLOC(ret_constr.datalen * sizeof(LDKNodeAnnouncement), "LDKCVec_NodeAnnouncementZ Elements");
	else
		ret_constr.data = NULL;
	int64_t* ret_vals = (*env)->GetLongArrayElements (env, ret, NULL);
	for (size_t s = 0; s < ret_constr.datalen; s++) {
		int64_t ret_conv_18 = ret_vals[s];
		LDKNodeAnnouncement ret_conv_18_conv;
		ret_conv_18_conv.inner = (void*)(ret_conv_18 & (~1));
		ret_conv_18_conv.is_owned = (ret_conv_18 & 1) || (ret_conv_18 == 0);
		ret_conv_18_conv = NodeAnnouncement_clone(&ret_conv_18_conv);
		ret_constr.data[s] = ret_conv_18_conv;
	}
	(*env)->ReleaseLongArrayElements(env, ret, ret_vals, 0);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
	}
	return ret_constr;
}
void sync_routing_table_LDKRoutingMessageHandler_jcall(const void* this_arg, LDKPublicKey their_node_id, const LDKInit * init) {
	LDKRoutingMessageHandler_JCalls *j_calls = (LDKRoutingMessageHandler_JCalls*) this_arg;
	JNIEnv *env;
	jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
	} else {
		DO_ASSERT(get_jenv_res == JNI_OK);
	}
	int8_tArray their_node_id_arr = (*env)->NewByteArray(env, 33);
	(*env)->SetByteArrayRegion(env, their_node_id_arr, 0, 33, their_node_id.compressed_form);
	LDKInit init_var = *init;
	uint64_t init_ref = 0;
	init_var = Init_clone(init);
	CHECK((((uint64_t)init_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&init_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	init_ref = (uint64_t)init_var.inner;
	if (init_var.is_owned) {
		init_ref |= 1;
	}
	jobject obj = (*env)->NewLocalRef(env, j_calls->o);
	CHECK(obj != NULL);
	(*env)->CallVoidMethod(env, obj, j_calls->sync_routing_table_meth, their_node_id_arr, init_ref);
	if ((*env)->ExceptionCheck(env)) {
		(*env)->ExceptionDescribe(env);
		(*env)->FatalError(env, "A call to sync_routing_table in LDKRoutingMessageHandler from rust threw an exception.");
	}
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
	}
}
LDKCResult_NoneLightningErrorZ handle_reply_channel_range_LDKRoutingMessageHandler_jcall(const void* this_arg, LDKPublicKey their_node_id, LDKReplyChannelRange msg) {
	LDKRoutingMessageHandler_JCalls *j_calls = (LDKRoutingMessageHandler_JCalls*) this_arg;
	JNIEnv *env;
	jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
	} else {
		DO_ASSERT(get_jenv_res == JNI_OK);
	}
	int8_tArray their_node_id_arr = (*env)->NewByteArray(env, 33);
	(*env)->SetByteArrayRegion(env, their_node_id_arr, 0, 33, their_node_id.compressed_form);
	LDKReplyChannelRange msg_var = msg;
	uint64_t msg_ref = 0;
	CHECK((((uint64_t)msg_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&msg_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	msg_ref = (uint64_t)msg_var.inner;
	if (msg_var.is_owned) {
		msg_ref |= 1;
	}
	jobject obj = (*env)->NewLocalRef(env, j_calls->o);
	CHECK(obj != NULL);
	uint64_t ret = (*env)->CallLongMethod(env, obj, j_calls->handle_reply_channel_range_meth, their_node_id_arr, msg_ref);
	if ((*env)->ExceptionCheck(env)) {
		(*env)->ExceptionDescribe(env);
		(*env)->FatalError(env, "A call to handle_reply_channel_range in LDKRoutingMessageHandler from rust threw an exception.");
	}
	void* ret_ptr = (void*)(((uint64_t)ret) & ~1);
	CHECK_ACCESS(ret_ptr);
	LDKCResult_NoneLightningErrorZ ret_conv = *(LDKCResult_NoneLightningErrorZ*)(ret_ptr);
	ret_conv = CResult_NoneLightningErrorZ_clone((LDKCResult_NoneLightningErrorZ*)(((uint64_t)ret) & ~1));
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
	}
	return ret_conv;
}
LDKCResult_NoneLightningErrorZ handle_reply_short_channel_ids_end_LDKRoutingMessageHandler_jcall(const void* this_arg, LDKPublicKey their_node_id, LDKReplyShortChannelIdsEnd msg) {
	LDKRoutingMessageHandler_JCalls *j_calls = (LDKRoutingMessageHandler_JCalls*) this_arg;
	JNIEnv *env;
	jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
	} else {
		DO_ASSERT(get_jenv_res == JNI_OK);
	}
	int8_tArray their_node_id_arr = (*env)->NewByteArray(env, 33);
	(*env)->SetByteArrayRegion(env, their_node_id_arr, 0, 33, their_node_id.compressed_form);
	LDKReplyShortChannelIdsEnd msg_var = msg;
	uint64_t msg_ref = 0;
	CHECK((((uint64_t)msg_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&msg_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	msg_ref = (uint64_t)msg_var.inner;
	if (msg_var.is_owned) {
		msg_ref |= 1;
	}
	jobject obj = (*env)->NewLocalRef(env, j_calls->o);
	CHECK(obj != NULL);
	uint64_t ret = (*env)->CallLongMethod(env, obj, j_calls->handle_reply_short_channel_ids_end_meth, their_node_id_arr, msg_ref);
	if ((*env)->ExceptionCheck(env)) {
		(*env)->ExceptionDescribe(env);
		(*env)->FatalError(env, "A call to handle_reply_short_channel_ids_end in LDKRoutingMessageHandler from rust threw an exception.");
	}
	void* ret_ptr = (void*)(((uint64_t)ret) & ~1);
	CHECK_ACCESS(ret_ptr);
	LDKCResult_NoneLightningErrorZ ret_conv = *(LDKCResult_NoneLightningErrorZ*)(ret_ptr);
	ret_conv = CResult_NoneLightningErrorZ_clone((LDKCResult_NoneLightningErrorZ*)(((uint64_t)ret) & ~1));
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
	}
	return ret_conv;
}
LDKCResult_NoneLightningErrorZ handle_query_channel_range_LDKRoutingMessageHandler_jcall(const void* this_arg, LDKPublicKey their_node_id, LDKQueryChannelRange msg) {
	LDKRoutingMessageHandler_JCalls *j_calls = (LDKRoutingMessageHandler_JCalls*) this_arg;
	JNIEnv *env;
	jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
	} else {
		DO_ASSERT(get_jenv_res == JNI_OK);
	}
	int8_tArray their_node_id_arr = (*env)->NewByteArray(env, 33);
	(*env)->SetByteArrayRegion(env, their_node_id_arr, 0, 33, their_node_id.compressed_form);
	LDKQueryChannelRange msg_var = msg;
	uint64_t msg_ref = 0;
	CHECK((((uint64_t)msg_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&msg_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	msg_ref = (uint64_t)msg_var.inner;
	if (msg_var.is_owned) {
		msg_ref |= 1;
	}
	jobject obj = (*env)->NewLocalRef(env, j_calls->o);
	CHECK(obj != NULL);
	uint64_t ret = (*env)->CallLongMethod(env, obj, j_calls->handle_query_channel_range_meth, their_node_id_arr, msg_ref);
	if ((*env)->ExceptionCheck(env)) {
		(*env)->ExceptionDescribe(env);
		(*env)->FatalError(env, "A call to handle_query_channel_range in LDKRoutingMessageHandler from rust threw an exception.");
	}
	void* ret_ptr = (void*)(((uint64_t)ret) & ~1);
	CHECK_ACCESS(ret_ptr);
	LDKCResult_NoneLightningErrorZ ret_conv = *(LDKCResult_NoneLightningErrorZ*)(ret_ptr);
	ret_conv = CResult_NoneLightningErrorZ_clone((LDKCResult_NoneLightningErrorZ*)(((uint64_t)ret) & ~1));
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
	}
	return ret_conv;
}
LDKCResult_NoneLightningErrorZ handle_query_short_channel_ids_LDKRoutingMessageHandler_jcall(const void* this_arg, LDKPublicKey their_node_id, LDKQueryShortChannelIds msg) {
	LDKRoutingMessageHandler_JCalls *j_calls = (LDKRoutingMessageHandler_JCalls*) this_arg;
	JNIEnv *env;
	jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
	} else {
		DO_ASSERT(get_jenv_res == JNI_OK);
	}
	int8_tArray their_node_id_arr = (*env)->NewByteArray(env, 33);
	(*env)->SetByteArrayRegion(env, their_node_id_arr, 0, 33, their_node_id.compressed_form);
	LDKQueryShortChannelIds msg_var = msg;
	uint64_t msg_ref = 0;
	CHECK((((uint64_t)msg_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&msg_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	msg_ref = (uint64_t)msg_var.inner;
	if (msg_var.is_owned) {
		msg_ref |= 1;
	}
	jobject obj = (*env)->NewLocalRef(env, j_calls->o);
	CHECK(obj != NULL);
	uint64_t ret = (*env)->CallLongMethod(env, obj, j_calls->handle_query_short_channel_ids_meth, their_node_id_arr, msg_ref);
	if ((*env)->ExceptionCheck(env)) {
		(*env)->ExceptionDescribe(env);
		(*env)->FatalError(env, "A call to handle_query_short_channel_ids in LDKRoutingMessageHandler from rust threw an exception.");
	}
	void* ret_ptr = (void*)(((uint64_t)ret) & ~1);
	CHECK_ACCESS(ret_ptr);
	LDKCResult_NoneLightningErrorZ ret_conv = *(LDKCResult_NoneLightningErrorZ*)(ret_ptr);
	ret_conv = CResult_NoneLightningErrorZ_clone((LDKCResult_NoneLightningErrorZ*)(((uint64_t)ret) & ~1));
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
	}
	return ret_conv;
}
static void LDKRoutingMessageHandler_JCalls_cloned(LDKRoutingMessageHandler* new_obj) {
	LDKRoutingMessageHandler_JCalls *j_calls = (LDKRoutingMessageHandler_JCalls*) new_obj->this_arg;
	atomic_fetch_add_explicit(&j_calls->refcnt, 1, memory_order_release);
	atomic_fetch_add_explicit(&j_calls->MessageSendEventsProvider->refcnt, 1, memory_order_release);
}
static inline LDKRoutingMessageHandler LDKRoutingMessageHandler_init (JNIEnv *env, jclass clz, jobject o, jobject MessageSendEventsProvider) {
	jclass c = (*env)->GetObjectClass(env, o);
	CHECK(c != NULL);
	LDKRoutingMessageHandler_JCalls *calls = MALLOC(sizeof(LDKRoutingMessageHandler_JCalls), "LDKRoutingMessageHandler_JCalls");
	atomic_init(&calls->refcnt, 1);
	DO_ASSERT((*env)->GetJavaVM(env, &calls->vm) == 0);
	calls->o = (*env)->NewWeakGlobalRef(env, o);
	calls->handle_node_announcement_meth = (*env)->GetMethodID(env, c, "handle_node_announcement", "(J)J");
	CHECK(calls->handle_node_announcement_meth != NULL);
	calls->handle_channel_announcement_meth = (*env)->GetMethodID(env, c, "handle_channel_announcement", "(J)J");
	CHECK(calls->handle_channel_announcement_meth != NULL);
	calls->handle_channel_update_meth = (*env)->GetMethodID(env, c, "handle_channel_update", "(J)J");
	CHECK(calls->handle_channel_update_meth != NULL);
	calls->get_next_channel_announcements_meth = (*env)->GetMethodID(env, c, "get_next_channel_announcements", "(JB)[J");
	CHECK(calls->get_next_channel_announcements_meth != NULL);
	calls->get_next_node_announcements_meth = (*env)->GetMethodID(env, c, "get_next_node_announcements", "([BB)[J");
	CHECK(calls->get_next_node_announcements_meth != NULL);
	calls->sync_routing_table_meth = (*env)->GetMethodID(env, c, "sync_routing_table", "([BJ)V");
	CHECK(calls->sync_routing_table_meth != NULL);
	calls->handle_reply_channel_range_meth = (*env)->GetMethodID(env, c, "handle_reply_channel_range", "([BJ)J");
	CHECK(calls->handle_reply_channel_range_meth != NULL);
	calls->handle_reply_short_channel_ids_end_meth = (*env)->GetMethodID(env, c, "handle_reply_short_channel_ids_end", "([BJ)J");
	CHECK(calls->handle_reply_short_channel_ids_end_meth != NULL);
	calls->handle_query_channel_range_meth = (*env)->GetMethodID(env, c, "handle_query_channel_range", "([BJ)J");
	CHECK(calls->handle_query_channel_range_meth != NULL);
	calls->handle_query_short_channel_ids_meth = (*env)->GetMethodID(env, c, "handle_query_short_channel_ids", "([BJ)J");
	CHECK(calls->handle_query_short_channel_ids_meth != NULL);

	LDKRoutingMessageHandler ret = {
		.this_arg = (void*) calls,
		.handle_node_announcement = handle_node_announcement_LDKRoutingMessageHandler_jcall,
		.handle_channel_announcement = handle_channel_announcement_LDKRoutingMessageHandler_jcall,
		.handle_channel_update = handle_channel_update_LDKRoutingMessageHandler_jcall,
		.get_next_channel_announcements = get_next_channel_announcements_LDKRoutingMessageHandler_jcall,
		.get_next_node_announcements = get_next_node_announcements_LDKRoutingMessageHandler_jcall,
		.sync_routing_table = sync_routing_table_LDKRoutingMessageHandler_jcall,
		.handle_reply_channel_range = handle_reply_channel_range_LDKRoutingMessageHandler_jcall,
		.handle_reply_short_channel_ids_end = handle_reply_short_channel_ids_end_LDKRoutingMessageHandler_jcall,
		.handle_query_channel_range = handle_query_channel_range_LDKRoutingMessageHandler_jcall,
		.handle_query_short_channel_ids = handle_query_short_channel_ids_LDKRoutingMessageHandler_jcall,
		.free = LDKRoutingMessageHandler_JCalls_free,
		.MessageSendEventsProvider = LDKMessageSendEventsProvider_init(env, clz, MessageSendEventsProvider),
	};
	calls->MessageSendEventsProvider = ret.MessageSendEventsProvider.this_arg;
	return ret;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKRoutingMessageHandler_1new(JNIEnv *env, jclass clz, jobject o, jobject MessageSendEventsProvider) {
	LDKRoutingMessageHandler *res_ptr = MALLOC(sizeof(LDKRoutingMessageHandler), "LDKRoutingMessageHandler");
	*res_ptr = LDKRoutingMessageHandler_init(env, clz, o, MessageSendEventsProvider);
	return (uint64_t)res_ptr;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKRoutingMessageHandler_1get_1MessageSendEventsProvider(JNIEnv *env, jclass clz, int64_t arg) {
	LDKRoutingMessageHandler *inp = (LDKRoutingMessageHandler *)(arg & ~1);
	uint64_t res_ptr = (uint64_t)&inp->MessageSendEventsProvider;
	DO_ASSERT((res_ptr & 1) == 0);
	return (int64_t)(res_ptr | 1);
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_RoutingMessageHandler_1handle_1node_1announcement(JNIEnv *env, jclass clz, int64_t this_arg, int64_t msg) {
	void* this_arg_ptr = (void*)(((uint64_t)this_arg) & ~1);
	if (!(this_arg & 1)) { CHECK_ACCESS(this_arg_ptr); }
	LDKRoutingMessageHandler* this_arg_conv = (LDKRoutingMessageHandler*)this_arg_ptr;
	LDKNodeAnnouncement msg_conv;
	msg_conv.inner = (void*)(msg & (~1));
	msg_conv.is_owned = false;
	LDKCResult_boolLightningErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_boolLightningErrorZ), "LDKCResult_boolLightningErrorZ");
	*ret_conv = (this_arg_conv->handle_node_announcement)(this_arg_conv->this_arg, &msg_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_RoutingMessageHandler_1handle_1channel_1announcement(JNIEnv *env, jclass clz, int64_t this_arg, int64_t msg) {
	void* this_arg_ptr = (void*)(((uint64_t)this_arg) & ~1);
	if (!(this_arg & 1)) { CHECK_ACCESS(this_arg_ptr); }
	LDKRoutingMessageHandler* this_arg_conv = (LDKRoutingMessageHandler*)this_arg_ptr;
	LDKChannelAnnouncement msg_conv;
	msg_conv.inner = (void*)(msg & (~1));
	msg_conv.is_owned = false;
	LDKCResult_boolLightningErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_boolLightningErrorZ), "LDKCResult_boolLightningErrorZ");
	*ret_conv = (this_arg_conv->handle_channel_announcement)(this_arg_conv->this_arg, &msg_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_RoutingMessageHandler_1handle_1channel_1update(JNIEnv *env, jclass clz, int64_t this_arg, int64_t msg) {
	void* this_arg_ptr = (void*)(((uint64_t)this_arg) & ~1);
	if (!(this_arg & 1)) { CHECK_ACCESS(this_arg_ptr); }
	LDKRoutingMessageHandler* this_arg_conv = (LDKRoutingMessageHandler*)this_arg_ptr;
	LDKChannelUpdate msg_conv;
	msg_conv.inner = (void*)(msg & (~1));
	msg_conv.is_owned = false;
	LDKCResult_boolLightningErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_boolLightningErrorZ), "LDKCResult_boolLightningErrorZ");
	*ret_conv = (this_arg_conv->handle_channel_update)(this_arg_conv->this_arg, &msg_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_tArray JNICALL Java_org_ldk_impl_bindings_RoutingMessageHandler_1get_1next_1channel_1announcements(JNIEnv *env, jclass clz, int64_t this_arg, int64_t starting_point, int8_t batch_amount) {
	void* this_arg_ptr = (void*)(((uint64_t)this_arg) & ~1);
	if (!(this_arg & 1)) { CHECK_ACCESS(this_arg_ptr); }
	LDKRoutingMessageHandler* this_arg_conv = (LDKRoutingMessageHandler*)this_arg_ptr;
	LDKCVec_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ ret_var = (this_arg_conv->get_next_channel_announcements)(this_arg_conv->this_arg, starting_point, batch_amount);
	int64_tArray ret_arr = NULL;
	ret_arr = (*env)->NewLongArray(env, ret_var.datalen);
	int64_t *ret_arr_ptr = (*env)->GetPrimitiveArrayCritical(env, ret_arr, NULL);
	for (size_t h = 0; h < ret_var.datalen; h++) {
		LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ* ret_conv_59_conv = MALLOC(sizeof(LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ), "LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ");
		*ret_conv_59_conv = ret_var.data[h];
		ret_arr_ptr[h] = ((uint64_t)ret_conv_59_conv);
	}
	(*env)->ReleasePrimitiveArrayCritical(env, ret_arr, ret_arr_ptr, 0);
	FREE(ret_var.data);
	return ret_arr;
}

JNIEXPORT int64_tArray JNICALL Java_org_ldk_impl_bindings_RoutingMessageHandler_1get_1next_1node_1announcements(JNIEnv *env, jclass clz, int64_t this_arg, int8_tArray starting_point, int8_t batch_amount) {
	void* this_arg_ptr = (void*)(((uint64_t)this_arg) & ~1);
	if (!(this_arg & 1)) { CHECK_ACCESS(this_arg_ptr); }
	LDKRoutingMessageHandler* this_arg_conv = (LDKRoutingMessageHandler*)this_arg_ptr;
	LDKPublicKey starting_point_ref;
	CHECK((*env)->GetArrayLength(env, starting_point) == 33);
	(*env)->GetByteArrayRegion(env, starting_point, 0, 33, starting_point_ref.compressed_form);
	LDKCVec_NodeAnnouncementZ ret_var = (this_arg_conv->get_next_node_announcements)(this_arg_conv->this_arg, starting_point_ref, batch_amount);
	int64_tArray ret_arr = NULL;
	ret_arr = (*env)->NewLongArray(env, ret_var.datalen);
	int64_t *ret_arr_ptr = (*env)->GetPrimitiveArrayCritical(env, ret_arr, NULL);
	for (size_t s = 0; s < ret_var.datalen; s++) {
		LDKNodeAnnouncement ret_conv_18_var = ret_var.data[s];
		uint64_t ret_conv_18_ref = 0;
		CHECK((((uint64_t)ret_conv_18_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
		CHECK((((uint64_t)&ret_conv_18_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
		ret_conv_18_ref = (uint64_t)ret_conv_18_var.inner;
		if (ret_conv_18_var.is_owned) {
			ret_conv_18_ref |= 1;
		}
		ret_arr_ptr[s] = ret_conv_18_ref;
	}
	(*env)->ReleasePrimitiveArrayCritical(env, ret_arr, ret_arr_ptr, 0);
	FREE(ret_var.data);
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_RoutingMessageHandler_1sync_1routing_1table(JNIEnv *env, jclass clz, int64_t this_arg, int8_tArray their_node_id, int64_t init) {
	void* this_arg_ptr = (void*)(((uint64_t)this_arg) & ~1);
	if (!(this_arg & 1)) { CHECK_ACCESS(this_arg_ptr); }
	LDKRoutingMessageHandler* this_arg_conv = (LDKRoutingMessageHandler*)this_arg_ptr;
	LDKPublicKey their_node_id_ref;
	CHECK((*env)->GetArrayLength(env, their_node_id) == 33);
	(*env)->GetByteArrayRegion(env, their_node_id, 0, 33, their_node_id_ref.compressed_form);
	LDKInit init_conv;
	init_conv.inner = (void*)(init & (~1));
	init_conv.is_owned = false;
	(this_arg_conv->sync_routing_table)(this_arg_conv->this_arg, their_node_id_ref, &init_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_RoutingMessageHandler_1handle_1reply_1channel_1range(JNIEnv *env, jclass clz, int64_t this_arg, int8_tArray their_node_id, int64_t msg) {
	void* this_arg_ptr = (void*)(((uint64_t)this_arg) & ~1);
	if (!(this_arg & 1)) { CHECK_ACCESS(this_arg_ptr); }
	LDKRoutingMessageHandler* this_arg_conv = (LDKRoutingMessageHandler*)this_arg_ptr;
	LDKPublicKey their_node_id_ref;
	CHECK((*env)->GetArrayLength(env, their_node_id) == 33);
	(*env)->GetByteArrayRegion(env, their_node_id, 0, 33, their_node_id_ref.compressed_form);
	LDKReplyChannelRange msg_conv;
	msg_conv.inner = (void*)(msg & (~1));
	msg_conv.is_owned = (msg & 1) || (msg == 0);
	msg_conv = ReplyChannelRange_clone(&msg_conv);
	LDKCResult_NoneLightningErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_NoneLightningErrorZ), "LDKCResult_NoneLightningErrorZ");
	*ret_conv = (this_arg_conv->handle_reply_channel_range)(this_arg_conv->this_arg, their_node_id_ref, msg_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_RoutingMessageHandler_1handle_1reply_1short_1channel_1ids_1end(JNIEnv *env, jclass clz, int64_t this_arg, int8_tArray their_node_id, int64_t msg) {
	void* this_arg_ptr = (void*)(((uint64_t)this_arg) & ~1);
	if (!(this_arg & 1)) { CHECK_ACCESS(this_arg_ptr); }
	LDKRoutingMessageHandler* this_arg_conv = (LDKRoutingMessageHandler*)this_arg_ptr;
	LDKPublicKey their_node_id_ref;
	CHECK((*env)->GetArrayLength(env, their_node_id) == 33);
	(*env)->GetByteArrayRegion(env, their_node_id, 0, 33, their_node_id_ref.compressed_form);
	LDKReplyShortChannelIdsEnd msg_conv;
	msg_conv.inner = (void*)(msg & (~1));
	msg_conv.is_owned = (msg & 1) || (msg == 0);
	msg_conv = ReplyShortChannelIdsEnd_clone(&msg_conv);
	LDKCResult_NoneLightningErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_NoneLightningErrorZ), "LDKCResult_NoneLightningErrorZ");
	*ret_conv = (this_arg_conv->handle_reply_short_channel_ids_end)(this_arg_conv->this_arg, their_node_id_ref, msg_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_RoutingMessageHandler_1handle_1query_1channel_1range(JNIEnv *env, jclass clz, int64_t this_arg, int8_tArray their_node_id, int64_t msg) {
	void* this_arg_ptr = (void*)(((uint64_t)this_arg) & ~1);
	if (!(this_arg & 1)) { CHECK_ACCESS(this_arg_ptr); }
	LDKRoutingMessageHandler* this_arg_conv = (LDKRoutingMessageHandler*)this_arg_ptr;
	LDKPublicKey their_node_id_ref;
	CHECK((*env)->GetArrayLength(env, their_node_id) == 33);
	(*env)->GetByteArrayRegion(env, their_node_id, 0, 33, their_node_id_ref.compressed_form);
	LDKQueryChannelRange msg_conv;
	msg_conv.inner = (void*)(msg & (~1));
	msg_conv.is_owned = (msg & 1) || (msg == 0);
	msg_conv = QueryChannelRange_clone(&msg_conv);
	LDKCResult_NoneLightningErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_NoneLightningErrorZ), "LDKCResult_NoneLightningErrorZ");
	*ret_conv = (this_arg_conv->handle_query_channel_range)(this_arg_conv->this_arg, their_node_id_ref, msg_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_RoutingMessageHandler_1handle_1query_1short_1channel_1ids(JNIEnv *env, jclass clz, int64_t this_arg, int8_tArray their_node_id, int64_t msg) {
	void* this_arg_ptr = (void*)(((uint64_t)this_arg) & ~1);
	if (!(this_arg & 1)) { CHECK_ACCESS(this_arg_ptr); }
	LDKRoutingMessageHandler* this_arg_conv = (LDKRoutingMessageHandler*)this_arg_ptr;
	LDKPublicKey their_node_id_ref;
	CHECK((*env)->GetArrayLength(env, their_node_id) == 33);
	(*env)->GetByteArrayRegion(env, their_node_id, 0, 33, their_node_id_ref.compressed_form);
	LDKQueryShortChannelIds msg_conv;
	msg_conv.inner = (void*)(msg & (~1));
	msg_conv.is_owned = (msg & 1) || (msg == 0);
	msg_conv = QueryShortChannelIds_clone(&msg_conv);
	LDKCResult_NoneLightningErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_NoneLightningErrorZ), "LDKCResult_NoneLightningErrorZ");
	*ret_conv = (this_arg_conv->handle_query_short_channel_ids)(this_arg_conv->this_arg, their_node_id_ref, msg_conv);
	return (uint64_t)ret_conv;
}

typedef struct LDKCustomMessageReader_JCalls {
	atomic_size_t refcnt;
	JavaVM *vm;
	jweak o;
	jmethodID read_meth;
} LDKCustomMessageReader_JCalls;
static void LDKCustomMessageReader_JCalls_free(void* this_arg) {
	LDKCustomMessageReader_JCalls *j_calls = (LDKCustomMessageReader_JCalls*) this_arg;
	if (atomic_fetch_sub_explicit(&j_calls->refcnt, 1, memory_order_acquire) == 1) {
		JNIEnv *env;
		jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
		if (get_jenv_res == JNI_EDETACHED) {
			DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
		} else {
			DO_ASSERT(get_jenv_res == JNI_OK);
		}
		(*env)->DeleteWeakGlobalRef(env, j_calls->o);
		if (get_jenv_res == JNI_EDETACHED) {
			DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
		}
		FREE(j_calls);
	}
}
LDKCResult_COption_TypeZDecodeErrorZ read_LDKCustomMessageReader_jcall(const void* this_arg, uint16_t message_type, LDKu8slice buffer) {
	LDKCustomMessageReader_JCalls *j_calls = (LDKCustomMessageReader_JCalls*) this_arg;
	JNIEnv *env;
	jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
	} else {
		DO_ASSERT(get_jenv_res == JNI_OK);
	}
	LDKu8slice buffer_var = buffer;
	int8_tArray buffer_arr = (*env)->NewByteArray(env, buffer_var.datalen);
	(*env)->SetByteArrayRegion(env, buffer_arr, 0, buffer_var.datalen, buffer_var.data);
	jobject obj = (*env)->NewLocalRef(env, j_calls->o);
	CHECK(obj != NULL);
	uint64_t ret = (*env)->CallLongMethod(env, obj, j_calls->read_meth, message_type, buffer_arr);
	if ((*env)->ExceptionCheck(env)) {
		(*env)->ExceptionDescribe(env);
		(*env)->FatalError(env, "A call to read in LDKCustomMessageReader from rust threw an exception.");
	}
	void* ret_ptr = (void*)(((uint64_t)ret) & ~1);
	CHECK_ACCESS(ret_ptr);
	LDKCResult_COption_TypeZDecodeErrorZ ret_conv = *(LDKCResult_COption_TypeZDecodeErrorZ*)(ret_ptr);
	ret_conv = CResult_COption_TypeZDecodeErrorZ_clone((LDKCResult_COption_TypeZDecodeErrorZ*)(((uint64_t)ret) & ~1));
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
	}
	return ret_conv;
}
static void LDKCustomMessageReader_JCalls_cloned(LDKCustomMessageReader* new_obj) {
	LDKCustomMessageReader_JCalls *j_calls = (LDKCustomMessageReader_JCalls*) new_obj->this_arg;
	atomic_fetch_add_explicit(&j_calls->refcnt, 1, memory_order_release);
}
static inline LDKCustomMessageReader LDKCustomMessageReader_init (JNIEnv *env, jclass clz, jobject o) {
	jclass c = (*env)->GetObjectClass(env, o);
	CHECK(c != NULL);
	LDKCustomMessageReader_JCalls *calls = MALLOC(sizeof(LDKCustomMessageReader_JCalls), "LDKCustomMessageReader_JCalls");
	atomic_init(&calls->refcnt, 1);
	DO_ASSERT((*env)->GetJavaVM(env, &calls->vm) == 0);
	calls->o = (*env)->NewWeakGlobalRef(env, o);
	calls->read_meth = (*env)->GetMethodID(env, c, "read", "(S[B)J");
	CHECK(calls->read_meth != NULL);

	LDKCustomMessageReader ret = {
		.this_arg = (void*) calls,
		.read = read_LDKCustomMessageReader_jcall,
		.free = LDKCustomMessageReader_JCalls_free,
	};
	return ret;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCustomMessageReader_1new(JNIEnv *env, jclass clz, jobject o) {
	LDKCustomMessageReader *res_ptr = MALLOC(sizeof(LDKCustomMessageReader), "LDKCustomMessageReader");
	*res_ptr = LDKCustomMessageReader_init(env, clz, o);
	return (uint64_t)res_ptr;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CustomMessageReader_1read(JNIEnv *env, jclass clz, int64_t this_arg, int16_t message_type, int8_tArray buffer) {
	void* this_arg_ptr = (void*)(((uint64_t)this_arg) & ~1);
	if (!(this_arg & 1)) { CHECK_ACCESS(this_arg_ptr); }
	LDKCustomMessageReader* this_arg_conv = (LDKCustomMessageReader*)this_arg_ptr;
	LDKu8slice buffer_ref;
	buffer_ref.datalen = (*env)->GetArrayLength(env, buffer);
	buffer_ref.data = (*env)->GetByteArrayElements (env, buffer, NULL);
	LDKCResult_COption_TypeZDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_COption_TypeZDecodeErrorZ), "LDKCResult_COption_TypeZDecodeErrorZ");
	*ret_conv = (this_arg_conv->read)(this_arg_conv->this_arg, message_type, buffer_ref);
	(*env)->ReleaseByteArrayElements(env, buffer, (int8_t*)buffer_ref.data, 0);
	return (uint64_t)ret_conv;
}

typedef struct LDKCustomMessageHandler_JCalls {
	atomic_size_t refcnt;
	JavaVM *vm;
	jweak o;
	LDKCustomMessageReader_JCalls* CustomMessageReader;
	jmethodID handle_custom_message_meth;
	jmethodID get_and_clear_pending_msg_meth;
} LDKCustomMessageHandler_JCalls;
static void LDKCustomMessageHandler_JCalls_free(void* this_arg) {
	LDKCustomMessageHandler_JCalls *j_calls = (LDKCustomMessageHandler_JCalls*) this_arg;
	if (atomic_fetch_sub_explicit(&j_calls->refcnt, 1, memory_order_acquire) == 1) {
		JNIEnv *env;
		jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
		if (get_jenv_res == JNI_EDETACHED) {
			DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
		} else {
			DO_ASSERT(get_jenv_res == JNI_OK);
		}
		(*env)->DeleteWeakGlobalRef(env, j_calls->o);
		if (get_jenv_res == JNI_EDETACHED) {
			DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
		}
		FREE(j_calls);
	}
}
LDKCResult_NoneLightningErrorZ handle_custom_message_LDKCustomMessageHandler_jcall(const void* this_arg, LDKType msg, LDKPublicKey sender_node_id) {
	LDKCustomMessageHandler_JCalls *j_calls = (LDKCustomMessageHandler_JCalls*) this_arg;
	JNIEnv *env;
	jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
	} else {
		DO_ASSERT(get_jenv_res == JNI_OK);
	}
	LDKType* msg_ret = MALLOC(sizeof(LDKType), "LDKType");
	*msg_ret = msg;
	int8_tArray sender_node_id_arr = (*env)->NewByteArray(env, 33);
	(*env)->SetByteArrayRegion(env, sender_node_id_arr, 0, 33, sender_node_id.compressed_form);
	jobject obj = (*env)->NewLocalRef(env, j_calls->o);
	CHECK(obj != NULL);
	uint64_t ret = (*env)->CallLongMethod(env, obj, j_calls->handle_custom_message_meth, (uint64_t)msg_ret, sender_node_id_arr);
	if ((*env)->ExceptionCheck(env)) {
		(*env)->ExceptionDescribe(env);
		(*env)->FatalError(env, "A call to handle_custom_message in LDKCustomMessageHandler from rust threw an exception.");
	}
	void* ret_ptr = (void*)(((uint64_t)ret) & ~1);
	CHECK_ACCESS(ret_ptr);
	LDKCResult_NoneLightningErrorZ ret_conv = *(LDKCResult_NoneLightningErrorZ*)(ret_ptr);
	ret_conv = CResult_NoneLightningErrorZ_clone((LDKCResult_NoneLightningErrorZ*)(((uint64_t)ret) & ~1));
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
	}
	return ret_conv;
}
LDKCVec_C2Tuple_PublicKeyTypeZZ get_and_clear_pending_msg_LDKCustomMessageHandler_jcall(const void* this_arg) {
	LDKCustomMessageHandler_JCalls *j_calls = (LDKCustomMessageHandler_JCalls*) this_arg;
	JNIEnv *env;
	jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
	} else {
		DO_ASSERT(get_jenv_res == JNI_OK);
	}
	jobject obj = (*env)->NewLocalRef(env, j_calls->o);
	CHECK(obj != NULL);
	int64_tArray ret = (*env)->CallObjectMethod(env, obj, j_calls->get_and_clear_pending_msg_meth);
	if ((*env)->ExceptionCheck(env)) {
		(*env)->ExceptionDescribe(env);
		(*env)->FatalError(env, "A call to get_and_clear_pending_msg in LDKCustomMessageHandler from rust threw an exception.");
	}
	LDKCVec_C2Tuple_PublicKeyTypeZZ ret_constr;
	ret_constr.datalen = (*env)->GetArrayLength(env, ret);
	if (ret_constr.datalen > 0)
		ret_constr.data = MALLOC(ret_constr.datalen * sizeof(LDKC2Tuple_PublicKeyTypeZ), "LDKCVec_C2Tuple_PublicKeyTypeZZ Elements");
	else
		ret_constr.data = NULL;
	int64_t* ret_vals = (*env)->GetLongArrayElements (env, ret, NULL);
	for (size_t z = 0; z < ret_constr.datalen; z++) {
		int64_t ret_conv_25 = ret_vals[z];
		void* ret_conv_25_ptr = (void*)(((uint64_t)ret_conv_25) & ~1);
		CHECK_ACCESS(ret_conv_25_ptr);
		LDKC2Tuple_PublicKeyTypeZ ret_conv_25_conv = *(LDKC2Tuple_PublicKeyTypeZ*)(ret_conv_25_ptr);
		ret_conv_25_conv = C2Tuple_PublicKeyTypeZ_clone((LDKC2Tuple_PublicKeyTypeZ*)(((uint64_t)ret_conv_25) & ~1));
		ret_constr.data[z] = ret_conv_25_conv;
	}
	(*env)->ReleaseLongArrayElements(env, ret, ret_vals, 0);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
	}
	return ret_constr;
}
static void LDKCustomMessageHandler_JCalls_cloned(LDKCustomMessageHandler* new_obj) {
	LDKCustomMessageHandler_JCalls *j_calls = (LDKCustomMessageHandler_JCalls*) new_obj->this_arg;
	atomic_fetch_add_explicit(&j_calls->refcnt, 1, memory_order_release);
	atomic_fetch_add_explicit(&j_calls->CustomMessageReader->refcnt, 1, memory_order_release);
}
static inline LDKCustomMessageHandler LDKCustomMessageHandler_init (JNIEnv *env, jclass clz, jobject o, jobject CustomMessageReader) {
	jclass c = (*env)->GetObjectClass(env, o);
	CHECK(c != NULL);
	LDKCustomMessageHandler_JCalls *calls = MALLOC(sizeof(LDKCustomMessageHandler_JCalls), "LDKCustomMessageHandler_JCalls");
	atomic_init(&calls->refcnt, 1);
	DO_ASSERT((*env)->GetJavaVM(env, &calls->vm) == 0);
	calls->o = (*env)->NewWeakGlobalRef(env, o);
	calls->handle_custom_message_meth = (*env)->GetMethodID(env, c, "handle_custom_message", "(J[B)J");
	CHECK(calls->handle_custom_message_meth != NULL);
	calls->get_and_clear_pending_msg_meth = (*env)->GetMethodID(env, c, "get_and_clear_pending_msg", "()[J");
	CHECK(calls->get_and_clear_pending_msg_meth != NULL);

	LDKCustomMessageHandler ret = {
		.this_arg = (void*) calls,
		.handle_custom_message = handle_custom_message_LDKCustomMessageHandler_jcall,
		.get_and_clear_pending_msg = get_and_clear_pending_msg_LDKCustomMessageHandler_jcall,
		.free = LDKCustomMessageHandler_JCalls_free,
		.CustomMessageReader = LDKCustomMessageReader_init(env, clz, CustomMessageReader),
	};
	calls->CustomMessageReader = ret.CustomMessageReader.this_arg;
	return ret;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCustomMessageHandler_1new(JNIEnv *env, jclass clz, jobject o, jobject CustomMessageReader) {
	LDKCustomMessageHandler *res_ptr = MALLOC(sizeof(LDKCustomMessageHandler), "LDKCustomMessageHandler");
	*res_ptr = LDKCustomMessageHandler_init(env, clz, o, CustomMessageReader);
	return (uint64_t)res_ptr;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKCustomMessageHandler_1get_1CustomMessageReader(JNIEnv *env, jclass clz, int64_t arg) {
	LDKCustomMessageHandler *inp = (LDKCustomMessageHandler *)(arg & ~1);
	uint64_t res_ptr = (uint64_t)&inp->CustomMessageReader;
	DO_ASSERT((res_ptr & 1) == 0);
	return (int64_t)(res_ptr | 1);
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CustomMessageHandler_1handle_1custom_1message(JNIEnv *env, jclass clz, int64_t this_arg, int64_t msg, int8_tArray sender_node_id) {
	void* this_arg_ptr = (void*)(((uint64_t)this_arg) & ~1);
	if (!(this_arg & 1)) { CHECK_ACCESS(this_arg_ptr); }
	LDKCustomMessageHandler* this_arg_conv = (LDKCustomMessageHandler*)this_arg_ptr;
	void* msg_ptr = (void*)(((uint64_t)msg) & ~1);
	CHECK_ACCESS(msg_ptr);
	LDKType msg_conv = *(LDKType*)(msg_ptr);
	if (msg_conv.free == LDKType_JCalls_free) {
		// If this_arg is a JCalls struct, then we need to increment the refcnt in it.
		LDKType_JCalls_cloned(&msg_conv);
	}
	LDKPublicKey sender_node_id_ref;
	CHECK((*env)->GetArrayLength(env, sender_node_id) == 33);
	(*env)->GetByteArrayRegion(env, sender_node_id, 0, 33, sender_node_id_ref.compressed_form);
	LDKCResult_NoneLightningErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_NoneLightningErrorZ), "LDKCResult_NoneLightningErrorZ");
	*ret_conv = (this_arg_conv->handle_custom_message)(this_arg_conv->this_arg, msg_conv, sender_node_id_ref);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_tArray JNICALL Java_org_ldk_impl_bindings_CustomMessageHandler_1get_1and_1clear_1pending_1msg(JNIEnv *env, jclass clz, int64_t this_arg) {
	void* this_arg_ptr = (void*)(((uint64_t)this_arg) & ~1);
	if (!(this_arg & 1)) { CHECK_ACCESS(this_arg_ptr); }
	LDKCustomMessageHandler* this_arg_conv = (LDKCustomMessageHandler*)this_arg_ptr;
	LDKCVec_C2Tuple_PublicKeyTypeZZ ret_var = (this_arg_conv->get_and_clear_pending_msg)(this_arg_conv->this_arg);
	int64_tArray ret_arr = NULL;
	ret_arr = (*env)->NewLongArray(env, ret_var.datalen);
	int64_t *ret_arr_ptr = (*env)->GetPrimitiveArrayCritical(env, ret_arr, NULL);
	for (size_t z = 0; z < ret_var.datalen; z++) {
		LDKC2Tuple_PublicKeyTypeZ* ret_conv_25_conv = MALLOC(sizeof(LDKC2Tuple_PublicKeyTypeZ), "LDKC2Tuple_PublicKeyTypeZ");
		*ret_conv_25_conv = ret_var.data[z];
		ret_arr_ptr[z] = ((uint64_t)ret_conv_25_conv);
	}
	(*env)->ReleasePrimitiveArrayCritical(env, ret_arr, ret_arr_ptr, 0);
	FREE(ret_var.data);
	return ret_arr;
}

typedef struct LDKSocketDescriptor_JCalls {
	atomic_size_t refcnt;
	JavaVM *vm;
	jweak o;
	jmethodID send_data_meth;
	jmethodID disconnect_socket_meth;
	jmethodID eq_meth;
	jmethodID hash_meth;
} LDKSocketDescriptor_JCalls;
static void LDKSocketDescriptor_JCalls_free(void* this_arg) {
	LDKSocketDescriptor_JCalls *j_calls = (LDKSocketDescriptor_JCalls*) this_arg;
	if (atomic_fetch_sub_explicit(&j_calls->refcnt, 1, memory_order_acquire) == 1) {
		JNIEnv *env;
		jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
		if (get_jenv_res == JNI_EDETACHED) {
			DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
		} else {
			DO_ASSERT(get_jenv_res == JNI_OK);
		}
		(*env)->DeleteWeakGlobalRef(env, j_calls->o);
		if (get_jenv_res == JNI_EDETACHED) {
			DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
		}
		FREE(j_calls);
	}
}
uintptr_t send_data_LDKSocketDescriptor_jcall(void* this_arg, LDKu8slice data, bool resume_read) {
	LDKSocketDescriptor_JCalls *j_calls = (LDKSocketDescriptor_JCalls*) this_arg;
	JNIEnv *env;
	jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
	} else {
		DO_ASSERT(get_jenv_res == JNI_OK);
	}
	LDKu8slice data_var = data;
	int8_tArray data_arr = (*env)->NewByteArray(env, data_var.datalen);
	(*env)->SetByteArrayRegion(env, data_arr, 0, data_var.datalen, data_var.data);
	jobject obj = (*env)->NewLocalRef(env, j_calls->o);
	CHECK(obj != NULL);
	int64_t ret = (*env)->CallLongMethod(env, obj, j_calls->send_data_meth, data_arr, resume_read);
	if ((*env)->ExceptionCheck(env)) {
		(*env)->ExceptionDescribe(env);
		(*env)->FatalError(env, "A call to send_data in LDKSocketDescriptor from rust threw an exception.");
	}
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
	}
	return ret;
}
void disconnect_socket_LDKSocketDescriptor_jcall(void* this_arg) {
	LDKSocketDescriptor_JCalls *j_calls = (LDKSocketDescriptor_JCalls*) this_arg;
	JNIEnv *env;
	jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
	} else {
		DO_ASSERT(get_jenv_res == JNI_OK);
	}
	jobject obj = (*env)->NewLocalRef(env, j_calls->o);
	CHECK(obj != NULL);
	(*env)->CallVoidMethod(env, obj, j_calls->disconnect_socket_meth);
	if ((*env)->ExceptionCheck(env)) {
		(*env)->ExceptionDescribe(env);
		(*env)->FatalError(env, "A call to disconnect_socket in LDKSocketDescriptor from rust threw an exception.");
	}
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
	}
}
bool eq_LDKSocketDescriptor_jcall(const void* this_arg, const LDKSocketDescriptor * other_arg) {
	LDKSocketDescriptor_JCalls *j_calls = (LDKSocketDescriptor_JCalls*) this_arg;
	JNIEnv *env;
	jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
	} else {
		DO_ASSERT(get_jenv_res == JNI_OK);
	}
	LDKSocketDescriptor *other_arg_clone = MALLOC(sizeof(LDKSocketDescriptor), "LDKSocketDescriptor");
	*other_arg_clone = SocketDescriptor_clone(other_arg);
	jobject obj = (*env)->NewLocalRef(env, j_calls->o);
	CHECK(obj != NULL);
	jboolean ret = (*env)->CallBooleanMethod(env, obj, j_calls->eq_meth, (uint64_t)other_arg_clone);
	if ((*env)->ExceptionCheck(env)) {
		(*env)->ExceptionDescribe(env);
		(*env)->FatalError(env, "A call to eq in LDKSocketDescriptor from rust threw an exception.");
	}
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
	}
	return ret;
}
uint64_t hash_LDKSocketDescriptor_jcall(const void* this_arg) {
	LDKSocketDescriptor_JCalls *j_calls = (LDKSocketDescriptor_JCalls*) this_arg;
	JNIEnv *env;
	jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
	} else {
		DO_ASSERT(get_jenv_res == JNI_OK);
	}
	jobject obj = (*env)->NewLocalRef(env, j_calls->o);
	CHECK(obj != NULL);
	int64_t ret = (*env)->CallLongMethod(env, obj, j_calls->hash_meth);
	if ((*env)->ExceptionCheck(env)) {
		(*env)->ExceptionDescribe(env);
		(*env)->FatalError(env, "A call to hash in LDKSocketDescriptor from rust threw an exception.");
	}
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
	}
	return ret;
}
static void LDKSocketDescriptor_JCalls_cloned(LDKSocketDescriptor* new_obj) {
	LDKSocketDescriptor_JCalls *j_calls = (LDKSocketDescriptor_JCalls*) new_obj->this_arg;
	atomic_fetch_add_explicit(&j_calls->refcnt, 1, memory_order_release);
}
static inline LDKSocketDescriptor LDKSocketDescriptor_init (JNIEnv *env, jclass clz, jobject o) {
	jclass c = (*env)->GetObjectClass(env, o);
	CHECK(c != NULL);
	LDKSocketDescriptor_JCalls *calls = MALLOC(sizeof(LDKSocketDescriptor_JCalls), "LDKSocketDescriptor_JCalls");
	atomic_init(&calls->refcnt, 1);
	DO_ASSERT((*env)->GetJavaVM(env, &calls->vm) == 0);
	calls->o = (*env)->NewWeakGlobalRef(env, o);
	calls->send_data_meth = (*env)->GetMethodID(env, c, "send_data", "([BZ)J");
	CHECK(calls->send_data_meth != NULL);
	calls->disconnect_socket_meth = (*env)->GetMethodID(env, c, "disconnect_socket", "()V");
	CHECK(calls->disconnect_socket_meth != NULL);
	calls->eq_meth = (*env)->GetMethodID(env, c, "eq", "(J)Z");
	CHECK(calls->eq_meth != NULL);
	calls->hash_meth = (*env)->GetMethodID(env, c, "hash", "()J");
	CHECK(calls->hash_meth != NULL);

	LDKSocketDescriptor ret = {
		.this_arg = (void*) calls,
		.send_data = send_data_LDKSocketDescriptor_jcall,
		.disconnect_socket = disconnect_socket_LDKSocketDescriptor_jcall,
		.eq = eq_LDKSocketDescriptor_jcall,
		.hash = hash_LDKSocketDescriptor_jcall,
		.cloned = LDKSocketDescriptor_JCalls_cloned,
		.free = LDKSocketDescriptor_JCalls_free,
	};
	return ret;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKSocketDescriptor_1new(JNIEnv *env, jclass clz, jobject o) {
	LDKSocketDescriptor *res_ptr = MALLOC(sizeof(LDKSocketDescriptor), "LDKSocketDescriptor");
	*res_ptr = LDKSocketDescriptor_init(env, clz, o);
	return (uint64_t)res_ptr;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_SocketDescriptor_1send_1data(JNIEnv *env, jclass clz, int64_t this_arg, int8_tArray data, jboolean resume_read) {
	void* this_arg_ptr = (void*)(((uint64_t)this_arg) & ~1);
	if (!(this_arg & 1)) { CHECK_ACCESS(this_arg_ptr); }
	LDKSocketDescriptor* this_arg_conv = (LDKSocketDescriptor*)this_arg_ptr;
	LDKu8slice data_ref;
	data_ref.datalen = (*env)->GetArrayLength(env, data);
	data_ref.data = (*env)->GetByteArrayElements (env, data, NULL);
	int64_t ret_val = (this_arg_conv->send_data)(this_arg_conv->this_arg, data_ref, resume_read);
	(*env)->ReleaseByteArrayElements(env, data, (int8_t*)data_ref.data, 0);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_SocketDescriptor_1disconnect_1socket(JNIEnv *env, jclass clz, int64_t this_arg) {
	void* this_arg_ptr = (void*)(((uint64_t)this_arg) & ~1);
	if (!(this_arg & 1)) { CHECK_ACCESS(this_arg_ptr); }
	LDKSocketDescriptor* this_arg_conv = (LDKSocketDescriptor*)this_arg_ptr;
	(this_arg_conv->disconnect_socket)(this_arg_conv->this_arg);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_SocketDescriptor_1hash(JNIEnv *env, jclass clz, int64_t this_arg) {
	void* this_arg_ptr = (void*)(((uint64_t)this_arg) & ~1);
	if (!(this_arg & 1)) { CHECK_ACCESS(this_arg_ptr); }
	LDKSocketDescriptor* this_arg_conv = (LDKSocketDescriptor*)this_arg_ptr;
	int64_t ret_val = (this_arg_conv->hash)(this_arg_conv->this_arg);
	return ret_val;
}

typedef struct LDKScore_JCalls {
	atomic_size_t refcnt;
	JavaVM *vm;
	jweak o;
	jmethodID channel_penalty_msat_meth;
	jmethodID payment_path_failed_meth;
} LDKScore_JCalls;
static void LDKScore_JCalls_free(void* this_arg) {
	LDKScore_JCalls *j_calls = (LDKScore_JCalls*) this_arg;
	if (atomic_fetch_sub_explicit(&j_calls->refcnt, 1, memory_order_acquire) == 1) {
		JNIEnv *env;
		jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
		if (get_jenv_res == JNI_EDETACHED) {
			DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
		} else {
			DO_ASSERT(get_jenv_res == JNI_OK);
		}
		(*env)->DeleteWeakGlobalRef(env, j_calls->o);
		if (get_jenv_res == JNI_EDETACHED) {
			DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
		}
		FREE(j_calls);
	}
}
uint64_t channel_penalty_msat_LDKScore_jcall(const void* this_arg, uint64_t short_channel_id, const LDKNodeId * source, const LDKNodeId * target) {
	LDKScore_JCalls *j_calls = (LDKScore_JCalls*) this_arg;
	JNIEnv *env;
	jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
	} else {
		DO_ASSERT(get_jenv_res == JNI_OK);
	}
	LDKNodeId source_var = *source;
	uint64_t source_ref = 0;
	source_var = NodeId_clone(source);
	CHECK((((uint64_t)source_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&source_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	source_ref = (uint64_t)source_var.inner;
	if (source_var.is_owned) {
		source_ref |= 1;
	}
	LDKNodeId target_var = *target;
	uint64_t target_ref = 0;
	target_var = NodeId_clone(target);
	CHECK((((uint64_t)target_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&target_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	target_ref = (uint64_t)target_var.inner;
	if (target_var.is_owned) {
		target_ref |= 1;
	}
	jobject obj = (*env)->NewLocalRef(env, j_calls->o);
	CHECK(obj != NULL);
	int64_t ret = (*env)->CallLongMethod(env, obj, j_calls->channel_penalty_msat_meth, short_channel_id, source_ref, target_ref);
	if ((*env)->ExceptionCheck(env)) {
		(*env)->ExceptionDescribe(env);
		(*env)->FatalError(env, "A call to channel_penalty_msat in LDKScore from rust threw an exception.");
	}
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
	}
	return ret;
}
void payment_path_failed_LDKScore_jcall(void* this_arg, LDKCVec_RouteHopZ path, uint64_t short_channel_id) {
	LDKScore_JCalls *j_calls = (LDKScore_JCalls*) this_arg;
	JNIEnv *env;
	jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
	} else {
		DO_ASSERT(get_jenv_res == JNI_OK);
	}
	LDKCVec_RouteHopZ path_var = path;
	int64_tArray path_arr = NULL;
	path_arr = (*env)->NewLongArray(env, path_var.datalen);
	int64_t *path_arr_ptr = (*env)->GetPrimitiveArrayCritical(env, path_arr, NULL);
	for (size_t k = 0; k < path_var.datalen; k++) {
		LDKRouteHop path_conv_10_var = path_var.data[k];
		uint64_t path_conv_10_ref = 0;
		CHECK((((uint64_t)path_conv_10_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
		CHECK((((uint64_t)&path_conv_10_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
		path_conv_10_ref = (uint64_t)path_conv_10_var.inner;
		if (path_conv_10_var.is_owned) {
			path_conv_10_ref |= 1;
		}
		path_arr_ptr[k] = path_conv_10_ref;
	}
	(*env)->ReleasePrimitiveArrayCritical(env, path_arr, path_arr_ptr, 0);
	FREE(path_var.data);
	jobject obj = (*env)->NewLocalRef(env, j_calls->o);
	CHECK(obj != NULL);
	(*env)->CallVoidMethod(env, obj, j_calls->payment_path_failed_meth, path_arr, short_channel_id);
	if ((*env)->ExceptionCheck(env)) {
		(*env)->ExceptionDescribe(env);
		(*env)->FatalError(env, "A call to payment_path_failed in LDKScore from rust threw an exception.");
	}
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
	}
}
static void LDKScore_JCalls_cloned(LDKScore* new_obj) {
	LDKScore_JCalls *j_calls = (LDKScore_JCalls*) new_obj->this_arg;
	atomic_fetch_add_explicit(&j_calls->refcnt, 1, memory_order_release);
}
static inline LDKScore LDKScore_init (JNIEnv *env, jclass clz, jobject o) {
	jclass c = (*env)->GetObjectClass(env, o);
	CHECK(c != NULL);
	LDKScore_JCalls *calls = MALLOC(sizeof(LDKScore_JCalls), "LDKScore_JCalls");
	atomic_init(&calls->refcnt, 1);
	DO_ASSERT((*env)->GetJavaVM(env, &calls->vm) == 0);
	calls->o = (*env)->NewWeakGlobalRef(env, o);
	calls->channel_penalty_msat_meth = (*env)->GetMethodID(env, c, "channel_penalty_msat", "(JJJ)J");
	CHECK(calls->channel_penalty_msat_meth != NULL);
	calls->payment_path_failed_meth = (*env)->GetMethodID(env, c, "payment_path_failed", "([JJ)V");
	CHECK(calls->payment_path_failed_meth != NULL);

	LDKScore ret = {
		.this_arg = (void*) calls,
		.channel_penalty_msat = channel_penalty_msat_LDKScore_jcall,
		.payment_path_failed = payment_path_failed_LDKScore_jcall,
		.free = LDKScore_JCalls_free,
	};
	return ret;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKScore_1new(JNIEnv *env, jclass clz, jobject o) {
	LDKScore *res_ptr = MALLOC(sizeof(LDKScore), "LDKScore");
	*res_ptr = LDKScore_init(env, clz, o);
	return (uint64_t)res_ptr;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_Score_1channel_1penalty_1msat(JNIEnv *env, jclass clz, int64_t this_arg, int64_t short_channel_id, int64_t source, int64_t target) {
	void* this_arg_ptr = (void*)(((uint64_t)this_arg) & ~1);
	if (!(this_arg & 1)) { CHECK_ACCESS(this_arg_ptr); }
	LDKScore* this_arg_conv = (LDKScore*)this_arg_ptr;
	LDKNodeId source_conv;
	source_conv.inner = (void*)(source & (~1));
	source_conv.is_owned = false;
	LDKNodeId target_conv;
	target_conv.inner = (void*)(target & (~1));
	target_conv.is_owned = false;
	int64_t ret_val = (this_arg_conv->channel_penalty_msat)(this_arg_conv->this_arg, short_channel_id, &source_conv, &target_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_Score_1payment_1path_1failed(JNIEnv *env, jclass clz, int64_t this_arg, int64_tArray path, int64_t short_channel_id) {
	void* this_arg_ptr = (void*)(((uint64_t)this_arg) & ~1);
	if (!(this_arg & 1)) { CHECK_ACCESS(this_arg_ptr); }
	LDKScore* this_arg_conv = (LDKScore*)this_arg_ptr;
	LDKCVec_RouteHopZ path_constr;
	path_constr.datalen = (*env)->GetArrayLength(env, path);
	if (path_constr.datalen > 0)
		path_constr.data = MALLOC(path_constr.datalen * sizeof(LDKRouteHop), "LDKCVec_RouteHopZ Elements");
	else
		path_constr.data = NULL;
	int64_t* path_vals = (*env)->GetLongArrayElements (env, path, NULL);
	for (size_t k = 0; k < path_constr.datalen; k++) {
		int64_t path_conv_10 = path_vals[k];
		LDKRouteHop path_conv_10_conv;
		path_conv_10_conv.inner = (void*)(path_conv_10 & (~1));
		path_conv_10_conv.is_owned = (path_conv_10 & 1) || (path_conv_10 == 0);
		path_conv_10_conv = RouteHop_clone(&path_conv_10_conv);
		path_constr.data[k] = path_conv_10_conv;
	}
	(*env)->ReleaseLongArrayElements(env, path, path_vals, 0);
	(this_arg_conv->payment_path_failed)(this_arg_conv->this_arg, path_constr, short_channel_id);
}

typedef struct LDKChannelManagerPersister_JCalls {
	atomic_size_t refcnt;
	JavaVM *vm;
	jweak o;
	jmethodID persist_manager_meth;
} LDKChannelManagerPersister_JCalls;
static void LDKChannelManagerPersister_JCalls_free(void* this_arg) {
	LDKChannelManagerPersister_JCalls *j_calls = (LDKChannelManagerPersister_JCalls*) this_arg;
	if (atomic_fetch_sub_explicit(&j_calls->refcnt, 1, memory_order_acquire) == 1) {
		JNIEnv *env;
		jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
		if (get_jenv_res == JNI_EDETACHED) {
			DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
		} else {
			DO_ASSERT(get_jenv_res == JNI_OK);
		}
		(*env)->DeleteWeakGlobalRef(env, j_calls->o);
		if (get_jenv_res == JNI_EDETACHED) {
			DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
		}
		FREE(j_calls);
	}
}
LDKCResult_NoneErrorZ persist_manager_LDKChannelManagerPersister_jcall(const void* this_arg, const LDKChannelManager * channel_manager) {
	LDKChannelManagerPersister_JCalls *j_calls = (LDKChannelManagerPersister_JCalls*) this_arg;
	JNIEnv *env;
	jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
	} else {
		DO_ASSERT(get_jenv_res == JNI_OK);
	}
	LDKChannelManager channel_manager_var = *channel_manager;
	uint64_t channel_manager_ref = 0;
	// Warning: we may need a move here but no clone is available for LDKChannelManager
	CHECK((((uint64_t)channel_manager_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&channel_manager_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	channel_manager_ref = (uint64_t)channel_manager_var.inner;
	if (channel_manager_var.is_owned) {
		channel_manager_ref |= 1;
	}
	jobject obj = (*env)->NewLocalRef(env, j_calls->o);
	CHECK(obj != NULL);
	uint64_t ret = (*env)->CallLongMethod(env, obj, j_calls->persist_manager_meth, channel_manager_ref);
	if ((*env)->ExceptionCheck(env)) {
		(*env)->ExceptionDescribe(env);
		(*env)->FatalError(env, "A call to persist_manager in LDKChannelManagerPersister from rust threw an exception.");
	}
	void* ret_ptr = (void*)(((uint64_t)ret) & ~1);
	CHECK_ACCESS(ret_ptr);
	LDKCResult_NoneErrorZ ret_conv = *(LDKCResult_NoneErrorZ*)(ret_ptr);
	ret_conv = CResult_NoneErrorZ_clone((LDKCResult_NoneErrorZ*)(((uint64_t)ret) & ~1));
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
	}
	return ret_conv;
}
static void LDKChannelManagerPersister_JCalls_cloned(LDKChannelManagerPersister* new_obj) {
	LDKChannelManagerPersister_JCalls *j_calls = (LDKChannelManagerPersister_JCalls*) new_obj->this_arg;
	atomic_fetch_add_explicit(&j_calls->refcnt, 1, memory_order_release);
}
static inline LDKChannelManagerPersister LDKChannelManagerPersister_init (JNIEnv *env, jclass clz, jobject o) {
	jclass c = (*env)->GetObjectClass(env, o);
	CHECK(c != NULL);
	LDKChannelManagerPersister_JCalls *calls = MALLOC(sizeof(LDKChannelManagerPersister_JCalls), "LDKChannelManagerPersister_JCalls");
	atomic_init(&calls->refcnt, 1);
	DO_ASSERT((*env)->GetJavaVM(env, &calls->vm) == 0);
	calls->o = (*env)->NewWeakGlobalRef(env, o);
	calls->persist_manager_meth = (*env)->GetMethodID(env, c, "persist_manager", "(J)J");
	CHECK(calls->persist_manager_meth != NULL);

	LDKChannelManagerPersister ret = {
		.this_arg = (void*) calls,
		.persist_manager = persist_manager_LDKChannelManagerPersister_jcall,
		.free = LDKChannelManagerPersister_JCalls_free,
	};
	return ret;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKChannelManagerPersister_1new(JNIEnv *env, jclass clz, jobject o) {
	LDKChannelManagerPersister *res_ptr = MALLOC(sizeof(LDKChannelManagerPersister), "LDKChannelManagerPersister");
	*res_ptr = LDKChannelManagerPersister_init(env, clz, o);
	return (uint64_t)res_ptr;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelManagerPersister_1persist_1manager(JNIEnv *env, jclass clz, int64_t this_arg, int64_t channel_manager) {
	void* this_arg_ptr = (void*)(((uint64_t)this_arg) & ~1);
	if (!(this_arg & 1)) { CHECK_ACCESS(this_arg_ptr); }
	LDKChannelManagerPersister* this_arg_conv = (LDKChannelManagerPersister*)this_arg_ptr;
	LDKChannelManager channel_manager_conv;
	channel_manager_conv.inner = (void*)(channel_manager & (~1));
	channel_manager_conv.is_owned = false;
	LDKCResult_NoneErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_NoneErrorZ), "LDKCResult_NoneErrorZ");
	*ret_conv = (this_arg_conv->persist_manager)(this_arg_conv->this_arg, &channel_manager_conv);
	return (uint64_t)ret_conv;
}

static jclass LDKFallback_SegWitProgram_class = NULL;
static jmethodID LDKFallback_SegWitProgram_meth = NULL;
static jclass LDKFallback_PubKeyHash_class = NULL;
static jmethodID LDKFallback_PubKeyHash_meth = NULL;
static jclass LDKFallback_ScriptHash_class = NULL;
static jmethodID LDKFallback_ScriptHash_meth = NULL;
JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_00024LDKFallback_init (JNIEnv *env, jclass clz) {
	LDKFallback_SegWitProgram_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKFallback$SegWitProgram;"));
	CHECK(LDKFallback_SegWitProgram_class != NULL);
	LDKFallback_SegWitProgram_meth = (*env)->GetMethodID(env, LDKFallback_SegWitProgram_class, "<init>", "(B[B)V");
	CHECK(LDKFallback_SegWitProgram_meth != NULL);
	LDKFallback_PubKeyHash_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKFallback$PubKeyHash;"));
	CHECK(LDKFallback_PubKeyHash_class != NULL);
	LDKFallback_PubKeyHash_meth = (*env)->GetMethodID(env, LDKFallback_PubKeyHash_class, "<init>", "([B)V");
	CHECK(LDKFallback_PubKeyHash_meth != NULL);
	LDKFallback_ScriptHash_class =
		(*env)->NewGlobalRef(env, (*env)->FindClass(env, "Lorg/ldk/impl/bindings$LDKFallback$ScriptHash;"));
	CHECK(LDKFallback_ScriptHash_class != NULL);
	LDKFallback_ScriptHash_meth = (*env)->GetMethodID(env, LDKFallback_ScriptHash_class, "<init>", "([B)V");
	CHECK(LDKFallback_ScriptHash_meth != NULL);
}
JNIEXPORT jobject JNICALL Java_org_ldk_impl_bindings_LDKFallback_1ref_1from_1ptr(JNIEnv *env, jclass clz, int64_t ptr) {
	LDKFallback *obj = (LDKFallback*)(ptr & ~1);
	switch(obj->tag) {
		case LDKFallback_SegWitProgram: {
			uint8_t version_val = obj->seg_wit_program.version._0;
			LDKCVec_u8Z program_var = obj->seg_wit_program.program;
			int8_tArray program_arr = (*env)->NewByteArray(env, program_var.datalen);
			(*env)->SetByteArrayRegion(env, program_arr, 0, program_var.datalen, program_var.data);
			return (*env)->NewObject(env, LDKFallback_SegWitProgram_class, LDKFallback_SegWitProgram_meth, version_val, program_arr);
		}
		case LDKFallback_PubKeyHash: {
			int8_tArray pub_key_hash_arr = (*env)->NewByteArray(env, 20);
			(*env)->SetByteArrayRegion(env, pub_key_hash_arr, 0, 20, obj->pub_key_hash.data);
			return (*env)->NewObject(env, LDKFallback_PubKeyHash_class, LDKFallback_PubKeyHash_meth, pub_key_hash_arr);
		}
		case LDKFallback_ScriptHash: {
			int8_tArray script_hash_arr = (*env)->NewByteArray(env, 20);
			(*env)->SetByteArrayRegion(env, script_hash_arr, 0, 20, obj->script_hash.data);
			return (*env)->NewObject(env, LDKFallback_ScriptHash_class, LDKFallback_ScriptHash_meth, script_hash_arr);
		}
		default: abort();
	}
}
typedef struct LDKPayer_JCalls {
	atomic_size_t refcnt;
	JavaVM *vm;
	jweak o;
	jmethodID node_id_meth;
	jmethodID first_hops_meth;
	jmethodID send_payment_meth;
	jmethodID retry_payment_meth;
} LDKPayer_JCalls;
static void LDKPayer_JCalls_free(void* this_arg) {
	LDKPayer_JCalls *j_calls = (LDKPayer_JCalls*) this_arg;
	if (atomic_fetch_sub_explicit(&j_calls->refcnt, 1, memory_order_acquire) == 1) {
		JNIEnv *env;
		jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
		if (get_jenv_res == JNI_EDETACHED) {
			DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
		} else {
			DO_ASSERT(get_jenv_res == JNI_OK);
		}
		(*env)->DeleteWeakGlobalRef(env, j_calls->o);
		if (get_jenv_res == JNI_EDETACHED) {
			DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
		}
		FREE(j_calls);
	}
}
LDKPublicKey node_id_LDKPayer_jcall(const void* this_arg) {
	LDKPayer_JCalls *j_calls = (LDKPayer_JCalls*) this_arg;
	JNIEnv *env;
	jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
	} else {
		DO_ASSERT(get_jenv_res == JNI_OK);
	}
	jobject obj = (*env)->NewLocalRef(env, j_calls->o);
	CHECK(obj != NULL);
	int8_tArray ret = (*env)->CallObjectMethod(env, obj, j_calls->node_id_meth);
	if ((*env)->ExceptionCheck(env)) {
		(*env)->ExceptionDescribe(env);
		(*env)->FatalError(env, "A call to node_id in LDKPayer from rust threw an exception.");
	}
	LDKPublicKey ret_ref;
	CHECK((*env)->GetArrayLength(env, ret) == 33);
	(*env)->GetByteArrayRegion(env, ret, 0, 33, ret_ref.compressed_form);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
	}
	return ret_ref;
}
LDKCVec_ChannelDetailsZ first_hops_LDKPayer_jcall(const void* this_arg) {
	LDKPayer_JCalls *j_calls = (LDKPayer_JCalls*) this_arg;
	JNIEnv *env;
	jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
	} else {
		DO_ASSERT(get_jenv_res == JNI_OK);
	}
	jobject obj = (*env)->NewLocalRef(env, j_calls->o);
	CHECK(obj != NULL);
	int64_tArray ret = (*env)->CallObjectMethod(env, obj, j_calls->first_hops_meth);
	if ((*env)->ExceptionCheck(env)) {
		(*env)->ExceptionDescribe(env);
		(*env)->FatalError(env, "A call to first_hops in LDKPayer from rust threw an exception.");
	}
	LDKCVec_ChannelDetailsZ ret_constr;
	ret_constr.datalen = (*env)->GetArrayLength(env, ret);
	if (ret_constr.datalen > 0)
		ret_constr.data = MALLOC(ret_constr.datalen * sizeof(LDKChannelDetails), "LDKCVec_ChannelDetailsZ Elements");
	else
		ret_constr.data = NULL;
	int64_t* ret_vals = (*env)->GetLongArrayElements (env, ret, NULL);
	for (size_t q = 0; q < ret_constr.datalen; q++) {
		int64_t ret_conv_16 = ret_vals[q];
		LDKChannelDetails ret_conv_16_conv;
		ret_conv_16_conv.inner = (void*)(ret_conv_16 & (~1));
		ret_conv_16_conv.is_owned = (ret_conv_16 & 1) || (ret_conv_16 == 0);
		ret_conv_16_conv = ChannelDetails_clone(&ret_conv_16_conv);
		ret_constr.data[q] = ret_conv_16_conv;
	}
	(*env)->ReleaseLongArrayElements(env, ret, ret_vals, 0);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
	}
	return ret_constr;
}
LDKCResult_PaymentIdPaymentSendFailureZ send_payment_LDKPayer_jcall(const void* this_arg, const LDKRoute * route, LDKThirtyTwoBytes payment_hash, LDKThirtyTwoBytes payment_secret) {
	LDKPayer_JCalls *j_calls = (LDKPayer_JCalls*) this_arg;
	JNIEnv *env;
	jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
	} else {
		DO_ASSERT(get_jenv_res == JNI_OK);
	}
	LDKRoute route_var = *route;
	uint64_t route_ref = 0;
	route_var = Route_clone(route);
	CHECK((((uint64_t)route_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&route_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	route_ref = (uint64_t)route_var.inner;
	if (route_var.is_owned) {
		route_ref |= 1;
	}
	int8_tArray payment_hash_arr = (*env)->NewByteArray(env, 32);
	(*env)->SetByteArrayRegion(env, payment_hash_arr, 0, 32, payment_hash.data);
	int8_tArray payment_secret_arr = (*env)->NewByteArray(env, 32);
	(*env)->SetByteArrayRegion(env, payment_secret_arr, 0, 32, payment_secret.data);
	jobject obj = (*env)->NewLocalRef(env, j_calls->o);
	CHECK(obj != NULL);
	uint64_t ret = (*env)->CallLongMethod(env, obj, j_calls->send_payment_meth, route_ref, payment_hash_arr, payment_secret_arr);
	if ((*env)->ExceptionCheck(env)) {
		(*env)->ExceptionDescribe(env);
		(*env)->FatalError(env, "A call to send_payment in LDKPayer from rust threw an exception.");
	}
	void* ret_ptr = (void*)(((uint64_t)ret) & ~1);
	CHECK_ACCESS(ret_ptr);
	LDKCResult_PaymentIdPaymentSendFailureZ ret_conv = *(LDKCResult_PaymentIdPaymentSendFailureZ*)(ret_ptr);
	ret_conv = CResult_PaymentIdPaymentSendFailureZ_clone((LDKCResult_PaymentIdPaymentSendFailureZ*)(((uint64_t)ret) & ~1));
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
	}
	return ret_conv;
}
LDKCResult_NonePaymentSendFailureZ retry_payment_LDKPayer_jcall(const void* this_arg, const LDKRoute * route, LDKThirtyTwoBytes payment_id) {
	LDKPayer_JCalls *j_calls = (LDKPayer_JCalls*) this_arg;
	JNIEnv *env;
	jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
	} else {
		DO_ASSERT(get_jenv_res == JNI_OK);
	}
	LDKRoute route_var = *route;
	uint64_t route_ref = 0;
	route_var = Route_clone(route);
	CHECK((((uint64_t)route_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&route_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	route_ref = (uint64_t)route_var.inner;
	if (route_var.is_owned) {
		route_ref |= 1;
	}
	int8_tArray payment_id_arr = (*env)->NewByteArray(env, 32);
	(*env)->SetByteArrayRegion(env, payment_id_arr, 0, 32, payment_id.data);
	jobject obj = (*env)->NewLocalRef(env, j_calls->o);
	CHECK(obj != NULL);
	uint64_t ret = (*env)->CallLongMethod(env, obj, j_calls->retry_payment_meth, route_ref, payment_id_arr);
	if ((*env)->ExceptionCheck(env)) {
		(*env)->ExceptionDescribe(env);
		(*env)->FatalError(env, "A call to retry_payment in LDKPayer from rust threw an exception.");
	}
	void* ret_ptr = (void*)(((uint64_t)ret) & ~1);
	CHECK_ACCESS(ret_ptr);
	LDKCResult_NonePaymentSendFailureZ ret_conv = *(LDKCResult_NonePaymentSendFailureZ*)(ret_ptr);
	ret_conv = CResult_NonePaymentSendFailureZ_clone((LDKCResult_NonePaymentSendFailureZ*)(((uint64_t)ret) & ~1));
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
	}
	return ret_conv;
}
static void LDKPayer_JCalls_cloned(LDKPayer* new_obj) {
	LDKPayer_JCalls *j_calls = (LDKPayer_JCalls*) new_obj->this_arg;
	atomic_fetch_add_explicit(&j_calls->refcnt, 1, memory_order_release);
}
static inline LDKPayer LDKPayer_init (JNIEnv *env, jclass clz, jobject o) {
	jclass c = (*env)->GetObjectClass(env, o);
	CHECK(c != NULL);
	LDKPayer_JCalls *calls = MALLOC(sizeof(LDKPayer_JCalls), "LDKPayer_JCalls");
	atomic_init(&calls->refcnt, 1);
	DO_ASSERT((*env)->GetJavaVM(env, &calls->vm) == 0);
	calls->o = (*env)->NewWeakGlobalRef(env, o);
	calls->node_id_meth = (*env)->GetMethodID(env, c, "node_id", "()[B");
	CHECK(calls->node_id_meth != NULL);
	calls->first_hops_meth = (*env)->GetMethodID(env, c, "first_hops", "()[J");
	CHECK(calls->first_hops_meth != NULL);
	calls->send_payment_meth = (*env)->GetMethodID(env, c, "send_payment", "(J[B[B)J");
	CHECK(calls->send_payment_meth != NULL);
	calls->retry_payment_meth = (*env)->GetMethodID(env, c, "retry_payment", "(J[B)J");
	CHECK(calls->retry_payment_meth != NULL);

	LDKPayer ret = {
		.this_arg = (void*) calls,
		.node_id = node_id_LDKPayer_jcall,
		.first_hops = first_hops_LDKPayer_jcall,
		.send_payment = send_payment_LDKPayer_jcall,
		.retry_payment = retry_payment_LDKPayer_jcall,
		.free = LDKPayer_JCalls_free,
	};
	return ret;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKPayer_1new(JNIEnv *env, jclass clz, jobject o) {
	LDKPayer *res_ptr = MALLOC(sizeof(LDKPayer), "LDKPayer");
	*res_ptr = LDKPayer_init(env, clz, o);
	return (uint64_t)res_ptr;
}
JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_Payer_1node_1id(JNIEnv *env, jclass clz, int64_t this_arg) {
	void* this_arg_ptr = (void*)(((uint64_t)this_arg) & ~1);
	if (!(this_arg & 1)) { CHECK_ACCESS(this_arg_ptr); }
	LDKPayer* this_arg_conv = (LDKPayer*)this_arg_ptr;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 33);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 33, (this_arg_conv->node_id)(this_arg_conv->this_arg).compressed_form);
	return ret_arr;
}

JNIEXPORT int64_tArray JNICALL Java_org_ldk_impl_bindings_Payer_1first_1hops(JNIEnv *env, jclass clz, int64_t this_arg) {
	void* this_arg_ptr = (void*)(((uint64_t)this_arg) & ~1);
	if (!(this_arg & 1)) { CHECK_ACCESS(this_arg_ptr); }
	LDKPayer* this_arg_conv = (LDKPayer*)this_arg_ptr;
	LDKCVec_ChannelDetailsZ ret_var = (this_arg_conv->first_hops)(this_arg_conv->this_arg);
	int64_tArray ret_arr = NULL;
	ret_arr = (*env)->NewLongArray(env, ret_var.datalen);
	int64_t *ret_arr_ptr = (*env)->GetPrimitiveArrayCritical(env, ret_arr, NULL);
	for (size_t q = 0; q < ret_var.datalen; q++) {
		LDKChannelDetails ret_conv_16_var = ret_var.data[q];
		uint64_t ret_conv_16_ref = 0;
		CHECK((((uint64_t)ret_conv_16_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
		CHECK((((uint64_t)&ret_conv_16_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
		ret_conv_16_ref = (uint64_t)ret_conv_16_var.inner;
		if (ret_conv_16_var.is_owned) {
			ret_conv_16_ref |= 1;
		}
		ret_arr_ptr[q] = ret_conv_16_ref;
	}
	(*env)->ReleasePrimitiveArrayCritical(env, ret_arr, ret_arr_ptr, 0);
	FREE(ret_var.data);
	return ret_arr;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_Payer_1send_1payment(JNIEnv *env, jclass clz, int64_t this_arg, int64_t route, int8_tArray payment_hash, int8_tArray payment_secret) {
	void* this_arg_ptr = (void*)(((uint64_t)this_arg) & ~1);
	if (!(this_arg & 1)) { CHECK_ACCESS(this_arg_ptr); }
	LDKPayer* this_arg_conv = (LDKPayer*)this_arg_ptr;
	LDKRoute route_conv;
	route_conv.inner = (void*)(route & (~1));
	route_conv.is_owned = false;
	LDKThirtyTwoBytes payment_hash_ref;
	CHECK((*env)->GetArrayLength(env, payment_hash) == 32);
	(*env)->GetByteArrayRegion(env, payment_hash, 0, 32, payment_hash_ref.data);
	LDKThirtyTwoBytes payment_secret_ref;
	CHECK((*env)->GetArrayLength(env, payment_secret) == 32);
	(*env)->GetByteArrayRegion(env, payment_secret, 0, 32, payment_secret_ref.data);
	LDKCResult_PaymentIdPaymentSendFailureZ* ret_conv = MALLOC(sizeof(LDKCResult_PaymentIdPaymentSendFailureZ), "LDKCResult_PaymentIdPaymentSendFailureZ");
	*ret_conv = (this_arg_conv->send_payment)(this_arg_conv->this_arg, &route_conv, payment_hash_ref, payment_secret_ref);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_Payer_1retry_1payment(JNIEnv *env, jclass clz, int64_t this_arg, int64_t route, int8_tArray payment_id) {
	void* this_arg_ptr = (void*)(((uint64_t)this_arg) & ~1);
	if (!(this_arg & 1)) { CHECK_ACCESS(this_arg_ptr); }
	LDKPayer* this_arg_conv = (LDKPayer*)this_arg_ptr;
	LDKRoute route_conv;
	route_conv.inner = (void*)(route & (~1));
	route_conv.is_owned = false;
	LDKThirtyTwoBytes payment_id_ref;
	CHECK((*env)->GetArrayLength(env, payment_id) == 32);
	(*env)->GetByteArrayRegion(env, payment_id, 0, 32, payment_id_ref.data);
	LDKCResult_NonePaymentSendFailureZ* ret_conv = MALLOC(sizeof(LDKCResult_NonePaymentSendFailureZ), "LDKCResult_NonePaymentSendFailureZ");
	*ret_conv = (this_arg_conv->retry_payment)(this_arg_conv->this_arg, &route_conv, payment_id_ref);
	return (uint64_t)ret_conv;
}

typedef struct LDKRouter_JCalls {
	atomic_size_t refcnt;
	JavaVM *vm;
	jweak o;
	jmethodID find_route_meth;
} LDKRouter_JCalls;
static void LDKRouter_JCalls_free(void* this_arg) {
	LDKRouter_JCalls *j_calls = (LDKRouter_JCalls*) this_arg;
	if (atomic_fetch_sub_explicit(&j_calls->refcnt, 1, memory_order_acquire) == 1) {
		JNIEnv *env;
		jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
		if (get_jenv_res == JNI_EDETACHED) {
			DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
		} else {
			DO_ASSERT(get_jenv_res == JNI_OK);
		}
		(*env)->DeleteWeakGlobalRef(env, j_calls->o);
		if (get_jenv_res == JNI_EDETACHED) {
			DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
		}
		FREE(j_calls);
	}
}
LDKCResult_RouteLightningErrorZ find_route_LDKRouter_jcall(const void* this_arg, LDKPublicKey payer, const LDKRouteParameters * params, LDKCVec_ChannelDetailsZ * first_hops, const LDKScore * scorer) {
	LDKRouter_JCalls *j_calls = (LDKRouter_JCalls*) this_arg;
	JNIEnv *env;
	jint get_jenv_res = (*j_calls->vm)->GetEnv(j_calls->vm, (void**)&env, JNI_VERSION_1_6);
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->AttachCurrentThread(j_calls->vm, (void**)&env, NULL) == JNI_OK);
	} else {
		DO_ASSERT(get_jenv_res == JNI_OK);
	}
	int8_tArray payer_arr = (*env)->NewByteArray(env, 33);
	(*env)->SetByteArrayRegion(env, payer_arr, 0, 33, payer.compressed_form);
	LDKRouteParameters params_var = *params;
	uint64_t params_ref = 0;
	params_var = RouteParameters_clone(params);
	CHECK((((uint64_t)params_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&params_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	params_ref = (uint64_t)params_var.inner;
	if (params_var.is_owned) {
		params_ref |= 1;
	}
	LDKCVec_ChannelDetailsZ *first_hops_var_ptr = first_hops;
	int64_tArray first_hops_arr = NULL;
	if (first_hops != NULL) {
		LDKCVec_ChannelDetailsZ first_hops_var = *first_hops_var_ptr;
		first_hops_arr = (*env)->NewLongArray(env, first_hops_var.datalen);
		int64_t *first_hops_arr_ptr = (*env)->GetPrimitiveArrayCritical(env, first_hops_arr, NULL);
		for (size_t q = 0; q < first_hops_var.datalen; q++) {
			LDKChannelDetails first_hops_conv_16_var = 	first_hops_var.data[q];
			uint64_t first_hops_conv_16_ref = 0;
			CHECK((((uint64_t)first_hops_conv_16_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
			CHECK((((uint64_t)&first_hops_conv_16_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
			first_hops_conv_16_ref = (uint64_t)first_hops_conv_16_var.inner;
			if (first_hops_conv_16_var.is_owned) {
				first_hops_conv_16_ref |= 1;
			}
			first_hops_arr_ptr[q] = first_hops_conv_16_ref;
		}
		(*env)->ReleasePrimitiveArrayCritical(env, first_hops_arr, first_hops_arr_ptr, 0);
	}
	uint64_t ret_scorer = ((uint64_t)scorer)|1;
	jobject obj = (*env)->NewLocalRef(env, j_calls->o);
	CHECK(obj != NULL);
	uint64_t ret = (*env)->CallLongMethod(env, obj, j_calls->find_route_meth, payer_arr, params_ref, first_hops_arr, ret_scorer);
	if ((*env)->ExceptionCheck(env)) {
		(*env)->ExceptionDescribe(env);
		(*env)->FatalError(env, "A call to find_route in LDKRouter from rust threw an exception.");
	}
	void* ret_ptr = (void*)(((uint64_t)ret) & ~1);
	CHECK_ACCESS(ret_ptr);
	LDKCResult_RouteLightningErrorZ ret_conv = *(LDKCResult_RouteLightningErrorZ*)(ret_ptr);
	ret_conv = CResult_RouteLightningErrorZ_clone((LDKCResult_RouteLightningErrorZ*)(((uint64_t)ret) & ~1));
	if (get_jenv_res == JNI_EDETACHED) {
		DO_ASSERT((*j_calls->vm)->DetachCurrentThread(j_calls->vm) == JNI_OK);
	}
	return ret_conv;
}
static void LDKRouter_JCalls_cloned(LDKRouter* new_obj) {
	LDKRouter_JCalls *j_calls = (LDKRouter_JCalls*) new_obj->this_arg;
	atomic_fetch_add_explicit(&j_calls->refcnt, 1, memory_order_release);
}
static inline LDKRouter LDKRouter_init (JNIEnv *env, jclass clz, jobject o) {
	jclass c = (*env)->GetObjectClass(env, o);
	CHECK(c != NULL);
	LDKRouter_JCalls *calls = MALLOC(sizeof(LDKRouter_JCalls), "LDKRouter_JCalls");
	atomic_init(&calls->refcnt, 1);
	DO_ASSERT((*env)->GetJavaVM(env, &calls->vm) == 0);
	calls->o = (*env)->NewWeakGlobalRef(env, o);
	calls->find_route_meth = (*env)->GetMethodID(env, c, "find_route", "([BJ[JJ)J");
	CHECK(calls->find_route_meth != NULL);

	LDKRouter ret = {
		.this_arg = (void*) calls,
		.find_route = find_route_LDKRouter_jcall,
		.free = LDKRouter_JCalls_free,
	};
	return ret;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LDKRouter_1new(JNIEnv *env, jclass clz, jobject o) {
	LDKRouter *res_ptr = MALLOC(sizeof(LDKRouter), "LDKRouter");
	*res_ptr = LDKRouter_init(env, clz, o);
	return (uint64_t)res_ptr;
}
JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_Router_1find_1route(JNIEnv *env, jclass clz, int64_t this_arg, int8_tArray payer, int64_t params, int64_tArray first_hops, int64_t scorer) {
	void* this_arg_ptr = (void*)(((uint64_t)this_arg) & ~1);
	if (!(this_arg & 1)) { CHECK_ACCESS(this_arg_ptr); }
	LDKRouter* this_arg_conv = (LDKRouter*)this_arg_ptr;
	LDKPublicKey payer_ref;
	CHECK((*env)->GetArrayLength(env, payer) == 33);
	(*env)->GetByteArrayRegion(env, payer, 0, 33, payer_ref.compressed_form);
	LDKRouteParameters params_conv;
	params_conv.inner = (void*)(params & (~1));
	params_conv.is_owned = false;
	LDKCVec_ChannelDetailsZ first_hops_constr;
	LDKCVec_ChannelDetailsZ *first_hops_ptr = NULL;
	if (first_hops != NULL) {
		first_hops_constr.datalen = (*env)->GetArrayLength(env, first_hops);
		if (first_hops_constr.datalen > 0)
			first_hops_constr.data = MALLOC(first_hops_constr.datalen * sizeof(LDKChannelDetails), "LDKCVec_ChannelDetailsZ Elements");
		else
			first_hops_constr.data = NULL;
		int64_t* first_hops_vals = (*env)->GetLongArrayElements (env, first_hops, NULL);
		for (size_t q = 0; q < first_hops_constr.datalen; q++) {
			int64_t first_hops_conv_16 = first_hops_vals[q];
			LDKChannelDetails first_hops_conv_16_conv;
			first_hops_conv_16_conv.inner = (void*)(first_hops_conv_16 & (~1));
			first_hops_conv_16_conv.is_owned = (first_hops_conv_16 & 1) || (first_hops_conv_16 == 0);
			first_hops_constr.data[q] = first_hops_conv_16_conv;
		}
		(*env)->ReleaseLongArrayElements(env, first_hops, first_hops_vals, 0);
		first_hops_ptr = &first_hops_constr;
	}
	void* scorer_ptr = (void*)(((uint64_t)scorer) & ~1);
	if (!(scorer & 1)) { CHECK_ACCESS(scorer_ptr); }
	LDKScore* scorer_conv = (LDKScore*)scorer_ptr;
	LDKCResult_RouteLightningErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_RouteLightningErrorZ), "LDKCResult_RouteLightningErrorZ");
	*ret_conv = (this_arg_conv->find_route)(this_arg_conv->this_arg, payer_ref, &params_conv, first_hops_ptr, scorer_conv);
	if (first_hops_ptr != NULL) { FREE(first_hops_constr.data); }
	return (uint64_t)ret_conv;
}

JNIEXPORT jstring JNICALL Java_org_ldk_impl_bindings__1ldk_1get_1compiled_1version(JNIEnv *env, jclass clz) {
	LDKStr ret_str = _ldk_get_compiled_version();
	jstring ret_conv = str_ref_to_java(env, ret_str.chars, ret_str.len);
	Str_free(ret_str);
	return ret_conv;
}

JNIEXPORT jstring JNICALL Java_org_ldk_impl_bindings__1ldk_1c_1bindings_1get_1compiled_1version(JNIEnv *env, jclass clz) {
	LDKStr ret_str = _ldk_c_bindings_get_compiled_version();
	jstring ret_conv = str_ref_to_java(env, ret_str.chars, ret_str.len);
	Str_free(ret_str);
	return ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_Transaction_1free(JNIEnv *env, jclass clz, int8_tArray _res) {
	LDKTransaction _res_ref;
	_res_ref.datalen = (*env)->GetArrayLength(env, _res);
	_res_ref.data = MALLOC(_res_ref.datalen, "LDKTransaction Bytes");
	(*env)->GetByteArrayRegion(env, _res, 0, _res_ref.datalen, _res_ref.data);
	_res_ref.data_is_owned = true;
	Transaction_free(_res_ref);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_TxOut_1new(JNIEnv *env, jclass clz, int8_tArray script_pubkey, int64_t value) {
	LDKCVec_u8Z script_pubkey_ref;
	script_pubkey_ref.datalen = (*env)->GetArrayLength(env, script_pubkey);
	script_pubkey_ref.data = MALLOC(script_pubkey_ref.datalen, "LDKCVec_u8Z Bytes");
	(*env)->GetByteArrayRegion(env, script_pubkey, 0, script_pubkey_ref.datalen, script_pubkey_ref.data);
	LDKTxOut* ret_ref = MALLOC(sizeof(LDKTxOut), "LDKTxOut");
	*ret_ref = TxOut_new(script_pubkey_ref, value);
	return (uint64_t)ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_TxOut_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKTxOut _res_conv = *(LDKTxOut*)(_res_ptr);
	FREE((void*)_res);
	TxOut_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_TxOut_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKTxOut* orig_conv = (LDKTxOut*)(orig & ~1);
	LDKTxOut* ret_ref = MALLOC(sizeof(LDKTxOut), "LDKTxOut");
	*ret_ref = TxOut_clone(orig_conv);
	return (uint64_t)ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_Str_1free(JNIEnv *env, jclass clz, jstring _res) {
	LDKStr dummy = { .chars = NULL, .len = 0, .chars_is_owned = false };
	Str_free(dummy);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1SecretKeyErrorZ_1ok(JNIEnv *env, jclass clz, int8_tArray o) {
	LDKSecretKey o_ref;
	CHECK((*env)->GetArrayLength(env, o) == 32);
	(*env)->GetByteArrayRegion(env, o, 0, 32, o_ref.bytes);
	LDKCResult_SecretKeyErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_SecretKeyErrorZ), "LDKCResult_SecretKeyErrorZ");
	*ret_conv = CResult_SecretKeyErrorZ_ok(o_ref);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1SecretKeyErrorZ_1err(JNIEnv *env, jclass clz, jclass e) {
	LDKSecp256k1Error e_conv = LDKSecp256k1Error_from_java(env, e);
	LDKCResult_SecretKeyErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_SecretKeyErrorZ), "LDKCResult_SecretKeyErrorZ");
	*ret_conv = CResult_SecretKeyErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1SecretKeyErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_SecretKeyErrorZ _res_conv = *(LDKCResult_SecretKeyErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_SecretKeyErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1PublicKeyErrorZ_1ok(JNIEnv *env, jclass clz, int8_tArray o) {
	LDKPublicKey o_ref;
	CHECK((*env)->GetArrayLength(env, o) == 33);
	(*env)->GetByteArrayRegion(env, o, 0, 33, o_ref.compressed_form);
	LDKCResult_PublicKeyErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_PublicKeyErrorZ), "LDKCResult_PublicKeyErrorZ");
	*ret_conv = CResult_PublicKeyErrorZ_ok(o_ref);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1PublicKeyErrorZ_1err(JNIEnv *env, jclass clz, jclass e) {
	LDKSecp256k1Error e_conv = LDKSecp256k1Error_from_java(env, e);
	LDKCResult_PublicKeyErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_PublicKeyErrorZ), "LDKCResult_PublicKeyErrorZ");
	*ret_conv = CResult_PublicKeyErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1PublicKeyErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_PublicKeyErrorZ _res_conv = *(LDKCResult_PublicKeyErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_PublicKeyErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1PublicKeyErrorZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_PublicKeyErrorZ* orig_conv = (LDKCResult_PublicKeyErrorZ*)(orig & ~1);
	LDKCResult_PublicKeyErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_PublicKeyErrorZ), "LDKCResult_PublicKeyErrorZ");
	*ret_conv = CResult_PublicKeyErrorZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1TxCreationKeysDecodeErrorZ_1ok(JNIEnv *env, jclass clz, int64_t o) {
	LDKTxCreationKeys o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = (o & 1) || (o == 0);
	o_conv = TxCreationKeys_clone(&o_conv);
	LDKCResult_TxCreationKeysDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_TxCreationKeysDecodeErrorZ), "LDKCResult_TxCreationKeysDecodeErrorZ");
	*ret_conv = CResult_TxCreationKeysDecodeErrorZ_ok(o_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1TxCreationKeysDecodeErrorZ_1err(JNIEnv *env, jclass clz, int64_t e) {
	LDKDecodeError e_conv;
	e_conv.inner = (void*)(e & (~1));
	e_conv.is_owned = (e & 1) || (e == 0);
	e_conv = DecodeError_clone(&e_conv);
	LDKCResult_TxCreationKeysDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_TxCreationKeysDecodeErrorZ), "LDKCResult_TxCreationKeysDecodeErrorZ");
	*ret_conv = CResult_TxCreationKeysDecodeErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1TxCreationKeysDecodeErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_TxCreationKeysDecodeErrorZ _res_conv = *(LDKCResult_TxCreationKeysDecodeErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_TxCreationKeysDecodeErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1TxCreationKeysDecodeErrorZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_TxCreationKeysDecodeErrorZ* orig_conv = (LDKCResult_TxCreationKeysDecodeErrorZ*)(orig & ~1);
	LDKCResult_TxCreationKeysDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_TxCreationKeysDecodeErrorZ), "LDKCResult_TxCreationKeysDecodeErrorZ");
	*ret_conv = CResult_TxCreationKeysDecodeErrorZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1ChannelPublicKeysDecodeErrorZ_1ok(JNIEnv *env, jclass clz, int64_t o) {
	LDKChannelPublicKeys o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = (o & 1) || (o == 0);
	o_conv = ChannelPublicKeys_clone(&o_conv);
	LDKCResult_ChannelPublicKeysDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_ChannelPublicKeysDecodeErrorZ), "LDKCResult_ChannelPublicKeysDecodeErrorZ");
	*ret_conv = CResult_ChannelPublicKeysDecodeErrorZ_ok(o_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1ChannelPublicKeysDecodeErrorZ_1err(JNIEnv *env, jclass clz, int64_t e) {
	LDKDecodeError e_conv;
	e_conv.inner = (void*)(e & (~1));
	e_conv.is_owned = (e & 1) || (e == 0);
	e_conv = DecodeError_clone(&e_conv);
	LDKCResult_ChannelPublicKeysDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_ChannelPublicKeysDecodeErrorZ), "LDKCResult_ChannelPublicKeysDecodeErrorZ");
	*ret_conv = CResult_ChannelPublicKeysDecodeErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1ChannelPublicKeysDecodeErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_ChannelPublicKeysDecodeErrorZ _res_conv = *(LDKCResult_ChannelPublicKeysDecodeErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_ChannelPublicKeysDecodeErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1ChannelPublicKeysDecodeErrorZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_ChannelPublicKeysDecodeErrorZ* orig_conv = (LDKCResult_ChannelPublicKeysDecodeErrorZ*)(orig & ~1);
	LDKCResult_ChannelPublicKeysDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_ChannelPublicKeysDecodeErrorZ), "LDKCResult_ChannelPublicKeysDecodeErrorZ");
	*ret_conv = CResult_ChannelPublicKeysDecodeErrorZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1TxCreationKeysErrorZ_1ok(JNIEnv *env, jclass clz, int64_t o) {
	LDKTxCreationKeys o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = (o & 1) || (o == 0);
	o_conv = TxCreationKeys_clone(&o_conv);
	LDKCResult_TxCreationKeysErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_TxCreationKeysErrorZ), "LDKCResult_TxCreationKeysErrorZ");
	*ret_conv = CResult_TxCreationKeysErrorZ_ok(o_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1TxCreationKeysErrorZ_1err(JNIEnv *env, jclass clz, jclass e) {
	LDKSecp256k1Error e_conv = LDKSecp256k1Error_from_java(env, e);
	LDKCResult_TxCreationKeysErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_TxCreationKeysErrorZ), "LDKCResult_TxCreationKeysErrorZ");
	*ret_conv = CResult_TxCreationKeysErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1TxCreationKeysErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_TxCreationKeysErrorZ _res_conv = *(LDKCResult_TxCreationKeysErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_TxCreationKeysErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1TxCreationKeysErrorZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_TxCreationKeysErrorZ* orig_conv = (LDKCResult_TxCreationKeysErrorZ*)(orig & ~1);
	LDKCResult_TxCreationKeysErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_TxCreationKeysErrorZ), "LDKCResult_TxCreationKeysErrorZ");
	*ret_conv = CResult_TxCreationKeysErrorZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_COption_1u32Z_1some(JNIEnv *env, jclass clz, int32_t o) {
	LDKCOption_u32Z *ret_copy = MALLOC(sizeof(LDKCOption_u32Z), "LDKCOption_u32Z");
	*ret_copy = COption_u32Z_some(o);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_COption_1u32Z_1none(JNIEnv *env, jclass clz) {
	LDKCOption_u32Z *ret_copy = MALLOC(sizeof(LDKCOption_u32Z), "LDKCOption_u32Z");
	*ret_copy = COption_u32Z_none();
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_COption_1u32Z_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCOption_u32Z _res_conv = *(LDKCOption_u32Z*)(_res_ptr);
	FREE((void*)_res);
	COption_u32Z_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_COption_1u32Z_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCOption_u32Z* orig_conv = (LDKCOption_u32Z*)orig;
	LDKCOption_u32Z *ret_copy = MALLOC(sizeof(LDKCOption_u32Z), "LDKCOption_u32Z");
	*ret_copy = COption_u32Z_clone(orig_conv);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1HTLCOutputInCommitmentDecodeErrorZ_1ok(JNIEnv *env, jclass clz, int64_t o) {
	LDKHTLCOutputInCommitment o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = (o & 1) || (o == 0);
	o_conv = HTLCOutputInCommitment_clone(&o_conv);
	LDKCResult_HTLCOutputInCommitmentDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_HTLCOutputInCommitmentDecodeErrorZ), "LDKCResult_HTLCOutputInCommitmentDecodeErrorZ");
	*ret_conv = CResult_HTLCOutputInCommitmentDecodeErrorZ_ok(o_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1HTLCOutputInCommitmentDecodeErrorZ_1err(JNIEnv *env, jclass clz, int64_t e) {
	LDKDecodeError e_conv;
	e_conv.inner = (void*)(e & (~1));
	e_conv.is_owned = (e & 1) || (e == 0);
	e_conv = DecodeError_clone(&e_conv);
	LDKCResult_HTLCOutputInCommitmentDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_HTLCOutputInCommitmentDecodeErrorZ), "LDKCResult_HTLCOutputInCommitmentDecodeErrorZ");
	*ret_conv = CResult_HTLCOutputInCommitmentDecodeErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1HTLCOutputInCommitmentDecodeErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_HTLCOutputInCommitmentDecodeErrorZ _res_conv = *(LDKCResult_HTLCOutputInCommitmentDecodeErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_HTLCOutputInCommitmentDecodeErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1HTLCOutputInCommitmentDecodeErrorZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_HTLCOutputInCommitmentDecodeErrorZ* orig_conv = (LDKCResult_HTLCOutputInCommitmentDecodeErrorZ*)(orig & ~1);
	LDKCResult_HTLCOutputInCommitmentDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_HTLCOutputInCommitmentDecodeErrorZ), "LDKCResult_HTLCOutputInCommitmentDecodeErrorZ");
	*ret_conv = CResult_HTLCOutputInCommitmentDecodeErrorZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1CounterpartyChannelTransactionParametersDecodeErrorZ_1ok(JNIEnv *env, jclass clz, int64_t o) {
	LDKCounterpartyChannelTransactionParameters o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = (o & 1) || (o == 0);
	o_conv = CounterpartyChannelTransactionParameters_clone(&o_conv);
	LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ), "LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ");
	*ret_conv = CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_ok(o_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1CounterpartyChannelTransactionParametersDecodeErrorZ_1err(JNIEnv *env, jclass clz, int64_t e) {
	LDKDecodeError e_conv;
	e_conv.inner = (void*)(e & (~1));
	e_conv.is_owned = (e & 1) || (e == 0);
	e_conv = DecodeError_clone(&e_conv);
	LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ), "LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ");
	*ret_conv = CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1CounterpartyChannelTransactionParametersDecodeErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ _res_conv = *(LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1CounterpartyChannelTransactionParametersDecodeErrorZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ* orig_conv = (LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ*)(orig & ~1);
	LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ), "LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ");
	*ret_conv = CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1ChannelTransactionParametersDecodeErrorZ_1ok(JNIEnv *env, jclass clz, int64_t o) {
	LDKChannelTransactionParameters o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = (o & 1) || (o == 0);
	o_conv = ChannelTransactionParameters_clone(&o_conv);
	LDKCResult_ChannelTransactionParametersDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_ChannelTransactionParametersDecodeErrorZ), "LDKCResult_ChannelTransactionParametersDecodeErrorZ");
	*ret_conv = CResult_ChannelTransactionParametersDecodeErrorZ_ok(o_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1ChannelTransactionParametersDecodeErrorZ_1err(JNIEnv *env, jclass clz, int64_t e) {
	LDKDecodeError e_conv;
	e_conv.inner = (void*)(e & (~1));
	e_conv.is_owned = (e & 1) || (e == 0);
	e_conv = DecodeError_clone(&e_conv);
	LDKCResult_ChannelTransactionParametersDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_ChannelTransactionParametersDecodeErrorZ), "LDKCResult_ChannelTransactionParametersDecodeErrorZ");
	*ret_conv = CResult_ChannelTransactionParametersDecodeErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1ChannelTransactionParametersDecodeErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_ChannelTransactionParametersDecodeErrorZ _res_conv = *(LDKCResult_ChannelTransactionParametersDecodeErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_ChannelTransactionParametersDecodeErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1ChannelTransactionParametersDecodeErrorZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_ChannelTransactionParametersDecodeErrorZ* orig_conv = (LDKCResult_ChannelTransactionParametersDecodeErrorZ*)(orig & ~1);
	LDKCResult_ChannelTransactionParametersDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_ChannelTransactionParametersDecodeErrorZ), "LDKCResult_ChannelTransactionParametersDecodeErrorZ");
	*ret_conv = CResult_ChannelTransactionParametersDecodeErrorZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CVec_1SignatureZ_1free(JNIEnv *env, jclass clz, jobjectArray _res) {
	LDKCVec_SignatureZ _res_constr;
	_res_constr.datalen = (*env)->GetArrayLength(env, _res);
	if (_res_constr.datalen > 0)
		_res_constr.data = MALLOC(_res_constr.datalen * sizeof(LDKSignature), "LDKCVec_SignatureZ Elements");
	else
		_res_constr.data = NULL;
	for (size_t i = 0; i < _res_constr.datalen; i++) {
		int8_tArray _res_conv_8 = (*env)->GetObjectArrayElement(env, _res, i);
		LDKSignature _res_conv_8_ref;
		CHECK((*env)->GetArrayLength(env, _res_conv_8) == 64);
		(*env)->GetByteArrayRegion(env, _res_conv_8, 0, 64, _res_conv_8_ref.compact_form);
		_res_constr.data[i] = _res_conv_8_ref;
	}
	CVec_SignatureZ_free(_res_constr);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1HolderCommitmentTransactionDecodeErrorZ_1ok(JNIEnv *env, jclass clz, int64_t o) {
	LDKHolderCommitmentTransaction o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = (o & 1) || (o == 0);
	o_conv = HolderCommitmentTransaction_clone(&o_conv);
	LDKCResult_HolderCommitmentTransactionDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_HolderCommitmentTransactionDecodeErrorZ), "LDKCResult_HolderCommitmentTransactionDecodeErrorZ");
	*ret_conv = CResult_HolderCommitmentTransactionDecodeErrorZ_ok(o_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1HolderCommitmentTransactionDecodeErrorZ_1err(JNIEnv *env, jclass clz, int64_t e) {
	LDKDecodeError e_conv;
	e_conv.inner = (void*)(e & (~1));
	e_conv.is_owned = (e & 1) || (e == 0);
	e_conv = DecodeError_clone(&e_conv);
	LDKCResult_HolderCommitmentTransactionDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_HolderCommitmentTransactionDecodeErrorZ), "LDKCResult_HolderCommitmentTransactionDecodeErrorZ");
	*ret_conv = CResult_HolderCommitmentTransactionDecodeErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1HolderCommitmentTransactionDecodeErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_HolderCommitmentTransactionDecodeErrorZ _res_conv = *(LDKCResult_HolderCommitmentTransactionDecodeErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_HolderCommitmentTransactionDecodeErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1HolderCommitmentTransactionDecodeErrorZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_HolderCommitmentTransactionDecodeErrorZ* orig_conv = (LDKCResult_HolderCommitmentTransactionDecodeErrorZ*)(orig & ~1);
	LDKCResult_HolderCommitmentTransactionDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_HolderCommitmentTransactionDecodeErrorZ), "LDKCResult_HolderCommitmentTransactionDecodeErrorZ");
	*ret_conv = CResult_HolderCommitmentTransactionDecodeErrorZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1BuiltCommitmentTransactionDecodeErrorZ_1ok(JNIEnv *env, jclass clz, int64_t o) {
	LDKBuiltCommitmentTransaction o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = (o & 1) || (o == 0);
	o_conv = BuiltCommitmentTransaction_clone(&o_conv);
	LDKCResult_BuiltCommitmentTransactionDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_BuiltCommitmentTransactionDecodeErrorZ), "LDKCResult_BuiltCommitmentTransactionDecodeErrorZ");
	*ret_conv = CResult_BuiltCommitmentTransactionDecodeErrorZ_ok(o_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1BuiltCommitmentTransactionDecodeErrorZ_1err(JNIEnv *env, jclass clz, int64_t e) {
	LDKDecodeError e_conv;
	e_conv.inner = (void*)(e & (~1));
	e_conv.is_owned = (e & 1) || (e == 0);
	e_conv = DecodeError_clone(&e_conv);
	LDKCResult_BuiltCommitmentTransactionDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_BuiltCommitmentTransactionDecodeErrorZ), "LDKCResult_BuiltCommitmentTransactionDecodeErrorZ");
	*ret_conv = CResult_BuiltCommitmentTransactionDecodeErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1BuiltCommitmentTransactionDecodeErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_BuiltCommitmentTransactionDecodeErrorZ _res_conv = *(LDKCResult_BuiltCommitmentTransactionDecodeErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_BuiltCommitmentTransactionDecodeErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1BuiltCommitmentTransactionDecodeErrorZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_BuiltCommitmentTransactionDecodeErrorZ* orig_conv = (LDKCResult_BuiltCommitmentTransactionDecodeErrorZ*)(orig & ~1);
	LDKCResult_BuiltCommitmentTransactionDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_BuiltCommitmentTransactionDecodeErrorZ), "LDKCResult_BuiltCommitmentTransactionDecodeErrorZ");
	*ret_conv = CResult_BuiltCommitmentTransactionDecodeErrorZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1TrustedClosingTransactionNoneZ_1ok(JNIEnv *env, jclass clz, int64_t o) {
	LDKTrustedClosingTransaction o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = (o & 1) || (o == 0);
	// Warning: we need a move here but no clone is available for LDKTrustedClosingTransaction
	LDKCResult_TrustedClosingTransactionNoneZ* ret_conv = MALLOC(sizeof(LDKCResult_TrustedClosingTransactionNoneZ), "LDKCResult_TrustedClosingTransactionNoneZ");
	*ret_conv = CResult_TrustedClosingTransactionNoneZ_ok(o_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1TrustedClosingTransactionNoneZ_1err(JNIEnv *env, jclass clz) {
	LDKCResult_TrustedClosingTransactionNoneZ* ret_conv = MALLOC(sizeof(LDKCResult_TrustedClosingTransactionNoneZ), "LDKCResult_TrustedClosingTransactionNoneZ");
	*ret_conv = CResult_TrustedClosingTransactionNoneZ_err();
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1TrustedClosingTransactionNoneZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_TrustedClosingTransactionNoneZ _res_conv = *(LDKCResult_TrustedClosingTransactionNoneZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_TrustedClosingTransactionNoneZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1CommitmentTransactionDecodeErrorZ_1ok(JNIEnv *env, jclass clz, int64_t o) {
	LDKCommitmentTransaction o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = (o & 1) || (o == 0);
	o_conv = CommitmentTransaction_clone(&o_conv);
	LDKCResult_CommitmentTransactionDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_CommitmentTransactionDecodeErrorZ), "LDKCResult_CommitmentTransactionDecodeErrorZ");
	*ret_conv = CResult_CommitmentTransactionDecodeErrorZ_ok(o_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1CommitmentTransactionDecodeErrorZ_1err(JNIEnv *env, jclass clz, int64_t e) {
	LDKDecodeError e_conv;
	e_conv.inner = (void*)(e & (~1));
	e_conv.is_owned = (e & 1) || (e == 0);
	e_conv = DecodeError_clone(&e_conv);
	LDKCResult_CommitmentTransactionDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_CommitmentTransactionDecodeErrorZ), "LDKCResult_CommitmentTransactionDecodeErrorZ");
	*ret_conv = CResult_CommitmentTransactionDecodeErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1CommitmentTransactionDecodeErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_CommitmentTransactionDecodeErrorZ _res_conv = *(LDKCResult_CommitmentTransactionDecodeErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_CommitmentTransactionDecodeErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1CommitmentTransactionDecodeErrorZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_CommitmentTransactionDecodeErrorZ* orig_conv = (LDKCResult_CommitmentTransactionDecodeErrorZ*)(orig & ~1);
	LDKCResult_CommitmentTransactionDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_CommitmentTransactionDecodeErrorZ), "LDKCResult_CommitmentTransactionDecodeErrorZ");
	*ret_conv = CResult_CommitmentTransactionDecodeErrorZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1TrustedCommitmentTransactionNoneZ_1ok(JNIEnv *env, jclass clz, int64_t o) {
	LDKTrustedCommitmentTransaction o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = (o & 1) || (o == 0);
	// Warning: we need a move here but no clone is available for LDKTrustedCommitmentTransaction
	LDKCResult_TrustedCommitmentTransactionNoneZ* ret_conv = MALLOC(sizeof(LDKCResult_TrustedCommitmentTransactionNoneZ), "LDKCResult_TrustedCommitmentTransactionNoneZ");
	*ret_conv = CResult_TrustedCommitmentTransactionNoneZ_ok(o_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1TrustedCommitmentTransactionNoneZ_1err(JNIEnv *env, jclass clz) {
	LDKCResult_TrustedCommitmentTransactionNoneZ* ret_conv = MALLOC(sizeof(LDKCResult_TrustedCommitmentTransactionNoneZ), "LDKCResult_TrustedCommitmentTransactionNoneZ");
	*ret_conv = CResult_TrustedCommitmentTransactionNoneZ_err();
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1TrustedCommitmentTransactionNoneZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_TrustedCommitmentTransactionNoneZ _res_conv = *(LDKCResult_TrustedCommitmentTransactionNoneZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_TrustedCommitmentTransactionNoneZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1CVec_1SignatureZNoneZ_1ok(JNIEnv *env, jclass clz, jobjectArray o) {
	LDKCVec_SignatureZ o_constr;
	o_constr.datalen = (*env)->GetArrayLength(env, o);
	if (o_constr.datalen > 0)
		o_constr.data = MALLOC(o_constr.datalen * sizeof(LDKSignature), "LDKCVec_SignatureZ Elements");
	else
		o_constr.data = NULL;
	for (size_t i = 0; i < o_constr.datalen; i++) {
		int8_tArray o_conv_8 = (*env)->GetObjectArrayElement(env, o, i);
		LDKSignature o_conv_8_ref;
		CHECK((*env)->GetArrayLength(env, o_conv_8) == 64);
		(*env)->GetByteArrayRegion(env, o_conv_8, 0, 64, o_conv_8_ref.compact_form);
		o_constr.data[i] = o_conv_8_ref;
	}
	LDKCResult_CVec_SignatureZNoneZ* ret_conv = MALLOC(sizeof(LDKCResult_CVec_SignatureZNoneZ), "LDKCResult_CVec_SignatureZNoneZ");
	*ret_conv = CResult_CVec_SignatureZNoneZ_ok(o_constr);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1CVec_1SignatureZNoneZ_1err(JNIEnv *env, jclass clz) {
	LDKCResult_CVec_SignatureZNoneZ* ret_conv = MALLOC(sizeof(LDKCResult_CVec_SignatureZNoneZ), "LDKCResult_CVec_SignatureZNoneZ");
	*ret_conv = CResult_CVec_SignatureZNoneZ_err();
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1CVec_1SignatureZNoneZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_CVec_SignatureZNoneZ _res_conv = *(LDKCResult_CVec_SignatureZNoneZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_CVec_SignatureZNoneZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1CVec_1SignatureZNoneZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_CVec_SignatureZNoneZ* orig_conv = (LDKCResult_CVec_SignatureZNoneZ*)(orig & ~1);
	LDKCResult_CVec_SignatureZNoneZ* ret_conv = MALLOC(sizeof(LDKCResult_CVec_SignatureZNoneZ), "LDKCResult_CVec_SignatureZNoneZ");
	*ret_conv = CResult_CVec_SignatureZNoneZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1ShutdownScriptDecodeErrorZ_1ok(JNIEnv *env, jclass clz, int64_t o) {
	LDKShutdownScript o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = (o & 1) || (o == 0);
	o_conv = ShutdownScript_clone(&o_conv);
	LDKCResult_ShutdownScriptDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_ShutdownScriptDecodeErrorZ), "LDKCResult_ShutdownScriptDecodeErrorZ");
	*ret_conv = CResult_ShutdownScriptDecodeErrorZ_ok(o_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1ShutdownScriptDecodeErrorZ_1err(JNIEnv *env, jclass clz, int64_t e) {
	LDKDecodeError e_conv;
	e_conv.inner = (void*)(e & (~1));
	e_conv.is_owned = (e & 1) || (e == 0);
	e_conv = DecodeError_clone(&e_conv);
	LDKCResult_ShutdownScriptDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_ShutdownScriptDecodeErrorZ), "LDKCResult_ShutdownScriptDecodeErrorZ");
	*ret_conv = CResult_ShutdownScriptDecodeErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1ShutdownScriptDecodeErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_ShutdownScriptDecodeErrorZ _res_conv = *(LDKCResult_ShutdownScriptDecodeErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_ShutdownScriptDecodeErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1ShutdownScriptDecodeErrorZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_ShutdownScriptDecodeErrorZ* orig_conv = (LDKCResult_ShutdownScriptDecodeErrorZ*)(orig & ~1);
	LDKCResult_ShutdownScriptDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_ShutdownScriptDecodeErrorZ), "LDKCResult_ShutdownScriptDecodeErrorZ");
	*ret_conv = CResult_ShutdownScriptDecodeErrorZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1ShutdownScriptInvalidShutdownScriptZ_1ok(JNIEnv *env, jclass clz, int64_t o) {
	LDKShutdownScript o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = (o & 1) || (o == 0);
	o_conv = ShutdownScript_clone(&o_conv);
	LDKCResult_ShutdownScriptInvalidShutdownScriptZ* ret_conv = MALLOC(sizeof(LDKCResult_ShutdownScriptInvalidShutdownScriptZ), "LDKCResult_ShutdownScriptInvalidShutdownScriptZ");
	*ret_conv = CResult_ShutdownScriptInvalidShutdownScriptZ_ok(o_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1ShutdownScriptInvalidShutdownScriptZ_1err(JNIEnv *env, jclass clz, int64_t e) {
	LDKInvalidShutdownScript e_conv;
	e_conv.inner = (void*)(e & (~1));
	e_conv.is_owned = (e & 1) || (e == 0);
	e_conv = InvalidShutdownScript_clone(&e_conv);
	LDKCResult_ShutdownScriptInvalidShutdownScriptZ* ret_conv = MALLOC(sizeof(LDKCResult_ShutdownScriptInvalidShutdownScriptZ), "LDKCResult_ShutdownScriptInvalidShutdownScriptZ");
	*ret_conv = CResult_ShutdownScriptInvalidShutdownScriptZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1ShutdownScriptInvalidShutdownScriptZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_ShutdownScriptInvalidShutdownScriptZ _res_conv = *(LDKCResult_ShutdownScriptInvalidShutdownScriptZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_ShutdownScriptInvalidShutdownScriptZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1ShutdownScriptInvalidShutdownScriptZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_ShutdownScriptInvalidShutdownScriptZ* orig_conv = (LDKCResult_ShutdownScriptInvalidShutdownScriptZ*)(orig & ~1);
	LDKCResult_ShutdownScriptInvalidShutdownScriptZ* ret_conv = MALLOC(sizeof(LDKCResult_ShutdownScriptInvalidShutdownScriptZ), "LDKCResult_ShutdownScriptInvalidShutdownScriptZ");
	*ret_conv = CResult_ShutdownScriptInvalidShutdownScriptZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1NoneErrorZ_1ok(JNIEnv *env, jclass clz) {
	LDKCResult_NoneErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_NoneErrorZ), "LDKCResult_NoneErrorZ");
	*ret_conv = CResult_NoneErrorZ_ok();
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1NoneErrorZ_1err(JNIEnv *env, jclass clz, jclass e) {
	LDKIOError e_conv = LDKIOError_from_java(env, e);
	LDKCResult_NoneErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_NoneErrorZ), "LDKCResult_NoneErrorZ");
	*ret_conv = CResult_NoneErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1NoneErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_NoneErrorZ _res_conv = *(LDKCResult_NoneErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_NoneErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1NoneErrorZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_NoneErrorZ* orig_conv = (LDKCResult_NoneErrorZ*)(orig & ~1);
	LDKCResult_NoneErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_NoneErrorZ), "LDKCResult_NoneErrorZ");
	*ret_conv = CResult_NoneErrorZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1RouteHopDecodeErrorZ_1ok(JNIEnv *env, jclass clz, int64_t o) {
	LDKRouteHop o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = (o & 1) || (o == 0);
	o_conv = RouteHop_clone(&o_conv);
	LDKCResult_RouteHopDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_RouteHopDecodeErrorZ), "LDKCResult_RouteHopDecodeErrorZ");
	*ret_conv = CResult_RouteHopDecodeErrorZ_ok(o_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1RouteHopDecodeErrorZ_1err(JNIEnv *env, jclass clz, int64_t e) {
	LDKDecodeError e_conv;
	e_conv.inner = (void*)(e & (~1));
	e_conv.is_owned = (e & 1) || (e == 0);
	e_conv = DecodeError_clone(&e_conv);
	LDKCResult_RouteHopDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_RouteHopDecodeErrorZ), "LDKCResult_RouteHopDecodeErrorZ");
	*ret_conv = CResult_RouteHopDecodeErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1RouteHopDecodeErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_RouteHopDecodeErrorZ _res_conv = *(LDKCResult_RouteHopDecodeErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_RouteHopDecodeErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1RouteHopDecodeErrorZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_RouteHopDecodeErrorZ* orig_conv = (LDKCResult_RouteHopDecodeErrorZ*)(orig & ~1);
	LDKCResult_RouteHopDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_RouteHopDecodeErrorZ), "LDKCResult_RouteHopDecodeErrorZ");
	*ret_conv = CResult_RouteHopDecodeErrorZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CVec_1RouteHopZ_1free(JNIEnv *env, jclass clz, int64_tArray _res) {
	LDKCVec_RouteHopZ _res_constr;
	_res_constr.datalen = (*env)->GetArrayLength(env, _res);
	if (_res_constr.datalen > 0)
		_res_constr.data = MALLOC(_res_constr.datalen * sizeof(LDKRouteHop), "LDKCVec_RouteHopZ Elements");
	else
		_res_constr.data = NULL;
	int64_t* _res_vals = (*env)->GetLongArrayElements (env, _res, NULL);
	for (size_t k = 0; k < _res_constr.datalen; k++) {
		int64_t _res_conv_10 = _res_vals[k];
		LDKRouteHop _res_conv_10_conv;
		_res_conv_10_conv.inner = (void*)(_res_conv_10 & (~1));
		_res_conv_10_conv.is_owned = (_res_conv_10 & 1) || (_res_conv_10 == 0);
		_res_constr.data[k] = _res_conv_10_conv;
	}
	(*env)->ReleaseLongArrayElements(env, _res, _res_vals, 0);
	CVec_RouteHopZ_free(_res_constr);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CVec_1CVec_1RouteHopZZ_1free(JNIEnv *env, jclass clz, jobjectArray _res) {
	LDKCVec_CVec_RouteHopZZ _res_constr;
	_res_constr.datalen = (*env)->GetArrayLength(env, _res);
	if (_res_constr.datalen > 0)
		_res_constr.data = MALLOC(_res_constr.datalen * sizeof(LDKCVec_RouteHopZ), "LDKCVec_CVec_RouteHopZZ Elements");
	else
		_res_constr.data = NULL;
	for (size_t m = 0; m < _res_constr.datalen; m++) {
		int64_tArray _res_conv_12 = (*env)->GetObjectArrayElement(env, _res, m);
		LDKCVec_RouteHopZ _res_conv_12_constr;
		_res_conv_12_constr.datalen = (*env)->GetArrayLength(env, _res_conv_12);
		if (_res_conv_12_constr.datalen > 0)
			_res_conv_12_constr.data = MALLOC(_res_conv_12_constr.datalen * sizeof(LDKRouteHop), "LDKCVec_RouteHopZ Elements");
		else
			_res_conv_12_constr.data = NULL;
		int64_t* _res_conv_12_vals = (*env)->GetLongArrayElements (env, _res_conv_12, NULL);
		for (size_t k = 0; k < _res_conv_12_constr.datalen; k++) {
			int64_t _res_conv_12_conv_10 = _res_conv_12_vals[k];
			LDKRouteHop _res_conv_12_conv_10_conv;
			_res_conv_12_conv_10_conv.inner = (void*)(_res_conv_12_conv_10 & (~1));
			_res_conv_12_conv_10_conv.is_owned = (_res_conv_12_conv_10 & 1) || (_res_conv_12_conv_10 == 0);
			_res_conv_12_constr.data[k] = _res_conv_12_conv_10_conv;
		}
		(*env)->ReleaseLongArrayElements(env, _res_conv_12, _res_conv_12_vals, 0);
		_res_constr.data[m] = _res_conv_12_constr;
	}
	CVec_CVec_RouteHopZZ_free(_res_constr);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1RouteDecodeErrorZ_1ok(JNIEnv *env, jclass clz, int64_t o) {
	LDKRoute o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = (o & 1) || (o == 0);
	o_conv = Route_clone(&o_conv);
	LDKCResult_RouteDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_RouteDecodeErrorZ), "LDKCResult_RouteDecodeErrorZ");
	*ret_conv = CResult_RouteDecodeErrorZ_ok(o_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1RouteDecodeErrorZ_1err(JNIEnv *env, jclass clz, int64_t e) {
	LDKDecodeError e_conv;
	e_conv.inner = (void*)(e & (~1));
	e_conv.is_owned = (e & 1) || (e == 0);
	e_conv = DecodeError_clone(&e_conv);
	LDKCResult_RouteDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_RouteDecodeErrorZ), "LDKCResult_RouteDecodeErrorZ");
	*ret_conv = CResult_RouteDecodeErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1RouteDecodeErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_RouteDecodeErrorZ _res_conv = *(LDKCResult_RouteDecodeErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_RouteDecodeErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1RouteDecodeErrorZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_RouteDecodeErrorZ* orig_conv = (LDKCResult_RouteDecodeErrorZ*)(orig & ~1);
	LDKCResult_RouteDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_RouteDecodeErrorZ), "LDKCResult_RouteDecodeErrorZ");
	*ret_conv = CResult_RouteDecodeErrorZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1RouteParametersDecodeErrorZ_1ok(JNIEnv *env, jclass clz, int64_t o) {
	LDKRouteParameters o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = (o & 1) || (o == 0);
	o_conv = RouteParameters_clone(&o_conv);
	LDKCResult_RouteParametersDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_RouteParametersDecodeErrorZ), "LDKCResult_RouteParametersDecodeErrorZ");
	*ret_conv = CResult_RouteParametersDecodeErrorZ_ok(o_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1RouteParametersDecodeErrorZ_1err(JNIEnv *env, jclass clz, int64_t e) {
	LDKDecodeError e_conv;
	e_conv.inner = (void*)(e & (~1));
	e_conv.is_owned = (e & 1) || (e == 0);
	e_conv = DecodeError_clone(&e_conv);
	LDKCResult_RouteParametersDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_RouteParametersDecodeErrorZ), "LDKCResult_RouteParametersDecodeErrorZ");
	*ret_conv = CResult_RouteParametersDecodeErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1RouteParametersDecodeErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_RouteParametersDecodeErrorZ _res_conv = *(LDKCResult_RouteParametersDecodeErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_RouteParametersDecodeErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1RouteParametersDecodeErrorZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_RouteParametersDecodeErrorZ* orig_conv = (LDKCResult_RouteParametersDecodeErrorZ*)(orig & ~1);
	LDKCResult_RouteParametersDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_RouteParametersDecodeErrorZ), "LDKCResult_RouteParametersDecodeErrorZ");
	*ret_conv = CResult_RouteParametersDecodeErrorZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CVec_1RouteHintZ_1free(JNIEnv *env, jclass clz, int64_tArray _res) {
	LDKCVec_RouteHintZ _res_constr;
	_res_constr.datalen = (*env)->GetArrayLength(env, _res);
	if (_res_constr.datalen > 0)
		_res_constr.data = MALLOC(_res_constr.datalen * sizeof(LDKRouteHint), "LDKCVec_RouteHintZ Elements");
	else
		_res_constr.data = NULL;
	int64_t* _res_vals = (*env)->GetLongArrayElements (env, _res, NULL);
	for (size_t l = 0; l < _res_constr.datalen; l++) {
		int64_t _res_conv_11 = _res_vals[l];
		LDKRouteHint _res_conv_11_conv;
		_res_conv_11_conv.inner = (void*)(_res_conv_11 & (~1));
		_res_conv_11_conv.is_owned = (_res_conv_11 & 1) || (_res_conv_11 == 0);
		_res_constr.data[l] = _res_conv_11_conv;
	}
	(*env)->ReleaseLongArrayElements(env, _res, _res_vals, 0);
	CVec_RouteHintZ_free(_res_constr);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_COption_1u64Z_1some(JNIEnv *env, jclass clz, int64_t o) {
	LDKCOption_u64Z *ret_copy = MALLOC(sizeof(LDKCOption_u64Z), "LDKCOption_u64Z");
	*ret_copy = COption_u64Z_some(o);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_COption_1u64Z_1none(JNIEnv *env, jclass clz) {
	LDKCOption_u64Z *ret_copy = MALLOC(sizeof(LDKCOption_u64Z), "LDKCOption_u64Z");
	*ret_copy = COption_u64Z_none();
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_COption_1u64Z_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCOption_u64Z _res_conv = *(LDKCOption_u64Z*)(_res_ptr);
	FREE((void*)_res);
	COption_u64Z_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_COption_1u64Z_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCOption_u64Z* orig_conv = (LDKCOption_u64Z*)orig;
	LDKCOption_u64Z *ret_copy = MALLOC(sizeof(LDKCOption_u64Z), "LDKCOption_u64Z");
	*ret_copy = COption_u64Z_clone(orig_conv);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1PayeeDecodeErrorZ_1ok(JNIEnv *env, jclass clz, int64_t o) {
	LDKPayee o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = (o & 1) || (o == 0);
	o_conv = Payee_clone(&o_conv);
	LDKCResult_PayeeDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_PayeeDecodeErrorZ), "LDKCResult_PayeeDecodeErrorZ");
	*ret_conv = CResult_PayeeDecodeErrorZ_ok(o_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1PayeeDecodeErrorZ_1err(JNIEnv *env, jclass clz, int64_t e) {
	LDKDecodeError e_conv;
	e_conv.inner = (void*)(e & (~1));
	e_conv.is_owned = (e & 1) || (e == 0);
	e_conv = DecodeError_clone(&e_conv);
	LDKCResult_PayeeDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_PayeeDecodeErrorZ), "LDKCResult_PayeeDecodeErrorZ");
	*ret_conv = CResult_PayeeDecodeErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1PayeeDecodeErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_PayeeDecodeErrorZ _res_conv = *(LDKCResult_PayeeDecodeErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_PayeeDecodeErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1PayeeDecodeErrorZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_PayeeDecodeErrorZ* orig_conv = (LDKCResult_PayeeDecodeErrorZ*)(orig & ~1);
	LDKCResult_PayeeDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_PayeeDecodeErrorZ), "LDKCResult_PayeeDecodeErrorZ");
	*ret_conv = CResult_PayeeDecodeErrorZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CVec_1RouteHintHopZ_1free(JNIEnv *env, jclass clz, int64_tArray _res) {
	LDKCVec_RouteHintHopZ _res_constr;
	_res_constr.datalen = (*env)->GetArrayLength(env, _res);
	if (_res_constr.datalen > 0)
		_res_constr.data = MALLOC(_res_constr.datalen * sizeof(LDKRouteHintHop), "LDKCVec_RouteHintHopZ Elements");
	else
		_res_constr.data = NULL;
	int64_t* _res_vals = (*env)->GetLongArrayElements (env, _res, NULL);
	for (size_t o = 0; o < _res_constr.datalen; o++) {
		int64_t _res_conv_14 = _res_vals[o];
		LDKRouteHintHop _res_conv_14_conv;
		_res_conv_14_conv.inner = (void*)(_res_conv_14 & (~1));
		_res_conv_14_conv.is_owned = (_res_conv_14 & 1) || (_res_conv_14 == 0);
		_res_constr.data[o] = _res_conv_14_conv;
	}
	(*env)->ReleaseLongArrayElements(env, _res, _res_vals, 0);
	CVec_RouteHintHopZ_free(_res_constr);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1RouteHintDecodeErrorZ_1ok(JNIEnv *env, jclass clz, int64_t o) {
	LDKRouteHint o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = (o & 1) || (o == 0);
	o_conv = RouteHint_clone(&o_conv);
	LDKCResult_RouteHintDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_RouteHintDecodeErrorZ), "LDKCResult_RouteHintDecodeErrorZ");
	*ret_conv = CResult_RouteHintDecodeErrorZ_ok(o_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1RouteHintDecodeErrorZ_1err(JNIEnv *env, jclass clz, int64_t e) {
	LDKDecodeError e_conv;
	e_conv.inner = (void*)(e & (~1));
	e_conv.is_owned = (e & 1) || (e == 0);
	e_conv = DecodeError_clone(&e_conv);
	LDKCResult_RouteHintDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_RouteHintDecodeErrorZ), "LDKCResult_RouteHintDecodeErrorZ");
	*ret_conv = CResult_RouteHintDecodeErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1RouteHintDecodeErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_RouteHintDecodeErrorZ _res_conv = *(LDKCResult_RouteHintDecodeErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_RouteHintDecodeErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1RouteHintDecodeErrorZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_RouteHintDecodeErrorZ* orig_conv = (LDKCResult_RouteHintDecodeErrorZ*)(orig & ~1);
	LDKCResult_RouteHintDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_RouteHintDecodeErrorZ), "LDKCResult_RouteHintDecodeErrorZ");
	*ret_conv = CResult_RouteHintDecodeErrorZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1RouteHintHopDecodeErrorZ_1ok(JNIEnv *env, jclass clz, int64_t o) {
	LDKRouteHintHop o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = (o & 1) || (o == 0);
	o_conv = RouteHintHop_clone(&o_conv);
	LDKCResult_RouteHintHopDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_RouteHintHopDecodeErrorZ), "LDKCResult_RouteHintHopDecodeErrorZ");
	*ret_conv = CResult_RouteHintHopDecodeErrorZ_ok(o_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1RouteHintHopDecodeErrorZ_1err(JNIEnv *env, jclass clz, int64_t e) {
	LDKDecodeError e_conv;
	e_conv.inner = (void*)(e & (~1));
	e_conv.is_owned = (e & 1) || (e == 0);
	e_conv = DecodeError_clone(&e_conv);
	LDKCResult_RouteHintHopDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_RouteHintHopDecodeErrorZ), "LDKCResult_RouteHintHopDecodeErrorZ");
	*ret_conv = CResult_RouteHintHopDecodeErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1RouteHintHopDecodeErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_RouteHintHopDecodeErrorZ _res_conv = *(LDKCResult_RouteHintHopDecodeErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_RouteHintHopDecodeErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1RouteHintHopDecodeErrorZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_RouteHintHopDecodeErrorZ* orig_conv = (LDKCResult_RouteHintHopDecodeErrorZ*)(orig & ~1);
	LDKCResult_RouteHintHopDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_RouteHintHopDecodeErrorZ), "LDKCResult_RouteHintHopDecodeErrorZ");
	*ret_conv = CResult_RouteHintHopDecodeErrorZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CVec_1ChannelDetailsZ_1free(JNIEnv *env, jclass clz, int64_tArray _res) {
	LDKCVec_ChannelDetailsZ _res_constr;
	_res_constr.datalen = (*env)->GetArrayLength(env, _res);
	if (_res_constr.datalen > 0)
		_res_constr.data = MALLOC(_res_constr.datalen * sizeof(LDKChannelDetails), "LDKCVec_ChannelDetailsZ Elements");
	else
		_res_constr.data = NULL;
	int64_t* _res_vals = (*env)->GetLongArrayElements (env, _res, NULL);
	for (size_t q = 0; q < _res_constr.datalen; q++) {
		int64_t _res_conv_16 = _res_vals[q];
		LDKChannelDetails _res_conv_16_conv;
		_res_conv_16_conv.inner = (void*)(_res_conv_16 & (~1));
		_res_conv_16_conv.is_owned = (_res_conv_16 & 1) || (_res_conv_16 == 0);
		_res_constr.data[q] = _res_conv_16_conv;
	}
	(*env)->ReleaseLongArrayElements(env, _res, _res_vals, 0);
	CVec_ChannelDetailsZ_free(_res_constr);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1RouteLightningErrorZ_1ok(JNIEnv *env, jclass clz, int64_t o) {
	LDKRoute o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = (o & 1) || (o == 0);
	o_conv = Route_clone(&o_conv);
	LDKCResult_RouteLightningErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_RouteLightningErrorZ), "LDKCResult_RouteLightningErrorZ");
	*ret_conv = CResult_RouteLightningErrorZ_ok(o_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1RouteLightningErrorZ_1err(JNIEnv *env, jclass clz, int64_t e) {
	LDKLightningError e_conv;
	e_conv.inner = (void*)(e & (~1));
	e_conv.is_owned = (e & 1) || (e == 0);
	e_conv = LightningError_clone(&e_conv);
	LDKCResult_RouteLightningErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_RouteLightningErrorZ), "LDKCResult_RouteLightningErrorZ");
	*ret_conv = CResult_RouteLightningErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1RouteLightningErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_RouteLightningErrorZ _res_conv = *(LDKCResult_RouteLightningErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_RouteLightningErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1RouteLightningErrorZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_RouteLightningErrorZ* orig_conv = (LDKCResult_RouteLightningErrorZ*)(orig & ~1);
	LDKCResult_RouteLightningErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_RouteLightningErrorZ), "LDKCResult_RouteLightningErrorZ");
	*ret_conv = CResult_RouteLightningErrorZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1TxOutAccessErrorZ_1ok(JNIEnv *env, jclass clz, int64_t o) {
	void* o_ptr = (void*)(((uint64_t)o) & ~1);
	CHECK_ACCESS(o_ptr);
	LDKTxOut o_conv = *(LDKTxOut*)(o_ptr);
	o_conv = TxOut_clone((LDKTxOut*)(((uint64_t)o) & ~1));
	LDKCResult_TxOutAccessErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_TxOutAccessErrorZ), "LDKCResult_TxOutAccessErrorZ");
	*ret_conv = CResult_TxOutAccessErrorZ_ok(o_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1TxOutAccessErrorZ_1err(JNIEnv *env, jclass clz, jclass e) {
	LDKAccessError e_conv = LDKAccessError_from_java(env, e);
	LDKCResult_TxOutAccessErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_TxOutAccessErrorZ), "LDKCResult_TxOutAccessErrorZ");
	*ret_conv = CResult_TxOutAccessErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1TxOutAccessErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_TxOutAccessErrorZ _res_conv = *(LDKCResult_TxOutAccessErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_TxOutAccessErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1TxOutAccessErrorZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_TxOutAccessErrorZ* orig_conv = (LDKCResult_TxOutAccessErrorZ*)(orig & ~1);
	LDKCResult_TxOutAccessErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_TxOutAccessErrorZ), "LDKCResult_TxOutAccessErrorZ");
	*ret_conv = CResult_TxOutAccessErrorZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_C2Tuple_1usizeTransactionZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKC2Tuple_usizeTransactionZ* orig_conv = (LDKC2Tuple_usizeTransactionZ*)(orig & ~1);
	LDKC2Tuple_usizeTransactionZ* ret_conv = MALLOC(sizeof(LDKC2Tuple_usizeTransactionZ), "LDKC2Tuple_usizeTransactionZ");
	*ret_conv = C2Tuple_usizeTransactionZ_clone(orig_conv);
	return ((uint64_t)ret_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_C2Tuple_1usizeTransactionZ_1new(JNIEnv *env, jclass clz, int64_t a, int8_tArray b) {
	LDKTransaction b_ref;
	b_ref.datalen = (*env)->GetArrayLength(env, b);
	b_ref.data = MALLOC(b_ref.datalen, "LDKTransaction Bytes");
	(*env)->GetByteArrayRegion(env, b, 0, b_ref.datalen, b_ref.data);
	b_ref.data_is_owned = true;
	LDKC2Tuple_usizeTransactionZ* ret_conv = MALLOC(sizeof(LDKC2Tuple_usizeTransactionZ), "LDKC2Tuple_usizeTransactionZ");
	*ret_conv = C2Tuple_usizeTransactionZ_new(a, b_ref);
	return ((uint64_t)ret_conv);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_C2Tuple_1usizeTransactionZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKC2Tuple_usizeTransactionZ _res_conv = *(LDKC2Tuple_usizeTransactionZ*)(_res_ptr);
	FREE((void*)_res);
	C2Tuple_usizeTransactionZ_free(_res_conv);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CVec_1C2Tuple_1usizeTransactionZZ_1free(JNIEnv *env, jclass clz, int64_tArray _res) {
	LDKCVec_C2Tuple_usizeTransactionZZ _res_constr;
	_res_constr.datalen = (*env)->GetArrayLength(env, _res);
	if (_res_constr.datalen > 0)
		_res_constr.data = MALLOC(_res_constr.datalen * sizeof(LDKC2Tuple_usizeTransactionZ), "LDKCVec_C2Tuple_usizeTransactionZZ Elements");
	else
		_res_constr.data = NULL;
	int64_t* _res_vals = (*env)->GetLongArrayElements (env, _res, NULL);
	for (size_t c = 0; c < _res_constr.datalen; c++) {
		int64_t _res_conv_28 = _res_vals[c];
		void* _res_conv_28_ptr = (void*)(((uint64_t)_res_conv_28) & ~1);
		CHECK_ACCESS(_res_conv_28_ptr);
		LDKC2Tuple_usizeTransactionZ _res_conv_28_conv = *(LDKC2Tuple_usizeTransactionZ*)(_res_conv_28_ptr);
		FREE((void*)_res_conv_28);
		_res_constr.data[c] = _res_conv_28_conv;
	}
	(*env)->ReleaseLongArrayElements(env, _res, _res_vals, 0);
	CVec_C2Tuple_usizeTransactionZZ_free(_res_constr);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CVec_1TxidZ_1free(JNIEnv *env, jclass clz, jobjectArray _res) {
	LDKCVec_TxidZ _res_constr;
	_res_constr.datalen = (*env)->GetArrayLength(env, _res);
	if (_res_constr.datalen > 0)
		_res_constr.data = MALLOC(_res_constr.datalen * sizeof(LDKThirtyTwoBytes), "LDKCVec_TxidZ Elements");
	else
		_res_constr.data = NULL;
	for (size_t i = 0; i < _res_constr.datalen; i++) {
		int8_tArray _res_conv_8 = (*env)->GetObjectArrayElement(env, _res, i);
		LDKThirtyTwoBytes _res_conv_8_ref;
		CHECK((*env)->GetArrayLength(env, _res_conv_8) == 32);
		(*env)->GetByteArrayRegion(env, _res_conv_8, 0, 32, _res_conv_8_ref.data);
		_res_constr.data[i] = _res_conv_8_ref;
	}
	CVec_TxidZ_free(_res_constr);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1NoneChannelMonitorUpdateErrZ_1ok(JNIEnv *env, jclass clz) {
	LDKCResult_NoneChannelMonitorUpdateErrZ* ret_conv = MALLOC(sizeof(LDKCResult_NoneChannelMonitorUpdateErrZ), "LDKCResult_NoneChannelMonitorUpdateErrZ");
	*ret_conv = CResult_NoneChannelMonitorUpdateErrZ_ok();
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1NoneChannelMonitorUpdateErrZ_1err(JNIEnv *env, jclass clz, jclass e) {
	LDKChannelMonitorUpdateErr e_conv = LDKChannelMonitorUpdateErr_from_java(env, e);
	LDKCResult_NoneChannelMonitorUpdateErrZ* ret_conv = MALLOC(sizeof(LDKCResult_NoneChannelMonitorUpdateErrZ), "LDKCResult_NoneChannelMonitorUpdateErrZ");
	*ret_conv = CResult_NoneChannelMonitorUpdateErrZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1NoneChannelMonitorUpdateErrZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_NoneChannelMonitorUpdateErrZ _res_conv = *(LDKCResult_NoneChannelMonitorUpdateErrZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_NoneChannelMonitorUpdateErrZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1NoneChannelMonitorUpdateErrZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_NoneChannelMonitorUpdateErrZ* orig_conv = (LDKCResult_NoneChannelMonitorUpdateErrZ*)(orig & ~1);
	LDKCResult_NoneChannelMonitorUpdateErrZ* ret_conv = MALLOC(sizeof(LDKCResult_NoneChannelMonitorUpdateErrZ), "LDKCResult_NoneChannelMonitorUpdateErrZ");
	*ret_conv = CResult_NoneChannelMonitorUpdateErrZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CVec_1MonitorEventZ_1free(JNIEnv *env, jclass clz, int64_tArray _res) {
	LDKCVec_MonitorEventZ _res_constr;
	_res_constr.datalen = (*env)->GetArrayLength(env, _res);
	if (_res_constr.datalen > 0)
		_res_constr.data = MALLOC(_res_constr.datalen * sizeof(LDKMonitorEvent), "LDKCVec_MonitorEventZ Elements");
	else
		_res_constr.data = NULL;
	int64_t* _res_vals = (*env)->GetLongArrayElements (env, _res, NULL);
	for (size_t o = 0; o < _res_constr.datalen; o++) {
		int64_t _res_conv_14 = _res_vals[o];
		void* _res_conv_14_ptr = (void*)(((uint64_t)_res_conv_14) & ~1);
		CHECK_ACCESS(_res_conv_14_ptr);
		LDKMonitorEvent _res_conv_14_conv = *(LDKMonitorEvent*)(_res_conv_14_ptr);
		FREE((void*)_res_conv_14);
		_res_constr.data[o] = _res_conv_14_conv;
	}
	(*env)->ReleaseLongArrayElements(env, _res, _res_vals, 0);
	CVec_MonitorEventZ_free(_res_constr);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_COption_1C2Tuple_1usizeTransactionZZ_1some(JNIEnv *env, jclass clz, int64_t o) {
	void* o_ptr = (void*)(((uint64_t)o) & ~1);
	CHECK_ACCESS(o_ptr);
	LDKC2Tuple_usizeTransactionZ o_conv = *(LDKC2Tuple_usizeTransactionZ*)(o_ptr);
	o_conv = C2Tuple_usizeTransactionZ_clone((LDKC2Tuple_usizeTransactionZ*)(((uint64_t)o) & ~1));
	LDKCOption_C2Tuple_usizeTransactionZZ *ret_copy = MALLOC(sizeof(LDKCOption_C2Tuple_usizeTransactionZZ), "LDKCOption_C2Tuple_usizeTransactionZZ");
	*ret_copy = COption_C2Tuple_usizeTransactionZZ_some(o_conv);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_COption_1C2Tuple_1usizeTransactionZZ_1none(JNIEnv *env, jclass clz) {
	LDKCOption_C2Tuple_usizeTransactionZZ *ret_copy = MALLOC(sizeof(LDKCOption_C2Tuple_usizeTransactionZZ), "LDKCOption_C2Tuple_usizeTransactionZZ");
	*ret_copy = COption_C2Tuple_usizeTransactionZZ_none();
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_COption_1C2Tuple_1usizeTransactionZZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCOption_C2Tuple_usizeTransactionZZ _res_conv = *(LDKCOption_C2Tuple_usizeTransactionZZ*)(_res_ptr);
	FREE((void*)_res);
	COption_C2Tuple_usizeTransactionZZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_COption_1C2Tuple_1usizeTransactionZZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCOption_C2Tuple_usizeTransactionZZ* orig_conv = (LDKCOption_C2Tuple_usizeTransactionZZ*)orig;
	LDKCOption_C2Tuple_usizeTransactionZZ *ret_copy = MALLOC(sizeof(LDKCOption_C2Tuple_usizeTransactionZZ), "LDKCOption_C2Tuple_usizeTransactionZZ");
	*ret_copy = COption_C2Tuple_usizeTransactionZZ_clone(orig_conv);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_COption_1NetworkUpdateZ_1some(JNIEnv *env, jclass clz, int64_t o) {
	void* o_ptr = (void*)(((uint64_t)o) & ~1);
	CHECK_ACCESS(o_ptr);
	LDKNetworkUpdate o_conv = *(LDKNetworkUpdate*)(o_ptr);
	o_conv = NetworkUpdate_clone((LDKNetworkUpdate*)(((uint64_t)o) & ~1));
	LDKCOption_NetworkUpdateZ *ret_copy = MALLOC(sizeof(LDKCOption_NetworkUpdateZ), "LDKCOption_NetworkUpdateZ");
	*ret_copy = COption_NetworkUpdateZ_some(o_conv);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_COption_1NetworkUpdateZ_1none(JNIEnv *env, jclass clz) {
	LDKCOption_NetworkUpdateZ *ret_copy = MALLOC(sizeof(LDKCOption_NetworkUpdateZ), "LDKCOption_NetworkUpdateZ");
	*ret_copy = COption_NetworkUpdateZ_none();
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_COption_1NetworkUpdateZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCOption_NetworkUpdateZ _res_conv = *(LDKCOption_NetworkUpdateZ*)(_res_ptr);
	FREE((void*)_res);
	COption_NetworkUpdateZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_COption_1NetworkUpdateZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCOption_NetworkUpdateZ* orig_conv = (LDKCOption_NetworkUpdateZ*)orig;
	LDKCOption_NetworkUpdateZ *ret_copy = MALLOC(sizeof(LDKCOption_NetworkUpdateZ), "LDKCOption_NetworkUpdateZ");
	*ret_copy = COption_NetworkUpdateZ_clone(orig_conv);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CVec_1SpendableOutputDescriptorZ_1free(JNIEnv *env, jclass clz, int64_tArray _res) {
	LDKCVec_SpendableOutputDescriptorZ _res_constr;
	_res_constr.datalen = (*env)->GetArrayLength(env, _res);
	if (_res_constr.datalen > 0)
		_res_constr.data = MALLOC(_res_constr.datalen * sizeof(LDKSpendableOutputDescriptor), "LDKCVec_SpendableOutputDescriptorZ Elements");
	else
		_res_constr.data = NULL;
	int64_t* _res_vals = (*env)->GetLongArrayElements (env, _res, NULL);
	for (size_t b = 0; b < _res_constr.datalen; b++) {
		int64_t _res_conv_27 = _res_vals[b];
		void* _res_conv_27_ptr = (void*)(((uint64_t)_res_conv_27) & ~1);
		CHECK_ACCESS(_res_conv_27_ptr);
		LDKSpendableOutputDescriptor _res_conv_27_conv = *(LDKSpendableOutputDescriptor*)(_res_conv_27_ptr);
		FREE((void*)_res_conv_27);
		_res_constr.data[b] = _res_conv_27_conv;
	}
	(*env)->ReleaseLongArrayElements(env, _res, _res_vals, 0);
	CVec_SpendableOutputDescriptorZ_free(_res_constr);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CVec_1MessageSendEventZ_1free(JNIEnv *env, jclass clz, int64_tArray _res) {
	LDKCVec_MessageSendEventZ _res_constr;
	_res_constr.datalen = (*env)->GetArrayLength(env, _res);
	if (_res_constr.datalen > 0)
		_res_constr.data = MALLOC(_res_constr.datalen * sizeof(LDKMessageSendEvent), "LDKCVec_MessageSendEventZ Elements");
	else
		_res_constr.data = NULL;
	int64_t* _res_vals = (*env)->GetLongArrayElements (env, _res, NULL);
	for (size_t s = 0; s < _res_constr.datalen; s++) {
		int64_t _res_conv_18 = _res_vals[s];
		void* _res_conv_18_ptr = (void*)(((uint64_t)_res_conv_18) & ~1);
		CHECK_ACCESS(_res_conv_18_ptr);
		LDKMessageSendEvent _res_conv_18_conv = *(LDKMessageSendEvent*)(_res_conv_18_ptr);
		FREE((void*)_res_conv_18);
		_res_constr.data[s] = _res_conv_18_conv;
	}
	(*env)->ReleaseLongArrayElements(env, _res, _res_vals, 0);
	CVec_MessageSendEventZ_free(_res_constr);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1InitFeaturesDecodeErrorZ_1ok(JNIEnv *env, jclass clz, int64_t o) {
	LDKInitFeatures o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = (o & 1) || (o == 0);
	o_conv = InitFeatures_clone(&o_conv);
	LDKCResult_InitFeaturesDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_InitFeaturesDecodeErrorZ), "LDKCResult_InitFeaturesDecodeErrorZ");
	*ret_conv = CResult_InitFeaturesDecodeErrorZ_ok(o_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1InitFeaturesDecodeErrorZ_1err(JNIEnv *env, jclass clz, int64_t e) {
	LDKDecodeError e_conv;
	e_conv.inner = (void*)(e & (~1));
	e_conv.is_owned = (e & 1) || (e == 0);
	e_conv = DecodeError_clone(&e_conv);
	LDKCResult_InitFeaturesDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_InitFeaturesDecodeErrorZ), "LDKCResult_InitFeaturesDecodeErrorZ");
	*ret_conv = CResult_InitFeaturesDecodeErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1InitFeaturesDecodeErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_InitFeaturesDecodeErrorZ _res_conv = *(LDKCResult_InitFeaturesDecodeErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_InitFeaturesDecodeErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1NodeFeaturesDecodeErrorZ_1ok(JNIEnv *env, jclass clz, int64_t o) {
	LDKNodeFeatures o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = (o & 1) || (o == 0);
	o_conv = NodeFeatures_clone(&o_conv);
	LDKCResult_NodeFeaturesDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_NodeFeaturesDecodeErrorZ), "LDKCResult_NodeFeaturesDecodeErrorZ");
	*ret_conv = CResult_NodeFeaturesDecodeErrorZ_ok(o_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1NodeFeaturesDecodeErrorZ_1err(JNIEnv *env, jclass clz, int64_t e) {
	LDKDecodeError e_conv;
	e_conv.inner = (void*)(e & (~1));
	e_conv.is_owned = (e & 1) || (e == 0);
	e_conv = DecodeError_clone(&e_conv);
	LDKCResult_NodeFeaturesDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_NodeFeaturesDecodeErrorZ), "LDKCResult_NodeFeaturesDecodeErrorZ");
	*ret_conv = CResult_NodeFeaturesDecodeErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1NodeFeaturesDecodeErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_NodeFeaturesDecodeErrorZ _res_conv = *(LDKCResult_NodeFeaturesDecodeErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_NodeFeaturesDecodeErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1ChannelFeaturesDecodeErrorZ_1ok(JNIEnv *env, jclass clz, int64_t o) {
	LDKChannelFeatures o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = (o & 1) || (o == 0);
	o_conv = ChannelFeatures_clone(&o_conv);
	LDKCResult_ChannelFeaturesDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_ChannelFeaturesDecodeErrorZ), "LDKCResult_ChannelFeaturesDecodeErrorZ");
	*ret_conv = CResult_ChannelFeaturesDecodeErrorZ_ok(o_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1ChannelFeaturesDecodeErrorZ_1err(JNIEnv *env, jclass clz, int64_t e) {
	LDKDecodeError e_conv;
	e_conv.inner = (void*)(e & (~1));
	e_conv.is_owned = (e & 1) || (e == 0);
	e_conv = DecodeError_clone(&e_conv);
	LDKCResult_ChannelFeaturesDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_ChannelFeaturesDecodeErrorZ), "LDKCResult_ChannelFeaturesDecodeErrorZ");
	*ret_conv = CResult_ChannelFeaturesDecodeErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1ChannelFeaturesDecodeErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_ChannelFeaturesDecodeErrorZ _res_conv = *(LDKCResult_ChannelFeaturesDecodeErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_ChannelFeaturesDecodeErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1InvoiceFeaturesDecodeErrorZ_1ok(JNIEnv *env, jclass clz, int64_t o) {
	LDKInvoiceFeatures o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = (o & 1) || (o == 0);
	o_conv = InvoiceFeatures_clone(&o_conv);
	LDKCResult_InvoiceFeaturesDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_InvoiceFeaturesDecodeErrorZ), "LDKCResult_InvoiceFeaturesDecodeErrorZ");
	*ret_conv = CResult_InvoiceFeaturesDecodeErrorZ_ok(o_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1InvoiceFeaturesDecodeErrorZ_1err(JNIEnv *env, jclass clz, int64_t e) {
	LDKDecodeError e_conv;
	e_conv.inner = (void*)(e & (~1));
	e_conv.is_owned = (e & 1) || (e == 0);
	e_conv = DecodeError_clone(&e_conv);
	LDKCResult_InvoiceFeaturesDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_InvoiceFeaturesDecodeErrorZ), "LDKCResult_InvoiceFeaturesDecodeErrorZ");
	*ret_conv = CResult_InvoiceFeaturesDecodeErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1InvoiceFeaturesDecodeErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_InvoiceFeaturesDecodeErrorZ _res_conv = *(LDKCResult_InvoiceFeaturesDecodeErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_InvoiceFeaturesDecodeErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1DelayedPaymentOutputDescriptorDecodeErrorZ_1ok(JNIEnv *env, jclass clz, int64_t o) {
	LDKDelayedPaymentOutputDescriptor o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = (o & 1) || (o == 0);
	o_conv = DelayedPaymentOutputDescriptor_clone(&o_conv);
	LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ), "LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ");
	*ret_conv = CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_ok(o_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1DelayedPaymentOutputDescriptorDecodeErrorZ_1err(JNIEnv *env, jclass clz, int64_t e) {
	LDKDecodeError e_conv;
	e_conv.inner = (void*)(e & (~1));
	e_conv.is_owned = (e & 1) || (e == 0);
	e_conv = DecodeError_clone(&e_conv);
	LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ), "LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ");
	*ret_conv = CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1DelayedPaymentOutputDescriptorDecodeErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ _res_conv = *(LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1DelayedPaymentOutputDescriptorDecodeErrorZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ* orig_conv = (LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ*)(orig & ~1);
	LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ), "LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ");
	*ret_conv = CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1StaticPaymentOutputDescriptorDecodeErrorZ_1ok(JNIEnv *env, jclass clz, int64_t o) {
	LDKStaticPaymentOutputDescriptor o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = (o & 1) || (o == 0);
	o_conv = StaticPaymentOutputDescriptor_clone(&o_conv);
	LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ), "LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ");
	*ret_conv = CResult_StaticPaymentOutputDescriptorDecodeErrorZ_ok(o_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1StaticPaymentOutputDescriptorDecodeErrorZ_1err(JNIEnv *env, jclass clz, int64_t e) {
	LDKDecodeError e_conv;
	e_conv.inner = (void*)(e & (~1));
	e_conv.is_owned = (e & 1) || (e == 0);
	e_conv = DecodeError_clone(&e_conv);
	LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ), "LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ");
	*ret_conv = CResult_StaticPaymentOutputDescriptorDecodeErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1StaticPaymentOutputDescriptorDecodeErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ _res_conv = *(LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_StaticPaymentOutputDescriptorDecodeErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1StaticPaymentOutputDescriptorDecodeErrorZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ* orig_conv = (LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ*)(orig & ~1);
	LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ), "LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ");
	*ret_conv = CResult_StaticPaymentOutputDescriptorDecodeErrorZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1SpendableOutputDescriptorDecodeErrorZ_1ok(JNIEnv *env, jclass clz, int64_t o) {
	void* o_ptr = (void*)(((uint64_t)o) & ~1);
	CHECK_ACCESS(o_ptr);
	LDKSpendableOutputDescriptor o_conv = *(LDKSpendableOutputDescriptor*)(o_ptr);
	o_conv = SpendableOutputDescriptor_clone((LDKSpendableOutputDescriptor*)(((uint64_t)o) & ~1));
	LDKCResult_SpendableOutputDescriptorDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_SpendableOutputDescriptorDecodeErrorZ), "LDKCResult_SpendableOutputDescriptorDecodeErrorZ");
	*ret_conv = CResult_SpendableOutputDescriptorDecodeErrorZ_ok(o_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1SpendableOutputDescriptorDecodeErrorZ_1err(JNIEnv *env, jclass clz, int64_t e) {
	LDKDecodeError e_conv;
	e_conv.inner = (void*)(e & (~1));
	e_conv.is_owned = (e & 1) || (e == 0);
	e_conv = DecodeError_clone(&e_conv);
	LDKCResult_SpendableOutputDescriptorDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_SpendableOutputDescriptorDecodeErrorZ), "LDKCResult_SpendableOutputDescriptorDecodeErrorZ");
	*ret_conv = CResult_SpendableOutputDescriptorDecodeErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1SpendableOutputDescriptorDecodeErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_SpendableOutputDescriptorDecodeErrorZ _res_conv = *(LDKCResult_SpendableOutputDescriptorDecodeErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_SpendableOutputDescriptorDecodeErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1SpendableOutputDescriptorDecodeErrorZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_SpendableOutputDescriptorDecodeErrorZ* orig_conv = (LDKCResult_SpendableOutputDescriptorDecodeErrorZ*)(orig & ~1);
	LDKCResult_SpendableOutputDescriptorDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_SpendableOutputDescriptorDecodeErrorZ), "LDKCResult_SpendableOutputDescriptorDecodeErrorZ");
	*ret_conv = CResult_SpendableOutputDescriptorDecodeErrorZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1NoneNoneZ_1ok(JNIEnv *env, jclass clz) {
	LDKCResult_NoneNoneZ* ret_conv = MALLOC(sizeof(LDKCResult_NoneNoneZ), "LDKCResult_NoneNoneZ");
	*ret_conv = CResult_NoneNoneZ_ok();
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1NoneNoneZ_1err(JNIEnv *env, jclass clz) {
	LDKCResult_NoneNoneZ* ret_conv = MALLOC(sizeof(LDKCResult_NoneNoneZ), "LDKCResult_NoneNoneZ");
	*ret_conv = CResult_NoneNoneZ_err();
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1NoneNoneZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_NoneNoneZ _res_conv = *(LDKCResult_NoneNoneZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_NoneNoneZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1NoneNoneZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_NoneNoneZ* orig_conv = (LDKCResult_NoneNoneZ*)(orig & ~1);
	LDKCResult_NoneNoneZ* ret_conv = MALLOC(sizeof(LDKCResult_NoneNoneZ), "LDKCResult_NoneNoneZ");
	*ret_conv = CResult_NoneNoneZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_C2Tuple_1SignatureCVec_1SignatureZZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKC2Tuple_SignatureCVec_SignatureZZ* orig_conv = (LDKC2Tuple_SignatureCVec_SignatureZZ*)(orig & ~1);
	LDKC2Tuple_SignatureCVec_SignatureZZ* ret_conv = MALLOC(sizeof(LDKC2Tuple_SignatureCVec_SignatureZZ), "LDKC2Tuple_SignatureCVec_SignatureZZ");
	*ret_conv = C2Tuple_SignatureCVec_SignatureZZ_clone(orig_conv);
	return ((uint64_t)ret_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_C2Tuple_1SignatureCVec_1SignatureZZ_1new(JNIEnv *env, jclass clz, int8_tArray a, jobjectArray b) {
	LDKSignature a_ref;
	CHECK((*env)->GetArrayLength(env, a) == 64);
	(*env)->GetByteArrayRegion(env, a, 0, 64, a_ref.compact_form);
	LDKCVec_SignatureZ b_constr;
	b_constr.datalen = (*env)->GetArrayLength(env, b);
	if (b_constr.datalen > 0)
		b_constr.data = MALLOC(b_constr.datalen * sizeof(LDKSignature), "LDKCVec_SignatureZ Elements");
	else
		b_constr.data = NULL;
	for (size_t i = 0; i < b_constr.datalen; i++) {
		int8_tArray b_conv_8 = (*env)->GetObjectArrayElement(env, b, i);
		LDKSignature b_conv_8_ref;
		CHECK((*env)->GetArrayLength(env, b_conv_8) == 64);
		(*env)->GetByteArrayRegion(env, b_conv_8, 0, 64, b_conv_8_ref.compact_form);
		b_constr.data[i] = b_conv_8_ref;
	}
	LDKC2Tuple_SignatureCVec_SignatureZZ* ret_conv = MALLOC(sizeof(LDKC2Tuple_SignatureCVec_SignatureZZ), "LDKC2Tuple_SignatureCVec_SignatureZZ");
	*ret_conv = C2Tuple_SignatureCVec_SignatureZZ_new(a_ref, b_constr);
	return ((uint64_t)ret_conv);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_C2Tuple_1SignatureCVec_1SignatureZZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKC2Tuple_SignatureCVec_SignatureZZ _res_conv = *(LDKC2Tuple_SignatureCVec_SignatureZZ*)(_res_ptr);
	FREE((void*)_res);
	C2Tuple_SignatureCVec_SignatureZZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1C2Tuple_1SignatureCVec_1SignatureZZNoneZ_1ok(JNIEnv *env, jclass clz, int64_t o) {
	void* o_ptr = (void*)(((uint64_t)o) & ~1);
	CHECK_ACCESS(o_ptr);
	LDKC2Tuple_SignatureCVec_SignatureZZ o_conv = *(LDKC2Tuple_SignatureCVec_SignatureZZ*)(o_ptr);
	o_conv = C2Tuple_SignatureCVec_SignatureZZ_clone((LDKC2Tuple_SignatureCVec_SignatureZZ*)(((uint64_t)o) & ~1));
	LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ* ret_conv = MALLOC(sizeof(LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ), "LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ");
	*ret_conv = CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_ok(o_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1C2Tuple_1SignatureCVec_1SignatureZZNoneZ_1err(JNIEnv *env, jclass clz) {
	LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ* ret_conv = MALLOC(sizeof(LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ), "LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ");
	*ret_conv = CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_err();
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1C2Tuple_1SignatureCVec_1SignatureZZNoneZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ _res_conv = *(LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1C2Tuple_1SignatureCVec_1SignatureZZNoneZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ* orig_conv = (LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ*)(orig & ~1);
	LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ* ret_conv = MALLOC(sizeof(LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ), "LDKCResult_C2Tuple_SignatureCVec_SignatureZZNoneZ");
	*ret_conv = CResult_C2Tuple_SignatureCVec_SignatureZZNoneZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1SignatureNoneZ_1ok(JNIEnv *env, jclass clz, int8_tArray o) {
	LDKSignature o_ref;
	CHECK((*env)->GetArrayLength(env, o) == 64);
	(*env)->GetByteArrayRegion(env, o, 0, 64, o_ref.compact_form);
	LDKCResult_SignatureNoneZ* ret_conv = MALLOC(sizeof(LDKCResult_SignatureNoneZ), "LDKCResult_SignatureNoneZ");
	*ret_conv = CResult_SignatureNoneZ_ok(o_ref);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1SignatureNoneZ_1err(JNIEnv *env, jclass clz) {
	LDKCResult_SignatureNoneZ* ret_conv = MALLOC(sizeof(LDKCResult_SignatureNoneZ), "LDKCResult_SignatureNoneZ");
	*ret_conv = CResult_SignatureNoneZ_err();
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1SignatureNoneZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_SignatureNoneZ _res_conv = *(LDKCResult_SignatureNoneZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_SignatureNoneZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1SignatureNoneZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_SignatureNoneZ* orig_conv = (LDKCResult_SignatureNoneZ*)(orig & ~1);
	LDKCResult_SignatureNoneZ* ret_conv = MALLOC(sizeof(LDKCResult_SignatureNoneZ), "LDKCResult_SignatureNoneZ");
	*ret_conv = CResult_SignatureNoneZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1SignDecodeErrorZ_1ok(JNIEnv *env, jclass clz, int64_t o) {
	void* o_ptr = (void*)(((uint64_t)o) & ~1);
	CHECK_ACCESS(o_ptr);
	LDKSign o_conv = *(LDKSign*)(o_ptr);
	if (o_conv.free == LDKSign_JCalls_free) {
		// If this_arg is a JCalls struct, then we need to increment the refcnt in it.
		LDKSign_JCalls_cloned(&o_conv);
	}
	LDKCResult_SignDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_SignDecodeErrorZ), "LDKCResult_SignDecodeErrorZ");
	*ret_conv = CResult_SignDecodeErrorZ_ok(o_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1SignDecodeErrorZ_1err(JNIEnv *env, jclass clz, int64_t e) {
	LDKDecodeError e_conv;
	e_conv.inner = (void*)(e & (~1));
	e_conv.is_owned = (e & 1) || (e == 0);
	e_conv = DecodeError_clone(&e_conv);
	LDKCResult_SignDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_SignDecodeErrorZ), "LDKCResult_SignDecodeErrorZ");
	*ret_conv = CResult_SignDecodeErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1SignDecodeErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_SignDecodeErrorZ _res_conv = *(LDKCResult_SignDecodeErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_SignDecodeErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1SignDecodeErrorZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_SignDecodeErrorZ* orig_conv = (LDKCResult_SignDecodeErrorZ*)(orig & ~1);
	LDKCResult_SignDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_SignDecodeErrorZ), "LDKCResult_SignDecodeErrorZ");
	*ret_conv = CResult_SignDecodeErrorZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CVec_1u8Z_1free(JNIEnv *env, jclass clz, int8_tArray _res) {
	LDKCVec_u8Z _res_ref;
	_res_ref.datalen = (*env)->GetArrayLength(env, _res);
	_res_ref.data = MALLOC(_res_ref.datalen, "LDKCVec_u8Z Bytes");
	(*env)->GetByteArrayRegion(env, _res, 0, _res_ref.datalen, _res_ref.data);
	CVec_u8Z_free(_res_ref);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1RecoverableSignatureNoneZ_1ok(JNIEnv *env, jclass clz, int8_tArray arg) {
	LDKRecoverableSignature arg_ref;
	CHECK((*env)->GetArrayLength(env, arg) == 68);
	(*env)->GetByteArrayRegion(env, arg, 0, 68, arg_ref.serialized_form);
	LDKCResult_RecoverableSignatureNoneZ* ret_conv = MALLOC(sizeof(LDKCResult_RecoverableSignatureNoneZ), "LDKCResult_RecoverableSignatureNoneZ");
	*ret_conv = CResult_RecoverableSignatureNoneZ_ok(arg_ref);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1RecoverableSignatureNoneZ_1err(JNIEnv *env, jclass clz) {
	LDKCResult_RecoverableSignatureNoneZ* ret_conv = MALLOC(sizeof(LDKCResult_RecoverableSignatureNoneZ), "LDKCResult_RecoverableSignatureNoneZ");
	*ret_conv = CResult_RecoverableSignatureNoneZ_err();
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1RecoverableSignatureNoneZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_RecoverableSignatureNoneZ _res_conv = *(LDKCResult_RecoverableSignatureNoneZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_RecoverableSignatureNoneZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1RecoverableSignatureNoneZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_RecoverableSignatureNoneZ* orig_conv = (LDKCResult_RecoverableSignatureNoneZ*)(orig & ~1);
	LDKCResult_RecoverableSignatureNoneZ* ret_conv = MALLOC(sizeof(LDKCResult_RecoverableSignatureNoneZ), "LDKCResult_RecoverableSignatureNoneZ");
	*ret_conv = CResult_RecoverableSignatureNoneZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CVec_1CVec_1u8ZZ_1free(JNIEnv *env, jclass clz, jobjectArray _res) {
	LDKCVec_CVec_u8ZZ _res_constr;
	_res_constr.datalen = (*env)->GetArrayLength(env, _res);
	if (_res_constr.datalen > 0)
		_res_constr.data = MALLOC(_res_constr.datalen * sizeof(LDKCVec_u8Z), "LDKCVec_CVec_u8ZZ Elements");
	else
		_res_constr.data = NULL;
	for (size_t i = 0; i < _res_constr.datalen; i++) {
		int8_tArray _res_conv_8 = (*env)->GetObjectArrayElement(env, _res, i);
		LDKCVec_u8Z _res_conv_8_ref;
		_res_conv_8_ref.datalen = (*env)->GetArrayLength(env, _res_conv_8);
		_res_conv_8_ref.data = MALLOC(_res_conv_8_ref.datalen, "LDKCVec_u8Z Bytes");
		(*env)->GetByteArrayRegion(env, _res_conv_8, 0, _res_conv_8_ref.datalen, _res_conv_8_ref.data);
		_res_constr.data[i] = _res_conv_8_ref;
	}
	CVec_CVec_u8ZZ_free(_res_constr);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1CVec_1CVec_1u8ZZNoneZ_1ok(JNIEnv *env, jclass clz, jobjectArray o) {
	LDKCVec_CVec_u8ZZ o_constr;
	o_constr.datalen = (*env)->GetArrayLength(env, o);
	if (o_constr.datalen > 0)
		o_constr.data = MALLOC(o_constr.datalen * sizeof(LDKCVec_u8Z), "LDKCVec_CVec_u8ZZ Elements");
	else
		o_constr.data = NULL;
	for (size_t i = 0; i < o_constr.datalen; i++) {
		int8_tArray o_conv_8 = (*env)->GetObjectArrayElement(env, o, i);
		LDKCVec_u8Z o_conv_8_ref;
		o_conv_8_ref.datalen = (*env)->GetArrayLength(env, o_conv_8);
		o_conv_8_ref.data = MALLOC(o_conv_8_ref.datalen, "LDKCVec_u8Z Bytes");
		(*env)->GetByteArrayRegion(env, o_conv_8, 0, o_conv_8_ref.datalen, o_conv_8_ref.data);
		o_constr.data[i] = o_conv_8_ref;
	}
	LDKCResult_CVec_CVec_u8ZZNoneZ* ret_conv = MALLOC(sizeof(LDKCResult_CVec_CVec_u8ZZNoneZ), "LDKCResult_CVec_CVec_u8ZZNoneZ");
	*ret_conv = CResult_CVec_CVec_u8ZZNoneZ_ok(o_constr);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1CVec_1CVec_1u8ZZNoneZ_1err(JNIEnv *env, jclass clz) {
	LDKCResult_CVec_CVec_u8ZZNoneZ* ret_conv = MALLOC(sizeof(LDKCResult_CVec_CVec_u8ZZNoneZ), "LDKCResult_CVec_CVec_u8ZZNoneZ");
	*ret_conv = CResult_CVec_CVec_u8ZZNoneZ_err();
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1CVec_1CVec_1u8ZZNoneZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_CVec_CVec_u8ZZNoneZ _res_conv = *(LDKCResult_CVec_CVec_u8ZZNoneZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_CVec_CVec_u8ZZNoneZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1CVec_1CVec_1u8ZZNoneZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_CVec_CVec_u8ZZNoneZ* orig_conv = (LDKCResult_CVec_CVec_u8ZZNoneZ*)(orig & ~1);
	LDKCResult_CVec_CVec_u8ZZNoneZ* ret_conv = MALLOC(sizeof(LDKCResult_CVec_CVec_u8ZZNoneZ), "LDKCResult_CVec_CVec_u8ZZNoneZ");
	*ret_conv = CResult_CVec_CVec_u8ZZNoneZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1InMemorySignerDecodeErrorZ_1ok(JNIEnv *env, jclass clz, int64_t o) {
	LDKInMemorySigner o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = (o & 1) || (o == 0);
	o_conv = InMemorySigner_clone(&o_conv);
	LDKCResult_InMemorySignerDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_InMemorySignerDecodeErrorZ), "LDKCResult_InMemorySignerDecodeErrorZ");
	*ret_conv = CResult_InMemorySignerDecodeErrorZ_ok(o_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1InMemorySignerDecodeErrorZ_1err(JNIEnv *env, jclass clz, int64_t e) {
	LDKDecodeError e_conv;
	e_conv.inner = (void*)(e & (~1));
	e_conv.is_owned = (e & 1) || (e == 0);
	e_conv = DecodeError_clone(&e_conv);
	LDKCResult_InMemorySignerDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_InMemorySignerDecodeErrorZ), "LDKCResult_InMemorySignerDecodeErrorZ");
	*ret_conv = CResult_InMemorySignerDecodeErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1InMemorySignerDecodeErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_InMemorySignerDecodeErrorZ _res_conv = *(LDKCResult_InMemorySignerDecodeErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_InMemorySignerDecodeErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1InMemorySignerDecodeErrorZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_InMemorySignerDecodeErrorZ* orig_conv = (LDKCResult_InMemorySignerDecodeErrorZ*)(orig & ~1);
	LDKCResult_InMemorySignerDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_InMemorySignerDecodeErrorZ), "LDKCResult_InMemorySignerDecodeErrorZ");
	*ret_conv = CResult_InMemorySignerDecodeErrorZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CVec_1TxOutZ_1free(JNIEnv *env, jclass clz, int64_tArray _res) {
	LDKCVec_TxOutZ _res_constr;
	_res_constr.datalen = (*env)->GetArrayLength(env, _res);
	if (_res_constr.datalen > 0)
		_res_constr.data = MALLOC(_res_constr.datalen * sizeof(LDKTxOut), "LDKCVec_TxOutZ Elements");
	else
		_res_constr.data = NULL;
	int64_t* _res_vals = (*env)->GetLongArrayElements (env, _res, NULL);
	for (size_t h = 0; h < _res_constr.datalen; h++) {
		int64_t _res_conv_7 = _res_vals[h];
		void* _res_conv_7_ptr = (void*)(((uint64_t)_res_conv_7) & ~1);
		CHECK_ACCESS(_res_conv_7_ptr);
		LDKTxOut _res_conv_7_conv = *(LDKTxOut*)(_res_conv_7_ptr);
		FREE((void*)_res_conv_7);
		_res_constr.data[h] = _res_conv_7_conv;
	}
	(*env)->ReleaseLongArrayElements(env, _res, _res_vals, 0);
	CVec_TxOutZ_free(_res_constr);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1TransactionNoneZ_1ok(JNIEnv *env, jclass clz, int8_tArray o) {
	LDKTransaction o_ref;
	o_ref.datalen = (*env)->GetArrayLength(env, o);
	o_ref.data = MALLOC(o_ref.datalen, "LDKTransaction Bytes");
	(*env)->GetByteArrayRegion(env, o, 0, o_ref.datalen, o_ref.data);
	o_ref.data_is_owned = true;
	LDKCResult_TransactionNoneZ* ret_conv = MALLOC(sizeof(LDKCResult_TransactionNoneZ), "LDKCResult_TransactionNoneZ");
	*ret_conv = CResult_TransactionNoneZ_ok(o_ref);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1TransactionNoneZ_1err(JNIEnv *env, jclass clz) {
	LDKCResult_TransactionNoneZ* ret_conv = MALLOC(sizeof(LDKCResult_TransactionNoneZ), "LDKCResult_TransactionNoneZ");
	*ret_conv = CResult_TransactionNoneZ_err();
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1TransactionNoneZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_TransactionNoneZ _res_conv = *(LDKCResult_TransactionNoneZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_TransactionNoneZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1TransactionNoneZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_TransactionNoneZ* orig_conv = (LDKCResult_TransactionNoneZ*)(orig & ~1);
	LDKCResult_TransactionNoneZ* ret_conv = MALLOC(sizeof(LDKCResult_TransactionNoneZ), "LDKCResult_TransactionNoneZ");
	*ret_conv = CResult_TransactionNoneZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_C2Tuple_1BlockHashChannelMonitorZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKC2Tuple_BlockHashChannelMonitorZ* orig_conv = (LDKC2Tuple_BlockHashChannelMonitorZ*)(orig & ~1);
	LDKC2Tuple_BlockHashChannelMonitorZ* ret_conv = MALLOC(sizeof(LDKC2Tuple_BlockHashChannelMonitorZ), "LDKC2Tuple_BlockHashChannelMonitorZ");
	*ret_conv = C2Tuple_BlockHashChannelMonitorZ_clone(orig_conv);
	return ((uint64_t)ret_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_C2Tuple_1BlockHashChannelMonitorZ_1new(JNIEnv *env, jclass clz, int8_tArray a, int64_t b) {
	LDKThirtyTwoBytes a_ref;
	CHECK((*env)->GetArrayLength(env, a) == 32);
	(*env)->GetByteArrayRegion(env, a, 0, 32, a_ref.data);
	LDKChannelMonitor b_conv;
	b_conv.inner = (void*)(b & (~1));
	b_conv.is_owned = (b & 1) || (b == 0);
	b_conv = ChannelMonitor_clone(&b_conv);
	LDKC2Tuple_BlockHashChannelMonitorZ* ret_conv = MALLOC(sizeof(LDKC2Tuple_BlockHashChannelMonitorZ), "LDKC2Tuple_BlockHashChannelMonitorZ");
	*ret_conv = C2Tuple_BlockHashChannelMonitorZ_new(a_ref, b_conv);
	return ((uint64_t)ret_conv);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_C2Tuple_1BlockHashChannelMonitorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKC2Tuple_BlockHashChannelMonitorZ _res_conv = *(LDKC2Tuple_BlockHashChannelMonitorZ*)(_res_ptr);
	FREE((void*)_res);
	C2Tuple_BlockHashChannelMonitorZ_free(_res_conv);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CVec_1C2Tuple_1BlockHashChannelMonitorZZ_1free(JNIEnv *env, jclass clz, int64_tArray _res) {
	LDKCVec_C2Tuple_BlockHashChannelMonitorZZ _res_constr;
	_res_constr.datalen = (*env)->GetArrayLength(env, _res);
	if (_res_constr.datalen > 0)
		_res_constr.data = MALLOC(_res_constr.datalen * sizeof(LDKC2Tuple_BlockHashChannelMonitorZ), "LDKCVec_C2Tuple_BlockHashChannelMonitorZZ Elements");
	else
		_res_constr.data = NULL;
	int64_t* _res_vals = (*env)->GetLongArrayElements (env, _res, NULL);
	for (size_t j = 0; j < _res_constr.datalen; j++) {
		int64_t _res_conv_35 = _res_vals[j];
		void* _res_conv_35_ptr = (void*)(((uint64_t)_res_conv_35) & ~1);
		CHECK_ACCESS(_res_conv_35_ptr);
		LDKC2Tuple_BlockHashChannelMonitorZ _res_conv_35_conv = *(LDKC2Tuple_BlockHashChannelMonitorZ*)(_res_conv_35_ptr);
		FREE((void*)_res_conv_35);
		_res_constr.data[j] = _res_conv_35_conv;
	}
	(*env)->ReleaseLongArrayElements(env, _res, _res_vals, 0);
	CVec_C2Tuple_BlockHashChannelMonitorZZ_free(_res_constr);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1CVec_1C2Tuple_1BlockHashChannelMonitorZZErrorZ_1ok(JNIEnv *env, jclass clz, int64_tArray o) {
	LDKCVec_C2Tuple_BlockHashChannelMonitorZZ o_constr;
	o_constr.datalen = (*env)->GetArrayLength(env, o);
	if (o_constr.datalen > 0)
		o_constr.data = MALLOC(o_constr.datalen * sizeof(LDKC2Tuple_BlockHashChannelMonitorZ), "LDKCVec_C2Tuple_BlockHashChannelMonitorZZ Elements");
	else
		o_constr.data = NULL;
	int64_t* o_vals = (*env)->GetLongArrayElements (env, o, NULL);
	for (size_t j = 0; j < o_constr.datalen; j++) {
		int64_t o_conv_35 = o_vals[j];
		void* o_conv_35_ptr = (void*)(((uint64_t)o_conv_35) & ~1);
		CHECK_ACCESS(o_conv_35_ptr);
		LDKC2Tuple_BlockHashChannelMonitorZ o_conv_35_conv = *(LDKC2Tuple_BlockHashChannelMonitorZ*)(o_conv_35_ptr);
		o_conv_35_conv = C2Tuple_BlockHashChannelMonitorZ_clone((LDKC2Tuple_BlockHashChannelMonitorZ*)(((uint64_t)o_conv_35) & ~1));
		o_constr.data[j] = o_conv_35_conv;
	}
	(*env)->ReleaseLongArrayElements(env, o, o_vals, 0);
	LDKCResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ), "LDKCResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ");
	*ret_conv = CResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ_ok(o_constr);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1CVec_1C2Tuple_1BlockHashChannelMonitorZZErrorZ_1err(JNIEnv *env, jclass clz, jclass e) {
	LDKIOError e_conv = LDKIOError_from_java(env, e);
	LDKCResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ), "LDKCResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ");
	*ret_conv = CResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1CVec_1C2Tuple_1BlockHashChannelMonitorZZErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ _res_conv = *(LDKCResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1CVec_1C2Tuple_1BlockHashChannelMonitorZZErrorZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ* orig_conv = (LDKCResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ*)(orig & ~1);
	LDKCResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ), "LDKCResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ");
	*ret_conv = CResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_COption_1u16Z_1some(JNIEnv *env, jclass clz, int16_t o) {
	LDKCOption_u16Z *ret_copy = MALLOC(sizeof(LDKCOption_u16Z), "LDKCOption_u16Z");
	*ret_copy = COption_u16Z_some(o);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_COption_1u16Z_1none(JNIEnv *env, jclass clz) {
	LDKCOption_u16Z *ret_copy = MALLOC(sizeof(LDKCOption_u16Z), "LDKCOption_u16Z");
	*ret_copy = COption_u16Z_none();
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_COption_1u16Z_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCOption_u16Z _res_conv = *(LDKCOption_u16Z*)(_res_ptr);
	FREE((void*)_res);
	COption_u16Z_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_COption_1u16Z_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCOption_u16Z* orig_conv = (LDKCOption_u16Z*)orig;
	LDKCOption_u16Z *ret_copy = MALLOC(sizeof(LDKCOption_u16Z), "LDKCOption_u16Z");
	*ret_copy = COption_u16Z_clone(orig_conv);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1NoneAPIErrorZ_1ok(JNIEnv *env, jclass clz) {
	LDKCResult_NoneAPIErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_NoneAPIErrorZ), "LDKCResult_NoneAPIErrorZ");
	*ret_conv = CResult_NoneAPIErrorZ_ok();
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1NoneAPIErrorZ_1err(JNIEnv *env, jclass clz, int64_t e) {
	void* e_ptr = (void*)(((uint64_t)e) & ~1);
	CHECK_ACCESS(e_ptr);
	LDKAPIError e_conv = *(LDKAPIError*)(e_ptr);
	e_conv = APIError_clone((LDKAPIError*)(((uint64_t)e) & ~1));
	LDKCResult_NoneAPIErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_NoneAPIErrorZ), "LDKCResult_NoneAPIErrorZ");
	*ret_conv = CResult_NoneAPIErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1NoneAPIErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_NoneAPIErrorZ _res_conv = *(LDKCResult_NoneAPIErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_NoneAPIErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1NoneAPIErrorZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_NoneAPIErrorZ* orig_conv = (LDKCResult_NoneAPIErrorZ*)(orig & ~1);
	LDKCResult_NoneAPIErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_NoneAPIErrorZ), "LDKCResult_NoneAPIErrorZ");
	*ret_conv = CResult_NoneAPIErrorZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CVec_1CResult_1NoneAPIErrorZZ_1free(JNIEnv *env, jclass clz, int64_tArray _res) {
	LDKCVec_CResult_NoneAPIErrorZZ _res_constr;
	_res_constr.datalen = (*env)->GetArrayLength(env, _res);
	if (_res_constr.datalen > 0)
		_res_constr.data = MALLOC(_res_constr.datalen * sizeof(LDKCResult_NoneAPIErrorZ), "LDKCVec_CResult_NoneAPIErrorZZ Elements");
	else
		_res_constr.data = NULL;
	int64_t* _res_vals = (*env)->GetLongArrayElements (env, _res, NULL);
	for (size_t w = 0; w < _res_constr.datalen; w++) {
		int64_t _res_conv_22 = _res_vals[w];
		void* _res_conv_22_ptr = (void*)(((uint64_t)_res_conv_22) & ~1);
		CHECK_ACCESS(_res_conv_22_ptr);
		LDKCResult_NoneAPIErrorZ _res_conv_22_conv = *(LDKCResult_NoneAPIErrorZ*)(_res_conv_22_ptr);
		FREE((void*)_res_conv_22);
		_res_constr.data[w] = _res_conv_22_conv;
	}
	(*env)->ReleaseLongArrayElements(env, _res, _res_vals, 0);
	CVec_CResult_NoneAPIErrorZZ_free(_res_constr);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CVec_1APIErrorZ_1free(JNIEnv *env, jclass clz, int64_tArray _res) {
	LDKCVec_APIErrorZ _res_constr;
	_res_constr.datalen = (*env)->GetArrayLength(env, _res);
	if (_res_constr.datalen > 0)
		_res_constr.data = MALLOC(_res_constr.datalen * sizeof(LDKAPIError), "LDKCVec_APIErrorZ Elements");
	else
		_res_constr.data = NULL;
	int64_t* _res_vals = (*env)->GetLongArrayElements (env, _res, NULL);
	for (size_t k = 0; k < _res_constr.datalen; k++) {
		int64_t _res_conv_10 = _res_vals[k];
		void* _res_conv_10_ptr = (void*)(((uint64_t)_res_conv_10) & ~1);
		CHECK_ACCESS(_res_conv_10_ptr);
		LDKAPIError _res_conv_10_conv = *(LDKAPIError*)(_res_conv_10_ptr);
		FREE((void*)_res_conv_10);
		_res_constr.data[k] = _res_conv_10_conv;
	}
	(*env)->ReleaseLongArrayElements(env, _res, _res_vals, 0);
	CVec_APIErrorZ_free(_res_constr);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1_1u832APIErrorZ_1ok(JNIEnv *env, jclass clz, int8_tArray o) {
	LDKThirtyTwoBytes o_ref;
	CHECK((*env)->GetArrayLength(env, o) == 32);
	(*env)->GetByteArrayRegion(env, o, 0, 32, o_ref.data);
	LDKCResult__u832APIErrorZ* ret_conv = MALLOC(sizeof(LDKCResult__u832APIErrorZ), "LDKCResult__u832APIErrorZ");
	*ret_conv = CResult__u832APIErrorZ_ok(o_ref);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1_1u832APIErrorZ_1err(JNIEnv *env, jclass clz, int64_t e) {
	void* e_ptr = (void*)(((uint64_t)e) & ~1);
	CHECK_ACCESS(e_ptr);
	LDKAPIError e_conv = *(LDKAPIError*)(e_ptr);
	e_conv = APIError_clone((LDKAPIError*)(((uint64_t)e) & ~1));
	LDKCResult__u832APIErrorZ* ret_conv = MALLOC(sizeof(LDKCResult__u832APIErrorZ), "LDKCResult__u832APIErrorZ");
	*ret_conv = CResult__u832APIErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1_1u832APIErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult__u832APIErrorZ _res_conv = *(LDKCResult__u832APIErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult__u832APIErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1_1u832APIErrorZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult__u832APIErrorZ* orig_conv = (LDKCResult__u832APIErrorZ*)(orig & ~1);
	LDKCResult__u832APIErrorZ* ret_conv = MALLOC(sizeof(LDKCResult__u832APIErrorZ), "LDKCResult__u832APIErrorZ");
	*ret_conv = CResult__u832APIErrorZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1PaymentIdPaymentSendFailureZ_1ok(JNIEnv *env, jclass clz, int8_tArray o) {
	LDKThirtyTwoBytes o_ref;
	CHECK((*env)->GetArrayLength(env, o) == 32);
	(*env)->GetByteArrayRegion(env, o, 0, 32, o_ref.data);
	LDKCResult_PaymentIdPaymentSendFailureZ* ret_conv = MALLOC(sizeof(LDKCResult_PaymentIdPaymentSendFailureZ), "LDKCResult_PaymentIdPaymentSendFailureZ");
	*ret_conv = CResult_PaymentIdPaymentSendFailureZ_ok(o_ref);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1PaymentIdPaymentSendFailureZ_1err(JNIEnv *env, jclass clz, int64_t e) {
	void* e_ptr = (void*)(((uint64_t)e) & ~1);
	CHECK_ACCESS(e_ptr);
	LDKPaymentSendFailure e_conv = *(LDKPaymentSendFailure*)(e_ptr);
	e_conv = PaymentSendFailure_clone((LDKPaymentSendFailure*)(((uint64_t)e) & ~1));
	LDKCResult_PaymentIdPaymentSendFailureZ* ret_conv = MALLOC(sizeof(LDKCResult_PaymentIdPaymentSendFailureZ), "LDKCResult_PaymentIdPaymentSendFailureZ");
	*ret_conv = CResult_PaymentIdPaymentSendFailureZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1PaymentIdPaymentSendFailureZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_PaymentIdPaymentSendFailureZ _res_conv = *(LDKCResult_PaymentIdPaymentSendFailureZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_PaymentIdPaymentSendFailureZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1PaymentIdPaymentSendFailureZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_PaymentIdPaymentSendFailureZ* orig_conv = (LDKCResult_PaymentIdPaymentSendFailureZ*)(orig & ~1);
	LDKCResult_PaymentIdPaymentSendFailureZ* ret_conv = MALLOC(sizeof(LDKCResult_PaymentIdPaymentSendFailureZ), "LDKCResult_PaymentIdPaymentSendFailureZ");
	*ret_conv = CResult_PaymentIdPaymentSendFailureZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1NonePaymentSendFailureZ_1ok(JNIEnv *env, jclass clz) {
	LDKCResult_NonePaymentSendFailureZ* ret_conv = MALLOC(sizeof(LDKCResult_NonePaymentSendFailureZ), "LDKCResult_NonePaymentSendFailureZ");
	*ret_conv = CResult_NonePaymentSendFailureZ_ok();
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1NonePaymentSendFailureZ_1err(JNIEnv *env, jclass clz, int64_t e) {
	void* e_ptr = (void*)(((uint64_t)e) & ~1);
	CHECK_ACCESS(e_ptr);
	LDKPaymentSendFailure e_conv = *(LDKPaymentSendFailure*)(e_ptr);
	e_conv = PaymentSendFailure_clone((LDKPaymentSendFailure*)(((uint64_t)e) & ~1));
	LDKCResult_NonePaymentSendFailureZ* ret_conv = MALLOC(sizeof(LDKCResult_NonePaymentSendFailureZ), "LDKCResult_NonePaymentSendFailureZ");
	*ret_conv = CResult_NonePaymentSendFailureZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1NonePaymentSendFailureZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_NonePaymentSendFailureZ _res_conv = *(LDKCResult_NonePaymentSendFailureZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_NonePaymentSendFailureZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1NonePaymentSendFailureZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_NonePaymentSendFailureZ* orig_conv = (LDKCResult_NonePaymentSendFailureZ*)(orig & ~1);
	LDKCResult_NonePaymentSendFailureZ* ret_conv = MALLOC(sizeof(LDKCResult_NonePaymentSendFailureZ), "LDKCResult_NonePaymentSendFailureZ");
	*ret_conv = CResult_NonePaymentSendFailureZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_C2Tuple_1PaymentHashPaymentIdZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKC2Tuple_PaymentHashPaymentIdZ* orig_conv = (LDKC2Tuple_PaymentHashPaymentIdZ*)(orig & ~1);
	LDKC2Tuple_PaymentHashPaymentIdZ* ret_conv = MALLOC(sizeof(LDKC2Tuple_PaymentHashPaymentIdZ), "LDKC2Tuple_PaymentHashPaymentIdZ");
	*ret_conv = C2Tuple_PaymentHashPaymentIdZ_clone(orig_conv);
	return ((uint64_t)ret_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_C2Tuple_1PaymentHashPaymentIdZ_1new(JNIEnv *env, jclass clz, int8_tArray a, int8_tArray b) {
	LDKThirtyTwoBytes a_ref;
	CHECK((*env)->GetArrayLength(env, a) == 32);
	(*env)->GetByteArrayRegion(env, a, 0, 32, a_ref.data);
	LDKThirtyTwoBytes b_ref;
	CHECK((*env)->GetArrayLength(env, b) == 32);
	(*env)->GetByteArrayRegion(env, b, 0, 32, b_ref.data);
	LDKC2Tuple_PaymentHashPaymentIdZ* ret_conv = MALLOC(sizeof(LDKC2Tuple_PaymentHashPaymentIdZ), "LDKC2Tuple_PaymentHashPaymentIdZ");
	*ret_conv = C2Tuple_PaymentHashPaymentIdZ_new(a_ref, b_ref);
	return ((uint64_t)ret_conv);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_C2Tuple_1PaymentHashPaymentIdZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKC2Tuple_PaymentHashPaymentIdZ _res_conv = *(LDKC2Tuple_PaymentHashPaymentIdZ*)(_res_ptr);
	FREE((void*)_res);
	C2Tuple_PaymentHashPaymentIdZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1C2Tuple_1PaymentHashPaymentIdZPaymentSendFailureZ_1ok(JNIEnv *env, jclass clz, int64_t o) {
	void* o_ptr = (void*)(((uint64_t)o) & ~1);
	CHECK_ACCESS(o_ptr);
	LDKC2Tuple_PaymentHashPaymentIdZ o_conv = *(LDKC2Tuple_PaymentHashPaymentIdZ*)(o_ptr);
	o_conv = C2Tuple_PaymentHashPaymentIdZ_clone((LDKC2Tuple_PaymentHashPaymentIdZ*)(((uint64_t)o) & ~1));
	LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ* ret_conv = MALLOC(sizeof(LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ), "LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ");
	*ret_conv = CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_ok(o_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1C2Tuple_1PaymentHashPaymentIdZPaymentSendFailureZ_1err(JNIEnv *env, jclass clz, int64_t e) {
	void* e_ptr = (void*)(((uint64_t)e) & ~1);
	CHECK_ACCESS(e_ptr);
	LDKPaymentSendFailure e_conv = *(LDKPaymentSendFailure*)(e_ptr);
	e_conv = PaymentSendFailure_clone((LDKPaymentSendFailure*)(((uint64_t)e) & ~1));
	LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ* ret_conv = MALLOC(sizeof(LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ), "LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ");
	*ret_conv = CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1C2Tuple_1PaymentHashPaymentIdZPaymentSendFailureZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ _res_conv = *(LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1C2Tuple_1PaymentHashPaymentIdZPaymentSendFailureZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ* orig_conv = (LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ*)(orig & ~1);
	LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ* ret_conv = MALLOC(sizeof(LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ), "LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ");
	*ret_conv = CResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CVec_1NetAddressZ_1free(JNIEnv *env, jclass clz, int64_tArray _res) {
	LDKCVec_NetAddressZ _res_constr;
	_res_constr.datalen = (*env)->GetArrayLength(env, _res);
	if (_res_constr.datalen > 0)
		_res_constr.data = MALLOC(_res_constr.datalen * sizeof(LDKNetAddress), "LDKCVec_NetAddressZ Elements");
	else
		_res_constr.data = NULL;
	int64_t* _res_vals = (*env)->GetLongArrayElements (env, _res, NULL);
	for (size_t m = 0; m < _res_constr.datalen; m++) {
		int64_t _res_conv_12 = _res_vals[m];
		void* _res_conv_12_ptr = (void*)(((uint64_t)_res_conv_12) & ~1);
		CHECK_ACCESS(_res_conv_12_ptr);
		LDKNetAddress _res_conv_12_conv = *(LDKNetAddress*)(_res_conv_12_ptr);
		FREE((void*)_res_conv_12);
		_res_constr.data[m] = _res_conv_12_conv;
	}
	(*env)->ReleaseLongArrayElements(env, _res, _res_vals, 0);
	CVec_NetAddressZ_free(_res_constr);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_C2Tuple_1PaymentHashPaymentSecretZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKC2Tuple_PaymentHashPaymentSecretZ* orig_conv = (LDKC2Tuple_PaymentHashPaymentSecretZ*)(orig & ~1);
	LDKC2Tuple_PaymentHashPaymentSecretZ* ret_conv = MALLOC(sizeof(LDKC2Tuple_PaymentHashPaymentSecretZ), "LDKC2Tuple_PaymentHashPaymentSecretZ");
	*ret_conv = C2Tuple_PaymentHashPaymentSecretZ_clone(orig_conv);
	return ((uint64_t)ret_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_C2Tuple_1PaymentHashPaymentSecretZ_1new(JNIEnv *env, jclass clz, int8_tArray a, int8_tArray b) {
	LDKThirtyTwoBytes a_ref;
	CHECK((*env)->GetArrayLength(env, a) == 32);
	(*env)->GetByteArrayRegion(env, a, 0, 32, a_ref.data);
	LDKThirtyTwoBytes b_ref;
	CHECK((*env)->GetArrayLength(env, b) == 32);
	(*env)->GetByteArrayRegion(env, b, 0, 32, b_ref.data);
	LDKC2Tuple_PaymentHashPaymentSecretZ* ret_conv = MALLOC(sizeof(LDKC2Tuple_PaymentHashPaymentSecretZ), "LDKC2Tuple_PaymentHashPaymentSecretZ");
	*ret_conv = C2Tuple_PaymentHashPaymentSecretZ_new(a_ref, b_ref);
	return ((uint64_t)ret_conv);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_C2Tuple_1PaymentHashPaymentSecretZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKC2Tuple_PaymentHashPaymentSecretZ _res_conv = *(LDKC2Tuple_PaymentHashPaymentSecretZ*)(_res_ptr);
	FREE((void*)_res);
	C2Tuple_PaymentHashPaymentSecretZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1PaymentSecretAPIErrorZ_1ok(JNIEnv *env, jclass clz, int8_tArray o) {
	LDKThirtyTwoBytes o_ref;
	CHECK((*env)->GetArrayLength(env, o) == 32);
	(*env)->GetByteArrayRegion(env, o, 0, 32, o_ref.data);
	LDKCResult_PaymentSecretAPIErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_PaymentSecretAPIErrorZ), "LDKCResult_PaymentSecretAPIErrorZ");
	*ret_conv = CResult_PaymentSecretAPIErrorZ_ok(o_ref);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1PaymentSecretAPIErrorZ_1err(JNIEnv *env, jclass clz, int64_t e) {
	void* e_ptr = (void*)(((uint64_t)e) & ~1);
	CHECK_ACCESS(e_ptr);
	LDKAPIError e_conv = *(LDKAPIError*)(e_ptr);
	e_conv = APIError_clone((LDKAPIError*)(((uint64_t)e) & ~1));
	LDKCResult_PaymentSecretAPIErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_PaymentSecretAPIErrorZ), "LDKCResult_PaymentSecretAPIErrorZ");
	*ret_conv = CResult_PaymentSecretAPIErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1PaymentSecretAPIErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_PaymentSecretAPIErrorZ _res_conv = *(LDKCResult_PaymentSecretAPIErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_PaymentSecretAPIErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1PaymentSecretAPIErrorZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_PaymentSecretAPIErrorZ* orig_conv = (LDKCResult_PaymentSecretAPIErrorZ*)(orig & ~1);
	LDKCResult_PaymentSecretAPIErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_PaymentSecretAPIErrorZ), "LDKCResult_PaymentSecretAPIErrorZ");
	*ret_conv = CResult_PaymentSecretAPIErrorZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CVec_1ChannelMonitorZ_1free(JNIEnv *env, jclass clz, int64_tArray _res) {
	LDKCVec_ChannelMonitorZ _res_constr;
	_res_constr.datalen = (*env)->GetArrayLength(env, _res);
	if (_res_constr.datalen > 0)
		_res_constr.data = MALLOC(_res_constr.datalen * sizeof(LDKChannelMonitor), "LDKCVec_ChannelMonitorZ Elements");
	else
		_res_constr.data = NULL;
	int64_t* _res_vals = (*env)->GetLongArrayElements (env, _res, NULL);
	for (size_t q = 0; q < _res_constr.datalen; q++) {
		int64_t _res_conv_16 = _res_vals[q];
		LDKChannelMonitor _res_conv_16_conv;
		_res_conv_16_conv.inner = (void*)(_res_conv_16 & (~1));
		_res_conv_16_conv.is_owned = (_res_conv_16 & 1) || (_res_conv_16 == 0);
		_res_constr.data[q] = _res_conv_16_conv;
	}
	(*env)->ReleaseLongArrayElements(env, _res, _res_vals, 0);
	CVec_ChannelMonitorZ_free(_res_constr);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_C2Tuple_1BlockHashChannelManagerZ_1new(JNIEnv *env, jclass clz, int8_tArray a, int64_t b) {
	LDKThirtyTwoBytes a_ref;
	CHECK((*env)->GetArrayLength(env, a) == 32);
	(*env)->GetByteArrayRegion(env, a, 0, 32, a_ref.data);
	LDKChannelManager b_conv;
	b_conv.inner = (void*)(b & (~1));
	b_conv.is_owned = (b & 1) || (b == 0);
	// Warning: we need a move here but no clone is available for LDKChannelManager
	LDKC2Tuple_BlockHashChannelManagerZ* ret_conv = MALLOC(sizeof(LDKC2Tuple_BlockHashChannelManagerZ), "LDKC2Tuple_BlockHashChannelManagerZ");
	*ret_conv = C2Tuple_BlockHashChannelManagerZ_new(a_ref, b_conv);
	return ((uint64_t)ret_conv);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_C2Tuple_1BlockHashChannelManagerZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKC2Tuple_BlockHashChannelManagerZ _res_conv = *(LDKC2Tuple_BlockHashChannelManagerZ*)(_res_ptr);
	FREE((void*)_res);
	C2Tuple_BlockHashChannelManagerZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1C2Tuple_1BlockHashChannelManagerZDecodeErrorZ_1ok(JNIEnv *env, jclass clz, int64_t o) {
	void* o_ptr = (void*)(((uint64_t)o) & ~1);
	CHECK_ACCESS(o_ptr);
	LDKC2Tuple_BlockHashChannelManagerZ o_conv = *(LDKC2Tuple_BlockHashChannelManagerZ*)(o_ptr);
	// Warning: we may need a move here but no clone is available for LDKC2Tuple_BlockHashChannelManagerZ
	LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ), "LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ");
	*ret_conv = CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_ok(o_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1C2Tuple_1BlockHashChannelManagerZDecodeErrorZ_1err(JNIEnv *env, jclass clz, int64_t e) {
	LDKDecodeError e_conv;
	e_conv.inner = (void*)(e & (~1));
	e_conv.is_owned = (e & 1) || (e == 0);
	e_conv = DecodeError_clone(&e_conv);
	LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ), "LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ");
	*ret_conv = CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1C2Tuple_1BlockHashChannelManagerZDecodeErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ _res_conv = *(LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1ChannelConfigDecodeErrorZ_1ok(JNIEnv *env, jclass clz, int64_t o) {
	LDKChannelConfig o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = (o & 1) || (o == 0);
	o_conv = ChannelConfig_clone(&o_conv);
	LDKCResult_ChannelConfigDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_ChannelConfigDecodeErrorZ), "LDKCResult_ChannelConfigDecodeErrorZ");
	*ret_conv = CResult_ChannelConfigDecodeErrorZ_ok(o_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1ChannelConfigDecodeErrorZ_1err(JNIEnv *env, jclass clz, int64_t e) {
	LDKDecodeError e_conv;
	e_conv.inner = (void*)(e & (~1));
	e_conv.is_owned = (e & 1) || (e == 0);
	e_conv = DecodeError_clone(&e_conv);
	LDKCResult_ChannelConfigDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_ChannelConfigDecodeErrorZ), "LDKCResult_ChannelConfigDecodeErrorZ");
	*ret_conv = CResult_ChannelConfigDecodeErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1ChannelConfigDecodeErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_ChannelConfigDecodeErrorZ _res_conv = *(LDKCResult_ChannelConfigDecodeErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_ChannelConfigDecodeErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1ChannelConfigDecodeErrorZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_ChannelConfigDecodeErrorZ* orig_conv = (LDKCResult_ChannelConfigDecodeErrorZ*)(orig & ~1);
	LDKCResult_ChannelConfigDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_ChannelConfigDecodeErrorZ), "LDKCResult_ChannelConfigDecodeErrorZ");
	*ret_conv = CResult_ChannelConfigDecodeErrorZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1OutPointDecodeErrorZ_1ok(JNIEnv *env, jclass clz, int64_t o) {
	LDKOutPoint o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = (o & 1) || (o == 0);
	o_conv = OutPoint_clone(&o_conv);
	LDKCResult_OutPointDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_OutPointDecodeErrorZ), "LDKCResult_OutPointDecodeErrorZ");
	*ret_conv = CResult_OutPointDecodeErrorZ_ok(o_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1OutPointDecodeErrorZ_1err(JNIEnv *env, jclass clz, int64_t e) {
	LDKDecodeError e_conv;
	e_conv.inner = (void*)(e & (~1));
	e_conv.is_owned = (e & 1) || (e == 0);
	e_conv = DecodeError_clone(&e_conv);
	LDKCResult_OutPointDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_OutPointDecodeErrorZ), "LDKCResult_OutPointDecodeErrorZ");
	*ret_conv = CResult_OutPointDecodeErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1OutPointDecodeErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_OutPointDecodeErrorZ _res_conv = *(LDKCResult_OutPointDecodeErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_OutPointDecodeErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1OutPointDecodeErrorZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_OutPointDecodeErrorZ* orig_conv = (LDKCResult_OutPointDecodeErrorZ*)(orig & ~1);
	LDKCResult_OutPointDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_OutPointDecodeErrorZ), "LDKCResult_OutPointDecodeErrorZ");
	*ret_conv = CResult_OutPointDecodeErrorZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_COption_1TypeZ_1some(JNIEnv *env, jclass clz, int64_t o) {
	void* o_ptr = (void*)(((uint64_t)o) & ~1);
	CHECK_ACCESS(o_ptr);
	LDKType o_conv = *(LDKType*)(o_ptr);
	if (o_conv.free == LDKType_JCalls_free) {
		// If this_arg is a JCalls struct, then we need to increment the refcnt in it.
		LDKType_JCalls_cloned(&o_conv);
	}
	LDKCOption_TypeZ *ret_copy = MALLOC(sizeof(LDKCOption_TypeZ), "LDKCOption_TypeZ");
	*ret_copy = COption_TypeZ_some(o_conv);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_COption_1TypeZ_1none(JNIEnv *env, jclass clz) {
	LDKCOption_TypeZ *ret_copy = MALLOC(sizeof(LDKCOption_TypeZ), "LDKCOption_TypeZ");
	*ret_copy = COption_TypeZ_none();
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_COption_1TypeZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCOption_TypeZ _res_conv = *(LDKCOption_TypeZ*)(_res_ptr);
	FREE((void*)_res);
	COption_TypeZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_COption_1TypeZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCOption_TypeZ* orig_conv = (LDKCOption_TypeZ*)orig;
	LDKCOption_TypeZ *ret_copy = MALLOC(sizeof(LDKCOption_TypeZ), "LDKCOption_TypeZ");
	*ret_copy = COption_TypeZ_clone(orig_conv);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1COption_1TypeZDecodeErrorZ_1ok(JNIEnv *env, jclass clz, int64_t o) {
	void* o_ptr = (void*)(((uint64_t)o) & ~1);
	CHECK_ACCESS(o_ptr);
	LDKCOption_TypeZ o_conv = *(LDKCOption_TypeZ*)(o_ptr);
	o_conv = COption_TypeZ_clone((LDKCOption_TypeZ*)(((uint64_t)o) & ~1));
	LDKCResult_COption_TypeZDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_COption_TypeZDecodeErrorZ), "LDKCResult_COption_TypeZDecodeErrorZ");
	*ret_conv = CResult_COption_TypeZDecodeErrorZ_ok(o_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1COption_1TypeZDecodeErrorZ_1err(JNIEnv *env, jclass clz, int64_t e) {
	LDKDecodeError e_conv;
	e_conv.inner = (void*)(e & (~1));
	e_conv.is_owned = (e & 1) || (e == 0);
	e_conv = DecodeError_clone(&e_conv);
	LDKCResult_COption_TypeZDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_COption_TypeZDecodeErrorZ), "LDKCResult_COption_TypeZDecodeErrorZ");
	*ret_conv = CResult_COption_TypeZDecodeErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1COption_1TypeZDecodeErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_COption_TypeZDecodeErrorZ _res_conv = *(LDKCResult_COption_TypeZDecodeErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_COption_TypeZDecodeErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1COption_1TypeZDecodeErrorZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_COption_TypeZDecodeErrorZ* orig_conv = (LDKCResult_COption_TypeZDecodeErrorZ*)(orig & ~1);
	LDKCResult_COption_TypeZDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_COption_TypeZDecodeErrorZ), "LDKCResult_COption_TypeZDecodeErrorZ");
	*ret_conv = CResult_COption_TypeZDecodeErrorZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1PaymentIdPaymentErrorZ_1ok(JNIEnv *env, jclass clz, int8_tArray o) {
	LDKThirtyTwoBytes o_ref;
	CHECK((*env)->GetArrayLength(env, o) == 32);
	(*env)->GetByteArrayRegion(env, o, 0, 32, o_ref.data);
	LDKCResult_PaymentIdPaymentErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_PaymentIdPaymentErrorZ), "LDKCResult_PaymentIdPaymentErrorZ");
	*ret_conv = CResult_PaymentIdPaymentErrorZ_ok(o_ref);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1PaymentIdPaymentErrorZ_1err(JNIEnv *env, jclass clz, int64_t e) {
	void* e_ptr = (void*)(((uint64_t)e) & ~1);
	CHECK_ACCESS(e_ptr);
	LDKPaymentError e_conv = *(LDKPaymentError*)(e_ptr);
	e_conv = PaymentError_clone((LDKPaymentError*)(((uint64_t)e) & ~1));
	LDKCResult_PaymentIdPaymentErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_PaymentIdPaymentErrorZ), "LDKCResult_PaymentIdPaymentErrorZ");
	*ret_conv = CResult_PaymentIdPaymentErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1PaymentIdPaymentErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_PaymentIdPaymentErrorZ _res_conv = *(LDKCResult_PaymentIdPaymentErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_PaymentIdPaymentErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1PaymentIdPaymentErrorZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_PaymentIdPaymentErrorZ* orig_conv = (LDKCResult_PaymentIdPaymentErrorZ*)(orig & ~1);
	LDKCResult_PaymentIdPaymentErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_PaymentIdPaymentErrorZ), "LDKCResult_PaymentIdPaymentErrorZ");
	*ret_conv = CResult_PaymentIdPaymentErrorZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1SiPrefixNoneZ_1ok(JNIEnv *env, jclass clz, jclass o) {
	LDKSiPrefix o_conv = LDKSiPrefix_from_java(env, o);
	LDKCResult_SiPrefixNoneZ* ret_conv = MALLOC(sizeof(LDKCResult_SiPrefixNoneZ), "LDKCResult_SiPrefixNoneZ");
	*ret_conv = CResult_SiPrefixNoneZ_ok(o_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1SiPrefixNoneZ_1err(JNIEnv *env, jclass clz) {
	LDKCResult_SiPrefixNoneZ* ret_conv = MALLOC(sizeof(LDKCResult_SiPrefixNoneZ), "LDKCResult_SiPrefixNoneZ");
	*ret_conv = CResult_SiPrefixNoneZ_err();
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1SiPrefixNoneZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_SiPrefixNoneZ _res_conv = *(LDKCResult_SiPrefixNoneZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_SiPrefixNoneZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1SiPrefixNoneZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_SiPrefixNoneZ* orig_conv = (LDKCResult_SiPrefixNoneZ*)(orig & ~1);
	LDKCResult_SiPrefixNoneZ* ret_conv = MALLOC(sizeof(LDKCResult_SiPrefixNoneZ), "LDKCResult_SiPrefixNoneZ");
	*ret_conv = CResult_SiPrefixNoneZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1InvoiceNoneZ_1ok(JNIEnv *env, jclass clz, int64_t o) {
	LDKInvoice o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = (o & 1) || (o == 0);
	o_conv = Invoice_clone(&o_conv);
	LDKCResult_InvoiceNoneZ* ret_conv = MALLOC(sizeof(LDKCResult_InvoiceNoneZ), "LDKCResult_InvoiceNoneZ");
	*ret_conv = CResult_InvoiceNoneZ_ok(o_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1InvoiceNoneZ_1err(JNIEnv *env, jclass clz) {
	LDKCResult_InvoiceNoneZ* ret_conv = MALLOC(sizeof(LDKCResult_InvoiceNoneZ), "LDKCResult_InvoiceNoneZ");
	*ret_conv = CResult_InvoiceNoneZ_err();
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1InvoiceNoneZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_InvoiceNoneZ _res_conv = *(LDKCResult_InvoiceNoneZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_InvoiceNoneZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1InvoiceNoneZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_InvoiceNoneZ* orig_conv = (LDKCResult_InvoiceNoneZ*)(orig & ~1);
	LDKCResult_InvoiceNoneZ* ret_conv = MALLOC(sizeof(LDKCResult_InvoiceNoneZ), "LDKCResult_InvoiceNoneZ");
	*ret_conv = CResult_InvoiceNoneZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1SignedRawInvoiceNoneZ_1ok(JNIEnv *env, jclass clz, int64_t o) {
	LDKSignedRawInvoice o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = (o & 1) || (o == 0);
	o_conv = SignedRawInvoice_clone(&o_conv);
	LDKCResult_SignedRawInvoiceNoneZ* ret_conv = MALLOC(sizeof(LDKCResult_SignedRawInvoiceNoneZ), "LDKCResult_SignedRawInvoiceNoneZ");
	*ret_conv = CResult_SignedRawInvoiceNoneZ_ok(o_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1SignedRawInvoiceNoneZ_1err(JNIEnv *env, jclass clz) {
	LDKCResult_SignedRawInvoiceNoneZ* ret_conv = MALLOC(sizeof(LDKCResult_SignedRawInvoiceNoneZ), "LDKCResult_SignedRawInvoiceNoneZ");
	*ret_conv = CResult_SignedRawInvoiceNoneZ_err();
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1SignedRawInvoiceNoneZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_SignedRawInvoiceNoneZ _res_conv = *(LDKCResult_SignedRawInvoiceNoneZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_SignedRawInvoiceNoneZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1SignedRawInvoiceNoneZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_SignedRawInvoiceNoneZ* orig_conv = (LDKCResult_SignedRawInvoiceNoneZ*)(orig & ~1);
	LDKCResult_SignedRawInvoiceNoneZ* ret_conv = MALLOC(sizeof(LDKCResult_SignedRawInvoiceNoneZ), "LDKCResult_SignedRawInvoiceNoneZ");
	*ret_conv = CResult_SignedRawInvoiceNoneZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_C3Tuple_1RawInvoice_1u832InvoiceSignatureZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKC3Tuple_RawInvoice_u832InvoiceSignatureZ* orig_conv = (LDKC3Tuple_RawInvoice_u832InvoiceSignatureZ*)(orig & ~1);
	LDKC3Tuple_RawInvoice_u832InvoiceSignatureZ* ret_conv = MALLOC(sizeof(LDKC3Tuple_RawInvoice_u832InvoiceSignatureZ), "LDKC3Tuple_RawInvoice_u832InvoiceSignatureZ");
	*ret_conv = C3Tuple_RawInvoice_u832InvoiceSignatureZ_clone(orig_conv);
	return ((uint64_t)ret_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_C3Tuple_1RawInvoice_1u832InvoiceSignatureZ_1new(JNIEnv *env, jclass clz, int64_t a, int8_tArray b, int64_t c) {
	LDKRawInvoice a_conv;
	a_conv.inner = (void*)(a & (~1));
	a_conv.is_owned = (a & 1) || (a == 0);
	a_conv = RawInvoice_clone(&a_conv);
	LDKThirtyTwoBytes b_ref;
	CHECK((*env)->GetArrayLength(env, b) == 32);
	(*env)->GetByteArrayRegion(env, b, 0, 32, b_ref.data);
	LDKInvoiceSignature c_conv;
	c_conv.inner = (void*)(c & (~1));
	c_conv.is_owned = (c & 1) || (c == 0);
	c_conv = InvoiceSignature_clone(&c_conv);
	LDKC3Tuple_RawInvoice_u832InvoiceSignatureZ* ret_conv = MALLOC(sizeof(LDKC3Tuple_RawInvoice_u832InvoiceSignatureZ), "LDKC3Tuple_RawInvoice_u832InvoiceSignatureZ");
	*ret_conv = C3Tuple_RawInvoice_u832InvoiceSignatureZ_new(a_conv, b_ref, c_conv);
	return ((uint64_t)ret_conv);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_C3Tuple_1RawInvoice_1u832InvoiceSignatureZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKC3Tuple_RawInvoice_u832InvoiceSignatureZ _res_conv = *(LDKC3Tuple_RawInvoice_u832InvoiceSignatureZ*)(_res_ptr);
	FREE((void*)_res);
	C3Tuple_RawInvoice_u832InvoiceSignatureZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1PayeePubKeyErrorZ_1ok(JNIEnv *env, jclass clz, int64_t o) {
	LDKPayeePubKey o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = (o & 1) || (o == 0);
	o_conv = PayeePubKey_clone(&o_conv);
	LDKCResult_PayeePubKeyErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_PayeePubKeyErrorZ), "LDKCResult_PayeePubKeyErrorZ");
	*ret_conv = CResult_PayeePubKeyErrorZ_ok(o_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1PayeePubKeyErrorZ_1err(JNIEnv *env, jclass clz, jclass e) {
	LDKSecp256k1Error e_conv = LDKSecp256k1Error_from_java(env, e);
	LDKCResult_PayeePubKeyErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_PayeePubKeyErrorZ), "LDKCResult_PayeePubKeyErrorZ");
	*ret_conv = CResult_PayeePubKeyErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1PayeePubKeyErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_PayeePubKeyErrorZ _res_conv = *(LDKCResult_PayeePubKeyErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_PayeePubKeyErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1PayeePubKeyErrorZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_PayeePubKeyErrorZ* orig_conv = (LDKCResult_PayeePubKeyErrorZ*)(orig & ~1);
	LDKCResult_PayeePubKeyErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_PayeePubKeyErrorZ), "LDKCResult_PayeePubKeyErrorZ");
	*ret_conv = CResult_PayeePubKeyErrorZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CVec_1PrivateRouteZ_1free(JNIEnv *env, jclass clz, int64_tArray _res) {
	LDKCVec_PrivateRouteZ _res_constr;
	_res_constr.datalen = (*env)->GetArrayLength(env, _res);
	if (_res_constr.datalen > 0)
		_res_constr.data = MALLOC(_res_constr.datalen * sizeof(LDKPrivateRoute), "LDKCVec_PrivateRouteZ Elements");
	else
		_res_constr.data = NULL;
	int64_t* _res_vals = (*env)->GetLongArrayElements (env, _res, NULL);
	for (size_t o = 0; o < _res_constr.datalen; o++) {
		int64_t _res_conv_14 = _res_vals[o];
		LDKPrivateRoute _res_conv_14_conv;
		_res_conv_14_conv.inner = (void*)(_res_conv_14 & (~1));
		_res_conv_14_conv.is_owned = (_res_conv_14 & 1) || (_res_conv_14 == 0);
		_res_constr.data[o] = _res_conv_14_conv;
	}
	(*env)->ReleaseLongArrayElements(env, _res, _res_vals, 0);
	CVec_PrivateRouteZ_free(_res_constr);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1PositiveTimestampCreationErrorZ_1ok(JNIEnv *env, jclass clz, int64_t o) {
	LDKPositiveTimestamp o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = (o & 1) || (o == 0);
	o_conv = PositiveTimestamp_clone(&o_conv);
	LDKCResult_PositiveTimestampCreationErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_PositiveTimestampCreationErrorZ), "LDKCResult_PositiveTimestampCreationErrorZ");
	*ret_conv = CResult_PositiveTimestampCreationErrorZ_ok(o_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1PositiveTimestampCreationErrorZ_1err(JNIEnv *env, jclass clz, jclass e) {
	LDKCreationError e_conv = LDKCreationError_from_java(env, e);
	LDKCResult_PositiveTimestampCreationErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_PositiveTimestampCreationErrorZ), "LDKCResult_PositiveTimestampCreationErrorZ");
	*ret_conv = CResult_PositiveTimestampCreationErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1PositiveTimestampCreationErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_PositiveTimestampCreationErrorZ _res_conv = *(LDKCResult_PositiveTimestampCreationErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_PositiveTimestampCreationErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1PositiveTimestampCreationErrorZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_PositiveTimestampCreationErrorZ* orig_conv = (LDKCResult_PositiveTimestampCreationErrorZ*)(orig & ~1);
	LDKCResult_PositiveTimestampCreationErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_PositiveTimestampCreationErrorZ), "LDKCResult_PositiveTimestampCreationErrorZ");
	*ret_conv = CResult_PositiveTimestampCreationErrorZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1NoneSemanticErrorZ_1ok(JNIEnv *env, jclass clz) {
	LDKCResult_NoneSemanticErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_NoneSemanticErrorZ), "LDKCResult_NoneSemanticErrorZ");
	*ret_conv = CResult_NoneSemanticErrorZ_ok();
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1NoneSemanticErrorZ_1err(JNIEnv *env, jclass clz, jclass e) {
	LDKSemanticError e_conv = LDKSemanticError_from_java(env, e);
	LDKCResult_NoneSemanticErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_NoneSemanticErrorZ), "LDKCResult_NoneSemanticErrorZ");
	*ret_conv = CResult_NoneSemanticErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1NoneSemanticErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_NoneSemanticErrorZ _res_conv = *(LDKCResult_NoneSemanticErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_NoneSemanticErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1NoneSemanticErrorZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_NoneSemanticErrorZ* orig_conv = (LDKCResult_NoneSemanticErrorZ*)(orig & ~1);
	LDKCResult_NoneSemanticErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_NoneSemanticErrorZ), "LDKCResult_NoneSemanticErrorZ");
	*ret_conv = CResult_NoneSemanticErrorZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1InvoiceSemanticErrorZ_1ok(JNIEnv *env, jclass clz, int64_t o) {
	LDKInvoice o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = (o & 1) || (o == 0);
	o_conv = Invoice_clone(&o_conv);
	LDKCResult_InvoiceSemanticErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_InvoiceSemanticErrorZ), "LDKCResult_InvoiceSemanticErrorZ");
	*ret_conv = CResult_InvoiceSemanticErrorZ_ok(o_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1InvoiceSemanticErrorZ_1err(JNIEnv *env, jclass clz, jclass e) {
	LDKSemanticError e_conv = LDKSemanticError_from_java(env, e);
	LDKCResult_InvoiceSemanticErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_InvoiceSemanticErrorZ), "LDKCResult_InvoiceSemanticErrorZ");
	*ret_conv = CResult_InvoiceSemanticErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1InvoiceSemanticErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_InvoiceSemanticErrorZ _res_conv = *(LDKCResult_InvoiceSemanticErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_InvoiceSemanticErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1InvoiceSemanticErrorZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_InvoiceSemanticErrorZ* orig_conv = (LDKCResult_InvoiceSemanticErrorZ*)(orig & ~1);
	LDKCResult_InvoiceSemanticErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_InvoiceSemanticErrorZ), "LDKCResult_InvoiceSemanticErrorZ");
	*ret_conv = CResult_InvoiceSemanticErrorZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1DescriptionCreationErrorZ_1ok(JNIEnv *env, jclass clz, int64_t o) {
	LDKDescription o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = (o & 1) || (o == 0);
	o_conv = Description_clone(&o_conv);
	LDKCResult_DescriptionCreationErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_DescriptionCreationErrorZ), "LDKCResult_DescriptionCreationErrorZ");
	*ret_conv = CResult_DescriptionCreationErrorZ_ok(o_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1DescriptionCreationErrorZ_1err(JNIEnv *env, jclass clz, jclass e) {
	LDKCreationError e_conv = LDKCreationError_from_java(env, e);
	LDKCResult_DescriptionCreationErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_DescriptionCreationErrorZ), "LDKCResult_DescriptionCreationErrorZ");
	*ret_conv = CResult_DescriptionCreationErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1DescriptionCreationErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_DescriptionCreationErrorZ _res_conv = *(LDKCResult_DescriptionCreationErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_DescriptionCreationErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1DescriptionCreationErrorZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_DescriptionCreationErrorZ* orig_conv = (LDKCResult_DescriptionCreationErrorZ*)(orig & ~1);
	LDKCResult_DescriptionCreationErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_DescriptionCreationErrorZ), "LDKCResult_DescriptionCreationErrorZ");
	*ret_conv = CResult_DescriptionCreationErrorZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1ExpiryTimeCreationErrorZ_1ok(JNIEnv *env, jclass clz, int64_t o) {
	LDKExpiryTime o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = (o & 1) || (o == 0);
	o_conv = ExpiryTime_clone(&o_conv);
	LDKCResult_ExpiryTimeCreationErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_ExpiryTimeCreationErrorZ), "LDKCResult_ExpiryTimeCreationErrorZ");
	*ret_conv = CResult_ExpiryTimeCreationErrorZ_ok(o_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1ExpiryTimeCreationErrorZ_1err(JNIEnv *env, jclass clz, jclass e) {
	LDKCreationError e_conv = LDKCreationError_from_java(env, e);
	LDKCResult_ExpiryTimeCreationErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_ExpiryTimeCreationErrorZ), "LDKCResult_ExpiryTimeCreationErrorZ");
	*ret_conv = CResult_ExpiryTimeCreationErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1ExpiryTimeCreationErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_ExpiryTimeCreationErrorZ _res_conv = *(LDKCResult_ExpiryTimeCreationErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_ExpiryTimeCreationErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1ExpiryTimeCreationErrorZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_ExpiryTimeCreationErrorZ* orig_conv = (LDKCResult_ExpiryTimeCreationErrorZ*)(orig & ~1);
	LDKCResult_ExpiryTimeCreationErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_ExpiryTimeCreationErrorZ), "LDKCResult_ExpiryTimeCreationErrorZ");
	*ret_conv = CResult_ExpiryTimeCreationErrorZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1PrivateRouteCreationErrorZ_1ok(JNIEnv *env, jclass clz, int64_t o) {
	LDKPrivateRoute o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = (o & 1) || (o == 0);
	o_conv = PrivateRoute_clone(&o_conv);
	LDKCResult_PrivateRouteCreationErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_PrivateRouteCreationErrorZ), "LDKCResult_PrivateRouteCreationErrorZ");
	*ret_conv = CResult_PrivateRouteCreationErrorZ_ok(o_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1PrivateRouteCreationErrorZ_1err(JNIEnv *env, jclass clz, jclass e) {
	LDKCreationError e_conv = LDKCreationError_from_java(env, e);
	LDKCResult_PrivateRouteCreationErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_PrivateRouteCreationErrorZ), "LDKCResult_PrivateRouteCreationErrorZ");
	*ret_conv = CResult_PrivateRouteCreationErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1PrivateRouteCreationErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_PrivateRouteCreationErrorZ _res_conv = *(LDKCResult_PrivateRouteCreationErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_PrivateRouteCreationErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1PrivateRouteCreationErrorZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_PrivateRouteCreationErrorZ* orig_conv = (LDKCResult_PrivateRouteCreationErrorZ*)(orig & ~1);
	LDKCResult_PrivateRouteCreationErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_PrivateRouteCreationErrorZ), "LDKCResult_PrivateRouteCreationErrorZ");
	*ret_conv = CResult_PrivateRouteCreationErrorZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1StringErrorZ_1ok(JNIEnv *env, jclass clz, jstring o) {
	LDKStr o_conv = java_to_owned_str(env, o);
	LDKCResult_StringErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_StringErrorZ), "LDKCResult_StringErrorZ");
	*ret_conv = CResult_StringErrorZ_ok(o_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1StringErrorZ_1err(JNIEnv *env, jclass clz, jclass e) {
	LDKSecp256k1Error e_conv = LDKSecp256k1Error_from_java(env, e);
	LDKCResult_StringErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_StringErrorZ), "LDKCResult_StringErrorZ");
	*ret_conv = CResult_StringErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1StringErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_StringErrorZ _res_conv = *(LDKCResult_StringErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_StringErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1ChannelMonitorUpdateDecodeErrorZ_1ok(JNIEnv *env, jclass clz, int64_t o) {
	LDKChannelMonitorUpdate o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = (o & 1) || (o == 0);
	o_conv = ChannelMonitorUpdate_clone(&o_conv);
	LDKCResult_ChannelMonitorUpdateDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_ChannelMonitorUpdateDecodeErrorZ), "LDKCResult_ChannelMonitorUpdateDecodeErrorZ");
	*ret_conv = CResult_ChannelMonitorUpdateDecodeErrorZ_ok(o_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1ChannelMonitorUpdateDecodeErrorZ_1err(JNIEnv *env, jclass clz, int64_t e) {
	LDKDecodeError e_conv;
	e_conv.inner = (void*)(e & (~1));
	e_conv.is_owned = (e & 1) || (e == 0);
	e_conv = DecodeError_clone(&e_conv);
	LDKCResult_ChannelMonitorUpdateDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_ChannelMonitorUpdateDecodeErrorZ), "LDKCResult_ChannelMonitorUpdateDecodeErrorZ");
	*ret_conv = CResult_ChannelMonitorUpdateDecodeErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1ChannelMonitorUpdateDecodeErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_ChannelMonitorUpdateDecodeErrorZ _res_conv = *(LDKCResult_ChannelMonitorUpdateDecodeErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_ChannelMonitorUpdateDecodeErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1ChannelMonitorUpdateDecodeErrorZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_ChannelMonitorUpdateDecodeErrorZ* orig_conv = (LDKCResult_ChannelMonitorUpdateDecodeErrorZ*)(orig & ~1);
	LDKCResult_ChannelMonitorUpdateDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_ChannelMonitorUpdateDecodeErrorZ), "LDKCResult_ChannelMonitorUpdateDecodeErrorZ");
	*ret_conv = CResult_ChannelMonitorUpdateDecodeErrorZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1HTLCUpdateDecodeErrorZ_1ok(JNIEnv *env, jclass clz, int64_t o) {
	LDKHTLCUpdate o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = (o & 1) || (o == 0);
	o_conv = HTLCUpdate_clone(&o_conv);
	LDKCResult_HTLCUpdateDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_HTLCUpdateDecodeErrorZ), "LDKCResult_HTLCUpdateDecodeErrorZ");
	*ret_conv = CResult_HTLCUpdateDecodeErrorZ_ok(o_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1HTLCUpdateDecodeErrorZ_1err(JNIEnv *env, jclass clz, int64_t e) {
	LDKDecodeError e_conv;
	e_conv.inner = (void*)(e & (~1));
	e_conv.is_owned = (e & 1) || (e == 0);
	e_conv = DecodeError_clone(&e_conv);
	LDKCResult_HTLCUpdateDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_HTLCUpdateDecodeErrorZ), "LDKCResult_HTLCUpdateDecodeErrorZ");
	*ret_conv = CResult_HTLCUpdateDecodeErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1HTLCUpdateDecodeErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_HTLCUpdateDecodeErrorZ _res_conv = *(LDKCResult_HTLCUpdateDecodeErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_HTLCUpdateDecodeErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1HTLCUpdateDecodeErrorZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_HTLCUpdateDecodeErrorZ* orig_conv = (LDKCResult_HTLCUpdateDecodeErrorZ*)(orig & ~1);
	LDKCResult_HTLCUpdateDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_HTLCUpdateDecodeErrorZ), "LDKCResult_HTLCUpdateDecodeErrorZ");
	*ret_conv = CResult_HTLCUpdateDecodeErrorZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1NoneMonitorUpdateErrorZ_1ok(JNIEnv *env, jclass clz) {
	LDKCResult_NoneMonitorUpdateErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_NoneMonitorUpdateErrorZ), "LDKCResult_NoneMonitorUpdateErrorZ");
	*ret_conv = CResult_NoneMonitorUpdateErrorZ_ok();
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1NoneMonitorUpdateErrorZ_1err(JNIEnv *env, jclass clz, int64_t e) {
	LDKMonitorUpdateError e_conv;
	e_conv.inner = (void*)(e & (~1));
	e_conv.is_owned = (e & 1) || (e == 0);
	e_conv = MonitorUpdateError_clone(&e_conv);
	LDKCResult_NoneMonitorUpdateErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_NoneMonitorUpdateErrorZ), "LDKCResult_NoneMonitorUpdateErrorZ");
	*ret_conv = CResult_NoneMonitorUpdateErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1NoneMonitorUpdateErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_NoneMonitorUpdateErrorZ _res_conv = *(LDKCResult_NoneMonitorUpdateErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_NoneMonitorUpdateErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1NoneMonitorUpdateErrorZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_NoneMonitorUpdateErrorZ* orig_conv = (LDKCResult_NoneMonitorUpdateErrorZ*)(orig & ~1);
	LDKCResult_NoneMonitorUpdateErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_NoneMonitorUpdateErrorZ), "LDKCResult_NoneMonitorUpdateErrorZ");
	*ret_conv = CResult_NoneMonitorUpdateErrorZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_C2Tuple_1OutPointScriptZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKC2Tuple_OutPointScriptZ* orig_conv = (LDKC2Tuple_OutPointScriptZ*)(orig & ~1);
	LDKC2Tuple_OutPointScriptZ* ret_conv = MALLOC(sizeof(LDKC2Tuple_OutPointScriptZ), "LDKC2Tuple_OutPointScriptZ");
	*ret_conv = C2Tuple_OutPointScriptZ_clone(orig_conv);
	return ((uint64_t)ret_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_C2Tuple_1OutPointScriptZ_1new(JNIEnv *env, jclass clz, int64_t a, int8_tArray b) {
	LDKOutPoint a_conv;
	a_conv.inner = (void*)(a & (~1));
	a_conv.is_owned = (a & 1) || (a == 0);
	a_conv = OutPoint_clone(&a_conv);
	LDKCVec_u8Z b_ref;
	b_ref.datalen = (*env)->GetArrayLength(env, b);
	b_ref.data = MALLOC(b_ref.datalen, "LDKCVec_u8Z Bytes");
	(*env)->GetByteArrayRegion(env, b, 0, b_ref.datalen, b_ref.data);
	LDKC2Tuple_OutPointScriptZ* ret_conv = MALLOC(sizeof(LDKC2Tuple_OutPointScriptZ), "LDKC2Tuple_OutPointScriptZ");
	*ret_conv = C2Tuple_OutPointScriptZ_new(a_conv, b_ref);
	return ((uint64_t)ret_conv);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_C2Tuple_1OutPointScriptZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKC2Tuple_OutPointScriptZ _res_conv = *(LDKC2Tuple_OutPointScriptZ*)(_res_ptr);
	FREE((void*)_res);
	C2Tuple_OutPointScriptZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_C2Tuple_1u32ScriptZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKC2Tuple_u32ScriptZ* orig_conv = (LDKC2Tuple_u32ScriptZ*)(orig & ~1);
	LDKC2Tuple_u32ScriptZ* ret_conv = MALLOC(sizeof(LDKC2Tuple_u32ScriptZ), "LDKC2Tuple_u32ScriptZ");
	*ret_conv = C2Tuple_u32ScriptZ_clone(orig_conv);
	return ((uint64_t)ret_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_C2Tuple_1u32ScriptZ_1new(JNIEnv *env, jclass clz, int32_t a, int8_tArray b) {
	LDKCVec_u8Z b_ref;
	b_ref.datalen = (*env)->GetArrayLength(env, b);
	b_ref.data = MALLOC(b_ref.datalen, "LDKCVec_u8Z Bytes");
	(*env)->GetByteArrayRegion(env, b, 0, b_ref.datalen, b_ref.data);
	LDKC2Tuple_u32ScriptZ* ret_conv = MALLOC(sizeof(LDKC2Tuple_u32ScriptZ), "LDKC2Tuple_u32ScriptZ");
	*ret_conv = C2Tuple_u32ScriptZ_new(a, b_ref);
	return ((uint64_t)ret_conv);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_C2Tuple_1u32ScriptZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKC2Tuple_u32ScriptZ _res_conv = *(LDKC2Tuple_u32ScriptZ*)(_res_ptr);
	FREE((void*)_res);
	C2Tuple_u32ScriptZ_free(_res_conv);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CVec_1C2Tuple_1u32ScriptZZ_1free(JNIEnv *env, jclass clz, int64_tArray _res) {
	LDKCVec_C2Tuple_u32ScriptZZ _res_constr;
	_res_constr.datalen = (*env)->GetArrayLength(env, _res);
	if (_res_constr.datalen > 0)
		_res_constr.data = MALLOC(_res_constr.datalen * sizeof(LDKC2Tuple_u32ScriptZ), "LDKCVec_C2Tuple_u32ScriptZZ Elements");
	else
		_res_constr.data = NULL;
	int64_t* _res_vals = (*env)->GetLongArrayElements (env, _res, NULL);
	for (size_t v = 0; v < _res_constr.datalen; v++) {
		int64_t _res_conv_21 = _res_vals[v];
		void* _res_conv_21_ptr = (void*)(((uint64_t)_res_conv_21) & ~1);
		CHECK_ACCESS(_res_conv_21_ptr);
		LDKC2Tuple_u32ScriptZ _res_conv_21_conv = *(LDKC2Tuple_u32ScriptZ*)(_res_conv_21_ptr);
		FREE((void*)_res_conv_21);
		_res_constr.data[v] = _res_conv_21_conv;
	}
	(*env)->ReleaseLongArrayElements(env, _res, _res_vals, 0);
	CVec_C2Tuple_u32ScriptZZ_free(_res_constr);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_C2Tuple_1TxidCVec_1C2Tuple_1u32ScriptZZZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKC2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ* orig_conv = (LDKC2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ*)(orig & ~1);
	LDKC2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ* ret_conv = MALLOC(sizeof(LDKC2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ), "LDKC2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ");
	*ret_conv = C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_clone(orig_conv);
	return ((uint64_t)ret_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_C2Tuple_1TxidCVec_1C2Tuple_1u32ScriptZZZ_1new(JNIEnv *env, jclass clz, int8_tArray a, int64_tArray b) {
	LDKThirtyTwoBytes a_ref;
	CHECK((*env)->GetArrayLength(env, a) == 32);
	(*env)->GetByteArrayRegion(env, a, 0, 32, a_ref.data);
	LDKCVec_C2Tuple_u32ScriptZZ b_constr;
	b_constr.datalen = (*env)->GetArrayLength(env, b);
	if (b_constr.datalen > 0)
		b_constr.data = MALLOC(b_constr.datalen * sizeof(LDKC2Tuple_u32ScriptZ), "LDKCVec_C2Tuple_u32ScriptZZ Elements");
	else
		b_constr.data = NULL;
	int64_t* b_vals = (*env)->GetLongArrayElements (env, b, NULL);
	for (size_t v = 0; v < b_constr.datalen; v++) {
		int64_t b_conv_21 = b_vals[v];
		void* b_conv_21_ptr = (void*)(((uint64_t)b_conv_21) & ~1);
		CHECK_ACCESS(b_conv_21_ptr);
		LDKC2Tuple_u32ScriptZ b_conv_21_conv = *(LDKC2Tuple_u32ScriptZ*)(b_conv_21_ptr);
		b_conv_21_conv = C2Tuple_u32ScriptZ_clone((LDKC2Tuple_u32ScriptZ*)(((uint64_t)b_conv_21) & ~1));
		b_constr.data[v] = b_conv_21_conv;
	}
	(*env)->ReleaseLongArrayElements(env, b, b_vals, 0);
	LDKC2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ* ret_conv = MALLOC(sizeof(LDKC2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ), "LDKC2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ");
	*ret_conv = C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_new(a_ref, b_constr);
	return ((uint64_t)ret_conv);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_C2Tuple_1TxidCVec_1C2Tuple_1u32ScriptZZZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKC2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ _res_conv = *(LDKC2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ*)(_res_ptr);
	FREE((void*)_res);
	C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ_free(_res_conv);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CVec_1C2Tuple_1TxidCVec_1C2Tuple_1u32ScriptZZZZ_1free(JNIEnv *env, jclass clz, int64_tArray _res) {
	LDKCVec_C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZZ _res_constr;
	_res_constr.datalen = (*env)->GetArrayLength(env, _res);
	if (_res_constr.datalen > 0)
		_res_constr.data = MALLOC(_res_constr.datalen * sizeof(LDKC2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ), "LDKCVec_C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZZ Elements");
	else
		_res_constr.data = NULL;
	int64_t* _res_vals = (*env)->GetLongArrayElements (env, _res, NULL);
	for (size_t o = 0; o < _res_constr.datalen; o++) {
		int64_t _res_conv_40 = _res_vals[o];
		void* _res_conv_40_ptr = (void*)(((uint64_t)_res_conv_40) & ~1);
		CHECK_ACCESS(_res_conv_40_ptr);
		LDKC2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ _res_conv_40_conv = *(LDKC2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ*)(_res_conv_40_ptr);
		FREE((void*)_res_conv_40);
		_res_constr.data[o] = _res_conv_40_conv;
	}
	(*env)->ReleaseLongArrayElements(env, _res, _res_vals, 0);
	CVec_C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZZ_free(_res_constr);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CVec_1EventZ_1free(JNIEnv *env, jclass clz, int64_tArray _res) {
	LDKCVec_EventZ _res_constr;
	_res_constr.datalen = (*env)->GetArrayLength(env, _res);
	if (_res_constr.datalen > 0)
		_res_constr.data = MALLOC(_res_constr.datalen * sizeof(LDKEvent), "LDKCVec_EventZ Elements");
	else
		_res_constr.data = NULL;
	int64_t* _res_vals = (*env)->GetLongArrayElements (env, _res, NULL);
	for (size_t h = 0; h < _res_constr.datalen; h++) {
		int64_t _res_conv_7 = _res_vals[h];
		void* _res_conv_7_ptr = (void*)(((uint64_t)_res_conv_7) & ~1);
		CHECK_ACCESS(_res_conv_7_ptr);
		LDKEvent _res_conv_7_conv = *(LDKEvent*)(_res_conv_7_ptr);
		FREE((void*)_res_conv_7);
		_res_constr.data[h] = _res_conv_7_conv;
	}
	(*env)->ReleaseLongArrayElements(env, _res, _res_vals, 0);
	CVec_EventZ_free(_res_constr);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CVec_1TransactionZ_1free(JNIEnv *env, jclass clz, jobjectArray _res) {
	LDKCVec_TransactionZ _res_constr;
	_res_constr.datalen = (*env)->GetArrayLength(env, _res);
	if (_res_constr.datalen > 0)
		_res_constr.data = MALLOC(_res_constr.datalen * sizeof(LDKTransaction), "LDKCVec_TransactionZ Elements");
	else
		_res_constr.data = NULL;
	for (size_t i = 0; i < _res_constr.datalen; i++) {
		int8_tArray _res_conv_8 = (*env)->GetObjectArrayElement(env, _res, i);
		LDKTransaction _res_conv_8_ref;
		_res_conv_8_ref.datalen = (*env)->GetArrayLength(env, _res_conv_8);
		_res_conv_8_ref.data = MALLOC(_res_conv_8_ref.datalen, "LDKTransaction Bytes");
		(*env)->GetByteArrayRegion(env, _res_conv_8, 0, _res_conv_8_ref.datalen, _res_conv_8_ref.data);
		_res_conv_8_ref.data_is_owned = true;
		_res_constr.data[i] = _res_conv_8_ref;
	}
	CVec_TransactionZ_free(_res_constr);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_C2Tuple_1u32TxOutZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKC2Tuple_u32TxOutZ* orig_conv = (LDKC2Tuple_u32TxOutZ*)(orig & ~1);
	LDKC2Tuple_u32TxOutZ* ret_conv = MALLOC(sizeof(LDKC2Tuple_u32TxOutZ), "LDKC2Tuple_u32TxOutZ");
	*ret_conv = C2Tuple_u32TxOutZ_clone(orig_conv);
	return ((uint64_t)ret_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_C2Tuple_1u32TxOutZ_1new(JNIEnv *env, jclass clz, int32_t a, int64_t b) {
	void* b_ptr = (void*)(((uint64_t)b) & ~1);
	CHECK_ACCESS(b_ptr);
	LDKTxOut b_conv = *(LDKTxOut*)(b_ptr);
	b_conv = TxOut_clone((LDKTxOut*)(((uint64_t)b) & ~1));
	LDKC2Tuple_u32TxOutZ* ret_conv = MALLOC(sizeof(LDKC2Tuple_u32TxOutZ), "LDKC2Tuple_u32TxOutZ");
	*ret_conv = C2Tuple_u32TxOutZ_new(a, b_conv);
	return ((uint64_t)ret_conv);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_C2Tuple_1u32TxOutZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKC2Tuple_u32TxOutZ _res_conv = *(LDKC2Tuple_u32TxOutZ*)(_res_ptr);
	FREE((void*)_res);
	C2Tuple_u32TxOutZ_free(_res_conv);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CVec_1C2Tuple_1u32TxOutZZ_1free(JNIEnv *env, jclass clz, int64_tArray _res) {
	LDKCVec_C2Tuple_u32TxOutZZ _res_constr;
	_res_constr.datalen = (*env)->GetArrayLength(env, _res);
	if (_res_constr.datalen > 0)
		_res_constr.data = MALLOC(_res_constr.datalen * sizeof(LDKC2Tuple_u32TxOutZ), "LDKCVec_C2Tuple_u32TxOutZZ Elements");
	else
		_res_constr.data = NULL;
	int64_t* _res_vals = (*env)->GetLongArrayElements (env, _res, NULL);
	for (size_t u = 0; u < _res_constr.datalen; u++) {
		int64_t _res_conv_20 = _res_vals[u];
		void* _res_conv_20_ptr = (void*)(((uint64_t)_res_conv_20) & ~1);
		CHECK_ACCESS(_res_conv_20_ptr);
		LDKC2Tuple_u32TxOutZ _res_conv_20_conv = *(LDKC2Tuple_u32TxOutZ*)(_res_conv_20_ptr);
		FREE((void*)_res_conv_20);
		_res_constr.data[u] = _res_conv_20_conv;
	}
	(*env)->ReleaseLongArrayElements(env, _res, _res_vals, 0);
	CVec_C2Tuple_u32TxOutZZ_free(_res_constr);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_C2Tuple_1TxidCVec_1C2Tuple_1u32TxOutZZZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ* orig_conv = (LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ*)(orig & ~1);
	LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ* ret_conv = MALLOC(sizeof(LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ), "LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ");
	*ret_conv = C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_clone(orig_conv);
	return ((uint64_t)ret_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_C2Tuple_1TxidCVec_1C2Tuple_1u32TxOutZZZ_1new(JNIEnv *env, jclass clz, int8_tArray a, int64_tArray b) {
	LDKThirtyTwoBytes a_ref;
	CHECK((*env)->GetArrayLength(env, a) == 32);
	(*env)->GetByteArrayRegion(env, a, 0, 32, a_ref.data);
	LDKCVec_C2Tuple_u32TxOutZZ b_constr;
	b_constr.datalen = (*env)->GetArrayLength(env, b);
	if (b_constr.datalen > 0)
		b_constr.data = MALLOC(b_constr.datalen * sizeof(LDKC2Tuple_u32TxOutZ), "LDKCVec_C2Tuple_u32TxOutZZ Elements");
	else
		b_constr.data = NULL;
	int64_t* b_vals = (*env)->GetLongArrayElements (env, b, NULL);
	for (size_t u = 0; u < b_constr.datalen; u++) {
		int64_t b_conv_20 = b_vals[u];
		void* b_conv_20_ptr = (void*)(((uint64_t)b_conv_20) & ~1);
		CHECK_ACCESS(b_conv_20_ptr);
		LDKC2Tuple_u32TxOutZ b_conv_20_conv = *(LDKC2Tuple_u32TxOutZ*)(b_conv_20_ptr);
		b_conv_20_conv = C2Tuple_u32TxOutZ_clone((LDKC2Tuple_u32TxOutZ*)(((uint64_t)b_conv_20) & ~1));
		b_constr.data[u] = b_conv_20_conv;
	}
	(*env)->ReleaseLongArrayElements(env, b, b_vals, 0);
	LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ* ret_conv = MALLOC(sizeof(LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ), "LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ");
	*ret_conv = C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_new(a_ref, b_constr);
	return ((uint64_t)ret_conv);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_C2Tuple_1TxidCVec_1C2Tuple_1u32TxOutZZZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ _res_conv = *(LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ*)(_res_ptr);
	FREE((void*)_res);
	C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ_free(_res_conv);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CVec_1C2Tuple_1TxidCVec_1C2Tuple_1u32TxOutZZZZ_1free(JNIEnv *env, jclass clz, int64_tArray _res) {
	LDKCVec_C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZZ _res_constr;
	_res_constr.datalen = (*env)->GetArrayLength(env, _res);
	if (_res_constr.datalen > 0)
		_res_constr.data = MALLOC(_res_constr.datalen * sizeof(LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ), "LDKCVec_C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZZ Elements");
	else
		_res_constr.data = NULL;
	int64_t* _res_vals = (*env)->GetLongArrayElements (env, _res, NULL);
	for (size_t n = 0; n < _res_constr.datalen; n++) {
		int64_t _res_conv_39 = _res_vals[n];
		void* _res_conv_39_ptr = (void*)(((uint64_t)_res_conv_39) & ~1);
		CHECK_ACCESS(_res_conv_39_ptr);
		LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ _res_conv_39_conv = *(LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ*)(_res_conv_39_ptr);
		FREE((void*)_res_conv_39);
		_res_constr.data[n] = _res_conv_39_conv;
	}
	(*env)->ReleaseLongArrayElements(env, _res, _res_vals, 0);
	CVec_C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZZ_free(_res_constr);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CVec_1BalanceZ_1free(JNIEnv *env, jclass clz, int64_tArray _res) {
	LDKCVec_BalanceZ _res_constr;
	_res_constr.datalen = (*env)->GetArrayLength(env, _res);
	if (_res_constr.datalen > 0)
		_res_constr.data = MALLOC(_res_constr.datalen * sizeof(LDKBalance), "LDKCVec_BalanceZ Elements");
	else
		_res_constr.data = NULL;
	int64_t* _res_vals = (*env)->GetLongArrayElements (env, _res, NULL);
	for (size_t j = 0; j < _res_constr.datalen; j++) {
		int64_t _res_conv_9 = _res_vals[j];
		void* _res_conv_9_ptr = (void*)(((uint64_t)_res_conv_9) & ~1);
		CHECK_ACCESS(_res_conv_9_ptr);
		LDKBalance _res_conv_9_conv = *(LDKBalance*)(_res_conv_9_ptr);
		FREE((void*)_res_conv_9);
		_res_constr.data[j] = _res_conv_9_conv;
	}
	(*env)->ReleaseLongArrayElements(env, _res, _res_vals, 0);
	CVec_BalanceZ_free(_res_constr);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1C2Tuple_1BlockHashChannelMonitorZDecodeErrorZ_1ok(JNIEnv *env, jclass clz, int64_t o) {
	void* o_ptr = (void*)(((uint64_t)o) & ~1);
	CHECK_ACCESS(o_ptr);
	LDKC2Tuple_BlockHashChannelMonitorZ o_conv = *(LDKC2Tuple_BlockHashChannelMonitorZ*)(o_ptr);
	o_conv = C2Tuple_BlockHashChannelMonitorZ_clone((LDKC2Tuple_BlockHashChannelMonitorZ*)(((uint64_t)o) & ~1));
	LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ), "LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ");
	*ret_conv = CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_ok(o_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1C2Tuple_1BlockHashChannelMonitorZDecodeErrorZ_1err(JNIEnv *env, jclass clz, int64_t e) {
	LDKDecodeError e_conv;
	e_conv.inner = (void*)(e & (~1));
	e_conv.is_owned = (e & 1) || (e == 0);
	e_conv = DecodeError_clone(&e_conv);
	LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ), "LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ");
	*ret_conv = CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1C2Tuple_1BlockHashChannelMonitorZDecodeErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ _res_conv = *(LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1C2Tuple_1BlockHashChannelMonitorZDecodeErrorZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ* orig_conv = (LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ*)(orig & ~1);
	LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ), "LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ");
	*ret_conv = CResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1NoneLightningErrorZ_1ok(JNIEnv *env, jclass clz) {
	LDKCResult_NoneLightningErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_NoneLightningErrorZ), "LDKCResult_NoneLightningErrorZ");
	*ret_conv = CResult_NoneLightningErrorZ_ok();
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1NoneLightningErrorZ_1err(JNIEnv *env, jclass clz, int64_t e) {
	LDKLightningError e_conv;
	e_conv.inner = (void*)(e & (~1));
	e_conv.is_owned = (e & 1) || (e == 0);
	e_conv = LightningError_clone(&e_conv);
	LDKCResult_NoneLightningErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_NoneLightningErrorZ), "LDKCResult_NoneLightningErrorZ");
	*ret_conv = CResult_NoneLightningErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1NoneLightningErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_NoneLightningErrorZ _res_conv = *(LDKCResult_NoneLightningErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_NoneLightningErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1NoneLightningErrorZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_NoneLightningErrorZ* orig_conv = (LDKCResult_NoneLightningErrorZ*)(orig & ~1);
	LDKCResult_NoneLightningErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_NoneLightningErrorZ), "LDKCResult_NoneLightningErrorZ");
	*ret_conv = CResult_NoneLightningErrorZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_C2Tuple_1PublicKeyTypeZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKC2Tuple_PublicKeyTypeZ* orig_conv = (LDKC2Tuple_PublicKeyTypeZ*)(orig & ~1);
	LDKC2Tuple_PublicKeyTypeZ* ret_conv = MALLOC(sizeof(LDKC2Tuple_PublicKeyTypeZ), "LDKC2Tuple_PublicKeyTypeZ");
	*ret_conv = C2Tuple_PublicKeyTypeZ_clone(orig_conv);
	return ((uint64_t)ret_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_C2Tuple_1PublicKeyTypeZ_1new(JNIEnv *env, jclass clz, int8_tArray a, int64_t b) {
	LDKPublicKey a_ref;
	CHECK((*env)->GetArrayLength(env, a) == 33);
	(*env)->GetByteArrayRegion(env, a, 0, 33, a_ref.compressed_form);
	void* b_ptr = (void*)(((uint64_t)b) & ~1);
	CHECK_ACCESS(b_ptr);
	LDKType b_conv = *(LDKType*)(b_ptr);
	if (b_conv.free == LDKType_JCalls_free) {
		// If this_arg is a JCalls struct, then we need to increment the refcnt in it.
		LDKType_JCalls_cloned(&b_conv);
	}
	LDKC2Tuple_PublicKeyTypeZ* ret_conv = MALLOC(sizeof(LDKC2Tuple_PublicKeyTypeZ), "LDKC2Tuple_PublicKeyTypeZ");
	*ret_conv = C2Tuple_PublicKeyTypeZ_new(a_ref, b_conv);
	return ((uint64_t)ret_conv);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_C2Tuple_1PublicKeyTypeZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKC2Tuple_PublicKeyTypeZ _res_conv = *(LDKC2Tuple_PublicKeyTypeZ*)(_res_ptr);
	FREE((void*)_res);
	C2Tuple_PublicKeyTypeZ_free(_res_conv);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CVec_1C2Tuple_1PublicKeyTypeZZ_1free(JNIEnv *env, jclass clz, int64_tArray _res) {
	LDKCVec_C2Tuple_PublicKeyTypeZZ _res_constr;
	_res_constr.datalen = (*env)->GetArrayLength(env, _res);
	if (_res_constr.datalen > 0)
		_res_constr.data = MALLOC(_res_constr.datalen * sizeof(LDKC2Tuple_PublicKeyTypeZ), "LDKCVec_C2Tuple_PublicKeyTypeZZ Elements");
	else
		_res_constr.data = NULL;
	int64_t* _res_vals = (*env)->GetLongArrayElements (env, _res, NULL);
	for (size_t z = 0; z < _res_constr.datalen; z++) {
		int64_t _res_conv_25 = _res_vals[z];
		void* _res_conv_25_ptr = (void*)(((uint64_t)_res_conv_25) & ~1);
		CHECK_ACCESS(_res_conv_25_ptr);
		LDKC2Tuple_PublicKeyTypeZ _res_conv_25_conv = *(LDKC2Tuple_PublicKeyTypeZ*)(_res_conv_25_ptr);
		FREE((void*)_res_conv_25);
		_res_constr.data[z] = _res_conv_25_conv;
	}
	(*env)->ReleaseLongArrayElements(env, _res, _res_vals, 0);
	CVec_C2Tuple_PublicKeyTypeZZ_free(_res_constr);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1boolLightningErrorZ_1ok(JNIEnv *env, jclass clz, jboolean o) {
	LDKCResult_boolLightningErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_boolLightningErrorZ), "LDKCResult_boolLightningErrorZ");
	*ret_conv = CResult_boolLightningErrorZ_ok(o);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1boolLightningErrorZ_1err(JNIEnv *env, jclass clz, int64_t e) {
	LDKLightningError e_conv;
	e_conv.inner = (void*)(e & (~1));
	e_conv.is_owned = (e & 1) || (e == 0);
	e_conv = LightningError_clone(&e_conv);
	LDKCResult_boolLightningErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_boolLightningErrorZ), "LDKCResult_boolLightningErrorZ");
	*ret_conv = CResult_boolLightningErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1boolLightningErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_boolLightningErrorZ _res_conv = *(LDKCResult_boolLightningErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_boolLightningErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1boolLightningErrorZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_boolLightningErrorZ* orig_conv = (LDKCResult_boolLightningErrorZ*)(orig & ~1);
	LDKCResult_boolLightningErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_boolLightningErrorZ), "LDKCResult_boolLightningErrorZ");
	*ret_conv = CResult_boolLightningErrorZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_C3Tuple_1ChannelAnnouncementChannelUpdateChannelUpdateZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ* orig_conv = (LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ*)(orig & ~1);
	LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ* ret_conv = MALLOC(sizeof(LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ), "LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ");
	*ret_conv = C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_clone(orig_conv);
	return ((uint64_t)ret_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_C3Tuple_1ChannelAnnouncementChannelUpdateChannelUpdateZ_1new(JNIEnv *env, jclass clz, int64_t a, int64_t b, int64_t c) {
	LDKChannelAnnouncement a_conv;
	a_conv.inner = (void*)(a & (~1));
	a_conv.is_owned = (a & 1) || (a == 0);
	a_conv = ChannelAnnouncement_clone(&a_conv);
	LDKChannelUpdate b_conv;
	b_conv.inner = (void*)(b & (~1));
	b_conv.is_owned = (b & 1) || (b == 0);
	b_conv = ChannelUpdate_clone(&b_conv);
	LDKChannelUpdate c_conv;
	c_conv.inner = (void*)(c & (~1));
	c_conv.is_owned = (c & 1) || (c == 0);
	c_conv = ChannelUpdate_clone(&c_conv);
	LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ* ret_conv = MALLOC(sizeof(LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ), "LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ");
	*ret_conv = C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_new(a_conv, b_conv, c_conv);
	return ((uint64_t)ret_conv);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_C3Tuple_1ChannelAnnouncementChannelUpdateChannelUpdateZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ _res_conv = *(LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ*)(_res_ptr);
	FREE((void*)_res);
	C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_free(_res_conv);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CVec_1C3Tuple_1ChannelAnnouncementChannelUpdateChannelUpdateZZ_1free(JNIEnv *env, jclass clz, int64_tArray _res) {
	LDKCVec_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ _res_constr;
	_res_constr.datalen = (*env)->GetArrayLength(env, _res);
	if (_res_constr.datalen > 0)
		_res_constr.data = MALLOC(_res_constr.datalen * sizeof(LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ), "LDKCVec_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ Elements");
	else
		_res_constr.data = NULL;
	int64_t* _res_vals = (*env)->GetLongArrayElements (env, _res, NULL);
	for (size_t h = 0; h < _res_constr.datalen; h++) {
		int64_t _res_conv_59 = _res_vals[h];
		void* _res_conv_59_ptr = (void*)(((uint64_t)_res_conv_59) & ~1);
		CHECK_ACCESS(_res_conv_59_ptr);
		LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ _res_conv_59_conv = *(LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ*)(_res_conv_59_ptr);
		FREE((void*)_res_conv_59);
		_res_constr.data[h] = _res_conv_59_conv;
	}
	(*env)->ReleaseLongArrayElements(env, _res, _res_vals, 0);
	CVec_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ_free(_res_constr);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CVec_1NodeAnnouncementZ_1free(JNIEnv *env, jclass clz, int64_tArray _res) {
	LDKCVec_NodeAnnouncementZ _res_constr;
	_res_constr.datalen = (*env)->GetArrayLength(env, _res);
	if (_res_constr.datalen > 0)
		_res_constr.data = MALLOC(_res_constr.datalen * sizeof(LDKNodeAnnouncement), "LDKCVec_NodeAnnouncementZ Elements");
	else
		_res_constr.data = NULL;
	int64_t* _res_vals = (*env)->GetLongArrayElements (env, _res, NULL);
	for (size_t s = 0; s < _res_constr.datalen; s++) {
		int64_t _res_conv_18 = _res_vals[s];
		LDKNodeAnnouncement _res_conv_18_conv;
		_res_conv_18_conv.inner = (void*)(_res_conv_18 & (~1));
		_res_conv_18_conv.is_owned = (_res_conv_18 & 1) || (_res_conv_18 == 0);
		_res_constr.data[s] = _res_conv_18_conv;
	}
	(*env)->ReleaseLongArrayElements(env, _res, _res_vals, 0);
	CVec_NodeAnnouncementZ_free(_res_constr);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CVec_1PublicKeyZ_1free(JNIEnv *env, jclass clz, jobjectArray _res) {
	LDKCVec_PublicKeyZ _res_constr;
	_res_constr.datalen = (*env)->GetArrayLength(env, _res);
	if (_res_constr.datalen > 0)
		_res_constr.data = MALLOC(_res_constr.datalen * sizeof(LDKPublicKey), "LDKCVec_PublicKeyZ Elements");
	else
		_res_constr.data = NULL;
	for (size_t i = 0; i < _res_constr.datalen; i++) {
		int8_tArray _res_conv_8 = (*env)->GetObjectArrayElement(env, _res, i);
		LDKPublicKey _res_conv_8_ref;
		CHECK((*env)->GetArrayLength(env, _res_conv_8) == 33);
		(*env)->GetByteArrayRegion(env, _res_conv_8, 0, 33, _res_conv_8_ref.compressed_form);
		_res_constr.data[i] = _res_conv_8_ref;
	}
	CVec_PublicKeyZ_free(_res_constr);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1CVec_1u8ZPeerHandleErrorZ_1ok(JNIEnv *env, jclass clz, int8_tArray o) {
	LDKCVec_u8Z o_ref;
	o_ref.datalen = (*env)->GetArrayLength(env, o);
	o_ref.data = MALLOC(o_ref.datalen, "LDKCVec_u8Z Bytes");
	(*env)->GetByteArrayRegion(env, o, 0, o_ref.datalen, o_ref.data);
	LDKCResult_CVec_u8ZPeerHandleErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_CVec_u8ZPeerHandleErrorZ), "LDKCResult_CVec_u8ZPeerHandleErrorZ");
	*ret_conv = CResult_CVec_u8ZPeerHandleErrorZ_ok(o_ref);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1CVec_1u8ZPeerHandleErrorZ_1err(JNIEnv *env, jclass clz, int64_t e) {
	LDKPeerHandleError e_conv;
	e_conv.inner = (void*)(e & (~1));
	e_conv.is_owned = (e & 1) || (e == 0);
	e_conv = PeerHandleError_clone(&e_conv);
	LDKCResult_CVec_u8ZPeerHandleErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_CVec_u8ZPeerHandleErrorZ), "LDKCResult_CVec_u8ZPeerHandleErrorZ");
	*ret_conv = CResult_CVec_u8ZPeerHandleErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1CVec_1u8ZPeerHandleErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_CVec_u8ZPeerHandleErrorZ _res_conv = *(LDKCResult_CVec_u8ZPeerHandleErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_CVec_u8ZPeerHandleErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1CVec_1u8ZPeerHandleErrorZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_CVec_u8ZPeerHandleErrorZ* orig_conv = (LDKCResult_CVec_u8ZPeerHandleErrorZ*)(orig & ~1);
	LDKCResult_CVec_u8ZPeerHandleErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_CVec_u8ZPeerHandleErrorZ), "LDKCResult_CVec_u8ZPeerHandleErrorZ");
	*ret_conv = CResult_CVec_u8ZPeerHandleErrorZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1NonePeerHandleErrorZ_1ok(JNIEnv *env, jclass clz) {
	LDKCResult_NonePeerHandleErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_NonePeerHandleErrorZ), "LDKCResult_NonePeerHandleErrorZ");
	*ret_conv = CResult_NonePeerHandleErrorZ_ok();
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1NonePeerHandleErrorZ_1err(JNIEnv *env, jclass clz, int64_t e) {
	LDKPeerHandleError e_conv;
	e_conv.inner = (void*)(e & (~1));
	e_conv.is_owned = (e & 1) || (e == 0);
	e_conv = PeerHandleError_clone(&e_conv);
	LDKCResult_NonePeerHandleErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_NonePeerHandleErrorZ), "LDKCResult_NonePeerHandleErrorZ");
	*ret_conv = CResult_NonePeerHandleErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1NonePeerHandleErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_NonePeerHandleErrorZ _res_conv = *(LDKCResult_NonePeerHandleErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_NonePeerHandleErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1NonePeerHandleErrorZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_NonePeerHandleErrorZ* orig_conv = (LDKCResult_NonePeerHandleErrorZ*)(orig & ~1);
	LDKCResult_NonePeerHandleErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_NonePeerHandleErrorZ), "LDKCResult_NonePeerHandleErrorZ");
	*ret_conv = CResult_NonePeerHandleErrorZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1boolPeerHandleErrorZ_1ok(JNIEnv *env, jclass clz, jboolean o) {
	LDKCResult_boolPeerHandleErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_boolPeerHandleErrorZ), "LDKCResult_boolPeerHandleErrorZ");
	*ret_conv = CResult_boolPeerHandleErrorZ_ok(o);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1boolPeerHandleErrorZ_1err(JNIEnv *env, jclass clz, int64_t e) {
	LDKPeerHandleError e_conv;
	e_conv.inner = (void*)(e & (~1));
	e_conv.is_owned = (e & 1) || (e == 0);
	e_conv = PeerHandleError_clone(&e_conv);
	LDKCResult_boolPeerHandleErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_boolPeerHandleErrorZ), "LDKCResult_boolPeerHandleErrorZ");
	*ret_conv = CResult_boolPeerHandleErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1boolPeerHandleErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_boolPeerHandleErrorZ _res_conv = *(LDKCResult_boolPeerHandleErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_boolPeerHandleErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1boolPeerHandleErrorZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_boolPeerHandleErrorZ* orig_conv = (LDKCResult_boolPeerHandleErrorZ*)(orig & ~1);
	LDKCResult_boolPeerHandleErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_boolPeerHandleErrorZ), "LDKCResult_boolPeerHandleErrorZ");
	*ret_conv = CResult_boolPeerHandleErrorZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1NodeIdDecodeErrorZ_1ok(JNIEnv *env, jclass clz, int64_t o) {
	LDKNodeId o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = (o & 1) || (o == 0);
	o_conv = NodeId_clone(&o_conv);
	LDKCResult_NodeIdDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_NodeIdDecodeErrorZ), "LDKCResult_NodeIdDecodeErrorZ");
	*ret_conv = CResult_NodeIdDecodeErrorZ_ok(o_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1NodeIdDecodeErrorZ_1err(JNIEnv *env, jclass clz, int64_t e) {
	LDKDecodeError e_conv;
	e_conv.inner = (void*)(e & (~1));
	e_conv.is_owned = (e & 1) || (e == 0);
	e_conv = DecodeError_clone(&e_conv);
	LDKCResult_NodeIdDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_NodeIdDecodeErrorZ), "LDKCResult_NodeIdDecodeErrorZ");
	*ret_conv = CResult_NodeIdDecodeErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1NodeIdDecodeErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_NodeIdDecodeErrorZ _res_conv = *(LDKCResult_NodeIdDecodeErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_NodeIdDecodeErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1NodeIdDecodeErrorZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_NodeIdDecodeErrorZ* orig_conv = (LDKCResult_NodeIdDecodeErrorZ*)(orig & ~1);
	LDKCResult_NodeIdDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_NodeIdDecodeErrorZ), "LDKCResult_NodeIdDecodeErrorZ");
	*ret_conv = CResult_NodeIdDecodeErrorZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_COption_1AccessZ_1some(JNIEnv *env, jclass clz, int64_t o) {
	void* o_ptr = (void*)(((uint64_t)o) & ~1);
	CHECK_ACCESS(o_ptr);
	LDKAccess o_conv = *(LDKAccess*)(o_ptr);
	if (o_conv.free == LDKAccess_JCalls_free) {
		// If this_arg is a JCalls struct, then we need to increment the refcnt in it.
		LDKAccess_JCalls_cloned(&o_conv);
	}
	LDKCOption_AccessZ *ret_copy = MALLOC(sizeof(LDKCOption_AccessZ), "LDKCOption_AccessZ");
	*ret_copy = COption_AccessZ_some(o_conv);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_COption_1AccessZ_1none(JNIEnv *env, jclass clz) {
	LDKCOption_AccessZ *ret_copy = MALLOC(sizeof(LDKCOption_AccessZ), "LDKCOption_AccessZ");
	*ret_copy = COption_AccessZ_none();
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_COption_1AccessZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCOption_AccessZ _res_conv = *(LDKCOption_AccessZ*)(_res_ptr);
	FREE((void*)_res);
	COption_AccessZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1DirectionalChannelInfoDecodeErrorZ_1ok(JNIEnv *env, jclass clz, int64_t o) {
	LDKDirectionalChannelInfo o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = (o & 1) || (o == 0);
	o_conv = DirectionalChannelInfo_clone(&o_conv);
	LDKCResult_DirectionalChannelInfoDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_DirectionalChannelInfoDecodeErrorZ), "LDKCResult_DirectionalChannelInfoDecodeErrorZ");
	*ret_conv = CResult_DirectionalChannelInfoDecodeErrorZ_ok(o_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1DirectionalChannelInfoDecodeErrorZ_1err(JNIEnv *env, jclass clz, int64_t e) {
	LDKDecodeError e_conv;
	e_conv.inner = (void*)(e & (~1));
	e_conv.is_owned = (e & 1) || (e == 0);
	e_conv = DecodeError_clone(&e_conv);
	LDKCResult_DirectionalChannelInfoDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_DirectionalChannelInfoDecodeErrorZ), "LDKCResult_DirectionalChannelInfoDecodeErrorZ");
	*ret_conv = CResult_DirectionalChannelInfoDecodeErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1DirectionalChannelInfoDecodeErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_DirectionalChannelInfoDecodeErrorZ _res_conv = *(LDKCResult_DirectionalChannelInfoDecodeErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_DirectionalChannelInfoDecodeErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1DirectionalChannelInfoDecodeErrorZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_DirectionalChannelInfoDecodeErrorZ* orig_conv = (LDKCResult_DirectionalChannelInfoDecodeErrorZ*)(orig & ~1);
	LDKCResult_DirectionalChannelInfoDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_DirectionalChannelInfoDecodeErrorZ), "LDKCResult_DirectionalChannelInfoDecodeErrorZ");
	*ret_conv = CResult_DirectionalChannelInfoDecodeErrorZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1ChannelInfoDecodeErrorZ_1ok(JNIEnv *env, jclass clz, int64_t o) {
	LDKChannelInfo o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = (o & 1) || (o == 0);
	o_conv = ChannelInfo_clone(&o_conv);
	LDKCResult_ChannelInfoDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_ChannelInfoDecodeErrorZ), "LDKCResult_ChannelInfoDecodeErrorZ");
	*ret_conv = CResult_ChannelInfoDecodeErrorZ_ok(o_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1ChannelInfoDecodeErrorZ_1err(JNIEnv *env, jclass clz, int64_t e) {
	LDKDecodeError e_conv;
	e_conv.inner = (void*)(e & (~1));
	e_conv.is_owned = (e & 1) || (e == 0);
	e_conv = DecodeError_clone(&e_conv);
	LDKCResult_ChannelInfoDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_ChannelInfoDecodeErrorZ), "LDKCResult_ChannelInfoDecodeErrorZ");
	*ret_conv = CResult_ChannelInfoDecodeErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1ChannelInfoDecodeErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_ChannelInfoDecodeErrorZ _res_conv = *(LDKCResult_ChannelInfoDecodeErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_ChannelInfoDecodeErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1ChannelInfoDecodeErrorZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_ChannelInfoDecodeErrorZ* orig_conv = (LDKCResult_ChannelInfoDecodeErrorZ*)(orig & ~1);
	LDKCResult_ChannelInfoDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_ChannelInfoDecodeErrorZ), "LDKCResult_ChannelInfoDecodeErrorZ");
	*ret_conv = CResult_ChannelInfoDecodeErrorZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1RoutingFeesDecodeErrorZ_1ok(JNIEnv *env, jclass clz, int64_t o) {
	LDKRoutingFees o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = (o & 1) || (o == 0);
	o_conv = RoutingFees_clone(&o_conv);
	LDKCResult_RoutingFeesDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_RoutingFeesDecodeErrorZ), "LDKCResult_RoutingFeesDecodeErrorZ");
	*ret_conv = CResult_RoutingFeesDecodeErrorZ_ok(o_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1RoutingFeesDecodeErrorZ_1err(JNIEnv *env, jclass clz, int64_t e) {
	LDKDecodeError e_conv;
	e_conv.inner = (void*)(e & (~1));
	e_conv.is_owned = (e & 1) || (e == 0);
	e_conv = DecodeError_clone(&e_conv);
	LDKCResult_RoutingFeesDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_RoutingFeesDecodeErrorZ), "LDKCResult_RoutingFeesDecodeErrorZ");
	*ret_conv = CResult_RoutingFeesDecodeErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1RoutingFeesDecodeErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_RoutingFeesDecodeErrorZ _res_conv = *(LDKCResult_RoutingFeesDecodeErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_RoutingFeesDecodeErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1RoutingFeesDecodeErrorZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_RoutingFeesDecodeErrorZ* orig_conv = (LDKCResult_RoutingFeesDecodeErrorZ*)(orig & ~1);
	LDKCResult_RoutingFeesDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_RoutingFeesDecodeErrorZ), "LDKCResult_RoutingFeesDecodeErrorZ");
	*ret_conv = CResult_RoutingFeesDecodeErrorZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1NodeAnnouncementInfoDecodeErrorZ_1ok(JNIEnv *env, jclass clz, int64_t o) {
	LDKNodeAnnouncementInfo o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = (o & 1) || (o == 0);
	o_conv = NodeAnnouncementInfo_clone(&o_conv);
	LDKCResult_NodeAnnouncementInfoDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_NodeAnnouncementInfoDecodeErrorZ), "LDKCResult_NodeAnnouncementInfoDecodeErrorZ");
	*ret_conv = CResult_NodeAnnouncementInfoDecodeErrorZ_ok(o_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1NodeAnnouncementInfoDecodeErrorZ_1err(JNIEnv *env, jclass clz, int64_t e) {
	LDKDecodeError e_conv;
	e_conv.inner = (void*)(e & (~1));
	e_conv.is_owned = (e & 1) || (e == 0);
	e_conv = DecodeError_clone(&e_conv);
	LDKCResult_NodeAnnouncementInfoDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_NodeAnnouncementInfoDecodeErrorZ), "LDKCResult_NodeAnnouncementInfoDecodeErrorZ");
	*ret_conv = CResult_NodeAnnouncementInfoDecodeErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1NodeAnnouncementInfoDecodeErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_NodeAnnouncementInfoDecodeErrorZ _res_conv = *(LDKCResult_NodeAnnouncementInfoDecodeErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_NodeAnnouncementInfoDecodeErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1NodeAnnouncementInfoDecodeErrorZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_NodeAnnouncementInfoDecodeErrorZ* orig_conv = (LDKCResult_NodeAnnouncementInfoDecodeErrorZ*)(orig & ~1);
	LDKCResult_NodeAnnouncementInfoDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_NodeAnnouncementInfoDecodeErrorZ), "LDKCResult_NodeAnnouncementInfoDecodeErrorZ");
	*ret_conv = CResult_NodeAnnouncementInfoDecodeErrorZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CVec_1u64Z_1free(JNIEnv *env, jclass clz, int64_tArray _res) {
	LDKCVec_u64Z _res_constr;
	_res_constr.datalen = (*env)->GetArrayLength(env, _res);
	if (_res_constr.datalen > 0)
		_res_constr.data = MALLOC(_res_constr.datalen * sizeof(int64_t), "LDKCVec_u64Z Elements");
	else
		_res_constr.data = NULL;
	int64_t* _res_vals = (*env)->GetLongArrayElements (env, _res, NULL);
	for (size_t g = 0; g < _res_constr.datalen; g++) {
		int64_t _res_conv_6 = _res_vals[g];
		_res_constr.data[g] = _res_conv_6;
	}
	(*env)->ReleaseLongArrayElements(env, _res, _res_vals, 0);
	CVec_u64Z_free(_res_constr);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1NodeInfoDecodeErrorZ_1ok(JNIEnv *env, jclass clz, int64_t o) {
	LDKNodeInfo o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = (o & 1) || (o == 0);
	o_conv = NodeInfo_clone(&o_conv);
	LDKCResult_NodeInfoDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_NodeInfoDecodeErrorZ), "LDKCResult_NodeInfoDecodeErrorZ");
	*ret_conv = CResult_NodeInfoDecodeErrorZ_ok(o_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1NodeInfoDecodeErrorZ_1err(JNIEnv *env, jclass clz, int64_t e) {
	LDKDecodeError e_conv;
	e_conv.inner = (void*)(e & (~1));
	e_conv.is_owned = (e & 1) || (e == 0);
	e_conv = DecodeError_clone(&e_conv);
	LDKCResult_NodeInfoDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_NodeInfoDecodeErrorZ), "LDKCResult_NodeInfoDecodeErrorZ");
	*ret_conv = CResult_NodeInfoDecodeErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1NodeInfoDecodeErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_NodeInfoDecodeErrorZ _res_conv = *(LDKCResult_NodeInfoDecodeErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_NodeInfoDecodeErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1NodeInfoDecodeErrorZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_NodeInfoDecodeErrorZ* orig_conv = (LDKCResult_NodeInfoDecodeErrorZ*)(orig & ~1);
	LDKCResult_NodeInfoDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_NodeInfoDecodeErrorZ), "LDKCResult_NodeInfoDecodeErrorZ");
	*ret_conv = CResult_NodeInfoDecodeErrorZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1NetworkGraphDecodeErrorZ_1ok(JNIEnv *env, jclass clz, int64_t o) {
	LDKNetworkGraph o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = (o & 1) || (o == 0);
	o_conv = NetworkGraph_clone(&o_conv);
	LDKCResult_NetworkGraphDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_NetworkGraphDecodeErrorZ), "LDKCResult_NetworkGraphDecodeErrorZ");
	*ret_conv = CResult_NetworkGraphDecodeErrorZ_ok(o_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1NetworkGraphDecodeErrorZ_1err(JNIEnv *env, jclass clz, int64_t e) {
	LDKDecodeError e_conv;
	e_conv.inner = (void*)(e & (~1));
	e_conv.is_owned = (e & 1) || (e == 0);
	e_conv = DecodeError_clone(&e_conv);
	LDKCResult_NetworkGraphDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_NetworkGraphDecodeErrorZ), "LDKCResult_NetworkGraphDecodeErrorZ");
	*ret_conv = CResult_NetworkGraphDecodeErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1NetworkGraphDecodeErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_NetworkGraphDecodeErrorZ _res_conv = *(LDKCResult_NetworkGraphDecodeErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_NetworkGraphDecodeErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1NetworkGraphDecodeErrorZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_NetworkGraphDecodeErrorZ* orig_conv = (LDKCResult_NetworkGraphDecodeErrorZ*)(orig & ~1);
	LDKCResult_NetworkGraphDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_NetworkGraphDecodeErrorZ), "LDKCResult_NetworkGraphDecodeErrorZ");
	*ret_conv = CResult_NetworkGraphDecodeErrorZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_COption_1CVec_1NetAddressZZ_1some(JNIEnv *env, jclass clz, int64_tArray o) {
	LDKCVec_NetAddressZ o_constr;
	o_constr.datalen = (*env)->GetArrayLength(env, o);
	if (o_constr.datalen > 0)
		o_constr.data = MALLOC(o_constr.datalen * sizeof(LDKNetAddress), "LDKCVec_NetAddressZ Elements");
	else
		o_constr.data = NULL;
	int64_t* o_vals = (*env)->GetLongArrayElements (env, o, NULL);
	for (size_t m = 0; m < o_constr.datalen; m++) {
		int64_t o_conv_12 = o_vals[m];
		void* o_conv_12_ptr = (void*)(((uint64_t)o_conv_12) & ~1);
		CHECK_ACCESS(o_conv_12_ptr);
		LDKNetAddress o_conv_12_conv = *(LDKNetAddress*)(o_conv_12_ptr);
		o_conv_12_conv = NetAddress_clone((LDKNetAddress*)(((uint64_t)o_conv_12) & ~1));
		o_constr.data[m] = o_conv_12_conv;
	}
	(*env)->ReleaseLongArrayElements(env, o, o_vals, 0);
	LDKCOption_CVec_NetAddressZZ *ret_copy = MALLOC(sizeof(LDKCOption_CVec_NetAddressZZ), "LDKCOption_CVec_NetAddressZZ");
	*ret_copy = COption_CVec_NetAddressZZ_some(o_constr);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_COption_1CVec_1NetAddressZZ_1none(JNIEnv *env, jclass clz) {
	LDKCOption_CVec_NetAddressZZ *ret_copy = MALLOC(sizeof(LDKCOption_CVec_NetAddressZZ), "LDKCOption_CVec_NetAddressZZ");
	*ret_copy = COption_CVec_NetAddressZZ_none();
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_COption_1CVec_1NetAddressZZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCOption_CVec_NetAddressZZ _res_conv = *(LDKCOption_CVec_NetAddressZZ*)(_res_ptr);
	FREE((void*)_res);
	COption_CVec_NetAddressZZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_COption_1CVec_1NetAddressZZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCOption_CVec_NetAddressZZ* orig_conv = (LDKCOption_CVec_NetAddressZZ*)orig;
	LDKCOption_CVec_NetAddressZZ *ret_copy = MALLOC(sizeof(LDKCOption_CVec_NetAddressZZ), "LDKCOption_CVec_NetAddressZZ");
	*ret_copy = COption_CVec_NetAddressZZ_clone(orig_conv);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1NetAddressDecodeErrorZ_1ok(JNIEnv *env, jclass clz, int64_t o) {
	void* o_ptr = (void*)(((uint64_t)o) & ~1);
	CHECK_ACCESS(o_ptr);
	LDKNetAddress o_conv = *(LDKNetAddress*)(o_ptr);
	o_conv = NetAddress_clone((LDKNetAddress*)(((uint64_t)o) & ~1));
	LDKCResult_NetAddressDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_NetAddressDecodeErrorZ), "LDKCResult_NetAddressDecodeErrorZ");
	*ret_conv = CResult_NetAddressDecodeErrorZ_ok(o_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1NetAddressDecodeErrorZ_1err(JNIEnv *env, jclass clz, int64_t e) {
	LDKDecodeError e_conv;
	e_conv.inner = (void*)(e & (~1));
	e_conv.is_owned = (e & 1) || (e == 0);
	e_conv = DecodeError_clone(&e_conv);
	LDKCResult_NetAddressDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_NetAddressDecodeErrorZ), "LDKCResult_NetAddressDecodeErrorZ");
	*ret_conv = CResult_NetAddressDecodeErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1NetAddressDecodeErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_NetAddressDecodeErrorZ _res_conv = *(LDKCResult_NetAddressDecodeErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_NetAddressDecodeErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1NetAddressDecodeErrorZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_NetAddressDecodeErrorZ* orig_conv = (LDKCResult_NetAddressDecodeErrorZ*)(orig & ~1);
	LDKCResult_NetAddressDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_NetAddressDecodeErrorZ), "LDKCResult_NetAddressDecodeErrorZ");
	*ret_conv = CResult_NetAddressDecodeErrorZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CVec_1UpdateAddHTLCZ_1free(JNIEnv *env, jclass clz, int64_tArray _res) {
	LDKCVec_UpdateAddHTLCZ _res_constr;
	_res_constr.datalen = (*env)->GetArrayLength(env, _res);
	if (_res_constr.datalen > 0)
		_res_constr.data = MALLOC(_res_constr.datalen * sizeof(LDKUpdateAddHTLC), "LDKCVec_UpdateAddHTLCZ Elements");
	else
		_res_constr.data = NULL;
	int64_t* _res_vals = (*env)->GetLongArrayElements (env, _res, NULL);
	for (size_t p = 0; p < _res_constr.datalen; p++) {
		int64_t _res_conv_15 = _res_vals[p];
		LDKUpdateAddHTLC _res_conv_15_conv;
		_res_conv_15_conv.inner = (void*)(_res_conv_15 & (~1));
		_res_conv_15_conv.is_owned = (_res_conv_15 & 1) || (_res_conv_15 == 0);
		_res_constr.data[p] = _res_conv_15_conv;
	}
	(*env)->ReleaseLongArrayElements(env, _res, _res_vals, 0);
	CVec_UpdateAddHTLCZ_free(_res_constr);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CVec_1UpdateFulfillHTLCZ_1free(JNIEnv *env, jclass clz, int64_tArray _res) {
	LDKCVec_UpdateFulfillHTLCZ _res_constr;
	_res_constr.datalen = (*env)->GetArrayLength(env, _res);
	if (_res_constr.datalen > 0)
		_res_constr.data = MALLOC(_res_constr.datalen * sizeof(LDKUpdateFulfillHTLC), "LDKCVec_UpdateFulfillHTLCZ Elements");
	else
		_res_constr.data = NULL;
	int64_t* _res_vals = (*env)->GetLongArrayElements (env, _res, NULL);
	for (size_t t = 0; t < _res_constr.datalen; t++) {
		int64_t _res_conv_19 = _res_vals[t];
		LDKUpdateFulfillHTLC _res_conv_19_conv;
		_res_conv_19_conv.inner = (void*)(_res_conv_19 & (~1));
		_res_conv_19_conv.is_owned = (_res_conv_19 & 1) || (_res_conv_19 == 0);
		_res_constr.data[t] = _res_conv_19_conv;
	}
	(*env)->ReleaseLongArrayElements(env, _res, _res_vals, 0);
	CVec_UpdateFulfillHTLCZ_free(_res_constr);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CVec_1UpdateFailHTLCZ_1free(JNIEnv *env, jclass clz, int64_tArray _res) {
	LDKCVec_UpdateFailHTLCZ _res_constr;
	_res_constr.datalen = (*env)->GetArrayLength(env, _res);
	if (_res_constr.datalen > 0)
		_res_constr.data = MALLOC(_res_constr.datalen * sizeof(LDKUpdateFailHTLC), "LDKCVec_UpdateFailHTLCZ Elements");
	else
		_res_constr.data = NULL;
	int64_t* _res_vals = (*env)->GetLongArrayElements (env, _res, NULL);
	for (size_t q = 0; q < _res_constr.datalen; q++) {
		int64_t _res_conv_16 = _res_vals[q];
		LDKUpdateFailHTLC _res_conv_16_conv;
		_res_conv_16_conv.inner = (void*)(_res_conv_16 & (~1));
		_res_conv_16_conv.is_owned = (_res_conv_16 & 1) || (_res_conv_16 == 0);
		_res_constr.data[q] = _res_conv_16_conv;
	}
	(*env)->ReleaseLongArrayElements(env, _res, _res_vals, 0);
	CVec_UpdateFailHTLCZ_free(_res_constr);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CVec_1UpdateFailMalformedHTLCZ_1free(JNIEnv *env, jclass clz, int64_tArray _res) {
	LDKCVec_UpdateFailMalformedHTLCZ _res_constr;
	_res_constr.datalen = (*env)->GetArrayLength(env, _res);
	if (_res_constr.datalen > 0)
		_res_constr.data = MALLOC(_res_constr.datalen * sizeof(LDKUpdateFailMalformedHTLC), "LDKCVec_UpdateFailMalformedHTLCZ Elements");
	else
		_res_constr.data = NULL;
	int64_t* _res_vals = (*env)->GetLongArrayElements (env, _res, NULL);
	for (size_t z = 0; z < _res_constr.datalen; z++) {
		int64_t _res_conv_25 = _res_vals[z];
		LDKUpdateFailMalformedHTLC _res_conv_25_conv;
		_res_conv_25_conv.inner = (void*)(_res_conv_25 & (~1));
		_res_conv_25_conv.is_owned = (_res_conv_25 & 1) || (_res_conv_25 == 0);
		_res_constr.data[z] = _res_conv_25_conv;
	}
	(*env)->ReleaseLongArrayElements(env, _res, _res_vals, 0);
	CVec_UpdateFailMalformedHTLCZ_free(_res_constr);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1AcceptChannelDecodeErrorZ_1ok(JNIEnv *env, jclass clz, int64_t o) {
	LDKAcceptChannel o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = (o & 1) || (o == 0);
	o_conv = AcceptChannel_clone(&o_conv);
	LDKCResult_AcceptChannelDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_AcceptChannelDecodeErrorZ), "LDKCResult_AcceptChannelDecodeErrorZ");
	*ret_conv = CResult_AcceptChannelDecodeErrorZ_ok(o_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1AcceptChannelDecodeErrorZ_1err(JNIEnv *env, jclass clz, int64_t e) {
	LDKDecodeError e_conv;
	e_conv.inner = (void*)(e & (~1));
	e_conv.is_owned = (e & 1) || (e == 0);
	e_conv = DecodeError_clone(&e_conv);
	LDKCResult_AcceptChannelDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_AcceptChannelDecodeErrorZ), "LDKCResult_AcceptChannelDecodeErrorZ");
	*ret_conv = CResult_AcceptChannelDecodeErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1AcceptChannelDecodeErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_AcceptChannelDecodeErrorZ _res_conv = *(LDKCResult_AcceptChannelDecodeErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_AcceptChannelDecodeErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1AcceptChannelDecodeErrorZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_AcceptChannelDecodeErrorZ* orig_conv = (LDKCResult_AcceptChannelDecodeErrorZ*)(orig & ~1);
	LDKCResult_AcceptChannelDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_AcceptChannelDecodeErrorZ), "LDKCResult_AcceptChannelDecodeErrorZ");
	*ret_conv = CResult_AcceptChannelDecodeErrorZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1AnnouncementSignaturesDecodeErrorZ_1ok(JNIEnv *env, jclass clz, int64_t o) {
	LDKAnnouncementSignatures o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = (o & 1) || (o == 0);
	o_conv = AnnouncementSignatures_clone(&o_conv);
	LDKCResult_AnnouncementSignaturesDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_AnnouncementSignaturesDecodeErrorZ), "LDKCResult_AnnouncementSignaturesDecodeErrorZ");
	*ret_conv = CResult_AnnouncementSignaturesDecodeErrorZ_ok(o_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1AnnouncementSignaturesDecodeErrorZ_1err(JNIEnv *env, jclass clz, int64_t e) {
	LDKDecodeError e_conv;
	e_conv.inner = (void*)(e & (~1));
	e_conv.is_owned = (e & 1) || (e == 0);
	e_conv = DecodeError_clone(&e_conv);
	LDKCResult_AnnouncementSignaturesDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_AnnouncementSignaturesDecodeErrorZ), "LDKCResult_AnnouncementSignaturesDecodeErrorZ");
	*ret_conv = CResult_AnnouncementSignaturesDecodeErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1AnnouncementSignaturesDecodeErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_AnnouncementSignaturesDecodeErrorZ _res_conv = *(LDKCResult_AnnouncementSignaturesDecodeErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_AnnouncementSignaturesDecodeErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1AnnouncementSignaturesDecodeErrorZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_AnnouncementSignaturesDecodeErrorZ* orig_conv = (LDKCResult_AnnouncementSignaturesDecodeErrorZ*)(orig & ~1);
	LDKCResult_AnnouncementSignaturesDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_AnnouncementSignaturesDecodeErrorZ), "LDKCResult_AnnouncementSignaturesDecodeErrorZ");
	*ret_conv = CResult_AnnouncementSignaturesDecodeErrorZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1ChannelReestablishDecodeErrorZ_1ok(JNIEnv *env, jclass clz, int64_t o) {
	LDKChannelReestablish o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = (o & 1) || (o == 0);
	o_conv = ChannelReestablish_clone(&o_conv);
	LDKCResult_ChannelReestablishDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_ChannelReestablishDecodeErrorZ), "LDKCResult_ChannelReestablishDecodeErrorZ");
	*ret_conv = CResult_ChannelReestablishDecodeErrorZ_ok(o_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1ChannelReestablishDecodeErrorZ_1err(JNIEnv *env, jclass clz, int64_t e) {
	LDKDecodeError e_conv;
	e_conv.inner = (void*)(e & (~1));
	e_conv.is_owned = (e & 1) || (e == 0);
	e_conv = DecodeError_clone(&e_conv);
	LDKCResult_ChannelReestablishDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_ChannelReestablishDecodeErrorZ), "LDKCResult_ChannelReestablishDecodeErrorZ");
	*ret_conv = CResult_ChannelReestablishDecodeErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1ChannelReestablishDecodeErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_ChannelReestablishDecodeErrorZ _res_conv = *(LDKCResult_ChannelReestablishDecodeErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_ChannelReestablishDecodeErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1ChannelReestablishDecodeErrorZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_ChannelReestablishDecodeErrorZ* orig_conv = (LDKCResult_ChannelReestablishDecodeErrorZ*)(orig & ~1);
	LDKCResult_ChannelReestablishDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_ChannelReestablishDecodeErrorZ), "LDKCResult_ChannelReestablishDecodeErrorZ");
	*ret_conv = CResult_ChannelReestablishDecodeErrorZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1ClosingSignedDecodeErrorZ_1ok(JNIEnv *env, jclass clz, int64_t o) {
	LDKClosingSigned o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = (o & 1) || (o == 0);
	o_conv = ClosingSigned_clone(&o_conv);
	LDKCResult_ClosingSignedDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_ClosingSignedDecodeErrorZ), "LDKCResult_ClosingSignedDecodeErrorZ");
	*ret_conv = CResult_ClosingSignedDecodeErrorZ_ok(o_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1ClosingSignedDecodeErrorZ_1err(JNIEnv *env, jclass clz, int64_t e) {
	LDKDecodeError e_conv;
	e_conv.inner = (void*)(e & (~1));
	e_conv.is_owned = (e & 1) || (e == 0);
	e_conv = DecodeError_clone(&e_conv);
	LDKCResult_ClosingSignedDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_ClosingSignedDecodeErrorZ), "LDKCResult_ClosingSignedDecodeErrorZ");
	*ret_conv = CResult_ClosingSignedDecodeErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1ClosingSignedDecodeErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_ClosingSignedDecodeErrorZ _res_conv = *(LDKCResult_ClosingSignedDecodeErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_ClosingSignedDecodeErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1ClosingSignedDecodeErrorZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_ClosingSignedDecodeErrorZ* orig_conv = (LDKCResult_ClosingSignedDecodeErrorZ*)(orig & ~1);
	LDKCResult_ClosingSignedDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_ClosingSignedDecodeErrorZ), "LDKCResult_ClosingSignedDecodeErrorZ");
	*ret_conv = CResult_ClosingSignedDecodeErrorZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1ClosingSignedFeeRangeDecodeErrorZ_1ok(JNIEnv *env, jclass clz, int64_t o) {
	LDKClosingSignedFeeRange o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = (o & 1) || (o == 0);
	o_conv = ClosingSignedFeeRange_clone(&o_conv);
	LDKCResult_ClosingSignedFeeRangeDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_ClosingSignedFeeRangeDecodeErrorZ), "LDKCResult_ClosingSignedFeeRangeDecodeErrorZ");
	*ret_conv = CResult_ClosingSignedFeeRangeDecodeErrorZ_ok(o_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1ClosingSignedFeeRangeDecodeErrorZ_1err(JNIEnv *env, jclass clz, int64_t e) {
	LDKDecodeError e_conv;
	e_conv.inner = (void*)(e & (~1));
	e_conv.is_owned = (e & 1) || (e == 0);
	e_conv = DecodeError_clone(&e_conv);
	LDKCResult_ClosingSignedFeeRangeDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_ClosingSignedFeeRangeDecodeErrorZ), "LDKCResult_ClosingSignedFeeRangeDecodeErrorZ");
	*ret_conv = CResult_ClosingSignedFeeRangeDecodeErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1ClosingSignedFeeRangeDecodeErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_ClosingSignedFeeRangeDecodeErrorZ _res_conv = *(LDKCResult_ClosingSignedFeeRangeDecodeErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_ClosingSignedFeeRangeDecodeErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1ClosingSignedFeeRangeDecodeErrorZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_ClosingSignedFeeRangeDecodeErrorZ* orig_conv = (LDKCResult_ClosingSignedFeeRangeDecodeErrorZ*)(orig & ~1);
	LDKCResult_ClosingSignedFeeRangeDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_ClosingSignedFeeRangeDecodeErrorZ), "LDKCResult_ClosingSignedFeeRangeDecodeErrorZ");
	*ret_conv = CResult_ClosingSignedFeeRangeDecodeErrorZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1CommitmentSignedDecodeErrorZ_1ok(JNIEnv *env, jclass clz, int64_t o) {
	LDKCommitmentSigned o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = (o & 1) || (o == 0);
	o_conv = CommitmentSigned_clone(&o_conv);
	LDKCResult_CommitmentSignedDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_CommitmentSignedDecodeErrorZ), "LDKCResult_CommitmentSignedDecodeErrorZ");
	*ret_conv = CResult_CommitmentSignedDecodeErrorZ_ok(o_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1CommitmentSignedDecodeErrorZ_1err(JNIEnv *env, jclass clz, int64_t e) {
	LDKDecodeError e_conv;
	e_conv.inner = (void*)(e & (~1));
	e_conv.is_owned = (e & 1) || (e == 0);
	e_conv = DecodeError_clone(&e_conv);
	LDKCResult_CommitmentSignedDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_CommitmentSignedDecodeErrorZ), "LDKCResult_CommitmentSignedDecodeErrorZ");
	*ret_conv = CResult_CommitmentSignedDecodeErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1CommitmentSignedDecodeErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_CommitmentSignedDecodeErrorZ _res_conv = *(LDKCResult_CommitmentSignedDecodeErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_CommitmentSignedDecodeErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1CommitmentSignedDecodeErrorZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_CommitmentSignedDecodeErrorZ* orig_conv = (LDKCResult_CommitmentSignedDecodeErrorZ*)(orig & ~1);
	LDKCResult_CommitmentSignedDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_CommitmentSignedDecodeErrorZ), "LDKCResult_CommitmentSignedDecodeErrorZ");
	*ret_conv = CResult_CommitmentSignedDecodeErrorZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1FundingCreatedDecodeErrorZ_1ok(JNIEnv *env, jclass clz, int64_t o) {
	LDKFundingCreated o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = (o & 1) || (o == 0);
	o_conv = FundingCreated_clone(&o_conv);
	LDKCResult_FundingCreatedDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_FundingCreatedDecodeErrorZ), "LDKCResult_FundingCreatedDecodeErrorZ");
	*ret_conv = CResult_FundingCreatedDecodeErrorZ_ok(o_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1FundingCreatedDecodeErrorZ_1err(JNIEnv *env, jclass clz, int64_t e) {
	LDKDecodeError e_conv;
	e_conv.inner = (void*)(e & (~1));
	e_conv.is_owned = (e & 1) || (e == 0);
	e_conv = DecodeError_clone(&e_conv);
	LDKCResult_FundingCreatedDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_FundingCreatedDecodeErrorZ), "LDKCResult_FundingCreatedDecodeErrorZ");
	*ret_conv = CResult_FundingCreatedDecodeErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1FundingCreatedDecodeErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_FundingCreatedDecodeErrorZ _res_conv = *(LDKCResult_FundingCreatedDecodeErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_FundingCreatedDecodeErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1FundingCreatedDecodeErrorZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_FundingCreatedDecodeErrorZ* orig_conv = (LDKCResult_FundingCreatedDecodeErrorZ*)(orig & ~1);
	LDKCResult_FundingCreatedDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_FundingCreatedDecodeErrorZ), "LDKCResult_FundingCreatedDecodeErrorZ");
	*ret_conv = CResult_FundingCreatedDecodeErrorZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1FundingSignedDecodeErrorZ_1ok(JNIEnv *env, jclass clz, int64_t o) {
	LDKFundingSigned o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = (o & 1) || (o == 0);
	o_conv = FundingSigned_clone(&o_conv);
	LDKCResult_FundingSignedDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_FundingSignedDecodeErrorZ), "LDKCResult_FundingSignedDecodeErrorZ");
	*ret_conv = CResult_FundingSignedDecodeErrorZ_ok(o_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1FundingSignedDecodeErrorZ_1err(JNIEnv *env, jclass clz, int64_t e) {
	LDKDecodeError e_conv;
	e_conv.inner = (void*)(e & (~1));
	e_conv.is_owned = (e & 1) || (e == 0);
	e_conv = DecodeError_clone(&e_conv);
	LDKCResult_FundingSignedDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_FundingSignedDecodeErrorZ), "LDKCResult_FundingSignedDecodeErrorZ");
	*ret_conv = CResult_FundingSignedDecodeErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1FundingSignedDecodeErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_FundingSignedDecodeErrorZ _res_conv = *(LDKCResult_FundingSignedDecodeErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_FundingSignedDecodeErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1FundingSignedDecodeErrorZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_FundingSignedDecodeErrorZ* orig_conv = (LDKCResult_FundingSignedDecodeErrorZ*)(orig & ~1);
	LDKCResult_FundingSignedDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_FundingSignedDecodeErrorZ), "LDKCResult_FundingSignedDecodeErrorZ");
	*ret_conv = CResult_FundingSignedDecodeErrorZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1FundingLockedDecodeErrorZ_1ok(JNIEnv *env, jclass clz, int64_t o) {
	LDKFundingLocked o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = (o & 1) || (o == 0);
	o_conv = FundingLocked_clone(&o_conv);
	LDKCResult_FundingLockedDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_FundingLockedDecodeErrorZ), "LDKCResult_FundingLockedDecodeErrorZ");
	*ret_conv = CResult_FundingLockedDecodeErrorZ_ok(o_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1FundingLockedDecodeErrorZ_1err(JNIEnv *env, jclass clz, int64_t e) {
	LDKDecodeError e_conv;
	e_conv.inner = (void*)(e & (~1));
	e_conv.is_owned = (e & 1) || (e == 0);
	e_conv = DecodeError_clone(&e_conv);
	LDKCResult_FundingLockedDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_FundingLockedDecodeErrorZ), "LDKCResult_FundingLockedDecodeErrorZ");
	*ret_conv = CResult_FundingLockedDecodeErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1FundingLockedDecodeErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_FundingLockedDecodeErrorZ _res_conv = *(LDKCResult_FundingLockedDecodeErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_FundingLockedDecodeErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1FundingLockedDecodeErrorZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_FundingLockedDecodeErrorZ* orig_conv = (LDKCResult_FundingLockedDecodeErrorZ*)(orig & ~1);
	LDKCResult_FundingLockedDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_FundingLockedDecodeErrorZ), "LDKCResult_FundingLockedDecodeErrorZ");
	*ret_conv = CResult_FundingLockedDecodeErrorZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1InitDecodeErrorZ_1ok(JNIEnv *env, jclass clz, int64_t o) {
	LDKInit o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = (o & 1) || (o == 0);
	o_conv = Init_clone(&o_conv);
	LDKCResult_InitDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_InitDecodeErrorZ), "LDKCResult_InitDecodeErrorZ");
	*ret_conv = CResult_InitDecodeErrorZ_ok(o_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1InitDecodeErrorZ_1err(JNIEnv *env, jclass clz, int64_t e) {
	LDKDecodeError e_conv;
	e_conv.inner = (void*)(e & (~1));
	e_conv.is_owned = (e & 1) || (e == 0);
	e_conv = DecodeError_clone(&e_conv);
	LDKCResult_InitDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_InitDecodeErrorZ), "LDKCResult_InitDecodeErrorZ");
	*ret_conv = CResult_InitDecodeErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1InitDecodeErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_InitDecodeErrorZ _res_conv = *(LDKCResult_InitDecodeErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_InitDecodeErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1InitDecodeErrorZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_InitDecodeErrorZ* orig_conv = (LDKCResult_InitDecodeErrorZ*)(orig & ~1);
	LDKCResult_InitDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_InitDecodeErrorZ), "LDKCResult_InitDecodeErrorZ");
	*ret_conv = CResult_InitDecodeErrorZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1OpenChannelDecodeErrorZ_1ok(JNIEnv *env, jclass clz, int64_t o) {
	LDKOpenChannel o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = (o & 1) || (o == 0);
	o_conv = OpenChannel_clone(&o_conv);
	LDKCResult_OpenChannelDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_OpenChannelDecodeErrorZ), "LDKCResult_OpenChannelDecodeErrorZ");
	*ret_conv = CResult_OpenChannelDecodeErrorZ_ok(o_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1OpenChannelDecodeErrorZ_1err(JNIEnv *env, jclass clz, int64_t e) {
	LDKDecodeError e_conv;
	e_conv.inner = (void*)(e & (~1));
	e_conv.is_owned = (e & 1) || (e == 0);
	e_conv = DecodeError_clone(&e_conv);
	LDKCResult_OpenChannelDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_OpenChannelDecodeErrorZ), "LDKCResult_OpenChannelDecodeErrorZ");
	*ret_conv = CResult_OpenChannelDecodeErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1OpenChannelDecodeErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_OpenChannelDecodeErrorZ _res_conv = *(LDKCResult_OpenChannelDecodeErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_OpenChannelDecodeErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1OpenChannelDecodeErrorZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_OpenChannelDecodeErrorZ* orig_conv = (LDKCResult_OpenChannelDecodeErrorZ*)(orig & ~1);
	LDKCResult_OpenChannelDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_OpenChannelDecodeErrorZ), "LDKCResult_OpenChannelDecodeErrorZ");
	*ret_conv = CResult_OpenChannelDecodeErrorZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1RevokeAndACKDecodeErrorZ_1ok(JNIEnv *env, jclass clz, int64_t o) {
	LDKRevokeAndACK o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = (o & 1) || (o == 0);
	o_conv = RevokeAndACK_clone(&o_conv);
	LDKCResult_RevokeAndACKDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_RevokeAndACKDecodeErrorZ), "LDKCResult_RevokeAndACKDecodeErrorZ");
	*ret_conv = CResult_RevokeAndACKDecodeErrorZ_ok(o_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1RevokeAndACKDecodeErrorZ_1err(JNIEnv *env, jclass clz, int64_t e) {
	LDKDecodeError e_conv;
	e_conv.inner = (void*)(e & (~1));
	e_conv.is_owned = (e & 1) || (e == 0);
	e_conv = DecodeError_clone(&e_conv);
	LDKCResult_RevokeAndACKDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_RevokeAndACKDecodeErrorZ), "LDKCResult_RevokeAndACKDecodeErrorZ");
	*ret_conv = CResult_RevokeAndACKDecodeErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1RevokeAndACKDecodeErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_RevokeAndACKDecodeErrorZ _res_conv = *(LDKCResult_RevokeAndACKDecodeErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_RevokeAndACKDecodeErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1RevokeAndACKDecodeErrorZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_RevokeAndACKDecodeErrorZ* orig_conv = (LDKCResult_RevokeAndACKDecodeErrorZ*)(orig & ~1);
	LDKCResult_RevokeAndACKDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_RevokeAndACKDecodeErrorZ), "LDKCResult_RevokeAndACKDecodeErrorZ");
	*ret_conv = CResult_RevokeAndACKDecodeErrorZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1ShutdownDecodeErrorZ_1ok(JNIEnv *env, jclass clz, int64_t o) {
	LDKShutdown o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = (o & 1) || (o == 0);
	o_conv = Shutdown_clone(&o_conv);
	LDKCResult_ShutdownDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_ShutdownDecodeErrorZ), "LDKCResult_ShutdownDecodeErrorZ");
	*ret_conv = CResult_ShutdownDecodeErrorZ_ok(o_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1ShutdownDecodeErrorZ_1err(JNIEnv *env, jclass clz, int64_t e) {
	LDKDecodeError e_conv;
	e_conv.inner = (void*)(e & (~1));
	e_conv.is_owned = (e & 1) || (e == 0);
	e_conv = DecodeError_clone(&e_conv);
	LDKCResult_ShutdownDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_ShutdownDecodeErrorZ), "LDKCResult_ShutdownDecodeErrorZ");
	*ret_conv = CResult_ShutdownDecodeErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1ShutdownDecodeErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_ShutdownDecodeErrorZ _res_conv = *(LDKCResult_ShutdownDecodeErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_ShutdownDecodeErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1ShutdownDecodeErrorZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_ShutdownDecodeErrorZ* orig_conv = (LDKCResult_ShutdownDecodeErrorZ*)(orig & ~1);
	LDKCResult_ShutdownDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_ShutdownDecodeErrorZ), "LDKCResult_ShutdownDecodeErrorZ");
	*ret_conv = CResult_ShutdownDecodeErrorZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1UpdateFailHTLCDecodeErrorZ_1ok(JNIEnv *env, jclass clz, int64_t o) {
	LDKUpdateFailHTLC o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = (o & 1) || (o == 0);
	o_conv = UpdateFailHTLC_clone(&o_conv);
	LDKCResult_UpdateFailHTLCDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_UpdateFailHTLCDecodeErrorZ), "LDKCResult_UpdateFailHTLCDecodeErrorZ");
	*ret_conv = CResult_UpdateFailHTLCDecodeErrorZ_ok(o_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1UpdateFailHTLCDecodeErrorZ_1err(JNIEnv *env, jclass clz, int64_t e) {
	LDKDecodeError e_conv;
	e_conv.inner = (void*)(e & (~1));
	e_conv.is_owned = (e & 1) || (e == 0);
	e_conv = DecodeError_clone(&e_conv);
	LDKCResult_UpdateFailHTLCDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_UpdateFailHTLCDecodeErrorZ), "LDKCResult_UpdateFailHTLCDecodeErrorZ");
	*ret_conv = CResult_UpdateFailHTLCDecodeErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1UpdateFailHTLCDecodeErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_UpdateFailHTLCDecodeErrorZ _res_conv = *(LDKCResult_UpdateFailHTLCDecodeErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_UpdateFailHTLCDecodeErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1UpdateFailHTLCDecodeErrorZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_UpdateFailHTLCDecodeErrorZ* orig_conv = (LDKCResult_UpdateFailHTLCDecodeErrorZ*)(orig & ~1);
	LDKCResult_UpdateFailHTLCDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_UpdateFailHTLCDecodeErrorZ), "LDKCResult_UpdateFailHTLCDecodeErrorZ");
	*ret_conv = CResult_UpdateFailHTLCDecodeErrorZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1UpdateFailMalformedHTLCDecodeErrorZ_1ok(JNIEnv *env, jclass clz, int64_t o) {
	LDKUpdateFailMalformedHTLC o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = (o & 1) || (o == 0);
	o_conv = UpdateFailMalformedHTLC_clone(&o_conv);
	LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ), "LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ");
	*ret_conv = CResult_UpdateFailMalformedHTLCDecodeErrorZ_ok(o_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1UpdateFailMalformedHTLCDecodeErrorZ_1err(JNIEnv *env, jclass clz, int64_t e) {
	LDKDecodeError e_conv;
	e_conv.inner = (void*)(e & (~1));
	e_conv.is_owned = (e & 1) || (e == 0);
	e_conv = DecodeError_clone(&e_conv);
	LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ), "LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ");
	*ret_conv = CResult_UpdateFailMalformedHTLCDecodeErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1UpdateFailMalformedHTLCDecodeErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ _res_conv = *(LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_UpdateFailMalformedHTLCDecodeErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1UpdateFailMalformedHTLCDecodeErrorZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ* orig_conv = (LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ*)(orig & ~1);
	LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ), "LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ");
	*ret_conv = CResult_UpdateFailMalformedHTLCDecodeErrorZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1UpdateFeeDecodeErrorZ_1ok(JNIEnv *env, jclass clz, int64_t o) {
	LDKUpdateFee o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = (o & 1) || (o == 0);
	o_conv = UpdateFee_clone(&o_conv);
	LDKCResult_UpdateFeeDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_UpdateFeeDecodeErrorZ), "LDKCResult_UpdateFeeDecodeErrorZ");
	*ret_conv = CResult_UpdateFeeDecodeErrorZ_ok(o_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1UpdateFeeDecodeErrorZ_1err(JNIEnv *env, jclass clz, int64_t e) {
	LDKDecodeError e_conv;
	e_conv.inner = (void*)(e & (~1));
	e_conv.is_owned = (e & 1) || (e == 0);
	e_conv = DecodeError_clone(&e_conv);
	LDKCResult_UpdateFeeDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_UpdateFeeDecodeErrorZ), "LDKCResult_UpdateFeeDecodeErrorZ");
	*ret_conv = CResult_UpdateFeeDecodeErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1UpdateFeeDecodeErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_UpdateFeeDecodeErrorZ _res_conv = *(LDKCResult_UpdateFeeDecodeErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_UpdateFeeDecodeErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1UpdateFeeDecodeErrorZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_UpdateFeeDecodeErrorZ* orig_conv = (LDKCResult_UpdateFeeDecodeErrorZ*)(orig & ~1);
	LDKCResult_UpdateFeeDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_UpdateFeeDecodeErrorZ), "LDKCResult_UpdateFeeDecodeErrorZ");
	*ret_conv = CResult_UpdateFeeDecodeErrorZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1UpdateFulfillHTLCDecodeErrorZ_1ok(JNIEnv *env, jclass clz, int64_t o) {
	LDKUpdateFulfillHTLC o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = (o & 1) || (o == 0);
	o_conv = UpdateFulfillHTLC_clone(&o_conv);
	LDKCResult_UpdateFulfillHTLCDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_UpdateFulfillHTLCDecodeErrorZ), "LDKCResult_UpdateFulfillHTLCDecodeErrorZ");
	*ret_conv = CResult_UpdateFulfillHTLCDecodeErrorZ_ok(o_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1UpdateFulfillHTLCDecodeErrorZ_1err(JNIEnv *env, jclass clz, int64_t e) {
	LDKDecodeError e_conv;
	e_conv.inner = (void*)(e & (~1));
	e_conv.is_owned = (e & 1) || (e == 0);
	e_conv = DecodeError_clone(&e_conv);
	LDKCResult_UpdateFulfillHTLCDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_UpdateFulfillHTLCDecodeErrorZ), "LDKCResult_UpdateFulfillHTLCDecodeErrorZ");
	*ret_conv = CResult_UpdateFulfillHTLCDecodeErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1UpdateFulfillHTLCDecodeErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_UpdateFulfillHTLCDecodeErrorZ _res_conv = *(LDKCResult_UpdateFulfillHTLCDecodeErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_UpdateFulfillHTLCDecodeErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1UpdateFulfillHTLCDecodeErrorZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_UpdateFulfillHTLCDecodeErrorZ* orig_conv = (LDKCResult_UpdateFulfillHTLCDecodeErrorZ*)(orig & ~1);
	LDKCResult_UpdateFulfillHTLCDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_UpdateFulfillHTLCDecodeErrorZ), "LDKCResult_UpdateFulfillHTLCDecodeErrorZ");
	*ret_conv = CResult_UpdateFulfillHTLCDecodeErrorZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1UpdateAddHTLCDecodeErrorZ_1ok(JNIEnv *env, jclass clz, int64_t o) {
	LDKUpdateAddHTLC o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = (o & 1) || (o == 0);
	o_conv = UpdateAddHTLC_clone(&o_conv);
	LDKCResult_UpdateAddHTLCDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_UpdateAddHTLCDecodeErrorZ), "LDKCResult_UpdateAddHTLCDecodeErrorZ");
	*ret_conv = CResult_UpdateAddHTLCDecodeErrorZ_ok(o_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1UpdateAddHTLCDecodeErrorZ_1err(JNIEnv *env, jclass clz, int64_t e) {
	LDKDecodeError e_conv;
	e_conv.inner = (void*)(e & (~1));
	e_conv.is_owned = (e & 1) || (e == 0);
	e_conv = DecodeError_clone(&e_conv);
	LDKCResult_UpdateAddHTLCDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_UpdateAddHTLCDecodeErrorZ), "LDKCResult_UpdateAddHTLCDecodeErrorZ");
	*ret_conv = CResult_UpdateAddHTLCDecodeErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1UpdateAddHTLCDecodeErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_UpdateAddHTLCDecodeErrorZ _res_conv = *(LDKCResult_UpdateAddHTLCDecodeErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_UpdateAddHTLCDecodeErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1UpdateAddHTLCDecodeErrorZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_UpdateAddHTLCDecodeErrorZ* orig_conv = (LDKCResult_UpdateAddHTLCDecodeErrorZ*)(orig & ~1);
	LDKCResult_UpdateAddHTLCDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_UpdateAddHTLCDecodeErrorZ), "LDKCResult_UpdateAddHTLCDecodeErrorZ");
	*ret_conv = CResult_UpdateAddHTLCDecodeErrorZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1PingDecodeErrorZ_1ok(JNIEnv *env, jclass clz, int64_t o) {
	LDKPing o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = (o & 1) || (o == 0);
	o_conv = Ping_clone(&o_conv);
	LDKCResult_PingDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_PingDecodeErrorZ), "LDKCResult_PingDecodeErrorZ");
	*ret_conv = CResult_PingDecodeErrorZ_ok(o_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1PingDecodeErrorZ_1err(JNIEnv *env, jclass clz, int64_t e) {
	LDKDecodeError e_conv;
	e_conv.inner = (void*)(e & (~1));
	e_conv.is_owned = (e & 1) || (e == 0);
	e_conv = DecodeError_clone(&e_conv);
	LDKCResult_PingDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_PingDecodeErrorZ), "LDKCResult_PingDecodeErrorZ");
	*ret_conv = CResult_PingDecodeErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1PingDecodeErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_PingDecodeErrorZ _res_conv = *(LDKCResult_PingDecodeErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_PingDecodeErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1PingDecodeErrorZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_PingDecodeErrorZ* orig_conv = (LDKCResult_PingDecodeErrorZ*)(orig & ~1);
	LDKCResult_PingDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_PingDecodeErrorZ), "LDKCResult_PingDecodeErrorZ");
	*ret_conv = CResult_PingDecodeErrorZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1PongDecodeErrorZ_1ok(JNIEnv *env, jclass clz, int64_t o) {
	LDKPong o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = (o & 1) || (o == 0);
	o_conv = Pong_clone(&o_conv);
	LDKCResult_PongDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_PongDecodeErrorZ), "LDKCResult_PongDecodeErrorZ");
	*ret_conv = CResult_PongDecodeErrorZ_ok(o_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1PongDecodeErrorZ_1err(JNIEnv *env, jclass clz, int64_t e) {
	LDKDecodeError e_conv;
	e_conv.inner = (void*)(e & (~1));
	e_conv.is_owned = (e & 1) || (e == 0);
	e_conv = DecodeError_clone(&e_conv);
	LDKCResult_PongDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_PongDecodeErrorZ), "LDKCResult_PongDecodeErrorZ");
	*ret_conv = CResult_PongDecodeErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1PongDecodeErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_PongDecodeErrorZ _res_conv = *(LDKCResult_PongDecodeErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_PongDecodeErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1PongDecodeErrorZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_PongDecodeErrorZ* orig_conv = (LDKCResult_PongDecodeErrorZ*)(orig & ~1);
	LDKCResult_PongDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_PongDecodeErrorZ), "LDKCResult_PongDecodeErrorZ");
	*ret_conv = CResult_PongDecodeErrorZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1UnsignedChannelAnnouncementDecodeErrorZ_1ok(JNIEnv *env, jclass clz, int64_t o) {
	LDKUnsignedChannelAnnouncement o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = (o & 1) || (o == 0);
	o_conv = UnsignedChannelAnnouncement_clone(&o_conv);
	LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ), "LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ");
	*ret_conv = CResult_UnsignedChannelAnnouncementDecodeErrorZ_ok(o_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1UnsignedChannelAnnouncementDecodeErrorZ_1err(JNIEnv *env, jclass clz, int64_t e) {
	LDKDecodeError e_conv;
	e_conv.inner = (void*)(e & (~1));
	e_conv.is_owned = (e & 1) || (e == 0);
	e_conv = DecodeError_clone(&e_conv);
	LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ), "LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ");
	*ret_conv = CResult_UnsignedChannelAnnouncementDecodeErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1UnsignedChannelAnnouncementDecodeErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ _res_conv = *(LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_UnsignedChannelAnnouncementDecodeErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1UnsignedChannelAnnouncementDecodeErrorZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ* orig_conv = (LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ*)(orig & ~1);
	LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ), "LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ");
	*ret_conv = CResult_UnsignedChannelAnnouncementDecodeErrorZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1ChannelAnnouncementDecodeErrorZ_1ok(JNIEnv *env, jclass clz, int64_t o) {
	LDKChannelAnnouncement o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = (o & 1) || (o == 0);
	o_conv = ChannelAnnouncement_clone(&o_conv);
	LDKCResult_ChannelAnnouncementDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_ChannelAnnouncementDecodeErrorZ), "LDKCResult_ChannelAnnouncementDecodeErrorZ");
	*ret_conv = CResult_ChannelAnnouncementDecodeErrorZ_ok(o_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1ChannelAnnouncementDecodeErrorZ_1err(JNIEnv *env, jclass clz, int64_t e) {
	LDKDecodeError e_conv;
	e_conv.inner = (void*)(e & (~1));
	e_conv.is_owned = (e & 1) || (e == 0);
	e_conv = DecodeError_clone(&e_conv);
	LDKCResult_ChannelAnnouncementDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_ChannelAnnouncementDecodeErrorZ), "LDKCResult_ChannelAnnouncementDecodeErrorZ");
	*ret_conv = CResult_ChannelAnnouncementDecodeErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1ChannelAnnouncementDecodeErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_ChannelAnnouncementDecodeErrorZ _res_conv = *(LDKCResult_ChannelAnnouncementDecodeErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_ChannelAnnouncementDecodeErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1ChannelAnnouncementDecodeErrorZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_ChannelAnnouncementDecodeErrorZ* orig_conv = (LDKCResult_ChannelAnnouncementDecodeErrorZ*)(orig & ~1);
	LDKCResult_ChannelAnnouncementDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_ChannelAnnouncementDecodeErrorZ), "LDKCResult_ChannelAnnouncementDecodeErrorZ");
	*ret_conv = CResult_ChannelAnnouncementDecodeErrorZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1UnsignedChannelUpdateDecodeErrorZ_1ok(JNIEnv *env, jclass clz, int64_t o) {
	LDKUnsignedChannelUpdate o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = (o & 1) || (o == 0);
	o_conv = UnsignedChannelUpdate_clone(&o_conv);
	LDKCResult_UnsignedChannelUpdateDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_UnsignedChannelUpdateDecodeErrorZ), "LDKCResult_UnsignedChannelUpdateDecodeErrorZ");
	*ret_conv = CResult_UnsignedChannelUpdateDecodeErrorZ_ok(o_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1UnsignedChannelUpdateDecodeErrorZ_1err(JNIEnv *env, jclass clz, int64_t e) {
	LDKDecodeError e_conv;
	e_conv.inner = (void*)(e & (~1));
	e_conv.is_owned = (e & 1) || (e == 0);
	e_conv = DecodeError_clone(&e_conv);
	LDKCResult_UnsignedChannelUpdateDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_UnsignedChannelUpdateDecodeErrorZ), "LDKCResult_UnsignedChannelUpdateDecodeErrorZ");
	*ret_conv = CResult_UnsignedChannelUpdateDecodeErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1UnsignedChannelUpdateDecodeErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_UnsignedChannelUpdateDecodeErrorZ _res_conv = *(LDKCResult_UnsignedChannelUpdateDecodeErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_UnsignedChannelUpdateDecodeErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1UnsignedChannelUpdateDecodeErrorZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_UnsignedChannelUpdateDecodeErrorZ* orig_conv = (LDKCResult_UnsignedChannelUpdateDecodeErrorZ*)(orig & ~1);
	LDKCResult_UnsignedChannelUpdateDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_UnsignedChannelUpdateDecodeErrorZ), "LDKCResult_UnsignedChannelUpdateDecodeErrorZ");
	*ret_conv = CResult_UnsignedChannelUpdateDecodeErrorZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1ChannelUpdateDecodeErrorZ_1ok(JNIEnv *env, jclass clz, int64_t o) {
	LDKChannelUpdate o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = (o & 1) || (o == 0);
	o_conv = ChannelUpdate_clone(&o_conv);
	LDKCResult_ChannelUpdateDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_ChannelUpdateDecodeErrorZ), "LDKCResult_ChannelUpdateDecodeErrorZ");
	*ret_conv = CResult_ChannelUpdateDecodeErrorZ_ok(o_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1ChannelUpdateDecodeErrorZ_1err(JNIEnv *env, jclass clz, int64_t e) {
	LDKDecodeError e_conv;
	e_conv.inner = (void*)(e & (~1));
	e_conv.is_owned = (e & 1) || (e == 0);
	e_conv = DecodeError_clone(&e_conv);
	LDKCResult_ChannelUpdateDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_ChannelUpdateDecodeErrorZ), "LDKCResult_ChannelUpdateDecodeErrorZ");
	*ret_conv = CResult_ChannelUpdateDecodeErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1ChannelUpdateDecodeErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_ChannelUpdateDecodeErrorZ _res_conv = *(LDKCResult_ChannelUpdateDecodeErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_ChannelUpdateDecodeErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1ChannelUpdateDecodeErrorZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_ChannelUpdateDecodeErrorZ* orig_conv = (LDKCResult_ChannelUpdateDecodeErrorZ*)(orig & ~1);
	LDKCResult_ChannelUpdateDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_ChannelUpdateDecodeErrorZ), "LDKCResult_ChannelUpdateDecodeErrorZ");
	*ret_conv = CResult_ChannelUpdateDecodeErrorZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1ErrorMessageDecodeErrorZ_1ok(JNIEnv *env, jclass clz, int64_t o) {
	LDKErrorMessage o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = (o & 1) || (o == 0);
	o_conv = ErrorMessage_clone(&o_conv);
	LDKCResult_ErrorMessageDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_ErrorMessageDecodeErrorZ), "LDKCResult_ErrorMessageDecodeErrorZ");
	*ret_conv = CResult_ErrorMessageDecodeErrorZ_ok(o_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1ErrorMessageDecodeErrorZ_1err(JNIEnv *env, jclass clz, int64_t e) {
	LDKDecodeError e_conv;
	e_conv.inner = (void*)(e & (~1));
	e_conv.is_owned = (e & 1) || (e == 0);
	e_conv = DecodeError_clone(&e_conv);
	LDKCResult_ErrorMessageDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_ErrorMessageDecodeErrorZ), "LDKCResult_ErrorMessageDecodeErrorZ");
	*ret_conv = CResult_ErrorMessageDecodeErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1ErrorMessageDecodeErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_ErrorMessageDecodeErrorZ _res_conv = *(LDKCResult_ErrorMessageDecodeErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_ErrorMessageDecodeErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1ErrorMessageDecodeErrorZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_ErrorMessageDecodeErrorZ* orig_conv = (LDKCResult_ErrorMessageDecodeErrorZ*)(orig & ~1);
	LDKCResult_ErrorMessageDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_ErrorMessageDecodeErrorZ), "LDKCResult_ErrorMessageDecodeErrorZ");
	*ret_conv = CResult_ErrorMessageDecodeErrorZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1UnsignedNodeAnnouncementDecodeErrorZ_1ok(JNIEnv *env, jclass clz, int64_t o) {
	LDKUnsignedNodeAnnouncement o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = (o & 1) || (o == 0);
	o_conv = UnsignedNodeAnnouncement_clone(&o_conv);
	LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ), "LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ");
	*ret_conv = CResult_UnsignedNodeAnnouncementDecodeErrorZ_ok(o_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1UnsignedNodeAnnouncementDecodeErrorZ_1err(JNIEnv *env, jclass clz, int64_t e) {
	LDKDecodeError e_conv;
	e_conv.inner = (void*)(e & (~1));
	e_conv.is_owned = (e & 1) || (e == 0);
	e_conv = DecodeError_clone(&e_conv);
	LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ), "LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ");
	*ret_conv = CResult_UnsignedNodeAnnouncementDecodeErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1UnsignedNodeAnnouncementDecodeErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ _res_conv = *(LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_UnsignedNodeAnnouncementDecodeErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1UnsignedNodeAnnouncementDecodeErrorZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ* orig_conv = (LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ*)(orig & ~1);
	LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ), "LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ");
	*ret_conv = CResult_UnsignedNodeAnnouncementDecodeErrorZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1NodeAnnouncementDecodeErrorZ_1ok(JNIEnv *env, jclass clz, int64_t o) {
	LDKNodeAnnouncement o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = (o & 1) || (o == 0);
	o_conv = NodeAnnouncement_clone(&o_conv);
	LDKCResult_NodeAnnouncementDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_NodeAnnouncementDecodeErrorZ), "LDKCResult_NodeAnnouncementDecodeErrorZ");
	*ret_conv = CResult_NodeAnnouncementDecodeErrorZ_ok(o_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1NodeAnnouncementDecodeErrorZ_1err(JNIEnv *env, jclass clz, int64_t e) {
	LDKDecodeError e_conv;
	e_conv.inner = (void*)(e & (~1));
	e_conv.is_owned = (e & 1) || (e == 0);
	e_conv = DecodeError_clone(&e_conv);
	LDKCResult_NodeAnnouncementDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_NodeAnnouncementDecodeErrorZ), "LDKCResult_NodeAnnouncementDecodeErrorZ");
	*ret_conv = CResult_NodeAnnouncementDecodeErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1NodeAnnouncementDecodeErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_NodeAnnouncementDecodeErrorZ _res_conv = *(LDKCResult_NodeAnnouncementDecodeErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_NodeAnnouncementDecodeErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1NodeAnnouncementDecodeErrorZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_NodeAnnouncementDecodeErrorZ* orig_conv = (LDKCResult_NodeAnnouncementDecodeErrorZ*)(orig & ~1);
	LDKCResult_NodeAnnouncementDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_NodeAnnouncementDecodeErrorZ), "LDKCResult_NodeAnnouncementDecodeErrorZ");
	*ret_conv = CResult_NodeAnnouncementDecodeErrorZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1QueryShortChannelIdsDecodeErrorZ_1ok(JNIEnv *env, jclass clz, int64_t o) {
	LDKQueryShortChannelIds o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = (o & 1) || (o == 0);
	o_conv = QueryShortChannelIds_clone(&o_conv);
	LDKCResult_QueryShortChannelIdsDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_QueryShortChannelIdsDecodeErrorZ), "LDKCResult_QueryShortChannelIdsDecodeErrorZ");
	*ret_conv = CResult_QueryShortChannelIdsDecodeErrorZ_ok(o_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1QueryShortChannelIdsDecodeErrorZ_1err(JNIEnv *env, jclass clz, int64_t e) {
	LDKDecodeError e_conv;
	e_conv.inner = (void*)(e & (~1));
	e_conv.is_owned = (e & 1) || (e == 0);
	e_conv = DecodeError_clone(&e_conv);
	LDKCResult_QueryShortChannelIdsDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_QueryShortChannelIdsDecodeErrorZ), "LDKCResult_QueryShortChannelIdsDecodeErrorZ");
	*ret_conv = CResult_QueryShortChannelIdsDecodeErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1QueryShortChannelIdsDecodeErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_QueryShortChannelIdsDecodeErrorZ _res_conv = *(LDKCResult_QueryShortChannelIdsDecodeErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_QueryShortChannelIdsDecodeErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1QueryShortChannelIdsDecodeErrorZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_QueryShortChannelIdsDecodeErrorZ* orig_conv = (LDKCResult_QueryShortChannelIdsDecodeErrorZ*)(orig & ~1);
	LDKCResult_QueryShortChannelIdsDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_QueryShortChannelIdsDecodeErrorZ), "LDKCResult_QueryShortChannelIdsDecodeErrorZ");
	*ret_conv = CResult_QueryShortChannelIdsDecodeErrorZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1ReplyShortChannelIdsEndDecodeErrorZ_1ok(JNIEnv *env, jclass clz, int64_t o) {
	LDKReplyShortChannelIdsEnd o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = (o & 1) || (o == 0);
	o_conv = ReplyShortChannelIdsEnd_clone(&o_conv);
	LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ), "LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ");
	*ret_conv = CResult_ReplyShortChannelIdsEndDecodeErrorZ_ok(o_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1ReplyShortChannelIdsEndDecodeErrorZ_1err(JNIEnv *env, jclass clz, int64_t e) {
	LDKDecodeError e_conv;
	e_conv.inner = (void*)(e & (~1));
	e_conv.is_owned = (e & 1) || (e == 0);
	e_conv = DecodeError_clone(&e_conv);
	LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ), "LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ");
	*ret_conv = CResult_ReplyShortChannelIdsEndDecodeErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1ReplyShortChannelIdsEndDecodeErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ _res_conv = *(LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_ReplyShortChannelIdsEndDecodeErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1ReplyShortChannelIdsEndDecodeErrorZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ* orig_conv = (LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ*)(orig & ~1);
	LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ), "LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ");
	*ret_conv = CResult_ReplyShortChannelIdsEndDecodeErrorZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1QueryChannelRangeDecodeErrorZ_1ok(JNIEnv *env, jclass clz, int64_t o) {
	LDKQueryChannelRange o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = (o & 1) || (o == 0);
	o_conv = QueryChannelRange_clone(&o_conv);
	LDKCResult_QueryChannelRangeDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_QueryChannelRangeDecodeErrorZ), "LDKCResult_QueryChannelRangeDecodeErrorZ");
	*ret_conv = CResult_QueryChannelRangeDecodeErrorZ_ok(o_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1QueryChannelRangeDecodeErrorZ_1err(JNIEnv *env, jclass clz, int64_t e) {
	LDKDecodeError e_conv;
	e_conv.inner = (void*)(e & (~1));
	e_conv.is_owned = (e & 1) || (e == 0);
	e_conv = DecodeError_clone(&e_conv);
	LDKCResult_QueryChannelRangeDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_QueryChannelRangeDecodeErrorZ), "LDKCResult_QueryChannelRangeDecodeErrorZ");
	*ret_conv = CResult_QueryChannelRangeDecodeErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1QueryChannelRangeDecodeErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_QueryChannelRangeDecodeErrorZ _res_conv = *(LDKCResult_QueryChannelRangeDecodeErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_QueryChannelRangeDecodeErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1QueryChannelRangeDecodeErrorZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_QueryChannelRangeDecodeErrorZ* orig_conv = (LDKCResult_QueryChannelRangeDecodeErrorZ*)(orig & ~1);
	LDKCResult_QueryChannelRangeDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_QueryChannelRangeDecodeErrorZ), "LDKCResult_QueryChannelRangeDecodeErrorZ");
	*ret_conv = CResult_QueryChannelRangeDecodeErrorZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1ReplyChannelRangeDecodeErrorZ_1ok(JNIEnv *env, jclass clz, int64_t o) {
	LDKReplyChannelRange o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = (o & 1) || (o == 0);
	o_conv = ReplyChannelRange_clone(&o_conv);
	LDKCResult_ReplyChannelRangeDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_ReplyChannelRangeDecodeErrorZ), "LDKCResult_ReplyChannelRangeDecodeErrorZ");
	*ret_conv = CResult_ReplyChannelRangeDecodeErrorZ_ok(o_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1ReplyChannelRangeDecodeErrorZ_1err(JNIEnv *env, jclass clz, int64_t e) {
	LDKDecodeError e_conv;
	e_conv.inner = (void*)(e & (~1));
	e_conv.is_owned = (e & 1) || (e == 0);
	e_conv = DecodeError_clone(&e_conv);
	LDKCResult_ReplyChannelRangeDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_ReplyChannelRangeDecodeErrorZ), "LDKCResult_ReplyChannelRangeDecodeErrorZ");
	*ret_conv = CResult_ReplyChannelRangeDecodeErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1ReplyChannelRangeDecodeErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_ReplyChannelRangeDecodeErrorZ _res_conv = *(LDKCResult_ReplyChannelRangeDecodeErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_ReplyChannelRangeDecodeErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1ReplyChannelRangeDecodeErrorZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_ReplyChannelRangeDecodeErrorZ* orig_conv = (LDKCResult_ReplyChannelRangeDecodeErrorZ*)(orig & ~1);
	LDKCResult_ReplyChannelRangeDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_ReplyChannelRangeDecodeErrorZ), "LDKCResult_ReplyChannelRangeDecodeErrorZ");
	*ret_conv = CResult_ReplyChannelRangeDecodeErrorZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1GossipTimestampFilterDecodeErrorZ_1ok(JNIEnv *env, jclass clz, int64_t o) {
	LDKGossipTimestampFilter o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = (o & 1) || (o == 0);
	o_conv = GossipTimestampFilter_clone(&o_conv);
	LDKCResult_GossipTimestampFilterDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_GossipTimestampFilterDecodeErrorZ), "LDKCResult_GossipTimestampFilterDecodeErrorZ");
	*ret_conv = CResult_GossipTimestampFilterDecodeErrorZ_ok(o_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1GossipTimestampFilterDecodeErrorZ_1err(JNIEnv *env, jclass clz, int64_t e) {
	LDKDecodeError e_conv;
	e_conv.inner = (void*)(e & (~1));
	e_conv.is_owned = (e & 1) || (e == 0);
	e_conv = DecodeError_clone(&e_conv);
	LDKCResult_GossipTimestampFilterDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_GossipTimestampFilterDecodeErrorZ), "LDKCResult_GossipTimestampFilterDecodeErrorZ");
	*ret_conv = CResult_GossipTimestampFilterDecodeErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1GossipTimestampFilterDecodeErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_GossipTimestampFilterDecodeErrorZ _res_conv = *(LDKCResult_GossipTimestampFilterDecodeErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_GossipTimestampFilterDecodeErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1GossipTimestampFilterDecodeErrorZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_GossipTimestampFilterDecodeErrorZ* orig_conv = (LDKCResult_GossipTimestampFilterDecodeErrorZ*)(orig & ~1);
	LDKCResult_GossipTimestampFilterDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_GossipTimestampFilterDecodeErrorZ), "LDKCResult_GossipTimestampFilterDecodeErrorZ");
	*ret_conv = CResult_GossipTimestampFilterDecodeErrorZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1InvoiceSignOrCreationErrorZ_1ok(JNIEnv *env, jclass clz, int64_t o) {
	LDKInvoice o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = (o & 1) || (o == 0);
	o_conv = Invoice_clone(&o_conv);
	LDKCResult_InvoiceSignOrCreationErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_InvoiceSignOrCreationErrorZ), "LDKCResult_InvoiceSignOrCreationErrorZ");
	*ret_conv = CResult_InvoiceSignOrCreationErrorZ_ok(o_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1InvoiceSignOrCreationErrorZ_1err(JNIEnv *env, jclass clz, int64_t e) {
	void* e_ptr = (void*)(((uint64_t)e) & ~1);
	CHECK_ACCESS(e_ptr);
	LDKSignOrCreationError e_conv = *(LDKSignOrCreationError*)(e_ptr);
	e_conv = SignOrCreationError_clone((LDKSignOrCreationError*)(((uint64_t)e) & ~1));
	LDKCResult_InvoiceSignOrCreationErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_InvoiceSignOrCreationErrorZ), "LDKCResult_InvoiceSignOrCreationErrorZ");
	*ret_conv = CResult_InvoiceSignOrCreationErrorZ_err(e_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1InvoiceSignOrCreationErrorZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_InvoiceSignOrCreationErrorZ _res_conv = *(LDKCResult_InvoiceSignOrCreationErrorZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_InvoiceSignOrCreationErrorZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1InvoiceSignOrCreationErrorZ_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCResult_InvoiceSignOrCreationErrorZ* orig_conv = (LDKCResult_InvoiceSignOrCreationErrorZ*)(orig & ~1);
	LDKCResult_InvoiceSignOrCreationErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_InvoiceSignOrCreationErrorZ), "LDKCResult_InvoiceSignOrCreationErrorZ");
	*ret_conv = CResult_InvoiceSignOrCreationErrorZ_clone(orig_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_COption_1FilterZ_1some(JNIEnv *env, jclass clz, int64_t o) {
	void* o_ptr = (void*)(((uint64_t)o) & ~1);
	CHECK_ACCESS(o_ptr);
	LDKFilter o_conv = *(LDKFilter*)(o_ptr);
	if (o_conv.free == LDKFilter_JCalls_free) {
		// If this_arg is a JCalls struct, then we need to increment the refcnt in it.
		LDKFilter_JCalls_cloned(&o_conv);
	}
	LDKCOption_FilterZ *ret_copy = MALLOC(sizeof(LDKCOption_FilterZ), "LDKCOption_FilterZ");
	*ret_copy = COption_FilterZ_some(o_conv);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_COption_1FilterZ_1none(JNIEnv *env, jclass clz) {
	LDKCOption_FilterZ *ret_copy = MALLOC(sizeof(LDKCOption_FilterZ), "LDKCOption_FilterZ");
	*ret_copy = COption_FilterZ_none();
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_COption_1FilterZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCOption_FilterZ _res_conv = *(LDKCOption_FilterZ*)(_res_ptr);
	FREE((void*)_res);
	COption_FilterZ_free(_res_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1LockedChannelMonitorNoneZ_1ok(JNIEnv *env, jclass clz, int64_t o) {
	LDKLockedChannelMonitor o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = (o & 1) || (o == 0);
	// Warning: we need a move here but no clone is available for LDKLockedChannelMonitor
	LDKCResult_LockedChannelMonitorNoneZ* ret_conv = MALLOC(sizeof(LDKCResult_LockedChannelMonitorNoneZ), "LDKCResult_LockedChannelMonitorNoneZ");
	*ret_conv = CResult_LockedChannelMonitorNoneZ_ok(o_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CResult_1LockedChannelMonitorNoneZ_1err(JNIEnv *env, jclass clz) {
	LDKCResult_LockedChannelMonitorNoneZ* ret_conv = MALLOC(sizeof(LDKCResult_LockedChannelMonitorNoneZ), "LDKCResult_LockedChannelMonitorNoneZ");
	*ret_conv = CResult_LockedChannelMonitorNoneZ_err();
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CResult_1LockedChannelMonitorNoneZ_1free(JNIEnv *env, jclass clz, int64_t _res) {
	if ((_res & 1) != 0) return;
	void* _res_ptr = (void*)(((uint64_t)_res) & ~1);
	CHECK_ACCESS(_res_ptr);
	LDKCResult_LockedChannelMonitorNoneZ _res_conv = *(LDKCResult_LockedChannelMonitorNoneZ*)(_res_ptr);
	FREE((void*)_res);
	CResult_LockedChannelMonitorNoneZ_free(_res_conv);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CVec_1OutPointZ_1free(JNIEnv *env, jclass clz, int64_tArray _res) {
	LDKCVec_OutPointZ _res_constr;
	_res_constr.datalen = (*env)->GetArrayLength(env, _res);
	if (_res_constr.datalen > 0)
		_res_constr.data = MALLOC(_res_constr.datalen * sizeof(LDKOutPoint), "LDKCVec_OutPointZ Elements");
	else
		_res_constr.data = NULL;
	int64_t* _res_vals = (*env)->GetLongArrayElements (env, _res, NULL);
	for (size_t k = 0; k < _res_constr.datalen; k++) {
		int64_t _res_conv_10 = _res_vals[k];
		LDKOutPoint _res_conv_10_conv;
		_res_conv_10_conv.inner = (void*)(_res_conv_10 & (~1));
		_res_conv_10_conv.is_owned = (_res_conv_10 & 1) || (_res_conv_10 == 0);
		_res_constr.data[k] = _res_conv_10_conv;
	}
	(*env)->ReleaseLongArrayElements(env, _res, _res_vals, 0);
	CVec_OutPointZ_free(_res_constr);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_PaymentPurpose_1free(JNIEnv *env, jclass clz, int64_t this_ptr) {
	if ((this_ptr & 1) != 0) return;
	void* this_ptr_ptr = (void*)(((uint64_t)this_ptr) & ~1);
	CHECK_ACCESS(this_ptr_ptr);
	LDKPaymentPurpose this_ptr_conv = *(LDKPaymentPurpose*)(this_ptr_ptr);
	FREE((void*)this_ptr);
	PaymentPurpose_free(this_ptr_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_PaymentPurpose_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKPaymentPurpose* orig_conv = (LDKPaymentPurpose*)orig;
	LDKPaymentPurpose *ret_copy = MALLOC(sizeof(LDKPaymentPurpose), "LDKPaymentPurpose");
	*ret_copy = PaymentPurpose_clone(orig_conv);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_PaymentPurpose_1invoice_1payment(JNIEnv *env, jclass clz, int8_tArray payment_preimage, int8_tArray payment_secret, int64_t user_payment_id) {
	LDKThirtyTwoBytes payment_preimage_ref;
	CHECK((*env)->GetArrayLength(env, payment_preimage) == 32);
	(*env)->GetByteArrayRegion(env, payment_preimage, 0, 32, payment_preimage_ref.data);
	LDKThirtyTwoBytes payment_secret_ref;
	CHECK((*env)->GetArrayLength(env, payment_secret) == 32);
	(*env)->GetByteArrayRegion(env, payment_secret, 0, 32, payment_secret_ref.data);
	LDKPaymentPurpose *ret_copy = MALLOC(sizeof(LDKPaymentPurpose), "LDKPaymentPurpose");
	*ret_copy = PaymentPurpose_invoice_payment(payment_preimage_ref, payment_secret_ref, user_payment_id);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_PaymentPurpose_1spontaneous_1payment(JNIEnv *env, jclass clz, int8_tArray a) {
	LDKThirtyTwoBytes a_ref;
	CHECK((*env)->GetArrayLength(env, a) == 32);
	(*env)->GetByteArrayRegion(env, a, 0, 32, a_ref.data);
	LDKPaymentPurpose *ret_copy = MALLOC(sizeof(LDKPaymentPurpose), "LDKPaymentPurpose");
	*ret_copy = PaymentPurpose_spontaneous_payment(a_ref);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ClosureReason_1free(JNIEnv *env, jclass clz, int64_t this_ptr) {
	if ((this_ptr & 1) != 0) return;
	void* this_ptr_ptr = (void*)(((uint64_t)this_ptr) & ~1);
	CHECK_ACCESS(this_ptr_ptr);
	LDKClosureReason this_ptr_conv = *(LDKClosureReason*)(this_ptr_ptr);
	FREE((void*)this_ptr);
	ClosureReason_free(this_ptr_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ClosureReason_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKClosureReason* orig_conv = (LDKClosureReason*)orig;
	LDKClosureReason *ret_copy = MALLOC(sizeof(LDKClosureReason), "LDKClosureReason");
	*ret_copy = ClosureReason_clone(orig_conv);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ClosureReason_1counterparty_1force_1closed(JNIEnv *env, jclass clz, jstring peer_msg) {
	LDKStr peer_msg_conv = java_to_owned_str(env, peer_msg);
	LDKClosureReason *ret_copy = MALLOC(sizeof(LDKClosureReason), "LDKClosureReason");
	*ret_copy = ClosureReason_counterparty_force_closed(peer_msg_conv);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ClosureReason_1holder_1force_1closed(JNIEnv *env, jclass clz) {
	LDKClosureReason *ret_copy = MALLOC(sizeof(LDKClosureReason), "LDKClosureReason");
	*ret_copy = ClosureReason_holder_force_closed();
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ClosureReason_1cooperative_1closure(JNIEnv *env, jclass clz) {
	LDKClosureReason *ret_copy = MALLOC(sizeof(LDKClosureReason), "LDKClosureReason");
	*ret_copy = ClosureReason_cooperative_closure();
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ClosureReason_1commitment_1tx_1confirmed(JNIEnv *env, jclass clz) {
	LDKClosureReason *ret_copy = MALLOC(sizeof(LDKClosureReason), "LDKClosureReason");
	*ret_copy = ClosureReason_commitment_tx_confirmed();
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ClosureReason_1processing_1error(JNIEnv *env, jclass clz, jstring err) {
	LDKStr err_conv = java_to_owned_str(env, err);
	LDKClosureReason *ret_copy = MALLOC(sizeof(LDKClosureReason), "LDKClosureReason");
	*ret_copy = ClosureReason_processing_error(err_conv);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ClosureReason_1disconnected_1peer(JNIEnv *env, jclass clz) {
	LDKClosureReason *ret_copy = MALLOC(sizeof(LDKClosureReason), "LDKClosureReason");
	*ret_copy = ClosureReason_disconnected_peer();
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ClosureReason_1outdated_1channel_1manager(JNIEnv *env, jclass clz) {
	LDKClosureReason *ret_copy = MALLOC(sizeof(LDKClosureReason), "LDKClosureReason");
	*ret_copy = ClosureReason_outdated_channel_manager();
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_ClosureReason_1write(JNIEnv *env, jclass clz, int64_t obj) {
	LDKClosureReason* obj_conv = (LDKClosureReason*)obj;
	LDKCVec_u8Z ret_var = ClosureReason_write(obj_conv);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	CVec_u8Z_free(ret_var);
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_Event_1free(JNIEnv *env, jclass clz, int64_t this_ptr) {
	if ((this_ptr & 1) != 0) return;
	void* this_ptr_ptr = (void*)(((uint64_t)this_ptr) & ~1);
	CHECK_ACCESS(this_ptr_ptr);
	LDKEvent this_ptr_conv = *(LDKEvent*)(this_ptr_ptr);
	FREE((void*)this_ptr);
	Event_free(this_ptr_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_Event_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKEvent* orig_conv = (LDKEvent*)orig;
	LDKEvent *ret_copy = MALLOC(sizeof(LDKEvent), "LDKEvent");
	*ret_copy = Event_clone(orig_conv);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_Event_1funding_1generation_1ready(JNIEnv *env, jclass clz, int8_tArray temporary_channel_id, int64_t channel_value_satoshis, int8_tArray output_script, int64_t user_channel_id) {
	LDKThirtyTwoBytes temporary_channel_id_ref;
	CHECK((*env)->GetArrayLength(env, temporary_channel_id) == 32);
	(*env)->GetByteArrayRegion(env, temporary_channel_id, 0, 32, temporary_channel_id_ref.data);
	LDKCVec_u8Z output_script_ref;
	output_script_ref.datalen = (*env)->GetArrayLength(env, output_script);
	output_script_ref.data = MALLOC(output_script_ref.datalen, "LDKCVec_u8Z Bytes");
	(*env)->GetByteArrayRegion(env, output_script, 0, output_script_ref.datalen, output_script_ref.data);
	LDKEvent *ret_copy = MALLOC(sizeof(LDKEvent), "LDKEvent");
	*ret_copy = Event_funding_generation_ready(temporary_channel_id_ref, channel_value_satoshis, output_script_ref, user_channel_id);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_Event_1payment_1received(JNIEnv *env, jclass clz, int8_tArray payment_hash, int64_t amt, int64_t purpose) {
	LDKThirtyTwoBytes payment_hash_ref;
	CHECK((*env)->GetArrayLength(env, payment_hash) == 32);
	(*env)->GetByteArrayRegion(env, payment_hash, 0, 32, payment_hash_ref.data);
	void* purpose_ptr = (void*)(((uint64_t)purpose) & ~1);
	CHECK_ACCESS(purpose_ptr);
	LDKPaymentPurpose purpose_conv = *(LDKPaymentPurpose*)(purpose_ptr);
	purpose_conv = PaymentPurpose_clone((LDKPaymentPurpose*)(((uint64_t)purpose) & ~1));
	LDKEvent *ret_copy = MALLOC(sizeof(LDKEvent), "LDKEvent");
	*ret_copy = Event_payment_received(payment_hash_ref, amt, purpose_conv);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_Event_1payment_1sent(JNIEnv *env, jclass clz, int8_tArray payment_id, int8_tArray payment_preimage, int8_tArray payment_hash, int64_t fee_paid_msat) {
	LDKThirtyTwoBytes payment_id_ref;
	CHECK((*env)->GetArrayLength(env, payment_id) == 32);
	(*env)->GetByteArrayRegion(env, payment_id, 0, 32, payment_id_ref.data);
	LDKThirtyTwoBytes payment_preimage_ref;
	CHECK((*env)->GetArrayLength(env, payment_preimage) == 32);
	(*env)->GetByteArrayRegion(env, payment_preimage, 0, 32, payment_preimage_ref.data);
	LDKThirtyTwoBytes payment_hash_ref;
	CHECK((*env)->GetArrayLength(env, payment_hash) == 32);
	(*env)->GetByteArrayRegion(env, payment_hash, 0, 32, payment_hash_ref.data);
	void* fee_paid_msat_ptr = (void*)(((uint64_t)fee_paid_msat) & ~1);
	CHECK_ACCESS(fee_paid_msat_ptr);
	LDKCOption_u64Z fee_paid_msat_conv = *(LDKCOption_u64Z*)(fee_paid_msat_ptr);
	fee_paid_msat_conv = COption_u64Z_clone((LDKCOption_u64Z*)(((uint64_t)fee_paid_msat) & ~1));
	LDKEvent *ret_copy = MALLOC(sizeof(LDKEvent), "LDKEvent");
	*ret_copy = Event_payment_sent(payment_id_ref, payment_preimage_ref, payment_hash_ref, fee_paid_msat_conv);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_Event_1payment_1path_1failed(JNIEnv *env, jclass clz, int8_tArray payment_id, int8_tArray payment_hash, jboolean rejected_by_dest, int64_t network_update, jboolean all_paths_failed, int64_tArray path, int64_t short_channel_id, int64_t retry) {
	LDKThirtyTwoBytes payment_id_ref;
	CHECK((*env)->GetArrayLength(env, payment_id) == 32);
	(*env)->GetByteArrayRegion(env, payment_id, 0, 32, payment_id_ref.data);
	LDKThirtyTwoBytes payment_hash_ref;
	CHECK((*env)->GetArrayLength(env, payment_hash) == 32);
	(*env)->GetByteArrayRegion(env, payment_hash, 0, 32, payment_hash_ref.data);
	void* network_update_ptr = (void*)(((uint64_t)network_update) & ~1);
	CHECK_ACCESS(network_update_ptr);
	LDKCOption_NetworkUpdateZ network_update_conv = *(LDKCOption_NetworkUpdateZ*)(network_update_ptr);
	network_update_conv = COption_NetworkUpdateZ_clone((LDKCOption_NetworkUpdateZ*)(((uint64_t)network_update) & ~1));
	LDKCVec_RouteHopZ path_constr;
	path_constr.datalen = (*env)->GetArrayLength(env, path);
	if (path_constr.datalen > 0)
		path_constr.data = MALLOC(path_constr.datalen * sizeof(LDKRouteHop), "LDKCVec_RouteHopZ Elements");
	else
		path_constr.data = NULL;
	int64_t* path_vals = (*env)->GetLongArrayElements (env, path, NULL);
	for (size_t k = 0; k < path_constr.datalen; k++) {
		int64_t path_conv_10 = path_vals[k];
		LDKRouteHop path_conv_10_conv;
		path_conv_10_conv.inner = (void*)(path_conv_10 & (~1));
		path_conv_10_conv.is_owned = (path_conv_10 & 1) || (path_conv_10 == 0);
		path_conv_10_conv = RouteHop_clone(&path_conv_10_conv);
		path_constr.data[k] = path_conv_10_conv;
	}
	(*env)->ReleaseLongArrayElements(env, path, path_vals, 0);
	void* short_channel_id_ptr = (void*)(((uint64_t)short_channel_id) & ~1);
	CHECK_ACCESS(short_channel_id_ptr);
	LDKCOption_u64Z short_channel_id_conv = *(LDKCOption_u64Z*)(short_channel_id_ptr);
	short_channel_id_conv = COption_u64Z_clone((LDKCOption_u64Z*)(((uint64_t)short_channel_id) & ~1));
	LDKRouteParameters retry_conv;
	retry_conv.inner = (void*)(retry & (~1));
	retry_conv.is_owned = (retry & 1) || (retry == 0);
	retry_conv = RouteParameters_clone(&retry_conv);
	LDKEvent *ret_copy = MALLOC(sizeof(LDKEvent), "LDKEvent");
	*ret_copy = Event_payment_path_failed(payment_id_ref, payment_hash_ref, rejected_by_dest, network_update_conv, all_paths_failed, path_constr, short_channel_id_conv, retry_conv);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_Event_1pending_1htlcs_1forwardable(JNIEnv *env, jclass clz, int64_t time_forwardable) {
	LDKEvent *ret_copy = MALLOC(sizeof(LDKEvent), "LDKEvent");
	*ret_copy = Event_pending_htlcs_forwardable(time_forwardable);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_Event_1spendable_1outputs(JNIEnv *env, jclass clz, int64_tArray outputs) {
	LDKCVec_SpendableOutputDescriptorZ outputs_constr;
	outputs_constr.datalen = (*env)->GetArrayLength(env, outputs);
	if (outputs_constr.datalen > 0)
		outputs_constr.data = MALLOC(outputs_constr.datalen * sizeof(LDKSpendableOutputDescriptor), "LDKCVec_SpendableOutputDescriptorZ Elements");
	else
		outputs_constr.data = NULL;
	int64_t* outputs_vals = (*env)->GetLongArrayElements (env, outputs, NULL);
	for (size_t b = 0; b < outputs_constr.datalen; b++) {
		int64_t outputs_conv_27 = outputs_vals[b];
		void* outputs_conv_27_ptr = (void*)(((uint64_t)outputs_conv_27) & ~1);
		CHECK_ACCESS(outputs_conv_27_ptr);
		LDKSpendableOutputDescriptor outputs_conv_27_conv = *(LDKSpendableOutputDescriptor*)(outputs_conv_27_ptr);
		outputs_conv_27_conv = SpendableOutputDescriptor_clone((LDKSpendableOutputDescriptor*)(((uint64_t)outputs_conv_27) & ~1));
		outputs_constr.data[b] = outputs_conv_27_conv;
	}
	(*env)->ReleaseLongArrayElements(env, outputs, outputs_vals, 0);
	LDKEvent *ret_copy = MALLOC(sizeof(LDKEvent), "LDKEvent");
	*ret_copy = Event_spendable_outputs(outputs_constr);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_Event_1payment_1forwarded(JNIEnv *env, jclass clz, int64_t fee_earned_msat, jboolean claim_from_onchain_tx) {
	void* fee_earned_msat_ptr = (void*)(((uint64_t)fee_earned_msat) & ~1);
	CHECK_ACCESS(fee_earned_msat_ptr);
	LDKCOption_u64Z fee_earned_msat_conv = *(LDKCOption_u64Z*)(fee_earned_msat_ptr);
	fee_earned_msat_conv = COption_u64Z_clone((LDKCOption_u64Z*)(((uint64_t)fee_earned_msat) & ~1));
	LDKEvent *ret_copy = MALLOC(sizeof(LDKEvent), "LDKEvent");
	*ret_copy = Event_payment_forwarded(fee_earned_msat_conv, claim_from_onchain_tx);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_Event_1channel_1closed(JNIEnv *env, jclass clz, int8_tArray channel_id, int64_t user_channel_id, int64_t reason) {
	LDKThirtyTwoBytes channel_id_ref;
	CHECK((*env)->GetArrayLength(env, channel_id) == 32);
	(*env)->GetByteArrayRegion(env, channel_id, 0, 32, channel_id_ref.data);
	void* reason_ptr = (void*)(((uint64_t)reason) & ~1);
	CHECK_ACCESS(reason_ptr);
	LDKClosureReason reason_conv = *(LDKClosureReason*)(reason_ptr);
	reason_conv = ClosureReason_clone((LDKClosureReason*)(((uint64_t)reason) & ~1));
	LDKEvent *ret_copy = MALLOC(sizeof(LDKEvent), "LDKEvent");
	*ret_copy = Event_channel_closed(channel_id_ref, user_channel_id, reason_conv);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_Event_1discard_1funding(JNIEnv *env, jclass clz, int8_tArray channel_id, int8_tArray transaction) {
	LDKThirtyTwoBytes channel_id_ref;
	CHECK((*env)->GetArrayLength(env, channel_id) == 32);
	(*env)->GetByteArrayRegion(env, channel_id, 0, 32, channel_id_ref.data);
	LDKTransaction transaction_ref;
	transaction_ref.datalen = (*env)->GetArrayLength(env, transaction);
	transaction_ref.data = MALLOC(transaction_ref.datalen, "LDKTransaction Bytes");
	(*env)->GetByteArrayRegion(env, transaction, 0, transaction_ref.datalen, transaction_ref.data);
	transaction_ref.data_is_owned = true;
	LDKEvent *ret_copy = MALLOC(sizeof(LDKEvent), "LDKEvent");
	*ret_copy = Event_discard_funding(channel_id_ref, transaction_ref);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_Event_1write(JNIEnv *env, jclass clz, int64_t obj) {
	LDKEvent* obj_conv = (LDKEvent*)obj;
	LDKCVec_u8Z ret_var = Event_write(obj_conv);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	CVec_u8Z_free(ret_var);
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_MessageSendEvent_1free(JNIEnv *env, jclass clz, int64_t this_ptr) {
	if ((this_ptr & 1) != 0) return;
	void* this_ptr_ptr = (void*)(((uint64_t)this_ptr) & ~1);
	CHECK_ACCESS(this_ptr_ptr);
	LDKMessageSendEvent this_ptr_conv = *(LDKMessageSendEvent*)(this_ptr_ptr);
	FREE((void*)this_ptr);
	MessageSendEvent_free(this_ptr_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_MessageSendEvent_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKMessageSendEvent* orig_conv = (LDKMessageSendEvent*)orig;
	LDKMessageSendEvent *ret_copy = MALLOC(sizeof(LDKMessageSendEvent), "LDKMessageSendEvent");
	*ret_copy = MessageSendEvent_clone(orig_conv);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_MessageSendEvent_1send_1accept_1channel(JNIEnv *env, jclass clz, int8_tArray node_id, int64_t msg) {
	LDKPublicKey node_id_ref;
	CHECK((*env)->GetArrayLength(env, node_id) == 33);
	(*env)->GetByteArrayRegion(env, node_id, 0, 33, node_id_ref.compressed_form);
	LDKAcceptChannel msg_conv;
	msg_conv.inner = (void*)(msg & (~1));
	msg_conv.is_owned = (msg & 1) || (msg == 0);
	msg_conv = AcceptChannel_clone(&msg_conv);
	LDKMessageSendEvent *ret_copy = MALLOC(sizeof(LDKMessageSendEvent), "LDKMessageSendEvent");
	*ret_copy = MessageSendEvent_send_accept_channel(node_id_ref, msg_conv);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_MessageSendEvent_1send_1open_1channel(JNIEnv *env, jclass clz, int8_tArray node_id, int64_t msg) {
	LDKPublicKey node_id_ref;
	CHECK((*env)->GetArrayLength(env, node_id) == 33);
	(*env)->GetByteArrayRegion(env, node_id, 0, 33, node_id_ref.compressed_form);
	LDKOpenChannel msg_conv;
	msg_conv.inner = (void*)(msg & (~1));
	msg_conv.is_owned = (msg & 1) || (msg == 0);
	msg_conv = OpenChannel_clone(&msg_conv);
	LDKMessageSendEvent *ret_copy = MALLOC(sizeof(LDKMessageSendEvent), "LDKMessageSendEvent");
	*ret_copy = MessageSendEvent_send_open_channel(node_id_ref, msg_conv);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_MessageSendEvent_1send_1funding_1created(JNIEnv *env, jclass clz, int8_tArray node_id, int64_t msg) {
	LDKPublicKey node_id_ref;
	CHECK((*env)->GetArrayLength(env, node_id) == 33);
	(*env)->GetByteArrayRegion(env, node_id, 0, 33, node_id_ref.compressed_form);
	LDKFundingCreated msg_conv;
	msg_conv.inner = (void*)(msg & (~1));
	msg_conv.is_owned = (msg & 1) || (msg == 0);
	msg_conv = FundingCreated_clone(&msg_conv);
	LDKMessageSendEvent *ret_copy = MALLOC(sizeof(LDKMessageSendEvent), "LDKMessageSendEvent");
	*ret_copy = MessageSendEvent_send_funding_created(node_id_ref, msg_conv);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_MessageSendEvent_1send_1funding_1signed(JNIEnv *env, jclass clz, int8_tArray node_id, int64_t msg) {
	LDKPublicKey node_id_ref;
	CHECK((*env)->GetArrayLength(env, node_id) == 33);
	(*env)->GetByteArrayRegion(env, node_id, 0, 33, node_id_ref.compressed_form);
	LDKFundingSigned msg_conv;
	msg_conv.inner = (void*)(msg & (~1));
	msg_conv.is_owned = (msg & 1) || (msg == 0);
	msg_conv = FundingSigned_clone(&msg_conv);
	LDKMessageSendEvent *ret_copy = MALLOC(sizeof(LDKMessageSendEvent), "LDKMessageSendEvent");
	*ret_copy = MessageSendEvent_send_funding_signed(node_id_ref, msg_conv);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_MessageSendEvent_1send_1funding_1locked(JNIEnv *env, jclass clz, int8_tArray node_id, int64_t msg) {
	LDKPublicKey node_id_ref;
	CHECK((*env)->GetArrayLength(env, node_id) == 33);
	(*env)->GetByteArrayRegion(env, node_id, 0, 33, node_id_ref.compressed_form);
	LDKFundingLocked msg_conv;
	msg_conv.inner = (void*)(msg & (~1));
	msg_conv.is_owned = (msg & 1) || (msg == 0);
	msg_conv = FundingLocked_clone(&msg_conv);
	LDKMessageSendEvent *ret_copy = MALLOC(sizeof(LDKMessageSendEvent), "LDKMessageSendEvent");
	*ret_copy = MessageSendEvent_send_funding_locked(node_id_ref, msg_conv);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_MessageSendEvent_1send_1announcement_1signatures(JNIEnv *env, jclass clz, int8_tArray node_id, int64_t msg) {
	LDKPublicKey node_id_ref;
	CHECK((*env)->GetArrayLength(env, node_id) == 33);
	(*env)->GetByteArrayRegion(env, node_id, 0, 33, node_id_ref.compressed_form);
	LDKAnnouncementSignatures msg_conv;
	msg_conv.inner = (void*)(msg & (~1));
	msg_conv.is_owned = (msg & 1) || (msg == 0);
	msg_conv = AnnouncementSignatures_clone(&msg_conv);
	LDKMessageSendEvent *ret_copy = MALLOC(sizeof(LDKMessageSendEvent), "LDKMessageSendEvent");
	*ret_copy = MessageSendEvent_send_announcement_signatures(node_id_ref, msg_conv);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_MessageSendEvent_1update_1htlcs(JNIEnv *env, jclass clz, int8_tArray node_id, int64_t updates) {
	LDKPublicKey node_id_ref;
	CHECK((*env)->GetArrayLength(env, node_id) == 33);
	(*env)->GetByteArrayRegion(env, node_id, 0, 33, node_id_ref.compressed_form);
	LDKCommitmentUpdate updates_conv;
	updates_conv.inner = (void*)(updates & (~1));
	updates_conv.is_owned = (updates & 1) || (updates == 0);
	updates_conv = CommitmentUpdate_clone(&updates_conv);
	LDKMessageSendEvent *ret_copy = MALLOC(sizeof(LDKMessageSendEvent), "LDKMessageSendEvent");
	*ret_copy = MessageSendEvent_update_htlcs(node_id_ref, updates_conv);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_MessageSendEvent_1send_1revoke_1and_1ack(JNIEnv *env, jclass clz, int8_tArray node_id, int64_t msg) {
	LDKPublicKey node_id_ref;
	CHECK((*env)->GetArrayLength(env, node_id) == 33);
	(*env)->GetByteArrayRegion(env, node_id, 0, 33, node_id_ref.compressed_form);
	LDKRevokeAndACK msg_conv;
	msg_conv.inner = (void*)(msg & (~1));
	msg_conv.is_owned = (msg & 1) || (msg == 0);
	msg_conv = RevokeAndACK_clone(&msg_conv);
	LDKMessageSendEvent *ret_copy = MALLOC(sizeof(LDKMessageSendEvent), "LDKMessageSendEvent");
	*ret_copy = MessageSendEvent_send_revoke_and_ack(node_id_ref, msg_conv);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_MessageSendEvent_1send_1closing_1signed(JNIEnv *env, jclass clz, int8_tArray node_id, int64_t msg) {
	LDKPublicKey node_id_ref;
	CHECK((*env)->GetArrayLength(env, node_id) == 33);
	(*env)->GetByteArrayRegion(env, node_id, 0, 33, node_id_ref.compressed_form);
	LDKClosingSigned msg_conv;
	msg_conv.inner = (void*)(msg & (~1));
	msg_conv.is_owned = (msg & 1) || (msg == 0);
	msg_conv = ClosingSigned_clone(&msg_conv);
	LDKMessageSendEvent *ret_copy = MALLOC(sizeof(LDKMessageSendEvent), "LDKMessageSendEvent");
	*ret_copy = MessageSendEvent_send_closing_signed(node_id_ref, msg_conv);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_MessageSendEvent_1send_1shutdown(JNIEnv *env, jclass clz, int8_tArray node_id, int64_t msg) {
	LDKPublicKey node_id_ref;
	CHECK((*env)->GetArrayLength(env, node_id) == 33);
	(*env)->GetByteArrayRegion(env, node_id, 0, 33, node_id_ref.compressed_form);
	LDKShutdown msg_conv;
	msg_conv.inner = (void*)(msg & (~1));
	msg_conv.is_owned = (msg & 1) || (msg == 0);
	msg_conv = Shutdown_clone(&msg_conv);
	LDKMessageSendEvent *ret_copy = MALLOC(sizeof(LDKMessageSendEvent), "LDKMessageSendEvent");
	*ret_copy = MessageSendEvent_send_shutdown(node_id_ref, msg_conv);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_MessageSendEvent_1send_1channel_1reestablish(JNIEnv *env, jclass clz, int8_tArray node_id, int64_t msg) {
	LDKPublicKey node_id_ref;
	CHECK((*env)->GetArrayLength(env, node_id) == 33);
	(*env)->GetByteArrayRegion(env, node_id, 0, 33, node_id_ref.compressed_form);
	LDKChannelReestablish msg_conv;
	msg_conv.inner = (void*)(msg & (~1));
	msg_conv.is_owned = (msg & 1) || (msg == 0);
	msg_conv = ChannelReestablish_clone(&msg_conv);
	LDKMessageSendEvent *ret_copy = MALLOC(sizeof(LDKMessageSendEvent), "LDKMessageSendEvent");
	*ret_copy = MessageSendEvent_send_channel_reestablish(node_id_ref, msg_conv);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_MessageSendEvent_1broadcast_1channel_1announcement(JNIEnv *env, jclass clz, int64_t msg, int64_t update_msg) {
	LDKChannelAnnouncement msg_conv;
	msg_conv.inner = (void*)(msg & (~1));
	msg_conv.is_owned = (msg & 1) || (msg == 0);
	msg_conv = ChannelAnnouncement_clone(&msg_conv);
	LDKChannelUpdate update_msg_conv;
	update_msg_conv.inner = (void*)(update_msg & (~1));
	update_msg_conv.is_owned = (update_msg & 1) || (update_msg == 0);
	update_msg_conv = ChannelUpdate_clone(&update_msg_conv);
	LDKMessageSendEvent *ret_copy = MALLOC(sizeof(LDKMessageSendEvent), "LDKMessageSendEvent");
	*ret_copy = MessageSendEvent_broadcast_channel_announcement(msg_conv, update_msg_conv);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_MessageSendEvent_1broadcast_1node_1announcement(JNIEnv *env, jclass clz, int64_t msg) {
	LDKNodeAnnouncement msg_conv;
	msg_conv.inner = (void*)(msg & (~1));
	msg_conv.is_owned = (msg & 1) || (msg == 0);
	msg_conv = NodeAnnouncement_clone(&msg_conv);
	LDKMessageSendEvent *ret_copy = MALLOC(sizeof(LDKMessageSendEvent), "LDKMessageSendEvent");
	*ret_copy = MessageSendEvent_broadcast_node_announcement(msg_conv);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_MessageSendEvent_1broadcast_1channel_1update(JNIEnv *env, jclass clz, int64_t msg) {
	LDKChannelUpdate msg_conv;
	msg_conv.inner = (void*)(msg & (~1));
	msg_conv.is_owned = (msg & 1) || (msg == 0);
	msg_conv = ChannelUpdate_clone(&msg_conv);
	LDKMessageSendEvent *ret_copy = MALLOC(sizeof(LDKMessageSendEvent), "LDKMessageSendEvent");
	*ret_copy = MessageSendEvent_broadcast_channel_update(msg_conv);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_MessageSendEvent_1send_1channel_1update(JNIEnv *env, jclass clz, int8_tArray node_id, int64_t msg) {
	LDKPublicKey node_id_ref;
	CHECK((*env)->GetArrayLength(env, node_id) == 33);
	(*env)->GetByteArrayRegion(env, node_id, 0, 33, node_id_ref.compressed_form);
	LDKChannelUpdate msg_conv;
	msg_conv.inner = (void*)(msg & (~1));
	msg_conv.is_owned = (msg & 1) || (msg == 0);
	msg_conv = ChannelUpdate_clone(&msg_conv);
	LDKMessageSendEvent *ret_copy = MALLOC(sizeof(LDKMessageSendEvent), "LDKMessageSendEvent");
	*ret_copy = MessageSendEvent_send_channel_update(node_id_ref, msg_conv);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_MessageSendEvent_1handle_1error(JNIEnv *env, jclass clz, int8_tArray node_id, int64_t action) {
	LDKPublicKey node_id_ref;
	CHECK((*env)->GetArrayLength(env, node_id) == 33);
	(*env)->GetByteArrayRegion(env, node_id, 0, 33, node_id_ref.compressed_form);
	void* action_ptr = (void*)(((uint64_t)action) & ~1);
	CHECK_ACCESS(action_ptr);
	LDKErrorAction action_conv = *(LDKErrorAction*)(action_ptr);
	action_conv = ErrorAction_clone((LDKErrorAction*)(((uint64_t)action) & ~1));
	LDKMessageSendEvent *ret_copy = MALLOC(sizeof(LDKMessageSendEvent), "LDKMessageSendEvent");
	*ret_copy = MessageSendEvent_handle_error(node_id_ref, action_conv);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_MessageSendEvent_1send_1channel_1range_1query(JNIEnv *env, jclass clz, int8_tArray node_id, int64_t msg) {
	LDKPublicKey node_id_ref;
	CHECK((*env)->GetArrayLength(env, node_id) == 33);
	(*env)->GetByteArrayRegion(env, node_id, 0, 33, node_id_ref.compressed_form);
	LDKQueryChannelRange msg_conv;
	msg_conv.inner = (void*)(msg & (~1));
	msg_conv.is_owned = (msg & 1) || (msg == 0);
	msg_conv = QueryChannelRange_clone(&msg_conv);
	LDKMessageSendEvent *ret_copy = MALLOC(sizeof(LDKMessageSendEvent), "LDKMessageSendEvent");
	*ret_copy = MessageSendEvent_send_channel_range_query(node_id_ref, msg_conv);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_MessageSendEvent_1send_1short_1ids_1query(JNIEnv *env, jclass clz, int8_tArray node_id, int64_t msg) {
	LDKPublicKey node_id_ref;
	CHECK((*env)->GetArrayLength(env, node_id) == 33);
	(*env)->GetByteArrayRegion(env, node_id, 0, 33, node_id_ref.compressed_form);
	LDKQueryShortChannelIds msg_conv;
	msg_conv.inner = (void*)(msg & (~1));
	msg_conv.is_owned = (msg & 1) || (msg == 0);
	msg_conv = QueryShortChannelIds_clone(&msg_conv);
	LDKMessageSendEvent *ret_copy = MALLOC(sizeof(LDKMessageSendEvent), "LDKMessageSendEvent");
	*ret_copy = MessageSendEvent_send_short_ids_query(node_id_ref, msg_conv);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_MessageSendEvent_1send_1reply_1channel_1range(JNIEnv *env, jclass clz, int8_tArray node_id, int64_t msg) {
	LDKPublicKey node_id_ref;
	CHECK((*env)->GetArrayLength(env, node_id) == 33);
	(*env)->GetByteArrayRegion(env, node_id, 0, 33, node_id_ref.compressed_form);
	LDKReplyChannelRange msg_conv;
	msg_conv.inner = (void*)(msg & (~1));
	msg_conv.is_owned = (msg & 1) || (msg == 0);
	msg_conv = ReplyChannelRange_clone(&msg_conv);
	LDKMessageSendEvent *ret_copy = MALLOC(sizeof(LDKMessageSendEvent), "LDKMessageSendEvent");
	*ret_copy = MessageSendEvent_send_reply_channel_range(node_id_ref, msg_conv);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_MessageSendEventsProvider_1free(JNIEnv *env, jclass clz, int64_t this_ptr) {
	if ((this_ptr & 1) != 0) return;
	void* this_ptr_ptr = (void*)(((uint64_t)this_ptr) & ~1);
	CHECK_ACCESS(this_ptr_ptr);
	LDKMessageSendEventsProvider this_ptr_conv = *(LDKMessageSendEventsProvider*)(this_ptr_ptr);
	FREE((void*)this_ptr);
	MessageSendEventsProvider_free(this_ptr_conv);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_EventsProvider_1free(JNIEnv *env, jclass clz, int64_t this_ptr) {
	if ((this_ptr & 1) != 0) return;
	void* this_ptr_ptr = (void*)(((uint64_t)this_ptr) & ~1);
	CHECK_ACCESS(this_ptr_ptr);
	LDKEventsProvider this_ptr_conv = *(LDKEventsProvider*)(this_ptr_ptr);
	FREE((void*)this_ptr);
	EventsProvider_free(this_ptr_conv);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_EventHandler_1free(JNIEnv *env, jclass clz, int64_t this_ptr) {
	if ((this_ptr & 1) != 0) return;
	void* this_ptr_ptr = (void*)(((uint64_t)this_ptr) & ~1);
	CHECK_ACCESS(this_ptr_ptr);
	LDKEventHandler this_ptr_conv = *(LDKEventHandler*)(this_ptr_ptr);
	FREE((void*)this_ptr);
	EventHandler_free(this_ptr_conv);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_APIError_1free(JNIEnv *env, jclass clz, int64_t this_ptr) {
	if ((this_ptr & 1) != 0) return;
	void* this_ptr_ptr = (void*)(((uint64_t)this_ptr) & ~1);
	CHECK_ACCESS(this_ptr_ptr);
	LDKAPIError this_ptr_conv = *(LDKAPIError*)(this_ptr_ptr);
	FREE((void*)this_ptr);
	APIError_free(this_ptr_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_APIError_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKAPIError* orig_conv = (LDKAPIError*)orig;
	LDKAPIError *ret_copy = MALLOC(sizeof(LDKAPIError), "LDKAPIError");
	*ret_copy = APIError_clone(orig_conv);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_APIError_1apimisuse_1error(JNIEnv *env, jclass clz, jstring err) {
	LDKStr err_conv = java_to_owned_str(env, err);
	LDKAPIError *ret_copy = MALLOC(sizeof(LDKAPIError), "LDKAPIError");
	*ret_copy = APIError_apimisuse_error(err_conv);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_APIError_1fee_1rate_1too_1high(JNIEnv *env, jclass clz, jstring err, int32_t feerate) {
	LDKStr err_conv = java_to_owned_str(env, err);
	LDKAPIError *ret_copy = MALLOC(sizeof(LDKAPIError), "LDKAPIError");
	*ret_copy = APIError_fee_rate_too_high(err_conv, feerate);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_APIError_1route_1error(JNIEnv *env, jclass clz, jstring err) {
	LDKStr err_conv = java_to_owned_str(env, err);
	LDKAPIError *ret_copy = MALLOC(sizeof(LDKAPIError), "LDKAPIError");
	*ret_copy = APIError_route_error(err_conv);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_APIError_1channel_1unavailable(JNIEnv *env, jclass clz, jstring err) {
	LDKStr err_conv = java_to_owned_str(env, err);
	LDKAPIError *ret_copy = MALLOC(sizeof(LDKAPIError), "LDKAPIError");
	*ret_copy = APIError_channel_unavailable(err_conv);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_APIError_1monitor_1update_1failed(JNIEnv *env, jclass clz) {
	LDKAPIError *ret_copy = MALLOC(sizeof(LDKAPIError), "LDKAPIError");
	*ret_copy = APIError_monitor_update_failed();
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_APIError_1incompatible_1shutdown_1script(JNIEnv *env, jclass clz, int64_t script) {
	LDKShutdownScript script_conv;
	script_conv.inner = (void*)(script & (~1));
	script_conv.is_owned = (script & 1) || (script == 0);
	script_conv = ShutdownScript_clone(&script_conv);
	LDKAPIError *ret_copy = MALLOC(sizeof(LDKAPIError), "LDKAPIError");
	*ret_copy = APIError_incompatible_shutdown_script(script_conv);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_sign(JNIEnv *env, jclass clz, int8_tArray msg, int8_tArray sk) {
	LDKu8slice msg_ref;
	msg_ref.datalen = (*env)->GetArrayLength(env, msg);
	msg_ref.data = (*env)->GetByteArrayElements (env, msg, NULL);
	unsigned char sk_arr[32];
	CHECK((*env)->GetArrayLength(env, sk) == 32);
	(*env)->GetByteArrayRegion(env, sk, 0, 32, sk_arr);
	unsigned char (*sk_ref)[32] = &sk_arr;
	LDKCResult_StringErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_StringErrorZ), "LDKCResult_StringErrorZ");
	*ret_conv = sign(msg_ref, sk_ref);
	(*env)->ReleaseByteArrayElements(env, msg, (int8_t*)msg_ref.data, 0);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_recover_1pk(JNIEnv *env, jclass clz, int8_tArray msg, jstring sig) {
	LDKu8slice msg_ref;
	msg_ref.datalen = (*env)->GetArrayLength(env, msg);
	msg_ref.data = (*env)->GetByteArrayElements (env, msg, NULL);
	LDKStr sig_conv = java_to_owned_str(env, sig);
	LDKCResult_PublicKeyErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_PublicKeyErrorZ), "LDKCResult_PublicKeyErrorZ");
	*ret_conv = recover_pk(msg_ref, sig_conv);
	(*env)->ReleaseByteArrayElements(env, msg, (int8_t*)msg_ref.data, 0);
	return (uint64_t)ret_conv;
}

JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_verify(JNIEnv *env, jclass clz, int8_tArray msg, jstring sig, int8_tArray pk) {
	LDKu8slice msg_ref;
	msg_ref.datalen = (*env)->GetArrayLength(env, msg);
	msg_ref.data = (*env)->GetByteArrayElements (env, msg, NULL);
	LDKStr sig_conv = java_to_owned_str(env, sig);
	LDKPublicKey pk_ref;
	CHECK((*env)->GetArrayLength(env, pk) == 33);
	(*env)->GetByteArrayRegion(env, pk, 0, 33, pk_ref.compressed_form);
	jboolean ret_val = verify(msg_ref, sig_conv, pk_ref);
	(*env)->ReleaseByteArrayElements(env, msg, (int8_t*)msg_ref.data, 0);
	return ret_val;
}

JNIEXPORT jclass JNICALL Java_org_ldk_impl_bindings_Level_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKLevel* orig_conv = (LDKLevel*)(orig & ~1);
	jclass ret_conv = LDKLevel_to_java(env, Level_clone(orig_conv));
	return ret_conv;
}

JNIEXPORT jclass JNICALL Java_org_ldk_impl_bindings_Level_1trace(JNIEnv *env, jclass clz) {
	jclass ret_conv = LDKLevel_to_java(env, Level_trace());
	return ret_conv;
}

JNIEXPORT jclass JNICALL Java_org_ldk_impl_bindings_Level_1debug(JNIEnv *env, jclass clz) {
	jclass ret_conv = LDKLevel_to_java(env, Level_debug());
	return ret_conv;
}

JNIEXPORT jclass JNICALL Java_org_ldk_impl_bindings_Level_1info(JNIEnv *env, jclass clz) {
	jclass ret_conv = LDKLevel_to_java(env, Level_info());
	return ret_conv;
}

JNIEXPORT jclass JNICALL Java_org_ldk_impl_bindings_Level_1warn(JNIEnv *env, jclass clz) {
	jclass ret_conv = LDKLevel_to_java(env, Level_warn());
	return ret_conv;
}

JNIEXPORT jclass JNICALL Java_org_ldk_impl_bindings_Level_1error(JNIEnv *env, jclass clz) {
	jclass ret_conv = LDKLevel_to_java(env, Level_error());
	return ret_conv;
}

JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_Level_1eq(JNIEnv *env, jclass clz, int64_t a, int64_t b) {
	LDKLevel* a_conv = (LDKLevel*)(a & ~1);
	LDKLevel* b_conv = (LDKLevel*)(b & ~1);
	jboolean ret_val = Level_eq(a_conv, b_conv);
	return ret_val;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_Level_1hash(JNIEnv *env, jclass clz, int64_t o) {
	LDKLevel* o_conv = (LDKLevel*)(o & ~1);
	int64_t ret_val = Level_hash(o_conv);
	return ret_val;
}

JNIEXPORT jclass JNICALL Java_org_ldk_impl_bindings_Level_1max(JNIEnv *env, jclass clz) {
	jclass ret_conv = LDKLevel_to_java(env, Level_max());
	return ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_Logger_1free(JNIEnv *env, jclass clz, int64_t this_ptr) {
	if ((this_ptr & 1) != 0) return;
	void* this_ptr_ptr = (void*)(((uint64_t)this_ptr) & ~1);
	CHECK_ACCESS(this_ptr_ptr);
	LDKLogger this_ptr_conv = *(LDKLogger*)(this_ptr_ptr);
	FREE((void*)this_ptr);
	Logger_free(this_ptr_conv);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelHandshakeConfig_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKChannelHandshakeConfig this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	ChannelHandshakeConfig_free(this_obj_conv);
}

JNIEXPORT int32_t JNICALL Java_org_ldk_impl_bindings_ChannelHandshakeConfig_1get_1minimum_1depth(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKChannelHandshakeConfig this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int32_t ret_val = ChannelHandshakeConfig_get_minimum_depth(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelHandshakeConfig_1set_1minimum_1depth(JNIEnv *env, jclass clz, int64_t this_ptr, int32_t val) {
	LDKChannelHandshakeConfig this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	ChannelHandshakeConfig_set_minimum_depth(&this_ptr_conv, val);
}

JNIEXPORT int16_t JNICALL Java_org_ldk_impl_bindings_ChannelHandshakeConfig_1get_1our_1to_1self_1delay(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKChannelHandshakeConfig this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int16_t ret_val = ChannelHandshakeConfig_get_our_to_self_delay(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelHandshakeConfig_1set_1our_1to_1self_1delay(JNIEnv *env, jclass clz, int64_t this_ptr, int16_t val) {
	LDKChannelHandshakeConfig this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	ChannelHandshakeConfig_set_our_to_self_delay(&this_ptr_conv, val);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelHandshakeConfig_1get_1our_1htlc_1minimum_1msat(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKChannelHandshakeConfig this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int64_t ret_val = ChannelHandshakeConfig_get_our_htlc_minimum_msat(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelHandshakeConfig_1set_1our_1htlc_1minimum_1msat(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKChannelHandshakeConfig this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	ChannelHandshakeConfig_set_our_htlc_minimum_msat(&this_ptr_conv, val);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelHandshakeConfig_1new(JNIEnv *env, jclass clz, int32_t minimum_depth_arg, int16_t our_to_self_delay_arg, int64_t our_htlc_minimum_msat_arg) {
	LDKChannelHandshakeConfig ret_var = ChannelHandshakeConfig_new(minimum_depth_arg, our_to_self_delay_arg, our_htlc_minimum_msat_arg);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelHandshakeConfig_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKChannelHandshakeConfig orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKChannelHandshakeConfig ret_var = ChannelHandshakeConfig_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelHandshakeConfig_1default(JNIEnv *env, jclass clz) {
	LDKChannelHandshakeConfig ret_var = ChannelHandshakeConfig_default();
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelHandshakeLimits_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKChannelHandshakeLimits this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	ChannelHandshakeLimits_free(this_obj_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelHandshakeLimits_1get_1min_1funding_1satoshis(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKChannelHandshakeLimits this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int64_t ret_val = ChannelHandshakeLimits_get_min_funding_satoshis(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelHandshakeLimits_1set_1min_1funding_1satoshis(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKChannelHandshakeLimits this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	ChannelHandshakeLimits_set_min_funding_satoshis(&this_ptr_conv, val);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelHandshakeLimits_1get_1max_1htlc_1minimum_1msat(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKChannelHandshakeLimits this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int64_t ret_val = ChannelHandshakeLimits_get_max_htlc_minimum_msat(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelHandshakeLimits_1set_1max_1htlc_1minimum_1msat(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKChannelHandshakeLimits this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	ChannelHandshakeLimits_set_max_htlc_minimum_msat(&this_ptr_conv, val);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelHandshakeLimits_1get_1min_1max_1htlc_1value_1in_1flight_1msat(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKChannelHandshakeLimits this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int64_t ret_val = ChannelHandshakeLimits_get_min_max_htlc_value_in_flight_msat(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelHandshakeLimits_1set_1min_1max_1htlc_1value_1in_1flight_1msat(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKChannelHandshakeLimits this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	ChannelHandshakeLimits_set_min_max_htlc_value_in_flight_msat(&this_ptr_conv, val);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelHandshakeLimits_1get_1max_1channel_1reserve_1satoshis(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKChannelHandshakeLimits this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int64_t ret_val = ChannelHandshakeLimits_get_max_channel_reserve_satoshis(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelHandshakeLimits_1set_1max_1channel_1reserve_1satoshis(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKChannelHandshakeLimits this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	ChannelHandshakeLimits_set_max_channel_reserve_satoshis(&this_ptr_conv, val);
}

JNIEXPORT int16_t JNICALL Java_org_ldk_impl_bindings_ChannelHandshakeLimits_1get_1min_1max_1accepted_1htlcs(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKChannelHandshakeLimits this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int16_t ret_val = ChannelHandshakeLimits_get_min_max_accepted_htlcs(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelHandshakeLimits_1set_1min_1max_1accepted_1htlcs(JNIEnv *env, jclass clz, int64_t this_ptr, int16_t val) {
	LDKChannelHandshakeLimits this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	ChannelHandshakeLimits_set_min_max_accepted_htlcs(&this_ptr_conv, val);
}

JNIEXPORT int32_t JNICALL Java_org_ldk_impl_bindings_ChannelHandshakeLimits_1get_1max_1minimum_1depth(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKChannelHandshakeLimits this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int32_t ret_val = ChannelHandshakeLimits_get_max_minimum_depth(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelHandshakeLimits_1set_1max_1minimum_1depth(JNIEnv *env, jclass clz, int64_t this_ptr, int32_t val) {
	LDKChannelHandshakeLimits this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	ChannelHandshakeLimits_set_max_minimum_depth(&this_ptr_conv, val);
}

JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_ChannelHandshakeLimits_1get_1force_1announced_1channel_1preference(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKChannelHandshakeLimits this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	jboolean ret_val = ChannelHandshakeLimits_get_force_announced_channel_preference(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelHandshakeLimits_1set_1force_1announced_1channel_1preference(JNIEnv *env, jclass clz, int64_t this_ptr, jboolean val) {
	LDKChannelHandshakeLimits this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	ChannelHandshakeLimits_set_force_announced_channel_preference(&this_ptr_conv, val);
}

JNIEXPORT int16_t JNICALL Java_org_ldk_impl_bindings_ChannelHandshakeLimits_1get_1their_1to_1self_1delay(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKChannelHandshakeLimits this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int16_t ret_val = ChannelHandshakeLimits_get_their_to_self_delay(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelHandshakeLimits_1set_1their_1to_1self_1delay(JNIEnv *env, jclass clz, int64_t this_ptr, int16_t val) {
	LDKChannelHandshakeLimits this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	ChannelHandshakeLimits_set_their_to_self_delay(&this_ptr_conv, val);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelHandshakeLimits_1new(JNIEnv *env, jclass clz, int64_t min_funding_satoshis_arg, int64_t max_htlc_minimum_msat_arg, int64_t min_max_htlc_value_in_flight_msat_arg, int64_t max_channel_reserve_satoshis_arg, int16_t min_max_accepted_htlcs_arg, int32_t max_minimum_depth_arg, jboolean force_announced_channel_preference_arg, int16_t their_to_self_delay_arg) {
	LDKChannelHandshakeLimits ret_var = ChannelHandshakeLimits_new(min_funding_satoshis_arg, max_htlc_minimum_msat_arg, min_max_htlc_value_in_flight_msat_arg, max_channel_reserve_satoshis_arg, min_max_accepted_htlcs_arg, max_minimum_depth_arg, force_announced_channel_preference_arg, their_to_self_delay_arg);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelHandshakeLimits_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKChannelHandshakeLimits orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKChannelHandshakeLimits ret_var = ChannelHandshakeLimits_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelHandshakeLimits_1default(JNIEnv *env, jclass clz) {
	LDKChannelHandshakeLimits ret_var = ChannelHandshakeLimits_default();
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelConfig_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKChannelConfig this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	ChannelConfig_free(this_obj_conv);
}

JNIEXPORT int32_t JNICALL Java_org_ldk_impl_bindings_ChannelConfig_1get_1forwarding_1fee_1proportional_1millionths(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKChannelConfig this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int32_t ret_val = ChannelConfig_get_forwarding_fee_proportional_millionths(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelConfig_1set_1forwarding_1fee_1proportional_1millionths(JNIEnv *env, jclass clz, int64_t this_ptr, int32_t val) {
	LDKChannelConfig this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	ChannelConfig_set_forwarding_fee_proportional_millionths(&this_ptr_conv, val);
}

JNIEXPORT int32_t JNICALL Java_org_ldk_impl_bindings_ChannelConfig_1get_1forwarding_1fee_1base_1msat(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKChannelConfig this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int32_t ret_val = ChannelConfig_get_forwarding_fee_base_msat(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelConfig_1set_1forwarding_1fee_1base_1msat(JNIEnv *env, jclass clz, int64_t this_ptr, int32_t val) {
	LDKChannelConfig this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	ChannelConfig_set_forwarding_fee_base_msat(&this_ptr_conv, val);
}

JNIEXPORT int16_t JNICALL Java_org_ldk_impl_bindings_ChannelConfig_1get_1cltv_1expiry_1delta(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKChannelConfig this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int16_t ret_val = ChannelConfig_get_cltv_expiry_delta(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelConfig_1set_1cltv_1expiry_1delta(JNIEnv *env, jclass clz, int64_t this_ptr, int16_t val) {
	LDKChannelConfig this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	ChannelConfig_set_cltv_expiry_delta(&this_ptr_conv, val);
}

JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_ChannelConfig_1get_1announced_1channel(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKChannelConfig this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	jboolean ret_val = ChannelConfig_get_announced_channel(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelConfig_1set_1announced_1channel(JNIEnv *env, jclass clz, int64_t this_ptr, jboolean val) {
	LDKChannelConfig this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	ChannelConfig_set_announced_channel(&this_ptr_conv, val);
}

JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_ChannelConfig_1get_1commit_1upfront_1shutdown_1pubkey(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKChannelConfig this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	jboolean ret_val = ChannelConfig_get_commit_upfront_shutdown_pubkey(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelConfig_1set_1commit_1upfront_1shutdown_1pubkey(JNIEnv *env, jclass clz, int64_t this_ptr, jboolean val) {
	LDKChannelConfig this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	ChannelConfig_set_commit_upfront_shutdown_pubkey(&this_ptr_conv, val);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelConfig_1get_1max_1dust_1htlc_1exposure_1msat(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKChannelConfig this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int64_t ret_val = ChannelConfig_get_max_dust_htlc_exposure_msat(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelConfig_1set_1max_1dust_1htlc_1exposure_1msat(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKChannelConfig this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	ChannelConfig_set_max_dust_htlc_exposure_msat(&this_ptr_conv, val);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelConfig_1get_1force_1close_1avoidance_1max_1fee_1satoshis(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKChannelConfig this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int64_t ret_val = ChannelConfig_get_force_close_avoidance_max_fee_satoshis(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelConfig_1set_1force_1close_1avoidance_1max_1fee_1satoshis(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKChannelConfig this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	ChannelConfig_set_force_close_avoidance_max_fee_satoshis(&this_ptr_conv, val);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelConfig_1new(JNIEnv *env, jclass clz, int32_t forwarding_fee_proportional_millionths_arg, int32_t forwarding_fee_base_msat_arg, int16_t cltv_expiry_delta_arg, jboolean announced_channel_arg, jboolean commit_upfront_shutdown_pubkey_arg, int64_t max_dust_htlc_exposure_msat_arg, int64_t force_close_avoidance_max_fee_satoshis_arg) {
	LDKChannelConfig ret_var = ChannelConfig_new(forwarding_fee_proportional_millionths_arg, forwarding_fee_base_msat_arg, cltv_expiry_delta_arg, announced_channel_arg, commit_upfront_shutdown_pubkey_arg, max_dust_htlc_exposure_msat_arg, force_close_avoidance_max_fee_satoshis_arg);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelConfig_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKChannelConfig orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKChannelConfig ret_var = ChannelConfig_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelConfig_1default(JNIEnv *env, jclass clz) {
	LDKChannelConfig ret_var = ChannelConfig_default();
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_ChannelConfig_1write(JNIEnv *env, jclass clz, int64_t obj) {
	LDKChannelConfig obj_conv;
	obj_conv.inner = (void*)(obj & (~1));
	obj_conv.is_owned = false;
	LDKCVec_u8Z ret_var = ChannelConfig_write(&obj_conv);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	CVec_u8Z_free(ret_var);
	return ret_arr;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelConfig_1read(JNIEnv *env, jclass clz, int8_tArray ser) {
	LDKu8slice ser_ref;
	ser_ref.datalen = (*env)->GetArrayLength(env, ser);
	ser_ref.data = (*env)->GetByteArrayElements (env, ser, NULL);
	LDKCResult_ChannelConfigDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_ChannelConfigDecodeErrorZ), "LDKCResult_ChannelConfigDecodeErrorZ");
	*ret_conv = ChannelConfig_read(ser_ref);
	(*env)->ReleaseByteArrayElements(env, ser, (int8_t*)ser_ref.data, 0);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_UserConfig_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKUserConfig this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	UserConfig_free(this_obj_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_UserConfig_1get_1own_1channel_1config(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKUserConfig this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKChannelHandshakeConfig ret_var = UserConfig_get_own_channel_config(&this_ptr_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_UserConfig_1set_1own_1channel_1config(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKUserConfig this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKChannelHandshakeConfig val_conv;
	val_conv.inner = (void*)(val & (~1));
	val_conv.is_owned = (val & 1) || (val == 0);
	val_conv = ChannelHandshakeConfig_clone(&val_conv);
	UserConfig_set_own_channel_config(&this_ptr_conv, val_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_UserConfig_1get_1peer_1channel_1config_1limits(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKUserConfig this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKChannelHandshakeLimits ret_var = UserConfig_get_peer_channel_config_limits(&this_ptr_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_UserConfig_1set_1peer_1channel_1config_1limits(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKUserConfig this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKChannelHandshakeLimits val_conv;
	val_conv.inner = (void*)(val & (~1));
	val_conv.is_owned = (val & 1) || (val == 0);
	val_conv = ChannelHandshakeLimits_clone(&val_conv);
	UserConfig_set_peer_channel_config_limits(&this_ptr_conv, val_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_UserConfig_1get_1channel_1options(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKUserConfig this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKChannelConfig ret_var = UserConfig_get_channel_options(&this_ptr_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_UserConfig_1set_1channel_1options(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKUserConfig this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKChannelConfig val_conv;
	val_conv.inner = (void*)(val & (~1));
	val_conv.is_owned = (val & 1) || (val == 0);
	val_conv = ChannelConfig_clone(&val_conv);
	UserConfig_set_channel_options(&this_ptr_conv, val_conv);
}

JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_UserConfig_1get_1accept_1forwards_1to_1priv_1channels(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKUserConfig this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	jboolean ret_val = UserConfig_get_accept_forwards_to_priv_channels(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_UserConfig_1set_1accept_1forwards_1to_1priv_1channels(JNIEnv *env, jclass clz, int64_t this_ptr, jboolean val) {
	LDKUserConfig this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	UserConfig_set_accept_forwards_to_priv_channels(&this_ptr_conv, val);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_UserConfig_1new(JNIEnv *env, jclass clz, int64_t own_channel_config_arg, int64_t peer_channel_config_limits_arg, int64_t channel_options_arg, jboolean accept_forwards_to_priv_channels_arg) {
	LDKChannelHandshakeConfig own_channel_config_arg_conv;
	own_channel_config_arg_conv.inner = (void*)(own_channel_config_arg & (~1));
	own_channel_config_arg_conv.is_owned = (own_channel_config_arg & 1) || (own_channel_config_arg == 0);
	own_channel_config_arg_conv = ChannelHandshakeConfig_clone(&own_channel_config_arg_conv);
	LDKChannelHandshakeLimits peer_channel_config_limits_arg_conv;
	peer_channel_config_limits_arg_conv.inner = (void*)(peer_channel_config_limits_arg & (~1));
	peer_channel_config_limits_arg_conv.is_owned = (peer_channel_config_limits_arg & 1) || (peer_channel_config_limits_arg == 0);
	peer_channel_config_limits_arg_conv = ChannelHandshakeLimits_clone(&peer_channel_config_limits_arg_conv);
	LDKChannelConfig channel_options_arg_conv;
	channel_options_arg_conv.inner = (void*)(channel_options_arg & (~1));
	channel_options_arg_conv.is_owned = (channel_options_arg & 1) || (channel_options_arg == 0);
	channel_options_arg_conv = ChannelConfig_clone(&channel_options_arg_conv);
	LDKUserConfig ret_var = UserConfig_new(own_channel_config_arg_conv, peer_channel_config_limits_arg_conv, channel_options_arg_conv, accept_forwards_to_priv_channels_arg);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_UserConfig_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKUserConfig orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKUserConfig ret_var = UserConfig_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_UserConfig_1default(JNIEnv *env, jclass clz) {
	LDKUserConfig ret_var = UserConfig_default();
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_BestBlock_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKBestBlock this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	BestBlock_free(this_obj_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_BestBlock_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKBestBlock orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKBestBlock ret_var = BestBlock_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_BestBlock_1from_1genesis(JNIEnv *env, jclass clz, jclass network) {
	LDKNetwork network_conv = LDKNetwork_from_java(env, network);
	LDKBestBlock ret_var = BestBlock_from_genesis(network_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_BestBlock_1new(JNIEnv *env, jclass clz, int8_tArray block_hash, int32_t height) {
	LDKThirtyTwoBytes block_hash_ref;
	CHECK((*env)->GetArrayLength(env, block_hash) == 32);
	(*env)->GetByteArrayRegion(env, block_hash, 0, 32, block_hash_ref.data);
	LDKBestBlock ret_var = BestBlock_new(block_hash_ref, height);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_BestBlock_1block_1hash(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKBestBlock this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 32);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 32, BestBlock_block_hash(&this_arg_conv).data);
	return ret_arr;
}

JNIEXPORT int32_t JNICALL Java_org_ldk_impl_bindings_BestBlock_1height(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKBestBlock this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	int32_t ret_val = BestBlock_height(&this_arg_conv);
	return ret_val;
}

JNIEXPORT jclass JNICALL Java_org_ldk_impl_bindings_AccessError_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKAccessError* orig_conv = (LDKAccessError*)(orig & ~1);
	jclass ret_conv = LDKAccessError_to_java(env, AccessError_clone(orig_conv));
	return ret_conv;
}

JNIEXPORT jclass JNICALL Java_org_ldk_impl_bindings_AccessError_1unknown_1chain(JNIEnv *env, jclass clz) {
	jclass ret_conv = LDKAccessError_to_java(env, AccessError_unknown_chain());
	return ret_conv;
}

JNIEXPORT jclass JNICALL Java_org_ldk_impl_bindings_AccessError_1unknown_1tx(JNIEnv *env, jclass clz) {
	jclass ret_conv = LDKAccessError_to_java(env, AccessError_unknown_tx());
	return ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_Access_1free(JNIEnv *env, jclass clz, int64_t this_ptr) {
	if ((this_ptr & 1) != 0) return;
	void* this_ptr_ptr = (void*)(((uint64_t)this_ptr) & ~1);
	CHECK_ACCESS(this_ptr_ptr);
	LDKAccess this_ptr_conv = *(LDKAccess*)(this_ptr_ptr);
	FREE((void*)this_ptr);
	Access_free(this_ptr_conv);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_Listen_1free(JNIEnv *env, jclass clz, int64_t this_ptr) {
	if ((this_ptr & 1) != 0) return;
	void* this_ptr_ptr = (void*)(((uint64_t)this_ptr) & ~1);
	CHECK_ACCESS(this_ptr_ptr);
	LDKListen this_ptr_conv = *(LDKListen*)(this_ptr_ptr);
	FREE((void*)this_ptr);
	Listen_free(this_ptr_conv);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_Confirm_1free(JNIEnv *env, jclass clz, int64_t this_ptr) {
	if ((this_ptr & 1) != 0) return;
	void* this_ptr_ptr = (void*)(((uint64_t)this_ptr) & ~1);
	CHECK_ACCESS(this_ptr_ptr);
	LDKConfirm this_ptr_conv = *(LDKConfirm*)(this_ptr_ptr);
	FREE((void*)this_ptr);
	Confirm_free(this_ptr_conv);
}

JNIEXPORT jclass JNICALL Java_org_ldk_impl_bindings_ChannelMonitorUpdateErr_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKChannelMonitorUpdateErr* orig_conv = (LDKChannelMonitorUpdateErr*)(orig & ~1);
	jclass ret_conv = LDKChannelMonitorUpdateErr_to_java(env, ChannelMonitorUpdateErr_clone(orig_conv));
	return ret_conv;
}

JNIEXPORT jclass JNICALL Java_org_ldk_impl_bindings_ChannelMonitorUpdateErr_1temporary_1failure(JNIEnv *env, jclass clz) {
	jclass ret_conv = LDKChannelMonitorUpdateErr_to_java(env, ChannelMonitorUpdateErr_temporary_failure());
	return ret_conv;
}

JNIEXPORT jclass JNICALL Java_org_ldk_impl_bindings_ChannelMonitorUpdateErr_1permanent_1failure(JNIEnv *env, jclass clz) {
	jclass ret_conv = LDKChannelMonitorUpdateErr_to_java(env, ChannelMonitorUpdateErr_permanent_failure());
	return ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_Watch_1free(JNIEnv *env, jclass clz, int64_t this_ptr) {
	if ((this_ptr & 1) != 0) return;
	void* this_ptr_ptr = (void*)(((uint64_t)this_ptr) & ~1);
	CHECK_ACCESS(this_ptr_ptr);
	LDKWatch this_ptr_conv = *(LDKWatch*)(this_ptr_ptr);
	FREE((void*)this_ptr);
	Watch_free(this_ptr_conv);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_Filter_1free(JNIEnv *env, jclass clz, int64_t this_ptr) {
	if ((this_ptr & 1) != 0) return;
	void* this_ptr_ptr = (void*)(((uint64_t)this_ptr) & ~1);
	CHECK_ACCESS(this_ptr_ptr);
	LDKFilter this_ptr_conv = *(LDKFilter*)(this_ptr_ptr);
	FREE((void*)this_ptr);
	Filter_free(this_ptr_conv);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_WatchedOutput_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKWatchedOutput this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	WatchedOutput_free(this_obj_conv);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_WatchedOutput_1get_1block_1hash(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKWatchedOutput this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 32);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 32, WatchedOutput_get_block_hash(&this_ptr_conv).data);
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_WatchedOutput_1set_1block_1hash(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKWatchedOutput this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKThirtyTwoBytes val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 32);
	(*env)->GetByteArrayRegion(env, val, 0, 32, val_ref.data);
	WatchedOutput_set_block_hash(&this_ptr_conv, val_ref);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_WatchedOutput_1get_1outpoint(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKWatchedOutput this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKOutPoint ret_var = WatchedOutput_get_outpoint(&this_ptr_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_WatchedOutput_1set_1outpoint(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKWatchedOutput this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKOutPoint val_conv;
	val_conv.inner = (void*)(val & (~1));
	val_conv.is_owned = (val & 1) || (val == 0);
	val_conv = OutPoint_clone(&val_conv);
	WatchedOutput_set_outpoint(&this_ptr_conv, val_conv);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_WatchedOutput_1get_1script_1pubkey(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKWatchedOutput this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKu8slice ret_var = WatchedOutput_get_script_pubkey(&this_ptr_conv);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_WatchedOutput_1set_1script_1pubkey(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKWatchedOutput this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKCVec_u8Z val_ref;
	val_ref.datalen = (*env)->GetArrayLength(env, val);
	val_ref.data = MALLOC(val_ref.datalen, "LDKCVec_u8Z Bytes");
	(*env)->GetByteArrayRegion(env, val, 0, val_ref.datalen, val_ref.data);
	WatchedOutput_set_script_pubkey(&this_ptr_conv, val_ref);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_WatchedOutput_1new(JNIEnv *env, jclass clz, int8_tArray block_hash_arg, int64_t outpoint_arg, int8_tArray script_pubkey_arg) {
	LDKThirtyTwoBytes block_hash_arg_ref;
	CHECK((*env)->GetArrayLength(env, block_hash_arg) == 32);
	(*env)->GetByteArrayRegion(env, block_hash_arg, 0, 32, block_hash_arg_ref.data);
	LDKOutPoint outpoint_arg_conv;
	outpoint_arg_conv.inner = (void*)(outpoint_arg & (~1));
	outpoint_arg_conv.is_owned = (outpoint_arg & 1) || (outpoint_arg == 0);
	outpoint_arg_conv = OutPoint_clone(&outpoint_arg_conv);
	LDKCVec_u8Z script_pubkey_arg_ref;
	script_pubkey_arg_ref.datalen = (*env)->GetArrayLength(env, script_pubkey_arg);
	script_pubkey_arg_ref.data = MALLOC(script_pubkey_arg_ref.datalen, "LDKCVec_u8Z Bytes");
	(*env)->GetByteArrayRegion(env, script_pubkey_arg, 0, script_pubkey_arg_ref.datalen, script_pubkey_arg_ref.data);
	LDKWatchedOutput ret_var = WatchedOutput_new(block_hash_arg_ref, outpoint_arg_conv, script_pubkey_arg_ref);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_WatchedOutput_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKWatchedOutput orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKWatchedOutput ret_var = WatchedOutput_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_WatchedOutput_1hash(JNIEnv *env, jclass clz, int64_t o) {
	LDKWatchedOutput o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = false;
	int64_t ret_val = WatchedOutput_hash(&o_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_BroadcasterInterface_1free(JNIEnv *env, jclass clz, int64_t this_ptr) {
	if ((this_ptr & 1) != 0) return;
	void* this_ptr_ptr = (void*)(((uint64_t)this_ptr) & ~1);
	CHECK_ACCESS(this_ptr_ptr);
	LDKBroadcasterInterface this_ptr_conv = *(LDKBroadcasterInterface*)(this_ptr_ptr);
	FREE((void*)this_ptr);
	BroadcasterInterface_free(this_ptr_conv);
}

JNIEXPORT jclass JNICALL Java_org_ldk_impl_bindings_ConfirmationTarget_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKConfirmationTarget* orig_conv = (LDKConfirmationTarget*)(orig & ~1);
	jclass ret_conv = LDKConfirmationTarget_to_java(env, ConfirmationTarget_clone(orig_conv));
	return ret_conv;
}

JNIEXPORT jclass JNICALL Java_org_ldk_impl_bindings_ConfirmationTarget_1background(JNIEnv *env, jclass clz) {
	jclass ret_conv = LDKConfirmationTarget_to_java(env, ConfirmationTarget_background());
	return ret_conv;
}

JNIEXPORT jclass JNICALL Java_org_ldk_impl_bindings_ConfirmationTarget_1normal(JNIEnv *env, jclass clz) {
	jclass ret_conv = LDKConfirmationTarget_to_java(env, ConfirmationTarget_normal());
	return ret_conv;
}

JNIEXPORT jclass JNICALL Java_org_ldk_impl_bindings_ConfirmationTarget_1high_1priority(JNIEnv *env, jclass clz) {
	jclass ret_conv = LDKConfirmationTarget_to_java(env, ConfirmationTarget_high_priority());
	return ret_conv;
}

JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_ConfirmationTarget_1eq(JNIEnv *env, jclass clz, int64_t a, int64_t b) {
	LDKConfirmationTarget* a_conv = (LDKConfirmationTarget*)(a & ~1);
	LDKConfirmationTarget* b_conv = (LDKConfirmationTarget*)(b & ~1);
	jboolean ret_val = ConfirmationTarget_eq(a_conv, b_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_FeeEstimator_1free(JNIEnv *env, jclass clz, int64_t this_ptr) {
	if ((this_ptr & 1) != 0) return;
	void* this_ptr_ptr = (void*)(((uint64_t)this_ptr) & ~1);
	CHECK_ACCESS(this_ptr_ptr);
	LDKFeeEstimator this_ptr_conv = *(LDKFeeEstimator*)(this_ptr_ptr);
	FREE((void*)this_ptr);
	FeeEstimator_free(this_ptr_conv);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_MonitorUpdateId_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKMonitorUpdateId this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	MonitorUpdateId_free(this_obj_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_MonitorUpdateId_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKMonitorUpdateId orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKMonitorUpdateId ret_var = MonitorUpdateId_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_MonitorUpdateId_1hash(JNIEnv *env, jclass clz, int64_t o) {
	LDKMonitorUpdateId o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = false;
	int64_t ret_val = MonitorUpdateId_hash(&o_conv);
	return ret_val;
}

JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_MonitorUpdateId_1eq(JNIEnv *env, jclass clz, int64_t a, int64_t b) {
	LDKMonitorUpdateId a_conv;
	a_conv.inner = (void*)(a & (~1));
	a_conv.is_owned = false;
	LDKMonitorUpdateId b_conv;
	b_conv.inner = (void*)(b & (~1));
	b_conv.is_owned = false;
	jboolean ret_val = MonitorUpdateId_eq(&a_conv, &b_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_Persist_1free(JNIEnv *env, jclass clz, int64_t this_ptr) {
	if ((this_ptr & 1) != 0) return;
	void* this_ptr_ptr = (void*)(((uint64_t)this_ptr) & ~1);
	CHECK_ACCESS(this_ptr_ptr);
	LDKPersist this_ptr_conv = *(LDKPersist*)(this_ptr_ptr);
	FREE((void*)this_ptr);
	Persist_free(this_ptr_conv);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_LockedChannelMonitor_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKLockedChannelMonitor this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	LockedChannelMonitor_free(this_obj_conv);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChainMonitor_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKChainMonitor this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	ChainMonitor_free(this_obj_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChainMonitor_1new(JNIEnv *env, jclass clz, int64_t chain_source, int64_t broadcaster, int64_t logger, int64_t feeest, int64_t persister) {
	void* chain_source_ptr = (void*)(((uint64_t)chain_source) & ~1);
	CHECK_ACCESS(chain_source_ptr);
	LDKCOption_FilterZ chain_source_conv = *(LDKCOption_FilterZ*)(chain_source_ptr);
	// Warning: we may need a move here but no clone is available for LDKCOption_FilterZ
	if (chain_source_conv.tag == LDKCOption_FilterZ_Some) {
		// Manually implement clone for Java trait instances
		if (chain_source_conv.some.free == LDKFilter_JCalls_free) {
			// If this_arg is a JCalls struct, then we need to increment the refcnt in it.
			LDKFilter_JCalls_cloned(&chain_source_conv.some);
		}
	}
	void* broadcaster_ptr = (void*)(((uint64_t)broadcaster) & ~1);
	CHECK_ACCESS(broadcaster_ptr);
	LDKBroadcasterInterface broadcaster_conv = *(LDKBroadcasterInterface*)(broadcaster_ptr);
	if (broadcaster_conv.free == LDKBroadcasterInterface_JCalls_free) {
		// If this_arg is a JCalls struct, then we need to increment the refcnt in it.
		LDKBroadcasterInterface_JCalls_cloned(&broadcaster_conv);
	}
	void* logger_ptr = (void*)(((uint64_t)logger) & ~1);
	CHECK_ACCESS(logger_ptr);
	LDKLogger logger_conv = *(LDKLogger*)(logger_ptr);
	if (logger_conv.free == LDKLogger_JCalls_free) {
		// If this_arg is a JCalls struct, then we need to increment the refcnt in it.
		LDKLogger_JCalls_cloned(&logger_conv);
	}
	void* feeest_ptr = (void*)(((uint64_t)feeest) & ~1);
	CHECK_ACCESS(feeest_ptr);
	LDKFeeEstimator feeest_conv = *(LDKFeeEstimator*)(feeest_ptr);
	if (feeest_conv.free == LDKFeeEstimator_JCalls_free) {
		// If this_arg is a JCalls struct, then we need to increment the refcnt in it.
		LDKFeeEstimator_JCalls_cloned(&feeest_conv);
	}
	void* persister_ptr = (void*)(((uint64_t)persister) & ~1);
	CHECK_ACCESS(persister_ptr);
	LDKPersist persister_conv = *(LDKPersist*)(persister_ptr);
	if (persister_conv.free == LDKPersist_JCalls_free) {
		// If this_arg is a JCalls struct, then we need to increment the refcnt in it.
		LDKPersist_JCalls_cloned(&persister_conv);
	}
	LDKChainMonitor ret_var = ChainMonitor_new(chain_source_conv, broadcaster_conv, logger_conv, feeest_conv, persister_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_tArray JNICALL Java_org_ldk_impl_bindings_ChainMonitor_1get_1claimable_1balances(JNIEnv *env, jclass clz, int64_t this_arg, int64_tArray ignored_channels) {
	LDKChainMonitor this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKCVec_ChannelDetailsZ ignored_channels_constr;
	ignored_channels_constr.datalen = (*env)->GetArrayLength(env, ignored_channels);
	if (ignored_channels_constr.datalen > 0)
		ignored_channels_constr.data = MALLOC(ignored_channels_constr.datalen * sizeof(LDKChannelDetails), "LDKCVec_ChannelDetailsZ Elements");
	else
		ignored_channels_constr.data = NULL;
	int64_t* ignored_channels_vals = (*env)->GetLongArrayElements (env, ignored_channels, NULL);
	for (size_t q = 0; q < ignored_channels_constr.datalen; q++) {
		int64_t ignored_channels_conv_16 = ignored_channels_vals[q];
		LDKChannelDetails ignored_channels_conv_16_conv;
		ignored_channels_conv_16_conv.inner = (void*)(ignored_channels_conv_16 & (~1));
		ignored_channels_conv_16_conv.is_owned = (ignored_channels_conv_16 & 1) || (ignored_channels_conv_16 == 0);
		ignored_channels_conv_16_conv = ChannelDetails_clone(&ignored_channels_conv_16_conv);
		ignored_channels_constr.data[q] = ignored_channels_conv_16_conv;
	}
	(*env)->ReleaseLongArrayElements(env, ignored_channels, ignored_channels_vals, 0);
	LDKCVec_BalanceZ ret_var = ChainMonitor_get_claimable_balances(&this_arg_conv, ignored_channels_constr);
	int64_tArray ret_arr = NULL;
	ret_arr = (*env)->NewLongArray(env, ret_var.datalen);
	int64_t *ret_arr_ptr = (*env)->GetPrimitiveArrayCritical(env, ret_arr, NULL);
	for (size_t j = 0; j < ret_var.datalen; j++) {
		LDKBalance *ret_conv_9_copy = MALLOC(sizeof(LDKBalance), "LDKBalance");
		*ret_conv_9_copy = ret_var.data[j];
		uint64_t ret_conv_9_ref = (uint64_t)ret_conv_9_copy;
		ret_arr_ptr[j] = ret_conv_9_ref;
	}
	(*env)->ReleasePrimitiveArrayCritical(env, ret_arr, ret_arr_ptr, 0);
	FREE(ret_var.data);
	return ret_arr;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChainMonitor_1get_1monitor(JNIEnv *env, jclass clz, int64_t this_arg, int64_t funding_txo) {
	LDKChainMonitor this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKOutPoint funding_txo_conv;
	funding_txo_conv.inner = (void*)(funding_txo & (~1));
	funding_txo_conv.is_owned = (funding_txo & 1) || (funding_txo == 0);
	funding_txo_conv = OutPoint_clone(&funding_txo_conv);
	LDKCResult_LockedChannelMonitorNoneZ* ret_conv = MALLOC(sizeof(LDKCResult_LockedChannelMonitorNoneZ), "LDKCResult_LockedChannelMonitorNoneZ");
	*ret_conv = ChainMonitor_get_monitor(&this_arg_conv, funding_txo_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_tArray JNICALL Java_org_ldk_impl_bindings_ChainMonitor_1list_1monitors(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKChainMonitor this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKCVec_OutPointZ ret_var = ChainMonitor_list_monitors(&this_arg_conv);
	int64_tArray ret_arr = NULL;
	ret_arr = (*env)->NewLongArray(env, ret_var.datalen);
	int64_t *ret_arr_ptr = (*env)->GetPrimitiveArrayCritical(env, ret_arr, NULL);
	for (size_t k = 0; k < ret_var.datalen; k++) {
		LDKOutPoint ret_conv_10_var = ret_var.data[k];
		uint64_t ret_conv_10_ref = 0;
		CHECK((((uint64_t)ret_conv_10_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
		CHECK((((uint64_t)&ret_conv_10_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
		ret_conv_10_ref = (uint64_t)ret_conv_10_var.inner;
		if (ret_conv_10_var.is_owned) {
			ret_conv_10_ref |= 1;
		}
		ret_arr_ptr[k] = ret_conv_10_ref;
	}
	(*env)->ReleasePrimitiveArrayCritical(env, ret_arr, ret_arr_ptr, 0);
	FREE(ret_var.data);
	return ret_arr;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChainMonitor_1channel_1monitor_1updated(JNIEnv *env, jclass clz, int64_t this_arg, int64_t funding_txo, int64_t completed_update_id) {
	LDKChainMonitor this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKOutPoint funding_txo_conv;
	funding_txo_conv.inner = (void*)(funding_txo & (~1));
	funding_txo_conv.is_owned = (funding_txo & 1) || (funding_txo == 0);
	funding_txo_conv = OutPoint_clone(&funding_txo_conv);
	LDKMonitorUpdateId completed_update_id_conv;
	completed_update_id_conv.inner = (void*)(completed_update_id & (~1));
	completed_update_id_conv.is_owned = (completed_update_id & 1) || (completed_update_id == 0);
	completed_update_id_conv = MonitorUpdateId_clone(&completed_update_id_conv);
	LDKCResult_NoneAPIErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_NoneAPIErrorZ), "LDKCResult_NoneAPIErrorZ");
	*ret_conv = ChainMonitor_channel_monitor_updated(&this_arg_conv, funding_txo_conv, completed_update_id_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChainMonitor_1as_1Listen(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKChainMonitor this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKListen* ret_ret = MALLOC(sizeof(LDKListen), "LDKListen");
	*ret_ret = ChainMonitor_as_Listen(&this_arg_conv);
	return (uint64_t)ret_ret;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChainMonitor_1as_1Confirm(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKChainMonitor this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKConfirm* ret_ret = MALLOC(sizeof(LDKConfirm), "LDKConfirm");
	*ret_ret = ChainMonitor_as_Confirm(&this_arg_conv);
	return (uint64_t)ret_ret;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChainMonitor_1as_1Watch(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKChainMonitor this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKWatch* ret_ret = MALLOC(sizeof(LDKWatch), "LDKWatch");
	*ret_ret = ChainMonitor_as_Watch(&this_arg_conv);
	return (uint64_t)ret_ret;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChainMonitor_1as_1EventsProvider(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKChainMonitor this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKEventsProvider* ret_ret = MALLOC(sizeof(LDKEventsProvider), "LDKEventsProvider");
	*ret_ret = ChainMonitor_as_EventsProvider(&this_arg_conv);
	return (uint64_t)ret_ret;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelMonitorUpdate_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKChannelMonitorUpdate this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	ChannelMonitorUpdate_free(this_obj_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelMonitorUpdate_1get_1update_1id(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKChannelMonitorUpdate this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int64_t ret_val = ChannelMonitorUpdate_get_update_id(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelMonitorUpdate_1set_1update_1id(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKChannelMonitorUpdate this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	ChannelMonitorUpdate_set_update_id(&this_ptr_conv, val);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelMonitorUpdate_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKChannelMonitorUpdate orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKChannelMonitorUpdate ret_var = ChannelMonitorUpdate_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_ChannelMonitorUpdate_1write(JNIEnv *env, jclass clz, int64_t obj) {
	LDKChannelMonitorUpdate obj_conv;
	obj_conv.inner = (void*)(obj & (~1));
	obj_conv.is_owned = false;
	LDKCVec_u8Z ret_var = ChannelMonitorUpdate_write(&obj_conv);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	CVec_u8Z_free(ret_var);
	return ret_arr;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelMonitorUpdate_1read(JNIEnv *env, jclass clz, int8_tArray ser) {
	LDKu8slice ser_ref;
	ser_ref.datalen = (*env)->GetArrayLength(env, ser);
	ser_ref.data = (*env)->GetByteArrayElements (env, ser, NULL);
	LDKCResult_ChannelMonitorUpdateDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_ChannelMonitorUpdateDecodeErrorZ), "LDKCResult_ChannelMonitorUpdateDecodeErrorZ");
	*ret_conv = ChannelMonitorUpdate_read(ser_ref);
	(*env)->ReleaseByteArrayElements(env, ser, (int8_t*)ser_ref.data, 0);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_MonitorUpdateError_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKMonitorUpdateError this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	MonitorUpdateError_free(this_obj_conv);
}

JNIEXPORT jstring JNICALL Java_org_ldk_impl_bindings_MonitorUpdateError_1get_1a(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKMonitorUpdateError this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKStr ret_str = MonitorUpdateError_get_a(&this_ptr_conv);
	jstring ret_conv = str_ref_to_java(env, ret_str.chars, ret_str.len);
	Str_free(ret_str);
	return ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_MonitorUpdateError_1set_1a(JNIEnv *env, jclass clz, int64_t this_ptr, jstring val) {
	LDKMonitorUpdateError this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKStr val_conv = java_to_owned_str(env, val);
	MonitorUpdateError_set_a(&this_ptr_conv, val_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_MonitorUpdateError_1new(JNIEnv *env, jclass clz, jstring a_arg) {
	LDKStr a_arg_conv = java_to_owned_str(env, a_arg);
	LDKMonitorUpdateError ret_var = MonitorUpdateError_new(a_arg_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_MonitorUpdateError_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKMonitorUpdateError orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKMonitorUpdateError ret_var = MonitorUpdateError_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_MonitorEvent_1free(JNIEnv *env, jclass clz, int64_t this_ptr) {
	if ((this_ptr & 1) != 0) return;
	void* this_ptr_ptr = (void*)(((uint64_t)this_ptr) & ~1);
	CHECK_ACCESS(this_ptr_ptr);
	LDKMonitorEvent this_ptr_conv = *(LDKMonitorEvent*)(this_ptr_ptr);
	FREE((void*)this_ptr);
	MonitorEvent_free(this_ptr_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_MonitorEvent_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKMonitorEvent* orig_conv = (LDKMonitorEvent*)orig;
	LDKMonitorEvent *ret_copy = MALLOC(sizeof(LDKMonitorEvent), "LDKMonitorEvent");
	*ret_copy = MonitorEvent_clone(orig_conv);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_MonitorEvent_1htlcevent(JNIEnv *env, jclass clz, int64_t a) {
	LDKHTLCUpdate a_conv;
	a_conv.inner = (void*)(a & (~1));
	a_conv.is_owned = (a & 1) || (a == 0);
	a_conv = HTLCUpdate_clone(&a_conv);
	LDKMonitorEvent *ret_copy = MALLOC(sizeof(LDKMonitorEvent), "LDKMonitorEvent");
	*ret_copy = MonitorEvent_htlcevent(a_conv);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_MonitorEvent_1commitment_1tx_1confirmed(JNIEnv *env, jclass clz, int64_t a) {
	LDKOutPoint a_conv;
	a_conv.inner = (void*)(a & (~1));
	a_conv.is_owned = (a & 1) || (a == 0);
	a_conv = OutPoint_clone(&a_conv);
	LDKMonitorEvent *ret_copy = MALLOC(sizeof(LDKMonitorEvent), "LDKMonitorEvent");
	*ret_copy = MonitorEvent_commitment_tx_confirmed(a_conv);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_MonitorEvent_1update_1completed(JNIEnv *env, jclass clz, int64_t funding_txo, int64_t monitor_update_id) {
	LDKOutPoint funding_txo_conv;
	funding_txo_conv.inner = (void*)(funding_txo & (~1));
	funding_txo_conv.is_owned = (funding_txo & 1) || (funding_txo == 0);
	funding_txo_conv = OutPoint_clone(&funding_txo_conv);
	LDKMonitorEvent *ret_copy = MALLOC(sizeof(LDKMonitorEvent), "LDKMonitorEvent");
	*ret_copy = MonitorEvent_update_completed(funding_txo_conv, monitor_update_id);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_MonitorEvent_1update_1failed(JNIEnv *env, jclass clz, int64_t a) {
	LDKOutPoint a_conv;
	a_conv.inner = (void*)(a & (~1));
	a_conv.is_owned = (a & 1) || (a == 0);
	a_conv = OutPoint_clone(&a_conv);
	LDKMonitorEvent *ret_copy = MALLOC(sizeof(LDKMonitorEvent), "LDKMonitorEvent");
	*ret_copy = MonitorEvent_update_failed(a_conv);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_MonitorEvent_1write(JNIEnv *env, jclass clz, int64_t obj) {
	LDKMonitorEvent* obj_conv = (LDKMonitorEvent*)obj;
	LDKCVec_u8Z ret_var = MonitorEvent_write(obj_conv);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	CVec_u8Z_free(ret_var);
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_HTLCUpdate_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKHTLCUpdate this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	HTLCUpdate_free(this_obj_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_HTLCUpdate_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKHTLCUpdate orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKHTLCUpdate ret_var = HTLCUpdate_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_HTLCUpdate_1write(JNIEnv *env, jclass clz, int64_t obj) {
	LDKHTLCUpdate obj_conv;
	obj_conv.inner = (void*)(obj & (~1));
	obj_conv.is_owned = false;
	LDKCVec_u8Z ret_var = HTLCUpdate_write(&obj_conv);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	CVec_u8Z_free(ret_var);
	return ret_arr;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_HTLCUpdate_1read(JNIEnv *env, jclass clz, int8_tArray ser) {
	LDKu8slice ser_ref;
	ser_ref.datalen = (*env)->GetArrayLength(env, ser);
	ser_ref.data = (*env)->GetByteArrayElements (env, ser, NULL);
	LDKCResult_HTLCUpdateDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_HTLCUpdateDecodeErrorZ), "LDKCResult_HTLCUpdateDecodeErrorZ");
	*ret_conv = HTLCUpdate_read(ser_ref);
	(*env)->ReleaseByteArrayElements(env, ser, (int8_t*)ser_ref.data, 0);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_Balance_1free(JNIEnv *env, jclass clz, int64_t this_ptr) {
	if ((this_ptr & 1) != 0) return;
	void* this_ptr_ptr = (void*)(((uint64_t)this_ptr) & ~1);
	CHECK_ACCESS(this_ptr_ptr);
	LDKBalance this_ptr_conv = *(LDKBalance*)(this_ptr_ptr);
	FREE((void*)this_ptr);
	Balance_free(this_ptr_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_Balance_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKBalance* orig_conv = (LDKBalance*)orig;
	LDKBalance *ret_copy = MALLOC(sizeof(LDKBalance), "LDKBalance");
	*ret_copy = Balance_clone(orig_conv);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_Balance_1claimable_1on_1channel_1close(JNIEnv *env, jclass clz, int64_t claimable_amount_satoshis) {
	LDKBalance *ret_copy = MALLOC(sizeof(LDKBalance), "LDKBalance");
	*ret_copy = Balance_claimable_on_channel_close(claimable_amount_satoshis);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_Balance_1claimable_1awaiting_1confirmations(JNIEnv *env, jclass clz, int64_t claimable_amount_satoshis, int32_t confirmation_height) {
	LDKBalance *ret_copy = MALLOC(sizeof(LDKBalance), "LDKBalance");
	*ret_copy = Balance_claimable_awaiting_confirmations(claimable_amount_satoshis, confirmation_height);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_Balance_1contentious_1claimable(JNIEnv *env, jclass clz, int64_t claimable_amount_satoshis, int32_t timeout_height) {
	LDKBalance *ret_copy = MALLOC(sizeof(LDKBalance), "LDKBalance");
	*ret_copy = Balance_contentious_claimable(claimable_amount_satoshis, timeout_height);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_Balance_1maybe_1claimable_1htlcawaiting_1timeout(JNIEnv *env, jclass clz, int64_t claimable_amount_satoshis, int32_t claimable_height) {
	LDKBalance *ret_copy = MALLOC(sizeof(LDKBalance), "LDKBalance");
	*ret_copy = Balance_maybe_claimable_htlcawaiting_timeout(claimable_amount_satoshis, claimable_height);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_Balance_1eq(JNIEnv *env, jclass clz, int64_t a, int64_t b) {
	LDKBalance* a_conv = (LDKBalance*)a;
	LDKBalance* b_conv = (LDKBalance*)b;
	jboolean ret_val = Balance_eq(a_conv, b_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelMonitor_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKChannelMonitor this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	ChannelMonitor_free(this_obj_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelMonitor_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKChannelMonitor orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKChannelMonitor ret_var = ChannelMonitor_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_ChannelMonitor_1write(JNIEnv *env, jclass clz, int64_t obj) {
	LDKChannelMonitor obj_conv;
	obj_conv.inner = (void*)(obj & (~1));
	obj_conv.is_owned = false;
	LDKCVec_u8Z ret_var = ChannelMonitor_write(&obj_conv);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	CVec_u8Z_free(ret_var);
	return ret_arr;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelMonitor_1update_1monitor(JNIEnv *env, jclass clz, int64_t this_arg, int64_t updates, int64_t broadcaster, int64_t fee_estimator, int64_t logger) {
	LDKChannelMonitor this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKChannelMonitorUpdate updates_conv;
	updates_conv.inner = (void*)(updates & (~1));
	updates_conv.is_owned = false;
	void* broadcaster_ptr = (void*)(((uint64_t)broadcaster) & ~1);
	if (!(broadcaster & 1)) { CHECK_ACCESS(broadcaster_ptr); }
	LDKBroadcasterInterface* broadcaster_conv = (LDKBroadcasterInterface*)broadcaster_ptr;
	void* fee_estimator_ptr = (void*)(((uint64_t)fee_estimator) & ~1);
	if (!(fee_estimator & 1)) { CHECK_ACCESS(fee_estimator_ptr); }
	LDKFeeEstimator* fee_estimator_conv = (LDKFeeEstimator*)fee_estimator_ptr;
	void* logger_ptr = (void*)(((uint64_t)logger) & ~1);
	if (!(logger & 1)) { CHECK_ACCESS(logger_ptr); }
	LDKLogger* logger_conv = (LDKLogger*)logger_ptr;
	LDKCResult_NoneMonitorUpdateErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_NoneMonitorUpdateErrorZ), "LDKCResult_NoneMonitorUpdateErrorZ");
	*ret_conv = ChannelMonitor_update_monitor(&this_arg_conv, &updates_conv, broadcaster_conv, fee_estimator_conv, logger_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelMonitor_1get_1latest_1update_1id(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKChannelMonitor this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	int64_t ret_val = ChannelMonitor_get_latest_update_id(&this_arg_conv);
	return ret_val;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelMonitor_1get_1funding_1txo(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKChannelMonitor this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKC2Tuple_OutPointScriptZ* ret_conv = MALLOC(sizeof(LDKC2Tuple_OutPointScriptZ), "LDKC2Tuple_OutPointScriptZ");
	*ret_conv = ChannelMonitor_get_funding_txo(&this_arg_conv);
	return ((uint64_t)ret_conv);
}

JNIEXPORT int64_tArray JNICALL Java_org_ldk_impl_bindings_ChannelMonitor_1get_1outputs_1to_1watch(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKChannelMonitor this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKCVec_C2Tuple_TxidCVec_C2Tuple_u32ScriptZZZZ ret_var = ChannelMonitor_get_outputs_to_watch(&this_arg_conv);
	int64_tArray ret_arr = NULL;
	ret_arr = (*env)->NewLongArray(env, ret_var.datalen);
	int64_t *ret_arr_ptr = (*env)->GetPrimitiveArrayCritical(env, ret_arr, NULL);
	for (size_t o = 0; o < ret_var.datalen; o++) {
		LDKC2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ* ret_conv_40_conv = MALLOC(sizeof(LDKC2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ), "LDKC2Tuple_TxidCVec_C2Tuple_u32ScriptZZZ");
		*ret_conv_40_conv = ret_var.data[o];
		ret_arr_ptr[o] = ((uint64_t)ret_conv_40_conv);
	}
	(*env)->ReleasePrimitiveArrayCritical(env, ret_arr, ret_arr_ptr, 0);
	FREE(ret_var.data);
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelMonitor_1load_1outputs_1to_1watch(JNIEnv *env, jclass clz, int64_t this_arg, int64_t filter) {
	LDKChannelMonitor this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	void* filter_ptr = (void*)(((uint64_t)filter) & ~1);
	if (!(filter & 1)) { CHECK_ACCESS(filter_ptr); }
	LDKFilter* filter_conv = (LDKFilter*)filter_ptr;
	ChannelMonitor_load_outputs_to_watch(&this_arg_conv, filter_conv);
}

JNIEXPORT int64_tArray JNICALL Java_org_ldk_impl_bindings_ChannelMonitor_1get_1and_1clear_1pending_1monitor_1events(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKChannelMonitor this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKCVec_MonitorEventZ ret_var = ChannelMonitor_get_and_clear_pending_monitor_events(&this_arg_conv);
	int64_tArray ret_arr = NULL;
	ret_arr = (*env)->NewLongArray(env, ret_var.datalen);
	int64_t *ret_arr_ptr = (*env)->GetPrimitiveArrayCritical(env, ret_arr, NULL);
	for (size_t o = 0; o < ret_var.datalen; o++) {
		LDKMonitorEvent *ret_conv_14_copy = MALLOC(sizeof(LDKMonitorEvent), "LDKMonitorEvent");
		*ret_conv_14_copy = ret_var.data[o];
		uint64_t ret_conv_14_ref = (uint64_t)ret_conv_14_copy;
		ret_arr_ptr[o] = ret_conv_14_ref;
	}
	(*env)->ReleasePrimitiveArrayCritical(env, ret_arr, ret_arr_ptr, 0);
	FREE(ret_var.data);
	return ret_arr;
}

JNIEXPORT int64_tArray JNICALL Java_org_ldk_impl_bindings_ChannelMonitor_1get_1and_1clear_1pending_1events(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKChannelMonitor this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKCVec_EventZ ret_var = ChannelMonitor_get_and_clear_pending_events(&this_arg_conv);
	int64_tArray ret_arr = NULL;
	ret_arr = (*env)->NewLongArray(env, ret_var.datalen);
	int64_t *ret_arr_ptr = (*env)->GetPrimitiveArrayCritical(env, ret_arr, NULL);
	for (size_t h = 0; h < ret_var.datalen; h++) {
		LDKEvent *ret_conv_7_copy = MALLOC(sizeof(LDKEvent), "LDKEvent");
		*ret_conv_7_copy = ret_var.data[h];
		uint64_t ret_conv_7_ref = (uint64_t)ret_conv_7_copy;
		ret_arr_ptr[h] = ret_conv_7_ref;
	}
	(*env)->ReleasePrimitiveArrayCritical(env, ret_arr, ret_arr_ptr, 0);
	FREE(ret_var.data);
	return ret_arr;
}

JNIEXPORT jobjectArray JNICALL Java_org_ldk_impl_bindings_ChannelMonitor_1get_1latest_1holder_1commitment_1txn(JNIEnv *env, jclass clz, int64_t this_arg, int64_t logger) {
	LDKChannelMonitor this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	void* logger_ptr = (void*)(((uint64_t)logger) & ~1);
	if (!(logger & 1)) { CHECK_ACCESS(logger_ptr); }
	LDKLogger* logger_conv = (LDKLogger*)logger_ptr;
	LDKCVec_TransactionZ ret_var = ChannelMonitor_get_latest_holder_commitment_txn(&this_arg_conv, logger_conv);
	jobjectArray ret_arr = NULL;
	ret_arr = (*env)->NewObjectArray(env, ret_var.datalen, arr_of_B_clz, NULL);
	;
	for (size_t i = 0; i < ret_var.datalen; i++) {
		LDKTransaction ret_conv_8_var = ret_var.data[i];
		int8_tArray ret_conv_8_arr = (*env)->NewByteArray(env, ret_conv_8_var.datalen);
		(*env)->SetByteArrayRegion(env, ret_conv_8_arr, 0, ret_conv_8_var.datalen, ret_conv_8_var.data);
		Transaction_free(ret_conv_8_var);
		(*env)->SetObjectArrayElement(env, ret_arr, i, ret_conv_8_arr);
	}
	
	FREE(ret_var.data);
	return ret_arr;
}

JNIEXPORT int64_tArray JNICALL Java_org_ldk_impl_bindings_ChannelMonitor_1block_1connected(JNIEnv *env, jclass clz, int64_t this_arg, int8_tArray header, int64_tArray txdata, int32_t height, int64_t broadcaster, int64_t fee_estimator, int64_t logger) {
	LDKChannelMonitor this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	unsigned char header_arr[80];
	CHECK((*env)->GetArrayLength(env, header) == 80);
	(*env)->GetByteArrayRegion(env, header, 0, 80, header_arr);
	unsigned char (*header_ref)[80] = &header_arr;
	LDKCVec_C2Tuple_usizeTransactionZZ txdata_constr;
	txdata_constr.datalen = (*env)->GetArrayLength(env, txdata);
	if (txdata_constr.datalen > 0)
		txdata_constr.data = MALLOC(txdata_constr.datalen * sizeof(LDKC2Tuple_usizeTransactionZ), "LDKCVec_C2Tuple_usizeTransactionZZ Elements");
	else
		txdata_constr.data = NULL;
	int64_t* txdata_vals = (*env)->GetLongArrayElements (env, txdata, NULL);
	for (size_t c = 0; c < txdata_constr.datalen; c++) {
		int64_t txdata_conv_28 = txdata_vals[c];
		void* txdata_conv_28_ptr = (void*)(((uint64_t)txdata_conv_28) & ~1);
		CHECK_ACCESS(txdata_conv_28_ptr);
		LDKC2Tuple_usizeTransactionZ txdata_conv_28_conv = *(LDKC2Tuple_usizeTransactionZ*)(txdata_conv_28_ptr);
		txdata_conv_28_conv = C2Tuple_usizeTransactionZ_clone((LDKC2Tuple_usizeTransactionZ*)(((uint64_t)txdata_conv_28) & ~1));
		txdata_constr.data[c] = txdata_conv_28_conv;
	}
	(*env)->ReleaseLongArrayElements(env, txdata, txdata_vals, 0);
	void* broadcaster_ptr = (void*)(((uint64_t)broadcaster) & ~1);
	CHECK_ACCESS(broadcaster_ptr);
	LDKBroadcasterInterface broadcaster_conv = *(LDKBroadcasterInterface*)(broadcaster_ptr);
	if (broadcaster_conv.free == LDKBroadcasterInterface_JCalls_free) {
		// If this_arg is a JCalls struct, then we need to increment the refcnt in it.
		LDKBroadcasterInterface_JCalls_cloned(&broadcaster_conv);
	}
	void* fee_estimator_ptr = (void*)(((uint64_t)fee_estimator) & ~1);
	CHECK_ACCESS(fee_estimator_ptr);
	LDKFeeEstimator fee_estimator_conv = *(LDKFeeEstimator*)(fee_estimator_ptr);
	if (fee_estimator_conv.free == LDKFeeEstimator_JCalls_free) {
		// If this_arg is a JCalls struct, then we need to increment the refcnt in it.
		LDKFeeEstimator_JCalls_cloned(&fee_estimator_conv);
	}
	void* logger_ptr = (void*)(((uint64_t)logger) & ~1);
	CHECK_ACCESS(logger_ptr);
	LDKLogger logger_conv = *(LDKLogger*)(logger_ptr);
	if (logger_conv.free == LDKLogger_JCalls_free) {
		// If this_arg is a JCalls struct, then we need to increment the refcnt in it.
		LDKLogger_JCalls_cloned(&logger_conv);
	}
	LDKCVec_C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZZ ret_var = ChannelMonitor_block_connected(&this_arg_conv, header_ref, txdata_constr, height, broadcaster_conv, fee_estimator_conv, logger_conv);
	int64_tArray ret_arr = NULL;
	ret_arr = (*env)->NewLongArray(env, ret_var.datalen);
	int64_t *ret_arr_ptr = (*env)->GetPrimitiveArrayCritical(env, ret_arr, NULL);
	for (size_t n = 0; n < ret_var.datalen; n++) {
		LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ* ret_conv_39_conv = MALLOC(sizeof(LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ), "LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ");
		*ret_conv_39_conv = ret_var.data[n];
		ret_arr_ptr[n] = ((uint64_t)ret_conv_39_conv);
	}
	(*env)->ReleasePrimitiveArrayCritical(env, ret_arr, ret_arr_ptr, 0);
	FREE(ret_var.data);
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelMonitor_1block_1disconnected(JNIEnv *env, jclass clz, int64_t this_arg, int8_tArray header, int32_t height, int64_t broadcaster, int64_t fee_estimator, int64_t logger) {
	LDKChannelMonitor this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	unsigned char header_arr[80];
	CHECK((*env)->GetArrayLength(env, header) == 80);
	(*env)->GetByteArrayRegion(env, header, 0, 80, header_arr);
	unsigned char (*header_ref)[80] = &header_arr;
	void* broadcaster_ptr = (void*)(((uint64_t)broadcaster) & ~1);
	CHECK_ACCESS(broadcaster_ptr);
	LDKBroadcasterInterface broadcaster_conv = *(LDKBroadcasterInterface*)(broadcaster_ptr);
	if (broadcaster_conv.free == LDKBroadcasterInterface_JCalls_free) {
		// If this_arg is a JCalls struct, then we need to increment the refcnt in it.
		LDKBroadcasterInterface_JCalls_cloned(&broadcaster_conv);
	}
	void* fee_estimator_ptr = (void*)(((uint64_t)fee_estimator) & ~1);
	CHECK_ACCESS(fee_estimator_ptr);
	LDKFeeEstimator fee_estimator_conv = *(LDKFeeEstimator*)(fee_estimator_ptr);
	if (fee_estimator_conv.free == LDKFeeEstimator_JCalls_free) {
		// If this_arg is a JCalls struct, then we need to increment the refcnt in it.
		LDKFeeEstimator_JCalls_cloned(&fee_estimator_conv);
	}
	void* logger_ptr = (void*)(((uint64_t)logger) & ~1);
	CHECK_ACCESS(logger_ptr);
	LDKLogger logger_conv = *(LDKLogger*)(logger_ptr);
	if (logger_conv.free == LDKLogger_JCalls_free) {
		// If this_arg is a JCalls struct, then we need to increment the refcnt in it.
		LDKLogger_JCalls_cloned(&logger_conv);
	}
	ChannelMonitor_block_disconnected(&this_arg_conv, header_ref, height, broadcaster_conv, fee_estimator_conv, logger_conv);
}

JNIEXPORT int64_tArray JNICALL Java_org_ldk_impl_bindings_ChannelMonitor_1transactions_1confirmed(JNIEnv *env, jclass clz, int64_t this_arg, int8_tArray header, int64_tArray txdata, int32_t height, int64_t broadcaster, int64_t fee_estimator, int64_t logger) {
	LDKChannelMonitor this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	unsigned char header_arr[80];
	CHECK((*env)->GetArrayLength(env, header) == 80);
	(*env)->GetByteArrayRegion(env, header, 0, 80, header_arr);
	unsigned char (*header_ref)[80] = &header_arr;
	LDKCVec_C2Tuple_usizeTransactionZZ txdata_constr;
	txdata_constr.datalen = (*env)->GetArrayLength(env, txdata);
	if (txdata_constr.datalen > 0)
		txdata_constr.data = MALLOC(txdata_constr.datalen * sizeof(LDKC2Tuple_usizeTransactionZ), "LDKCVec_C2Tuple_usizeTransactionZZ Elements");
	else
		txdata_constr.data = NULL;
	int64_t* txdata_vals = (*env)->GetLongArrayElements (env, txdata, NULL);
	for (size_t c = 0; c < txdata_constr.datalen; c++) {
		int64_t txdata_conv_28 = txdata_vals[c];
		void* txdata_conv_28_ptr = (void*)(((uint64_t)txdata_conv_28) & ~1);
		CHECK_ACCESS(txdata_conv_28_ptr);
		LDKC2Tuple_usizeTransactionZ txdata_conv_28_conv = *(LDKC2Tuple_usizeTransactionZ*)(txdata_conv_28_ptr);
		txdata_conv_28_conv = C2Tuple_usizeTransactionZ_clone((LDKC2Tuple_usizeTransactionZ*)(((uint64_t)txdata_conv_28) & ~1));
		txdata_constr.data[c] = txdata_conv_28_conv;
	}
	(*env)->ReleaseLongArrayElements(env, txdata, txdata_vals, 0);
	void* broadcaster_ptr = (void*)(((uint64_t)broadcaster) & ~1);
	CHECK_ACCESS(broadcaster_ptr);
	LDKBroadcasterInterface broadcaster_conv = *(LDKBroadcasterInterface*)(broadcaster_ptr);
	if (broadcaster_conv.free == LDKBroadcasterInterface_JCalls_free) {
		// If this_arg is a JCalls struct, then we need to increment the refcnt in it.
		LDKBroadcasterInterface_JCalls_cloned(&broadcaster_conv);
	}
	void* fee_estimator_ptr = (void*)(((uint64_t)fee_estimator) & ~1);
	CHECK_ACCESS(fee_estimator_ptr);
	LDKFeeEstimator fee_estimator_conv = *(LDKFeeEstimator*)(fee_estimator_ptr);
	if (fee_estimator_conv.free == LDKFeeEstimator_JCalls_free) {
		// If this_arg is a JCalls struct, then we need to increment the refcnt in it.
		LDKFeeEstimator_JCalls_cloned(&fee_estimator_conv);
	}
	void* logger_ptr = (void*)(((uint64_t)logger) & ~1);
	CHECK_ACCESS(logger_ptr);
	LDKLogger logger_conv = *(LDKLogger*)(logger_ptr);
	if (logger_conv.free == LDKLogger_JCalls_free) {
		// If this_arg is a JCalls struct, then we need to increment the refcnt in it.
		LDKLogger_JCalls_cloned(&logger_conv);
	}
	LDKCVec_C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZZ ret_var = ChannelMonitor_transactions_confirmed(&this_arg_conv, header_ref, txdata_constr, height, broadcaster_conv, fee_estimator_conv, logger_conv);
	int64_tArray ret_arr = NULL;
	ret_arr = (*env)->NewLongArray(env, ret_var.datalen);
	int64_t *ret_arr_ptr = (*env)->GetPrimitiveArrayCritical(env, ret_arr, NULL);
	for (size_t n = 0; n < ret_var.datalen; n++) {
		LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ* ret_conv_39_conv = MALLOC(sizeof(LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ), "LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ");
		*ret_conv_39_conv = ret_var.data[n];
		ret_arr_ptr[n] = ((uint64_t)ret_conv_39_conv);
	}
	(*env)->ReleasePrimitiveArrayCritical(env, ret_arr, ret_arr_ptr, 0);
	FREE(ret_var.data);
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelMonitor_1transaction_1unconfirmed(JNIEnv *env, jclass clz, int64_t this_arg, int8_tArray txid, int64_t broadcaster, int64_t fee_estimator, int64_t logger) {
	LDKChannelMonitor this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	unsigned char txid_arr[32];
	CHECK((*env)->GetArrayLength(env, txid) == 32);
	(*env)->GetByteArrayRegion(env, txid, 0, 32, txid_arr);
	unsigned char (*txid_ref)[32] = &txid_arr;
	void* broadcaster_ptr = (void*)(((uint64_t)broadcaster) & ~1);
	CHECK_ACCESS(broadcaster_ptr);
	LDKBroadcasterInterface broadcaster_conv = *(LDKBroadcasterInterface*)(broadcaster_ptr);
	if (broadcaster_conv.free == LDKBroadcasterInterface_JCalls_free) {
		// If this_arg is a JCalls struct, then we need to increment the refcnt in it.
		LDKBroadcasterInterface_JCalls_cloned(&broadcaster_conv);
	}
	void* fee_estimator_ptr = (void*)(((uint64_t)fee_estimator) & ~1);
	CHECK_ACCESS(fee_estimator_ptr);
	LDKFeeEstimator fee_estimator_conv = *(LDKFeeEstimator*)(fee_estimator_ptr);
	if (fee_estimator_conv.free == LDKFeeEstimator_JCalls_free) {
		// If this_arg is a JCalls struct, then we need to increment the refcnt in it.
		LDKFeeEstimator_JCalls_cloned(&fee_estimator_conv);
	}
	void* logger_ptr = (void*)(((uint64_t)logger) & ~1);
	CHECK_ACCESS(logger_ptr);
	LDKLogger logger_conv = *(LDKLogger*)(logger_ptr);
	if (logger_conv.free == LDKLogger_JCalls_free) {
		// If this_arg is a JCalls struct, then we need to increment the refcnt in it.
		LDKLogger_JCalls_cloned(&logger_conv);
	}
	ChannelMonitor_transaction_unconfirmed(&this_arg_conv, txid_ref, broadcaster_conv, fee_estimator_conv, logger_conv);
}

JNIEXPORT int64_tArray JNICALL Java_org_ldk_impl_bindings_ChannelMonitor_1best_1block_1updated(JNIEnv *env, jclass clz, int64_t this_arg, int8_tArray header, int32_t height, int64_t broadcaster, int64_t fee_estimator, int64_t logger) {
	LDKChannelMonitor this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	unsigned char header_arr[80];
	CHECK((*env)->GetArrayLength(env, header) == 80);
	(*env)->GetByteArrayRegion(env, header, 0, 80, header_arr);
	unsigned char (*header_ref)[80] = &header_arr;
	void* broadcaster_ptr = (void*)(((uint64_t)broadcaster) & ~1);
	CHECK_ACCESS(broadcaster_ptr);
	LDKBroadcasterInterface broadcaster_conv = *(LDKBroadcasterInterface*)(broadcaster_ptr);
	if (broadcaster_conv.free == LDKBroadcasterInterface_JCalls_free) {
		// If this_arg is a JCalls struct, then we need to increment the refcnt in it.
		LDKBroadcasterInterface_JCalls_cloned(&broadcaster_conv);
	}
	void* fee_estimator_ptr = (void*)(((uint64_t)fee_estimator) & ~1);
	CHECK_ACCESS(fee_estimator_ptr);
	LDKFeeEstimator fee_estimator_conv = *(LDKFeeEstimator*)(fee_estimator_ptr);
	if (fee_estimator_conv.free == LDKFeeEstimator_JCalls_free) {
		// If this_arg is a JCalls struct, then we need to increment the refcnt in it.
		LDKFeeEstimator_JCalls_cloned(&fee_estimator_conv);
	}
	void* logger_ptr = (void*)(((uint64_t)logger) & ~1);
	CHECK_ACCESS(logger_ptr);
	LDKLogger logger_conv = *(LDKLogger*)(logger_ptr);
	if (logger_conv.free == LDKLogger_JCalls_free) {
		// If this_arg is a JCalls struct, then we need to increment the refcnt in it.
		LDKLogger_JCalls_cloned(&logger_conv);
	}
	LDKCVec_C2Tuple_TxidCVec_C2Tuple_u32TxOutZZZZ ret_var = ChannelMonitor_best_block_updated(&this_arg_conv, header_ref, height, broadcaster_conv, fee_estimator_conv, logger_conv);
	int64_tArray ret_arr = NULL;
	ret_arr = (*env)->NewLongArray(env, ret_var.datalen);
	int64_t *ret_arr_ptr = (*env)->GetPrimitiveArrayCritical(env, ret_arr, NULL);
	for (size_t n = 0; n < ret_var.datalen; n++) {
		LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ* ret_conv_39_conv = MALLOC(sizeof(LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ), "LDKC2Tuple_TxidCVec_C2Tuple_u32TxOutZZZ");
		*ret_conv_39_conv = ret_var.data[n];
		ret_arr_ptr[n] = ((uint64_t)ret_conv_39_conv);
	}
	(*env)->ReleasePrimitiveArrayCritical(env, ret_arr, ret_arr_ptr, 0);
	FREE(ret_var.data);
	return ret_arr;
}

JNIEXPORT jobjectArray JNICALL Java_org_ldk_impl_bindings_ChannelMonitor_1get_1relevant_1txids(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKChannelMonitor this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKCVec_TxidZ ret_var = ChannelMonitor_get_relevant_txids(&this_arg_conv);
	jobjectArray ret_arr = NULL;
	ret_arr = (*env)->NewObjectArray(env, ret_var.datalen, arr_of_B_clz, NULL);
	;
	for (size_t i = 0; i < ret_var.datalen; i++) {
		int8_tArray ret_conv_8_arr = (*env)->NewByteArray(env, 32);
		(*env)->SetByteArrayRegion(env, ret_conv_8_arr, 0, 32, ret_var.data[i].data);
		(*env)->SetObjectArrayElement(env, ret_arr, i, ret_conv_8_arr);
	}
	
	FREE(ret_var.data);
	return ret_arr;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelMonitor_1current_1best_1block(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKChannelMonitor this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKBestBlock ret_var = ChannelMonitor_current_best_block(&this_arg_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_tArray JNICALL Java_org_ldk_impl_bindings_ChannelMonitor_1get_1claimable_1balances(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKChannelMonitor this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKCVec_BalanceZ ret_var = ChannelMonitor_get_claimable_balances(&this_arg_conv);
	int64_tArray ret_arr = NULL;
	ret_arr = (*env)->NewLongArray(env, ret_var.datalen);
	int64_t *ret_arr_ptr = (*env)->GetPrimitiveArrayCritical(env, ret_arr, NULL);
	for (size_t j = 0; j < ret_var.datalen; j++) {
		LDKBalance *ret_conv_9_copy = MALLOC(sizeof(LDKBalance), "LDKBalance");
		*ret_conv_9_copy = ret_var.data[j];
		uint64_t ret_conv_9_ref = (uint64_t)ret_conv_9_copy;
		ret_arr_ptr[j] = ret_conv_9_ref;
	}
	(*env)->ReleasePrimitiveArrayCritical(env, ret_arr, ret_arr_ptr, 0);
	FREE(ret_var.data);
	return ret_arr;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_C2Tuple_1BlockHashChannelMonitorZ_1read(JNIEnv *env, jclass clz, int8_tArray ser, int64_t arg) {
	LDKu8slice ser_ref;
	ser_ref.datalen = (*env)->GetArrayLength(env, ser);
	ser_ref.data = (*env)->GetByteArrayElements (env, ser, NULL);
	void* arg_ptr = (void*)(((uint64_t)arg) & ~1);
	if (!(arg & 1)) { CHECK_ACCESS(arg_ptr); }
	LDKKeysInterface* arg_conv = (LDKKeysInterface*)arg_ptr;
	LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ), "LDKCResult_C2Tuple_BlockHashChannelMonitorZDecodeErrorZ");
	*ret_conv = C2Tuple_BlockHashChannelMonitorZ_read(ser_ref, arg_conv);
	(*env)->ReleaseByteArrayElements(env, ser, (int8_t*)ser_ref.data, 0);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_OutPoint_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKOutPoint this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	OutPoint_free(this_obj_conv);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_OutPoint_1get_1txid(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKOutPoint this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 32);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 32, *OutPoint_get_txid(&this_ptr_conv));
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_OutPoint_1set_1txid(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKOutPoint this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKThirtyTwoBytes val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 32);
	(*env)->GetByteArrayRegion(env, val, 0, 32, val_ref.data);
	OutPoint_set_txid(&this_ptr_conv, val_ref);
}

JNIEXPORT int16_t JNICALL Java_org_ldk_impl_bindings_OutPoint_1get_1index(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKOutPoint this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int16_t ret_val = OutPoint_get_index(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_OutPoint_1set_1index(JNIEnv *env, jclass clz, int64_t this_ptr, int16_t val) {
	LDKOutPoint this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	OutPoint_set_index(&this_ptr_conv, val);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_OutPoint_1new(JNIEnv *env, jclass clz, int8_tArray txid_arg, int16_t index_arg) {
	LDKThirtyTwoBytes txid_arg_ref;
	CHECK((*env)->GetArrayLength(env, txid_arg) == 32);
	(*env)->GetByteArrayRegion(env, txid_arg, 0, 32, txid_arg_ref.data);
	LDKOutPoint ret_var = OutPoint_new(txid_arg_ref, index_arg);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_OutPoint_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKOutPoint orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKOutPoint ret_var = OutPoint_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_OutPoint_1eq(JNIEnv *env, jclass clz, int64_t a, int64_t b) {
	LDKOutPoint a_conv;
	a_conv.inner = (void*)(a & (~1));
	a_conv.is_owned = false;
	LDKOutPoint b_conv;
	b_conv.inner = (void*)(b & (~1));
	b_conv.is_owned = false;
	jboolean ret_val = OutPoint_eq(&a_conv, &b_conv);
	return ret_val;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_OutPoint_1hash(JNIEnv *env, jclass clz, int64_t o) {
	LDKOutPoint o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = false;
	int64_t ret_val = OutPoint_hash(&o_conv);
	return ret_val;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_OutPoint_1to_1channel_1id(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKOutPoint this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 32);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 32, OutPoint_to_channel_id(&this_arg_conv).data);
	return ret_arr;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_OutPoint_1write(JNIEnv *env, jclass clz, int64_t obj) {
	LDKOutPoint obj_conv;
	obj_conv.inner = (void*)(obj & (~1));
	obj_conv.is_owned = false;
	LDKCVec_u8Z ret_var = OutPoint_write(&obj_conv);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	CVec_u8Z_free(ret_var);
	return ret_arr;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_OutPoint_1read(JNIEnv *env, jclass clz, int8_tArray ser) {
	LDKu8slice ser_ref;
	ser_ref.datalen = (*env)->GetArrayLength(env, ser);
	ser_ref.data = (*env)->GetByteArrayElements (env, ser, NULL);
	LDKCResult_OutPointDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_OutPointDecodeErrorZ), "LDKCResult_OutPointDecodeErrorZ");
	*ret_conv = OutPoint_read(ser_ref);
	(*env)->ReleaseByteArrayElements(env, ser, (int8_t*)ser_ref.data, 0);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_DelayedPaymentOutputDescriptor_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKDelayedPaymentOutputDescriptor this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	DelayedPaymentOutputDescriptor_free(this_obj_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_DelayedPaymentOutputDescriptor_1get_1outpoint(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKDelayedPaymentOutputDescriptor this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKOutPoint ret_var = DelayedPaymentOutputDescriptor_get_outpoint(&this_ptr_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_DelayedPaymentOutputDescriptor_1set_1outpoint(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKDelayedPaymentOutputDescriptor this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKOutPoint val_conv;
	val_conv.inner = (void*)(val & (~1));
	val_conv.is_owned = (val & 1) || (val == 0);
	val_conv = OutPoint_clone(&val_conv);
	DelayedPaymentOutputDescriptor_set_outpoint(&this_ptr_conv, val_conv);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_DelayedPaymentOutputDescriptor_1get_1per_1commitment_1point(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKDelayedPaymentOutputDescriptor this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 33);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 33, DelayedPaymentOutputDescriptor_get_per_commitment_point(&this_ptr_conv).compressed_form);
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_DelayedPaymentOutputDescriptor_1set_1per_1commitment_1point(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKDelayedPaymentOutputDescriptor this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKPublicKey val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 33);
	(*env)->GetByteArrayRegion(env, val, 0, 33, val_ref.compressed_form);
	DelayedPaymentOutputDescriptor_set_per_commitment_point(&this_ptr_conv, val_ref);
}

JNIEXPORT int16_t JNICALL Java_org_ldk_impl_bindings_DelayedPaymentOutputDescriptor_1get_1to_1self_1delay(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKDelayedPaymentOutputDescriptor this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int16_t ret_val = DelayedPaymentOutputDescriptor_get_to_self_delay(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_DelayedPaymentOutputDescriptor_1set_1to_1self_1delay(JNIEnv *env, jclass clz, int64_t this_ptr, int16_t val) {
	LDKDelayedPaymentOutputDescriptor this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	DelayedPaymentOutputDescriptor_set_to_self_delay(&this_ptr_conv, val);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_DelayedPaymentOutputDescriptor_1set_1output(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKDelayedPaymentOutputDescriptor this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	void* val_ptr = (void*)(((uint64_t)val) & ~1);
	CHECK_ACCESS(val_ptr);
	LDKTxOut val_conv = *(LDKTxOut*)(val_ptr);
	val_conv = TxOut_clone((LDKTxOut*)(((uint64_t)val) & ~1));
	DelayedPaymentOutputDescriptor_set_output(&this_ptr_conv, val_conv);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_DelayedPaymentOutputDescriptor_1get_1revocation_1pubkey(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKDelayedPaymentOutputDescriptor this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 33);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 33, DelayedPaymentOutputDescriptor_get_revocation_pubkey(&this_ptr_conv).compressed_form);
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_DelayedPaymentOutputDescriptor_1set_1revocation_1pubkey(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKDelayedPaymentOutputDescriptor this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKPublicKey val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 33);
	(*env)->GetByteArrayRegion(env, val, 0, 33, val_ref.compressed_form);
	DelayedPaymentOutputDescriptor_set_revocation_pubkey(&this_ptr_conv, val_ref);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_DelayedPaymentOutputDescriptor_1get_1channel_1keys_1id(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKDelayedPaymentOutputDescriptor this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 32);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 32, *DelayedPaymentOutputDescriptor_get_channel_keys_id(&this_ptr_conv));
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_DelayedPaymentOutputDescriptor_1set_1channel_1keys_1id(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKDelayedPaymentOutputDescriptor this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKThirtyTwoBytes val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 32);
	(*env)->GetByteArrayRegion(env, val, 0, 32, val_ref.data);
	DelayedPaymentOutputDescriptor_set_channel_keys_id(&this_ptr_conv, val_ref);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_DelayedPaymentOutputDescriptor_1get_1channel_1value_1satoshis(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKDelayedPaymentOutputDescriptor this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int64_t ret_val = DelayedPaymentOutputDescriptor_get_channel_value_satoshis(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_DelayedPaymentOutputDescriptor_1set_1channel_1value_1satoshis(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKDelayedPaymentOutputDescriptor this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	DelayedPaymentOutputDescriptor_set_channel_value_satoshis(&this_ptr_conv, val);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_DelayedPaymentOutputDescriptor_1new(JNIEnv *env, jclass clz, int64_t outpoint_arg, int8_tArray per_commitment_point_arg, int16_t to_self_delay_arg, int64_t output_arg, int8_tArray revocation_pubkey_arg, int8_tArray channel_keys_id_arg, int64_t channel_value_satoshis_arg) {
	LDKOutPoint outpoint_arg_conv;
	outpoint_arg_conv.inner = (void*)(outpoint_arg & (~1));
	outpoint_arg_conv.is_owned = (outpoint_arg & 1) || (outpoint_arg == 0);
	outpoint_arg_conv = OutPoint_clone(&outpoint_arg_conv);
	LDKPublicKey per_commitment_point_arg_ref;
	CHECK((*env)->GetArrayLength(env, per_commitment_point_arg) == 33);
	(*env)->GetByteArrayRegion(env, per_commitment_point_arg, 0, 33, per_commitment_point_arg_ref.compressed_form);
	void* output_arg_ptr = (void*)(((uint64_t)output_arg) & ~1);
	CHECK_ACCESS(output_arg_ptr);
	LDKTxOut output_arg_conv = *(LDKTxOut*)(output_arg_ptr);
	output_arg_conv = TxOut_clone((LDKTxOut*)(((uint64_t)output_arg) & ~1));
	LDKPublicKey revocation_pubkey_arg_ref;
	CHECK((*env)->GetArrayLength(env, revocation_pubkey_arg) == 33);
	(*env)->GetByteArrayRegion(env, revocation_pubkey_arg, 0, 33, revocation_pubkey_arg_ref.compressed_form);
	LDKThirtyTwoBytes channel_keys_id_arg_ref;
	CHECK((*env)->GetArrayLength(env, channel_keys_id_arg) == 32);
	(*env)->GetByteArrayRegion(env, channel_keys_id_arg, 0, 32, channel_keys_id_arg_ref.data);
	LDKDelayedPaymentOutputDescriptor ret_var = DelayedPaymentOutputDescriptor_new(outpoint_arg_conv, per_commitment_point_arg_ref, to_self_delay_arg, output_arg_conv, revocation_pubkey_arg_ref, channel_keys_id_arg_ref, channel_value_satoshis_arg);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_DelayedPaymentOutputDescriptor_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKDelayedPaymentOutputDescriptor orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKDelayedPaymentOutputDescriptor ret_var = DelayedPaymentOutputDescriptor_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_DelayedPaymentOutputDescriptor_1write(JNIEnv *env, jclass clz, int64_t obj) {
	LDKDelayedPaymentOutputDescriptor obj_conv;
	obj_conv.inner = (void*)(obj & (~1));
	obj_conv.is_owned = false;
	LDKCVec_u8Z ret_var = DelayedPaymentOutputDescriptor_write(&obj_conv);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	CVec_u8Z_free(ret_var);
	return ret_arr;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_DelayedPaymentOutputDescriptor_1read(JNIEnv *env, jclass clz, int8_tArray ser) {
	LDKu8slice ser_ref;
	ser_ref.datalen = (*env)->GetArrayLength(env, ser);
	ser_ref.data = (*env)->GetByteArrayElements (env, ser, NULL);
	LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ), "LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ");
	*ret_conv = DelayedPaymentOutputDescriptor_read(ser_ref);
	(*env)->ReleaseByteArrayElements(env, ser, (int8_t*)ser_ref.data, 0);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_StaticPaymentOutputDescriptor_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKStaticPaymentOutputDescriptor this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	StaticPaymentOutputDescriptor_free(this_obj_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_StaticPaymentOutputDescriptor_1get_1outpoint(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKStaticPaymentOutputDescriptor this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKOutPoint ret_var = StaticPaymentOutputDescriptor_get_outpoint(&this_ptr_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_StaticPaymentOutputDescriptor_1set_1outpoint(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKStaticPaymentOutputDescriptor this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKOutPoint val_conv;
	val_conv.inner = (void*)(val & (~1));
	val_conv.is_owned = (val & 1) || (val == 0);
	val_conv = OutPoint_clone(&val_conv);
	StaticPaymentOutputDescriptor_set_outpoint(&this_ptr_conv, val_conv);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_StaticPaymentOutputDescriptor_1set_1output(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKStaticPaymentOutputDescriptor this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	void* val_ptr = (void*)(((uint64_t)val) & ~1);
	CHECK_ACCESS(val_ptr);
	LDKTxOut val_conv = *(LDKTxOut*)(val_ptr);
	val_conv = TxOut_clone((LDKTxOut*)(((uint64_t)val) & ~1));
	StaticPaymentOutputDescriptor_set_output(&this_ptr_conv, val_conv);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_StaticPaymentOutputDescriptor_1get_1channel_1keys_1id(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKStaticPaymentOutputDescriptor this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 32);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 32, *StaticPaymentOutputDescriptor_get_channel_keys_id(&this_ptr_conv));
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_StaticPaymentOutputDescriptor_1set_1channel_1keys_1id(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKStaticPaymentOutputDescriptor this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKThirtyTwoBytes val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 32);
	(*env)->GetByteArrayRegion(env, val, 0, 32, val_ref.data);
	StaticPaymentOutputDescriptor_set_channel_keys_id(&this_ptr_conv, val_ref);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_StaticPaymentOutputDescriptor_1get_1channel_1value_1satoshis(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKStaticPaymentOutputDescriptor this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int64_t ret_val = StaticPaymentOutputDescriptor_get_channel_value_satoshis(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_StaticPaymentOutputDescriptor_1set_1channel_1value_1satoshis(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKStaticPaymentOutputDescriptor this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	StaticPaymentOutputDescriptor_set_channel_value_satoshis(&this_ptr_conv, val);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_StaticPaymentOutputDescriptor_1new(JNIEnv *env, jclass clz, int64_t outpoint_arg, int64_t output_arg, int8_tArray channel_keys_id_arg, int64_t channel_value_satoshis_arg) {
	LDKOutPoint outpoint_arg_conv;
	outpoint_arg_conv.inner = (void*)(outpoint_arg & (~1));
	outpoint_arg_conv.is_owned = (outpoint_arg & 1) || (outpoint_arg == 0);
	outpoint_arg_conv = OutPoint_clone(&outpoint_arg_conv);
	void* output_arg_ptr = (void*)(((uint64_t)output_arg) & ~1);
	CHECK_ACCESS(output_arg_ptr);
	LDKTxOut output_arg_conv = *(LDKTxOut*)(output_arg_ptr);
	output_arg_conv = TxOut_clone((LDKTxOut*)(((uint64_t)output_arg) & ~1));
	LDKThirtyTwoBytes channel_keys_id_arg_ref;
	CHECK((*env)->GetArrayLength(env, channel_keys_id_arg) == 32);
	(*env)->GetByteArrayRegion(env, channel_keys_id_arg, 0, 32, channel_keys_id_arg_ref.data);
	LDKStaticPaymentOutputDescriptor ret_var = StaticPaymentOutputDescriptor_new(outpoint_arg_conv, output_arg_conv, channel_keys_id_arg_ref, channel_value_satoshis_arg);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_StaticPaymentOutputDescriptor_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKStaticPaymentOutputDescriptor orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKStaticPaymentOutputDescriptor ret_var = StaticPaymentOutputDescriptor_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_StaticPaymentOutputDescriptor_1write(JNIEnv *env, jclass clz, int64_t obj) {
	LDKStaticPaymentOutputDescriptor obj_conv;
	obj_conv.inner = (void*)(obj & (~1));
	obj_conv.is_owned = false;
	LDKCVec_u8Z ret_var = StaticPaymentOutputDescriptor_write(&obj_conv);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	CVec_u8Z_free(ret_var);
	return ret_arr;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_StaticPaymentOutputDescriptor_1read(JNIEnv *env, jclass clz, int8_tArray ser) {
	LDKu8slice ser_ref;
	ser_ref.datalen = (*env)->GetArrayLength(env, ser);
	ser_ref.data = (*env)->GetByteArrayElements (env, ser, NULL);
	LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ), "LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ");
	*ret_conv = StaticPaymentOutputDescriptor_read(ser_ref);
	(*env)->ReleaseByteArrayElements(env, ser, (int8_t*)ser_ref.data, 0);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_SpendableOutputDescriptor_1free(JNIEnv *env, jclass clz, int64_t this_ptr) {
	if ((this_ptr & 1) != 0) return;
	void* this_ptr_ptr = (void*)(((uint64_t)this_ptr) & ~1);
	CHECK_ACCESS(this_ptr_ptr);
	LDKSpendableOutputDescriptor this_ptr_conv = *(LDKSpendableOutputDescriptor*)(this_ptr_ptr);
	FREE((void*)this_ptr);
	SpendableOutputDescriptor_free(this_ptr_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_SpendableOutputDescriptor_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKSpendableOutputDescriptor* orig_conv = (LDKSpendableOutputDescriptor*)orig;
	LDKSpendableOutputDescriptor *ret_copy = MALLOC(sizeof(LDKSpendableOutputDescriptor), "LDKSpendableOutputDescriptor");
	*ret_copy = SpendableOutputDescriptor_clone(orig_conv);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_SpendableOutputDescriptor_1static_1output(JNIEnv *env, jclass clz, int64_t outpoint, int64_t output) {
	LDKOutPoint outpoint_conv;
	outpoint_conv.inner = (void*)(outpoint & (~1));
	outpoint_conv.is_owned = (outpoint & 1) || (outpoint == 0);
	outpoint_conv = OutPoint_clone(&outpoint_conv);
	void* output_ptr = (void*)(((uint64_t)output) & ~1);
	CHECK_ACCESS(output_ptr);
	LDKTxOut output_conv = *(LDKTxOut*)(output_ptr);
	output_conv = TxOut_clone((LDKTxOut*)(((uint64_t)output) & ~1));
	LDKSpendableOutputDescriptor *ret_copy = MALLOC(sizeof(LDKSpendableOutputDescriptor), "LDKSpendableOutputDescriptor");
	*ret_copy = SpendableOutputDescriptor_static_output(outpoint_conv, output_conv);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_SpendableOutputDescriptor_1delayed_1payment_1output(JNIEnv *env, jclass clz, int64_t a) {
	LDKDelayedPaymentOutputDescriptor a_conv;
	a_conv.inner = (void*)(a & (~1));
	a_conv.is_owned = (a & 1) || (a == 0);
	a_conv = DelayedPaymentOutputDescriptor_clone(&a_conv);
	LDKSpendableOutputDescriptor *ret_copy = MALLOC(sizeof(LDKSpendableOutputDescriptor), "LDKSpendableOutputDescriptor");
	*ret_copy = SpendableOutputDescriptor_delayed_payment_output(a_conv);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_SpendableOutputDescriptor_1static_1payment_1output(JNIEnv *env, jclass clz, int64_t a) {
	LDKStaticPaymentOutputDescriptor a_conv;
	a_conv.inner = (void*)(a & (~1));
	a_conv.is_owned = (a & 1) || (a == 0);
	a_conv = StaticPaymentOutputDescriptor_clone(&a_conv);
	LDKSpendableOutputDescriptor *ret_copy = MALLOC(sizeof(LDKSpendableOutputDescriptor), "LDKSpendableOutputDescriptor");
	*ret_copy = SpendableOutputDescriptor_static_payment_output(a_conv);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_SpendableOutputDescriptor_1write(JNIEnv *env, jclass clz, int64_t obj) {
	LDKSpendableOutputDescriptor* obj_conv = (LDKSpendableOutputDescriptor*)obj;
	LDKCVec_u8Z ret_var = SpendableOutputDescriptor_write(obj_conv);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	CVec_u8Z_free(ret_var);
	return ret_arr;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_SpendableOutputDescriptor_1read(JNIEnv *env, jclass clz, int8_tArray ser) {
	LDKu8slice ser_ref;
	ser_ref.datalen = (*env)->GetArrayLength(env, ser);
	ser_ref.data = (*env)->GetByteArrayElements (env, ser, NULL);
	LDKCResult_SpendableOutputDescriptorDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_SpendableOutputDescriptorDecodeErrorZ), "LDKCResult_SpendableOutputDescriptorDecodeErrorZ");
	*ret_conv = SpendableOutputDescriptor_read(ser_ref);
	(*env)->ReleaseByteArrayElements(env, ser, (int8_t*)ser_ref.data, 0);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_BaseSign_1free(JNIEnv *env, jclass clz, int64_t this_ptr) {
	if ((this_ptr & 1) != 0) return;
	void* this_ptr_ptr = (void*)(((uint64_t)this_ptr) & ~1);
	CHECK_ACCESS(this_ptr_ptr);
	LDKBaseSign this_ptr_conv = *(LDKBaseSign*)(this_ptr_ptr);
	FREE((void*)this_ptr);
	BaseSign_free(this_ptr_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_Sign_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	void* orig_ptr = (void*)(((uint64_t)orig) & ~1);
	if (!(orig & 1)) { CHECK_ACCESS(orig_ptr); }
	LDKSign* orig_conv = (LDKSign*)orig_ptr;
	LDKSign* ret_ret = MALLOC(sizeof(LDKSign), "LDKSign");
	*ret_ret = Sign_clone(orig_conv);
	return (uint64_t)ret_ret;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_Sign_1free(JNIEnv *env, jclass clz, int64_t this_ptr) {
	if ((this_ptr & 1) != 0) return;
	void* this_ptr_ptr = (void*)(((uint64_t)this_ptr) & ~1);
	CHECK_ACCESS(this_ptr_ptr);
	LDKSign this_ptr_conv = *(LDKSign*)(this_ptr_ptr);
	FREE((void*)this_ptr);
	Sign_free(this_ptr_conv);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_KeysInterface_1free(JNIEnv *env, jclass clz, int64_t this_ptr) {
	if ((this_ptr & 1) != 0) return;
	void* this_ptr_ptr = (void*)(((uint64_t)this_ptr) & ~1);
	CHECK_ACCESS(this_ptr_ptr);
	LDKKeysInterface this_ptr_conv = *(LDKKeysInterface*)(this_ptr_ptr);
	FREE((void*)this_ptr);
	KeysInterface_free(this_ptr_conv);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_InMemorySigner_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKInMemorySigner this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	InMemorySigner_free(this_obj_conv);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_InMemorySigner_1get_1funding_1key(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKInMemorySigner this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 32);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 32, *InMemorySigner_get_funding_key(&this_ptr_conv));
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_InMemorySigner_1set_1funding_1key(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKInMemorySigner this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKSecretKey val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 32);
	(*env)->GetByteArrayRegion(env, val, 0, 32, val_ref.bytes);
	InMemorySigner_set_funding_key(&this_ptr_conv, val_ref);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_InMemorySigner_1get_1revocation_1base_1key(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKInMemorySigner this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 32);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 32, *InMemorySigner_get_revocation_base_key(&this_ptr_conv));
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_InMemorySigner_1set_1revocation_1base_1key(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKInMemorySigner this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKSecretKey val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 32);
	(*env)->GetByteArrayRegion(env, val, 0, 32, val_ref.bytes);
	InMemorySigner_set_revocation_base_key(&this_ptr_conv, val_ref);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_InMemorySigner_1get_1payment_1key(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKInMemorySigner this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 32);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 32, *InMemorySigner_get_payment_key(&this_ptr_conv));
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_InMemorySigner_1set_1payment_1key(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKInMemorySigner this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKSecretKey val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 32);
	(*env)->GetByteArrayRegion(env, val, 0, 32, val_ref.bytes);
	InMemorySigner_set_payment_key(&this_ptr_conv, val_ref);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_InMemorySigner_1get_1delayed_1payment_1base_1key(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKInMemorySigner this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 32);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 32, *InMemorySigner_get_delayed_payment_base_key(&this_ptr_conv));
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_InMemorySigner_1set_1delayed_1payment_1base_1key(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKInMemorySigner this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKSecretKey val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 32);
	(*env)->GetByteArrayRegion(env, val, 0, 32, val_ref.bytes);
	InMemorySigner_set_delayed_payment_base_key(&this_ptr_conv, val_ref);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_InMemorySigner_1get_1htlc_1base_1key(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKInMemorySigner this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 32);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 32, *InMemorySigner_get_htlc_base_key(&this_ptr_conv));
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_InMemorySigner_1set_1htlc_1base_1key(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKInMemorySigner this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKSecretKey val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 32);
	(*env)->GetByteArrayRegion(env, val, 0, 32, val_ref.bytes);
	InMemorySigner_set_htlc_base_key(&this_ptr_conv, val_ref);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_InMemorySigner_1get_1commitment_1seed(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKInMemorySigner this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 32);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 32, *InMemorySigner_get_commitment_seed(&this_ptr_conv));
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_InMemorySigner_1set_1commitment_1seed(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKInMemorySigner this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKThirtyTwoBytes val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 32);
	(*env)->GetByteArrayRegion(env, val, 0, 32, val_ref.data);
	InMemorySigner_set_commitment_seed(&this_ptr_conv, val_ref);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_InMemorySigner_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKInMemorySigner orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKInMemorySigner ret_var = InMemorySigner_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_InMemorySigner_1new(JNIEnv *env, jclass clz, int8_tArray funding_key, int8_tArray revocation_base_key, int8_tArray payment_key, int8_tArray delayed_payment_base_key, int8_tArray htlc_base_key, int8_tArray commitment_seed, int64_t channel_value_satoshis, int8_tArray channel_keys_id) {
	LDKSecretKey funding_key_ref;
	CHECK((*env)->GetArrayLength(env, funding_key) == 32);
	(*env)->GetByteArrayRegion(env, funding_key, 0, 32, funding_key_ref.bytes);
	LDKSecretKey revocation_base_key_ref;
	CHECK((*env)->GetArrayLength(env, revocation_base_key) == 32);
	(*env)->GetByteArrayRegion(env, revocation_base_key, 0, 32, revocation_base_key_ref.bytes);
	LDKSecretKey payment_key_ref;
	CHECK((*env)->GetArrayLength(env, payment_key) == 32);
	(*env)->GetByteArrayRegion(env, payment_key, 0, 32, payment_key_ref.bytes);
	LDKSecretKey delayed_payment_base_key_ref;
	CHECK((*env)->GetArrayLength(env, delayed_payment_base_key) == 32);
	(*env)->GetByteArrayRegion(env, delayed_payment_base_key, 0, 32, delayed_payment_base_key_ref.bytes);
	LDKSecretKey htlc_base_key_ref;
	CHECK((*env)->GetArrayLength(env, htlc_base_key) == 32);
	(*env)->GetByteArrayRegion(env, htlc_base_key, 0, 32, htlc_base_key_ref.bytes);
	LDKThirtyTwoBytes commitment_seed_ref;
	CHECK((*env)->GetArrayLength(env, commitment_seed) == 32);
	(*env)->GetByteArrayRegion(env, commitment_seed, 0, 32, commitment_seed_ref.data);
	LDKThirtyTwoBytes channel_keys_id_ref;
	CHECK((*env)->GetArrayLength(env, channel_keys_id) == 32);
	(*env)->GetByteArrayRegion(env, channel_keys_id, 0, 32, channel_keys_id_ref.data);
	LDKInMemorySigner ret_var = InMemorySigner_new(funding_key_ref, revocation_base_key_ref, payment_key_ref, delayed_payment_base_key_ref, htlc_base_key_ref, commitment_seed_ref, channel_value_satoshis, channel_keys_id_ref);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_InMemorySigner_1counterparty_1pubkeys(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKInMemorySigner this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKChannelPublicKeys ret_var = InMemorySigner_counterparty_pubkeys(&this_arg_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int16_t JNICALL Java_org_ldk_impl_bindings_InMemorySigner_1counterparty_1selected_1contest_1delay(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKInMemorySigner this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	int16_t ret_val = InMemorySigner_counterparty_selected_contest_delay(&this_arg_conv);
	return ret_val;
}

JNIEXPORT int16_t JNICALL Java_org_ldk_impl_bindings_InMemorySigner_1holder_1selected_1contest_1delay(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKInMemorySigner this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	int16_t ret_val = InMemorySigner_holder_selected_contest_delay(&this_arg_conv);
	return ret_val;
}

JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_InMemorySigner_1is_1outbound(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKInMemorySigner this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	jboolean ret_val = InMemorySigner_is_outbound(&this_arg_conv);
	return ret_val;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_InMemorySigner_1funding_1outpoint(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKInMemorySigner this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKOutPoint ret_var = InMemorySigner_funding_outpoint(&this_arg_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_InMemorySigner_1get_1channel_1parameters(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKInMemorySigner this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKChannelTransactionParameters ret_var = InMemorySigner_get_channel_parameters(&this_arg_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_InMemorySigner_1sign_1counterparty_1payment_1input(JNIEnv *env, jclass clz, int64_t this_arg, int8_tArray spend_tx, int64_t input_idx, int64_t descriptor) {
	LDKInMemorySigner this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKTransaction spend_tx_ref;
	spend_tx_ref.datalen = (*env)->GetArrayLength(env, spend_tx);
	spend_tx_ref.data = MALLOC(spend_tx_ref.datalen, "LDKTransaction Bytes");
	(*env)->GetByteArrayRegion(env, spend_tx, 0, spend_tx_ref.datalen, spend_tx_ref.data);
	spend_tx_ref.data_is_owned = true;
	LDKStaticPaymentOutputDescriptor descriptor_conv;
	descriptor_conv.inner = (void*)(descriptor & (~1));
	descriptor_conv.is_owned = false;
	LDKCResult_CVec_CVec_u8ZZNoneZ* ret_conv = MALLOC(sizeof(LDKCResult_CVec_CVec_u8ZZNoneZ), "LDKCResult_CVec_CVec_u8ZZNoneZ");
	*ret_conv = InMemorySigner_sign_counterparty_payment_input(&this_arg_conv, spend_tx_ref, input_idx, &descriptor_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_InMemorySigner_1sign_1dynamic_1p2wsh_1input(JNIEnv *env, jclass clz, int64_t this_arg, int8_tArray spend_tx, int64_t input_idx, int64_t descriptor) {
	LDKInMemorySigner this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKTransaction spend_tx_ref;
	spend_tx_ref.datalen = (*env)->GetArrayLength(env, spend_tx);
	spend_tx_ref.data = MALLOC(spend_tx_ref.datalen, "LDKTransaction Bytes");
	(*env)->GetByteArrayRegion(env, spend_tx, 0, spend_tx_ref.datalen, spend_tx_ref.data);
	spend_tx_ref.data_is_owned = true;
	LDKDelayedPaymentOutputDescriptor descriptor_conv;
	descriptor_conv.inner = (void*)(descriptor & (~1));
	descriptor_conv.is_owned = false;
	LDKCResult_CVec_CVec_u8ZZNoneZ* ret_conv = MALLOC(sizeof(LDKCResult_CVec_CVec_u8ZZNoneZ), "LDKCResult_CVec_CVec_u8ZZNoneZ");
	*ret_conv = InMemorySigner_sign_dynamic_p2wsh_input(&this_arg_conv, spend_tx_ref, input_idx, &descriptor_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_InMemorySigner_1as_1BaseSign(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKInMemorySigner this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKBaseSign* ret_ret = MALLOC(sizeof(LDKBaseSign), "LDKBaseSign");
	*ret_ret = InMemorySigner_as_BaseSign(&this_arg_conv);
	return (uint64_t)ret_ret;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_InMemorySigner_1as_1Sign(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKInMemorySigner this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKSign* ret_ret = MALLOC(sizeof(LDKSign), "LDKSign");
	*ret_ret = InMemorySigner_as_Sign(&this_arg_conv);
	return (uint64_t)ret_ret;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_InMemorySigner_1write(JNIEnv *env, jclass clz, int64_t obj) {
	LDKInMemorySigner obj_conv;
	obj_conv.inner = (void*)(obj & (~1));
	obj_conv.is_owned = false;
	LDKCVec_u8Z ret_var = InMemorySigner_write(&obj_conv);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	CVec_u8Z_free(ret_var);
	return ret_arr;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_InMemorySigner_1read(JNIEnv *env, jclass clz, int8_tArray ser) {
	LDKu8slice ser_ref;
	ser_ref.datalen = (*env)->GetArrayLength(env, ser);
	ser_ref.data = (*env)->GetByteArrayElements (env, ser, NULL);
	LDKCResult_InMemorySignerDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_InMemorySignerDecodeErrorZ), "LDKCResult_InMemorySignerDecodeErrorZ");
	*ret_conv = InMemorySigner_read(ser_ref);
	(*env)->ReleaseByteArrayElements(env, ser, (int8_t*)ser_ref.data, 0);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_KeysManager_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKKeysManager this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	KeysManager_free(this_obj_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_KeysManager_1new(JNIEnv *env, jclass clz, int8_tArray seed, int64_t starting_time_secs, int32_t starting_time_nanos) {
	unsigned char seed_arr[32];
	CHECK((*env)->GetArrayLength(env, seed) == 32);
	(*env)->GetByteArrayRegion(env, seed, 0, 32, seed_arr);
	unsigned char (*seed_ref)[32] = &seed_arr;
	LDKKeysManager ret_var = KeysManager_new(seed_ref, starting_time_secs, starting_time_nanos);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_KeysManager_1derive_1channel_1keys(JNIEnv *env, jclass clz, int64_t this_arg, int64_t channel_value_satoshis, int8_tArray params) {
	LDKKeysManager this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	unsigned char params_arr[32];
	CHECK((*env)->GetArrayLength(env, params) == 32);
	(*env)->GetByteArrayRegion(env, params, 0, 32, params_arr);
	unsigned char (*params_ref)[32] = &params_arr;
	LDKInMemorySigner ret_var = KeysManager_derive_channel_keys(&this_arg_conv, channel_value_satoshis, params_ref);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_KeysManager_1spend_1spendable_1outputs(JNIEnv *env, jclass clz, int64_t this_arg, int64_tArray descriptors, int64_tArray outputs, int8_tArray change_destination_script, int32_t feerate_sat_per_1000_weight) {
	LDKKeysManager this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKCVec_SpendableOutputDescriptorZ descriptors_constr;
	descriptors_constr.datalen = (*env)->GetArrayLength(env, descriptors);
	if (descriptors_constr.datalen > 0)
		descriptors_constr.data = MALLOC(descriptors_constr.datalen * sizeof(LDKSpendableOutputDescriptor), "LDKCVec_SpendableOutputDescriptorZ Elements");
	else
		descriptors_constr.data = NULL;
	int64_t* descriptors_vals = (*env)->GetLongArrayElements (env, descriptors, NULL);
	for (size_t b = 0; b < descriptors_constr.datalen; b++) {
		int64_t descriptors_conv_27 = descriptors_vals[b];
		void* descriptors_conv_27_ptr = (void*)(((uint64_t)descriptors_conv_27) & ~1);
		CHECK_ACCESS(descriptors_conv_27_ptr);
		LDKSpendableOutputDescriptor descriptors_conv_27_conv = *(LDKSpendableOutputDescriptor*)(descriptors_conv_27_ptr);
		descriptors_conv_27_conv = SpendableOutputDescriptor_clone((LDKSpendableOutputDescriptor*)(((uint64_t)descriptors_conv_27) & ~1));
		descriptors_constr.data[b] = descriptors_conv_27_conv;
	}
	(*env)->ReleaseLongArrayElements(env, descriptors, descriptors_vals, 0);
	LDKCVec_TxOutZ outputs_constr;
	outputs_constr.datalen = (*env)->GetArrayLength(env, outputs);
	if (outputs_constr.datalen > 0)
		outputs_constr.data = MALLOC(outputs_constr.datalen * sizeof(LDKTxOut), "LDKCVec_TxOutZ Elements");
	else
		outputs_constr.data = NULL;
	int64_t* outputs_vals = (*env)->GetLongArrayElements (env, outputs, NULL);
	for (size_t h = 0; h < outputs_constr.datalen; h++) {
		int64_t outputs_conv_7 = outputs_vals[h];
		void* outputs_conv_7_ptr = (void*)(((uint64_t)outputs_conv_7) & ~1);
		CHECK_ACCESS(outputs_conv_7_ptr);
		LDKTxOut outputs_conv_7_conv = *(LDKTxOut*)(outputs_conv_7_ptr);
		outputs_conv_7_conv = TxOut_clone((LDKTxOut*)(((uint64_t)outputs_conv_7) & ~1));
		outputs_constr.data[h] = outputs_conv_7_conv;
	}
	(*env)->ReleaseLongArrayElements(env, outputs, outputs_vals, 0);
	LDKCVec_u8Z change_destination_script_ref;
	change_destination_script_ref.datalen = (*env)->GetArrayLength(env, change_destination_script);
	change_destination_script_ref.data = MALLOC(change_destination_script_ref.datalen, "LDKCVec_u8Z Bytes");
	(*env)->GetByteArrayRegion(env, change_destination_script, 0, change_destination_script_ref.datalen, change_destination_script_ref.data);
	LDKCResult_TransactionNoneZ* ret_conv = MALLOC(sizeof(LDKCResult_TransactionNoneZ), "LDKCResult_TransactionNoneZ");
	*ret_conv = KeysManager_spend_spendable_outputs(&this_arg_conv, descriptors_constr, outputs_constr, change_destination_script_ref, feerate_sat_per_1000_weight);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_KeysManager_1as_1KeysInterface(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKKeysManager this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKKeysInterface* ret_ret = MALLOC(sizeof(LDKKeysInterface), "LDKKeysInterface");
	*ret_ret = KeysManager_as_KeysInterface(&this_arg_conv);
	return (uint64_t)ret_ret;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelManager_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKChannelManager this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	ChannelManager_free(this_obj_conv);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChainParameters_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKChainParameters this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	ChainParameters_free(this_obj_conv);
}

JNIEXPORT jclass JNICALL Java_org_ldk_impl_bindings_ChainParameters_1get_1network(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKChainParameters this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	jclass ret_conv = LDKNetwork_to_java(env, ChainParameters_get_network(&this_ptr_conv));
	return ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChainParameters_1set_1network(JNIEnv *env, jclass clz, int64_t this_ptr, jclass val) {
	LDKChainParameters this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKNetwork val_conv = LDKNetwork_from_java(env, val);
	ChainParameters_set_network(&this_ptr_conv, val_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChainParameters_1get_1best_1block(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKChainParameters this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKBestBlock ret_var = ChainParameters_get_best_block(&this_ptr_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChainParameters_1set_1best_1block(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKChainParameters this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKBestBlock val_conv;
	val_conv.inner = (void*)(val & (~1));
	val_conv.is_owned = (val & 1) || (val == 0);
	val_conv = BestBlock_clone(&val_conv);
	ChainParameters_set_best_block(&this_ptr_conv, val_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChainParameters_1new(JNIEnv *env, jclass clz, jclass network_arg, int64_t best_block_arg) {
	LDKNetwork network_arg_conv = LDKNetwork_from_java(env, network_arg);
	LDKBestBlock best_block_arg_conv;
	best_block_arg_conv.inner = (void*)(best_block_arg & (~1));
	best_block_arg_conv.is_owned = (best_block_arg & 1) || (best_block_arg == 0);
	best_block_arg_conv = BestBlock_clone(&best_block_arg_conv);
	LDKChainParameters ret_var = ChainParameters_new(network_arg_conv, best_block_arg_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChainParameters_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKChainParameters orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKChainParameters ret_var = ChainParameters_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CounterpartyForwardingInfo_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKCounterpartyForwardingInfo this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	CounterpartyForwardingInfo_free(this_obj_conv);
}

JNIEXPORT int32_t JNICALL Java_org_ldk_impl_bindings_CounterpartyForwardingInfo_1get_1fee_1base_1msat(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKCounterpartyForwardingInfo this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int32_t ret_val = CounterpartyForwardingInfo_get_fee_base_msat(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CounterpartyForwardingInfo_1set_1fee_1base_1msat(JNIEnv *env, jclass clz, int64_t this_ptr, int32_t val) {
	LDKCounterpartyForwardingInfo this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	CounterpartyForwardingInfo_set_fee_base_msat(&this_ptr_conv, val);
}

JNIEXPORT int32_t JNICALL Java_org_ldk_impl_bindings_CounterpartyForwardingInfo_1get_1fee_1proportional_1millionths(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKCounterpartyForwardingInfo this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int32_t ret_val = CounterpartyForwardingInfo_get_fee_proportional_millionths(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CounterpartyForwardingInfo_1set_1fee_1proportional_1millionths(JNIEnv *env, jclass clz, int64_t this_ptr, int32_t val) {
	LDKCounterpartyForwardingInfo this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	CounterpartyForwardingInfo_set_fee_proportional_millionths(&this_ptr_conv, val);
}

JNIEXPORT int16_t JNICALL Java_org_ldk_impl_bindings_CounterpartyForwardingInfo_1get_1cltv_1expiry_1delta(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKCounterpartyForwardingInfo this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int16_t ret_val = CounterpartyForwardingInfo_get_cltv_expiry_delta(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CounterpartyForwardingInfo_1set_1cltv_1expiry_1delta(JNIEnv *env, jclass clz, int64_t this_ptr, int16_t val) {
	LDKCounterpartyForwardingInfo this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	CounterpartyForwardingInfo_set_cltv_expiry_delta(&this_ptr_conv, val);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CounterpartyForwardingInfo_1new(JNIEnv *env, jclass clz, int32_t fee_base_msat_arg, int32_t fee_proportional_millionths_arg, int16_t cltv_expiry_delta_arg) {
	LDKCounterpartyForwardingInfo ret_var = CounterpartyForwardingInfo_new(fee_base_msat_arg, fee_proportional_millionths_arg, cltv_expiry_delta_arg);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CounterpartyForwardingInfo_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCounterpartyForwardingInfo orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKCounterpartyForwardingInfo ret_var = CounterpartyForwardingInfo_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelCounterparty_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKChannelCounterparty this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	ChannelCounterparty_free(this_obj_conv);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_ChannelCounterparty_1get_1node_1id(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKChannelCounterparty this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 33);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 33, ChannelCounterparty_get_node_id(&this_ptr_conv).compressed_form);
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelCounterparty_1set_1node_1id(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKChannelCounterparty this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKPublicKey val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 33);
	(*env)->GetByteArrayRegion(env, val, 0, 33, val_ref.compressed_form);
	ChannelCounterparty_set_node_id(&this_ptr_conv, val_ref);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelCounterparty_1get_1features(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKChannelCounterparty this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKInitFeatures ret_var = ChannelCounterparty_get_features(&this_ptr_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelCounterparty_1set_1features(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKChannelCounterparty this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKInitFeatures val_conv;
	val_conv.inner = (void*)(val & (~1));
	val_conv.is_owned = (val & 1) || (val == 0);
	val_conv = InitFeatures_clone(&val_conv);
	ChannelCounterparty_set_features(&this_ptr_conv, val_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelCounterparty_1get_1unspendable_1punishment_1reserve(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKChannelCounterparty this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int64_t ret_val = ChannelCounterparty_get_unspendable_punishment_reserve(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelCounterparty_1set_1unspendable_1punishment_1reserve(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKChannelCounterparty this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	ChannelCounterparty_set_unspendable_punishment_reserve(&this_ptr_conv, val);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelCounterparty_1get_1forwarding_1info(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKChannelCounterparty this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKCounterpartyForwardingInfo ret_var = ChannelCounterparty_get_forwarding_info(&this_ptr_conv);
	uint64_t ret_ref = 0;
	if ((uint64_t)ret_var.inner > 4096) {
		CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
		CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
		ret_ref = (uint64_t)ret_var.inner;
		if (ret_var.is_owned) {
			ret_ref |= 1;
		}
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelCounterparty_1set_1forwarding_1info(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKChannelCounterparty this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKCounterpartyForwardingInfo val_conv;
	val_conv.inner = (void*)(val & (~1));
	val_conv.is_owned = (val & 1) || (val == 0);
	val_conv = CounterpartyForwardingInfo_clone(&val_conv);
	ChannelCounterparty_set_forwarding_info(&this_ptr_conv, val_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelCounterparty_1new(JNIEnv *env, jclass clz, int8_tArray node_id_arg, int64_t features_arg, int64_t unspendable_punishment_reserve_arg, int64_t forwarding_info_arg) {
	LDKPublicKey node_id_arg_ref;
	CHECK((*env)->GetArrayLength(env, node_id_arg) == 33);
	(*env)->GetByteArrayRegion(env, node_id_arg, 0, 33, node_id_arg_ref.compressed_form);
	LDKInitFeatures features_arg_conv;
	features_arg_conv.inner = (void*)(features_arg & (~1));
	features_arg_conv.is_owned = (features_arg & 1) || (features_arg == 0);
	features_arg_conv = InitFeatures_clone(&features_arg_conv);
	LDKCounterpartyForwardingInfo forwarding_info_arg_conv;
	forwarding_info_arg_conv.inner = (void*)(forwarding_info_arg & (~1));
	forwarding_info_arg_conv.is_owned = (forwarding_info_arg & 1) || (forwarding_info_arg == 0);
	forwarding_info_arg_conv = CounterpartyForwardingInfo_clone(&forwarding_info_arg_conv);
	LDKChannelCounterparty ret_var = ChannelCounterparty_new(node_id_arg_ref, features_arg_conv, unspendable_punishment_reserve_arg, forwarding_info_arg_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelCounterparty_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKChannelCounterparty orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKChannelCounterparty ret_var = ChannelCounterparty_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelDetails_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKChannelDetails this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	ChannelDetails_free(this_obj_conv);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_ChannelDetails_1get_1channel_1id(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKChannelDetails this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 32);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 32, *ChannelDetails_get_channel_id(&this_ptr_conv));
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelDetails_1set_1channel_1id(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKChannelDetails this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKThirtyTwoBytes val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 32);
	(*env)->GetByteArrayRegion(env, val, 0, 32, val_ref.data);
	ChannelDetails_set_channel_id(&this_ptr_conv, val_ref);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelDetails_1get_1counterparty(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKChannelDetails this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKChannelCounterparty ret_var = ChannelDetails_get_counterparty(&this_ptr_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelDetails_1set_1counterparty(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKChannelDetails this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKChannelCounterparty val_conv;
	val_conv.inner = (void*)(val & (~1));
	val_conv.is_owned = (val & 1) || (val == 0);
	val_conv = ChannelCounterparty_clone(&val_conv);
	ChannelDetails_set_counterparty(&this_ptr_conv, val_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelDetails_1get_1funding_1txo(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKChannelDetails this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKOutPoint ret_var = ChannelDetails_get_funding_txo(&this_ptr_conv);
	uint64_t ret_ref = 0;
	if ((uint64_t)ret_var.inner > 4096) {
		CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
		CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
		ret_ref = (uint64_t)ret_var.inner;
		if (ret_var.is_owned) {
			ret_ref |= 1;
		}
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelDetails_1set_1funding_1txo(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKChannelDetails this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKOutPoint val_conv;
	val_conv.inner = (void*)(val & (~1));
	val_conv.is_owned = (val & 1) || (val == 0);
	val_conv = OutPoint_clone(&val_conv);
	ChannelDetails_set_funding_txo(&this_ptr_conv, val_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelDetails_1get_1short_1channel_1id(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKChannelDetails this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKCOption_u64Z *ret_copy = MALLOC(sizeof(LDKCOption_u64Z), "LDKCOption_u64Z");
	*ret_copy = ChannelDetails_get_short_channel_id(&this_ptr_conv);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelDetails_1set_1short_1channel_1id(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKChannelDetails this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	void* val_ptr = (void*)(((uint64_t)val) & ~1);
	CHECK_ACCESS(val_ptr);
	LDKCOption_u64Z val_conv = *(LDKCOption_u64Z*)(val_ptr);
	val_conv = COption_u64Z_clone((LDKCOption_u64Z*)(((uint64_t)val) & ~1));
	ChannelDetails_set_short_channel_id(&this_ptr_conv, val_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelDetails_1get_1channel_1value_1satoshis(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKChannelDetails this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int64_t ret_val = ChannelDetails_get_channel_value_satoshis(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelDetails_1set_1channel_1value_1satoshis(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKChannelDetails this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	ChannelDetails_set_channel_value_satoshis(&this_ptr_conv, val);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelDetails_1get_1unspendable_1punishment_1reserve(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKChannelDetails this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKCOption_u64Z *ret_copy = MALLOC(sizeof(LDKCOption_u64Z), "LDKCOption_u64Z");
	*ret_copy = ChannelDetails_get_unspendable_punishment_reserve(&this_ptr_conv);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelDetails_1set_1unspendable_1punishment_1reserve(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKChannelDetails this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	void* val_ptr = (void*)(((uint64_t)val) & ~1);
	CHECK_ACCESS(val_ptr);
	LDKCOption_u64Z val_conv = *(LDKCOption_u64Z*)(val_ptr);
	val_conv = COption_u64Z_clone((LDKCOption_u64Z*)(((uint64_t)val) & ~1));
	ChannelDetails_set_unspendable_punishment_reserve(&this_ptr_conv, val_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelDetails_1get_1user_1channel_1id(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKChannelDetails this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int64_t ret_val = ChannelDetails_get_user_channel_id(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelDetails_1set_1user_1channel_1id(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKChannelDetails this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	ChannelDetails_set_user_channel_id(&this_ptr_conv, val);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelDetails_1get_1outbound_1capacity_1msat(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKChannelDetails this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int64_t ret_val = ChannelDetails_get_outbound_capacity_msat(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelDetails_1set_1outbound_1capacity_1msat(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKChannelDetails this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	ChannelDetails_set_outbound_capacity_msat(&this_ptr_conv, val);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelDetails_1get_1inbound_1capacity_1msat(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKChannelDetails this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int64_t ret_val = ChannelDetails_get_inbound_capacity_msat(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelDetails_1set_1inbound_1capacity_1msat(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKChannelDetails this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	ChannelDetails_set_inbound_capacity_msat(&this_ptr_conv, val);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelDetails_1get_1confirmations_1required(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKChannelDetails this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKCOption_u32Z *ret_copy = MALLOC(sizeof(LDKCOption_u32Z), "LDKCOption_u32Z");
	*ret_copy = ChannelDetails_get_confirmations_required(&this_ptr_conv);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelDetails_1set_1confirmations_1required(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKChannelDetails this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	void* val_ptr = (void*)(((uint64_t)val) & ~1);
	CHECK_ACCESS(val_ptr);
	LDKCOption_u32Z val_conv = *(LDKCOption_u32Z*)(val_ptr);
	val_conv = COption_u32Z_clone((LDKCOption_u32Z*)(((uint64_t)val) & ~1));
	ChannelDetails_set_confirmations_required(&this_ptr_conv, val_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelDetails_1get_1force_1close_1spend_1delay(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKChannelDetails this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKCOption_u16Z *ret_copy = MALLOC(sizeof(LDKCOption_u16Z), "LDKCOption_u16Z");
	*ret_copy = ChannelDetails_get_force_close_spend_delay(&this_ptr_conv);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelDetails_1set_1force_1close_1spend_1delay(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKChannelDetails this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	void* val_ptr = (void*)(((uint64_t)val) & ~1);
	CHECK_ACCESS(val_ptr);
	LDKCOption_u16Z val_conv = *(LDKCOption_u16Z*)(val_ptr);
	val_conv = COption_u16Z_clone((LDKCOption_u16Z*)(((uint64_t)val) & ~1));
	ChannelDetails_set_force_close_spend_delay(&this_ptr_conv, val_conv);
}

JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_ChannelDetails_1get_1is_1outbound(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKChannelDetails this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	jboolean ret_val = ChannelDetails_get_is_outbound(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelDetails_1set_1is_1outbound(JNIEnv *env, jclass clz, int64_t this_ptr, jboolean val) {
	LDKChannelDetails this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	ChannelDetails_set_is_outbound(&this_ptr_conv, val);
}

JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_ChannelDetails_1get_1is_1funding_1locked(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKChannelDetails this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	jboolean ret_val = ChannelDetails_get_is_funding_locked(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelDetails_1set_1is_1funding_1locked(JNIEnv *env, jclass clz, int64_t this_ptr, jboolean val) {
	LDKChannelDetails this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	ChannelDetails_set_is_funding_locked(&this_ptr_conv, val);
}

JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_ChannelDetails_1get_1is_1usable(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKChannelDetails this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	jboolean ret_val = ChannelDetails_get_is_usable(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelDetails_1set_1is_1usable(JNIEnv *env, jclass clz, int64_t this_ptr, jboolean val) {
	LDKChannelDetails this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	ChannelDetails_set_is_usable(&this_ptr_conv, val);
}

JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_ChannelDetails_1get_1is_1public(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKChannelDetails this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	jboolean ret_val = ChannelDetails_get_is_public(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelDetails_1set_1is_1public(JNIEnv *env, jclass clz, int64_t this_ptr, jboolean val) {
	LDKChannelDetails this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	ChannelDetails_set_is_public(&this_ptr_conv, val);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelDetails_1new(JNIEnv *env, jclass clz, int8_tArray channel_id_arg, int64_t counterparty_arg, int64_t funding_txo_arg, int64_t short_channel_id_arg, int64_t channel_value_satoshis_arg, int64_t unspendable_punishment_reserve_arg, int64_t user_channel_id_arg, int64_t outbound_capacity_msat_arg, int64_t inbound_capacity_msat_arg, int64_t confirmations_required_arg, int64_t force_close_spend_delay_arg, jboolean is_outbound_arg, jboolean is_funding_locked_arg, jboolean is_usable_arg, jboolean is_public_arg) {
	LDKThirtyTwoBytes channel_id_arg_ref;
	CHECK((*env)->GetArrayLength(env, channel_id_arg) == 32);
	(*env)->GetByteArrayRegion(env, channel_id_arg, 0, 32, channel_id_arg_ref.data);
	LDKChannelCounterparty counterparty_arg_conv;
	counterparty_arg_conv.inner = (void*)(counterparty_arg & (~1));
	counterparty_arg_conv.is_owned = (counterparty_arg & 1) || (counterparty_arg == 0);
	counterparty_arg_conv = ChannelCounterparty_clone(&counterparty_arg_conv);
	LDKOutPoint funding_txo_arg_conv;
	funding_txo_arg_conv.inner = (void*)(funding_txo_arg & (~1));
	funding_txo_arg_conv.is_owned = (funding_txo_arg & 1) || (funding_txo_arg == 0);
	funding_txo_arg_conv = OutPoint_clone(&funding_txo_arg_conv);
	void* short_channel_id_arg_ptr = (void*)(((uint64_t)short_channel_id_arg) & ~1);
	CHECK_ACCESS(short_channel_id_arg_ptr);
	LDKCOption_u64Z short_channel_id_arg_conv = *(LDKCOption_u64Z*)(short_channel_id_arg_ptr);
	short_channel_id_arg_conv = COption_u64Z_clone((LDKCOption_u64Z*)(((uint64_t)short_channel_id_arg) & ~1));
	void* unspendable_punishment_reserve_arg_ptr = (void*)(((uint64_t)unspendable_punishment_reserve_arg) & ~1);
	CHECK_ACCESS(unspendable_punishment_reserve_arg_ptr);
	LDKCOption_u64Z unspendable_punishment_reserve_arg_conv = *(LDKCOption_u64Z*)(unspendable_punishment_reserve_arg_ptr);
	void* confirmations_required_arg_ptr = (void*)(((uint64_t)confirmations_required_arg) & ~1);
	CHECK_ACCESS(confirmations_required_arg_ptr);
	LDKCOption_u32Z confirmations_required_arg_conv = *(LDKCOption_u32Z*)(confirmations_required_arg_ptr);
	confirmations_required_arg_conv = COption_u32Z_clone((LDKCOption_u32Z*)(((uint64_t)confirmations_required_arg) & ~1));
	void* force_close_spend_delay_arg_ptr = (void*)(((uint64_t)force_close_spend_delay_arg) & ~1);
	CHECK_ACCESS(force_close_spend_delay_arg_ptr);
	LDKCOption_u16Z force_close_spend_delay_arg_conv = *(LDKCOption_u16Z*)(force_close_spend_delay_arg_ptr);
	force_close_spend_delay_arg_conv = COption_u16Z_clone((LDKCOption_u16Z*)(((uint64_t)force_close_spend_delay_arg) & ~1));
	LDKChannelDetails ret_var = ChannelDetails_new(channel_id_arg_ref, counterparty_arg_conv, funding_txo_arg_conv, short_channel_id_arg_conv, channel_value_satoshis_arg, unspendable_punishment_reserve_arg_conv, user_channel_id_arg, outbound_capacity_msat_arg, inbound_capacity_msat_arg, confirmations_required_arg_conv, force_close_spend_delay_arg_conv, is_outbound_arg, is_funding_locked_arg, is_usable_arg, is_public_arg);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelDetails_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKChannelDetails orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKChannelDetails ret_var = ChannelDetails_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_PaymentSendFailure_1free(JNIEnv *env, jclass clz, int64_t this_ptr) {
	if ((this_ptr & 1) != 0) return;
	void* this_ptr_ptr = (void*)(((uint64_t)this_ptr) & ~1);
	CHECK_ACCESS(this_ptr_ptr);
	LDKPaymentSendFailure this_ptr_conv = *(LDKPaymentSendFailure*)(this_ptr_ptr);
	FREE((void*)this_ptr);
	PaymentSendFailure_free(this_ptr_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_PaymentSendFailure_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKPaymentSendFailure* orig_conv = (LDKPaymentSendFailure*)orig;
	LDKPaymentSendFailure *ret_copy = MALLOC(sizeof(LDKPaymentSendFailure), "LDKPaymentSendFailure");
	*ret_copy = PaymentSendFailure_clone(orig_conv);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_PaymentSendFailure_1parameter_1error(JNIEnv *env, jclass clz, int64_t a) {
	void* a_ptr = (void*)(((uint64_t)a) & ~1);
	CHECK_ACCESS(a_ptr);
	LDKAPIError a_conv = *(LDKAPIError*)(a_ptr);
	a_conv = APIError_clone((LDKAPIError*)(((uint64_t)a) & ~1));
	LDKPaymentSendFailure *ret_copy = MALLOC(sizeof(LDKPaymentSendFailure), "LDKPaymentSendFailure");
	*ret_copy = PaymentSendFailure_parameter_error(a_conv);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_PaymentSendFailure_1path_1parameter_1error(JNIEnv *env, jclass clz, int64_tArray a) {
	LDKCVec_CResult_NoneAPIErrorZZ a_constr;
	a_constr.datalen = (*env)->GetArrayLength(env, a);
	if (a_constr.datalen > 0)
		a_constr.data = MALLOC(a_constr.datalen * sizeof(LDKCResult_NoneAPIErrorZ), "LDKCVec_CResult_NoneAPIErrorZZ Elements");
	else
		a_constr.data = NULL;
	int64_t* a_vals = (*env)->GetLongArrayElements (env, a, NULL);
	for (size_t w = 0; w < a_constr.datalen; w++) {
		int64_t a_conv_22 = a_vals[w];
		void* a_conv_22_ptr = (void*)(((uint64_t)a_conv_22) & ~1);
		CHECK_ACCESS(a_conv_22_ptr);
		LDKCResult_NoneAPIErrorZ a_conv_22_conv = *(LDKCResult_NoneAPIErrorZ*)(a_conv_22_ptr);
		a_conv_22_conv = CResult_NoneAPIErrorZ_clone((LDKCResult_NoneAPIErrorZ*)(((uint64_t)a_conv_22) & ~1));
		a_constr.data[w] = a_conv_22_conv;
	}
	(*env)->ReleaseLongArrayElements(env, a, a_vals, 0);
	LDKPaymentSendFailure *ret_copy = MALLOC(sizeof(LDKPaymentSendFailure), "LDKPaymentSendFailure");
	*ret_copy = PaymentSendFailure_path_parameter_error(a_constr);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_PaymentSendFailure_1all_1failed_1retry_1safe(JNIEnv *env, jclass clz, int64_tArray a) {
	LDKCVec_APIErrorZ a_constr;
	a_constr.datalen = (*env)->GetArrayLength(env, a);
	if (a_constr.datalen > 0)
		a_constr.data = MALLOC(a_constr.datalen * sizeof(LDKAPIError), "LDKCVec_APIErrorZ Elements");
	else
		a_constr.data = NULL;
	int64_t* a_vals = (*env)->GetLongArrayElements (env, a, NULL);
	for (size_t k = 0; k < a_constr.datalen; k++) {
		int64_t a_conv_10 = a_vals[k];
		void* a_conv_10_ptr = (void*)(((uint64_t)a_conv_10) & ~1);
		CHECK_ACCESS(a_conv_10_ptr);
		LDKAPIError a_conv_10_conv = *(LDKAPIError*)(a_conv_10_ptr);
		a_conv_10_conv = APIError_clone((LDKAPIError*)(((uint64_t)a_conv_10) & ~1));
		a_constr.data[k] = a_conv_10_conv;
	}
	(*env)->ReleaseLongArrayElements(env, a, a_vals, 0);
	LDKPaymentSendFailure *ret_copy = MALLOC(sizeof(LDKPaymentSendFailure), "LDKPaymentSendFailure");
	*ret_copy = PaymentSendFailure_all_failed_retry_safe(a_constr);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_PaymentSendFailure_1partial_1failure(JNIEnv *env, jclass clz, int64_tArray results, int64_t failed_paths_retry, int8_tArray payment_id) {
	LDKCVec_CResult_NoneAPIErrorZZ results_constr;
	results_constr.datalen = (*env)->GetArrayLength(env, results);
	if (results_constr.datalen > 0)
		results_constr.data = MALLOC(results_constr.datalen * sizeof(LDKCResult_NoneAPIErrorZ), "LDKCVec_CResult_NoneAPIErrorZZ Elements");
	else
		results_constr.data = NULL;
	int64_t* results_vals = (*env)->GetLongArrayElements (env, results, NULL);
	for (size_t w = 0; w < results_constr.datalen; w++) {
		int64_t results_conv_22 = results_vals[w];
		void* results_conv_22_ptr = (void*)(((uint64_t)results_conv_22) & ~1);
		CHECK_ACCESS(results_conv_22_ptr);
		LDKCResult_NoneAPIErrorZ results_conv_22_conv = *(LDKCResult_NoneAPIErrorZ*)(results_conv_22_ptr);
		results_constr.data[w] = results_conv_22_conv;
	}
	(*env)->ReleaseLongArrayElements(env, results, results_vals, 0);
	LDKRouteParameters failed_paths_retry_conv;
	failed_paths_retry_conv.inner = (void*)(failed_paths_retry & (~1));
	failed_paths_retry_conv.is_owned = (failed_paths_retry & 1) || (failed_paths_retry == 0);
	failed_paths_retry_conv = RouteParameters_clone(&failed_paths_retry_conv);
	LDKThirtyTwoBytes payment_id_ref;
	CHECK((*env)->GetArrayLength(env, payment_id) == 32);
	(*env)->GetByteArrayRegion(env, payment_id, 0, 32, payment_id_ref.data);
	LDKPaymentSendFailure *ret_copy = MALLOC(sizeof(LDKPaymentSendFailure), "LDKPaymentSendFailure");
	*ret_copy = PaymentSendFailure_partial_failure(results_constr, failed_paths_retry_conv, payment_id_ref);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelManager_1new(JNIEnv *env, jclass clz, int64_t fee_est, int64_t chain_monitor, int64_t tx_broadcaster, int64_t logger, int64_t keys_manager, int64_t config, int64_t params) {
	void* fee_est_ptr = (void*)(((uint64_t)fee_est) & ~1);
	CHECK_ACCESS(fee_est_ptr);
	LDKFeeEstimator fee_est_conv = *(LDKFeeEstimator*)(fee_est_ptr);
	if (fee_est_conv.free == LDKFeeEstimator_JCalls_free) {
		// If this_arg is a JCalls struct, then we need to increment the refcnt in it.
		LDKFeeEstimator_JCalls_cloned(&fee_est_conv);
	}
	void* chain_monitor_ptr = (void*)(((uint64_t)chain_monitor) & ~1);
	CHECK_ACCESS(chain_monitor_ptr);
	LDKWatch chain_monitor_conv = *(LDKWatch*)(chain_monitor_ptr);
	if (chain_monitor_conv.free == LDKWatch_JCalls_free) {
		// If this_arg is a JCalls struct, then we need to increment the refcnt in it.
		LDKWatch_JCalls_cloned(&chain_monitor_conv);
	}
	void* tx_broadcaster_ptr = (void*)(((uint64_t)tx_broadcaster) & ~1);
	CHECK_ACCESS(tx_broadcaster_ptr);
	LDKBroadcasterInterface tx_broadcaster_conv = *(LDKBroadcasterInterface*)(tx_broadcaster_ptr);
	if (tx_broadcaster_conv.free == LDKBroadcasterInterface_JCalls_free) {
		// If this_arg is a JCalls struct, then we need to increment the refcnt in it.
		LDKBroadcasterInterface_JCalls_cloned(&tx_broadcaster_conv);
	}
	void* logger_ptr = (void*)(((uint64_t)logger) & ~1);
	CHECK_ACCESS(logger_ptr);
	LDKLogger logger_conv = *(LDKLogger*)(logger_ptr);
	if (logger_conv.free == LDKLogger_JCalls_free) {
		// If this_arg is a JCalls struct, then we need to increment the refcnt in it.
		LDKLogger_JCalls_cloned(&logger_conv);
	}
	void* keys_manager_ptr = (void*)(((uint64_t)keys_manager) & ~1);
	CHECK_ACCESS(keys_manager_ptr);
	LDKKeysInterface keys_manager_conv = *(LDKKeysInterface*)(keys_manager_ptr);
	if (keys_manager_conv.free == LDKKeysInterface_JCalls_free) {
		// If this_arg is a JCalls struct, then we need to increment the refcnt in it.
		LDKKeysInterface_JCalls_cloned(&keys_manager_conv);
	}
	LDKUserConfig config_conv;
	config_conv.inner = (void*)(config & (~1));
	config_conv.is_owned = (config & 1) || (config == 0);
	config_conv = UserConfig_clone(&config_conv);
	LDKChainParameters params_conv;
	params_conv.inner = (void*)(params & (~1));
	params_conv.is_owned = (params & 1) || (params == 0);
	params_conv = ChainParameters_clone(&params_conv);
	LDKChannelManager ret_var = ChannelManager_new(fee_est_conv, chain_monitor_conv, tx_broadcaster_conv, logger_conv, keys_manager_conv, config_conv, params_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelManager_1get_1current_1default_1configuration(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKChannelManager this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKUserConfig ret_var = ChannelManager_get_current_default_configuration(&this_arg_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelManager_1create_1channel(JNIEnv *env, jclass clz, int64_t this_arg, int8_tArray their_network_key, int64_t channel_value_satoshis, int64_t push_msat, int64_t user_channel_id, int64_t override_config) {
	LDKChannelManager this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKPublicKey their_network_key_ref;
	CHECK((*env)->GetArrayLength(env, their_network_key) == 33);
	(*env)->GetByteArrayRegion(env, their_network_key, 0, 33, their_network_key_ref.compressed_form);
	LDKUserConfig override_config_conv;
	override_config_conv.inner = (void*)(override_config & (~1));
	override_config_conv.is_owned = (override_config & 1) || (override_config == 0);
	override_config_conv = UserConfig_clone(&override_config_conv);
	LDKCResult__u832APIErrorZ* ret_conv = MALLOC(sizeof(LDKCResult__u832APIErrorZ), "LDKCResult__u832APIErrorZ");
	*ret_conv = ChannelManager_create_channel(&this_arg_conv, their_network_key_ref, channel_value_satoshis, push_msat, user_channel_id, override_config_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_tArray JNICALL Java_org_ldk_impl_bindings_ChannelManager_1list_1channels(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKChannelManager this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKCVec_ChannelDetailsZ ret_var = ChannelManager_list_channels(&this_arg_conv);
	int64_tArray ret_arr = NULL;
	ret_arr = (*env)->NewLongArray(env, ret_var.datalen);
	int64_t *ret_arr_ptr = (*env)->GetPrimitiveArrayCritical(env, ret_arr, NULL);
	for (size_t q = 0; q < ret_var.datalen; q++) {
		LDKChannelDetails ret_conv_16_var = ret_var.data[q];
		uint64_t ret_conv_16_ref = 0;
		CHECK((((uint64_t)ret_conv_16_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
		CHECK((((uint64_t)&ret_conv_16_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
		ret_conv_16_ref = (uint64_t)ret_conv_16_var.inner;
		if (ret_conv_16_var.is_owned) {
			ret_conv_16_ref |= 1;
		}
		ret_arr_ptr[q] = ret_conv_16_ref;
	}
	(*env)->ReleasePrimitiveArrayCritical(env, ret_arr, ret_arr_ptr, 0);
	FREE(ret_var.data);
	return ret_arr;
}

JNIEXPORT int64_tArray JNICALL Java_org_ldk_impl_bindings_ChannelManager_1list_1usable_1channels(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKChannelManager this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKCVec_ChannelDetailsZ ret_var = ChannelManager_list_usable_channels(&this_arg_conv);
	int64_tArray ret_arr = NULL;
	ret_arr = (*env)->NewLongArray(env, ret_var.datalen);
	int64_t *ret_arr_ptr = (*env)->GetPrimitiveArrayCritical(env, ret_arr, NULL);
	for (size_t q = 0; q < ret_var.datalen; q++) {
		LDKChannelDetails ret_conv_16_var = ret_var.data[q];
		uint64_t ret_conv_16_ref = 0;
		CHECK((((uint64_t)ret_conv_16_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
		CHECK((((uint64_t)&ret_conv_16_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
		ret_conv_16_ref = (uint64_t)ret_conv_16_var.inner;
		if (ret_conv_16_var.is_owned) {
			ret_conv_16_ref |= 1;
		}
		ret_arr_ptr[q] = ret_conv_16_ref;
	}
	(*env)->ReleasePrimitiveArrayCritical(env, ret_arr, ret_arr_ptr, 0);
	FREE(ret_var.data);
	return ret_arr;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelManager_1close_1channel(JNIEnv *env, jclass clz, int64_t this_arg, int8_tArray channel_id) {
	LDKChannelManager this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	unsigned char channel_id_arr[32];
	CHECK((*env)->GetArrayLength(env, channel_id) == 32);
	(*env)->GetByteArrayRegion(env, channel_id, 0, 32, channel_id_arr);
	unsigned char (*channel_id_ref)[32] = &channel_id_arr;
	LDKCResult_NoneAPIErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_NoneAPIErrorZ), "LDKCResult_NoneAPIErrorZ");
	*ret_conv = ChannelManager_close_channel(&this_arg_conv, channel_id_ref);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelManager_1close_1channel_1with_1target_1feerate(JNIEnv *env, jclass clz, int64_t this_arg, int8_tArray channel_id, int32_t target_feerate_sats_per_1000_weight) {
	LDKChannelManager this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	unsigned char channel_id_arr[32];
	CHECK((*env)->GetArrayLength(env, channel_id) == 32);
	(*env)->GetByteArrayRegion(env, channel_id, 0, 32, channel_id_arr);
	unsigned char (*channel_id_ref)[32] = &channel_id_arr;
	LDKCResult_NoneAPIErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_NoneAPIErrorZ), "LDKCResult_NoneAPIErrorZ");
	*ret_conv = ChannelManager_close_channel_with_target_feerate(&this_arg_conv, channel_id_ref, target_feerate_sats_per_1000_weight);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelManager_1force_1close_1channel(JNIEnv *env, jclass clz, int64_t this_arg, int8_tArray channel_id) {
	LDKChannelManager this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	unsigned char channel_id_arr[32];
	CHECK((*env)->GetArrayLength(env, channel_id) == 32);
	(*env)->GetByteArrayRegion(env, channel_id, 0, 32, channel_id_arr);
	unsigned char (*channel_id_ref)[32] = &channel_id_arr;
	LDKCResult_NoneAPIErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_NoneAPIErrorZ), "LDKCResult_NoneAPIErrorZ");
	*ret_conv = ChannelManager_force_close_channel(&this_arg_conv, channel_id_ref);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelManager_1force_1close_1all_1channels(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKChannelManager this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	ChannelManager_force_close_all_channels(&this_arg_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelManager_1send_1payment(JNIEnv *env, jclass clz, int64_t this_arg, int64_t route, int8_tArray payment_hash, int8_tArray payment_secret) {
	LDKChannelManager this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKRoute route_conv;
	route_conv.inner = (void*)(route & (~1));
	route_conv.is_owned = false;
	LDKThirtyTwoBytes payment_hash_ref;
	CHECK((*env)->GetArrayLength(env, payment_hash) == 32);
	(*env)->GetByteArrayRegion(env, payment_hash, 0, 32, payment_hash_ref.data);
	LDKThirtyTwoBytes payment_secret_ref;
	CHECK((*env)->GetArrayLength(env, payment_secret) == 32);
	(*env)->GetByteArrayRegion(env, payment_secret, 0, 32, payment_secret_ref.data);
	LDKCResult_PaymentIdPaymentSendFailureZ* ret_conv = MALLOC(sizeof(LDKCResult_PaymentIdPaymentSendFailureZ), "LDKCResult_PaymentIdPaymentSendFailureZ");
	*ret_conv = ChannelManager_send_payment(&this_arg_conv, &route_conv, payment_hash_ref, payment_secret_ref);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelManager_1retry_1payment(JNIEnv *env, jclass clz, int64_t this_arg, int64_t route, int8_tArray payment_id) {
	LDKChannelManager this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKRoute route_conv;
	route_conv.inner = (void*)(route & (~1));
	route_conv.is_owned = false;
	LDKThirtyTwoBytes payment_id_ref;
	CHECK((*env)->GetArrayLength(env, payment_id) == 32);
	(*env)->GetByteArrayRegion(env, payment_id, 0, 32, payment_id_ref.data);
	LDKCResult_NonePaymentSendFailureZ* ret_conv = MALLOC(sizeof(LDKCResult_NonePaymentSendFailureZ), "LDKCResult_NonePaymentSendFailureZ");
	*ret_conv = ChannelManager_retry_payment(&this_arg_conv, &route_conv, payment_id_ref);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelManager_1send_1spontaneous_1payment(JNIEnv *env, jclass clz, int64_t this_arg, int64_t route, int8_tArray payment_preimage) {
	LDKChannelManager this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKRoute route_conv;
	route_conv.inner = (void*)(route & (~1));
	route_conv.is_owned = false;
	LDKThirtyTwoBytes payment_preimage_ref;
	CHECK((*env)->GetArrayLength(env, payment_preimage) == 32);
	(*env)->GetByteArrayRegion(env, payment_preimage, 0, 32, payment_preimage_ref.data);
	LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ* ret_conv = MALLOC(sizeof(LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ), "LDKCResult_C2Tuple_PaymentHashPaymentIdZPaymentSendFailureZ");
	*ret_conv = ChannelManager_send_spontaneous_payment(&this_arg_conv, &route_conv, payment_preimage_ref);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelManager_1funding_1transaction_1generated(JNIEnv *env, jclass clz, int64_t this_arg, int8_tArray temporary_channel_id, int8_tArray funding_transaction) {
	LDKChannelManager this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	unsigned char temporary_channel_id_arr[32];
	CHECK((*env)->GetArrayLength(env, temporary_channel_id) == 32);
	(*env)->GetByteArrayRegion(env, temporary_channel_id, 0, 32, temporary_channel_id_arr);
	unsigned char (*temporary_channel_id_ref)[32] = &temporary_channel_id_arr;
	LDKTransaction funding_transaction_ref;
	funding_transaction_ref.datalen = (*env)->GetArrayLength(env, funding_transaction);
	funding_transaction_ref.data = MALLOC(funding_transaction_ref.datalen, "LDKTransaction Bytes");
	(*env)->GetByteArrayRegion(env, funding_transaction, 0, funding_transaction_ref.datalen, funding_transaction_ref.data);
	funding_transaction_ref.data_is_owned = true;
	LDKCResult_NoneAPIErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_NoneAPIErrorZ), "LDKCResult_NoneAPIErrorZ");
	*ret_conv = ChannelManager_funding_transaction_generated(&this_arg_conv, temporary_channel_id_ref, funding_transaction_ref);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelManager_1broadcast_1node_1announcement(JNIEnv *env, jclass clz, int64_t this_arg, int8_tArray rgb, int8_tArray alias, int64_tArray addresses) {
	LDKChannelManager this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKThreeBytes rgb_ref;
	CHECK((*env)->GetArrayLength(env, rgb) == 3);
	(*env)->GetByteArrayRegion(env, rgb, 0, 3, rgb_ref.data);
	LDKThirtyTwoBytes alias_ref;
	CHECK((*env)->GetArrayLength(env, alias) == 32);
	(*env)->GetByteArrayRegion(env, alias, 0, 32, alias_ref.data);
	LDKCVec_NetAddressZ addresses_constr;
	addresses_constr.datalen = (*env)->GetArrayLength(env, addresses);
	if (addresses_constr.datalen > 0)
		addresses_constr.data = MALLOC(addresses_constr.datalen * sizeof(LDKNetAddress), "LDKCVec_NetAddressZ Elements");
	else
		addresses_constr.data = NULL;
	int64_t* addresses_vals = (*env)->GetLongArrayElements (env, addresses, NULL);
	for (size_t m = 0; m < addresses_constr.datalen; m++) {
		int64_t addresses_conv_12 = addresses_vals[m];
		void* addresses_conv_12_ptr = (void*)(((uint64_t)addresses_conv_12) & ~1);
		CHECK_ACCESS(addresses_conv_12_ptr);
		LDKNetAddress addresses_conv_12_conv = *(LDKNetAddress*)(addresses_conv_12_ptr);
		addresses_constr.data[m] = addresses_conv_12_conv;
	}
	(*env)->ReleaseLongArrayElements(env, addresses, addresses_vals, 0);
	ChannelManager_broadcast_node_announcement(&this_arg_conv, rgb_ref, alias_ref, addresses_constr);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelManager_1process_1pending_1htlc_1forwards(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKChannelManager this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	ChannelManager_process_pending_htlc_forwards(&this_arg_conv);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelManager_1timer_1tick_1occurred(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKChannelManager this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	ChannelManager_timer_tick_occurred(&this_arg_conv);
}

JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_ChannelManager_1fail_1htlc_1backwards(JNIEnv *env, jclass clz, int64_t this_arg, int8_tArray payment_hash) {
	LDKChannelManager this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	unsigned char payment_hash_arr[32];
	CHECK((*env)->GetArrayLength(env, payment_hash) == 32);
	(*env)->GetByteArrayRegion(env, payment_hash, 0, 32, payment_hash_arr);
	unsigned char (*payment_hash_ref)[32] = &payment_hash_arr;
	jboolean ret_val = ChannelManager_fail_htlc_backwards(&this_arg_conv, payment_hash_ref);
	return ret_val;
}

JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_ChannelManager_1claim_1funds(JNIEnv *env, jclass clz, int64_t this_arg, int8_tArray payment_preimage) {
	LDKChannelManager this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKThirtyTwoBytes payment_preimage_ref;
	CHECK((*env)->GetArrayLength(env, payment_preimage) == 32);
	(*env)->GetByteArrayRegion(env, payment_preimage, 0, 32, payment_preimage_ref.data);
	jboolean ret_val = ChannelManager_claim_funds(&this_arg_conv, payment_preimage_ref);
	return ret_val;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_ChannelManager_1get_1our_1node_1id(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKChannelManager this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 33);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 33, ChannelManager_get_our_node_id(&this_arg_conv).compressed_form);
	return ret_arr;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelManager_1create_1inbound_1payment(JNIEnv *env, jclass clz, int64_t this_arg, int64_t min_value_msat, int32_t invoice_expiry_delta_secs, int64_t user_payment_id) {
	LDKChannelManager this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	void* min_value_msat_ptr = (void*)(((uint64_t)min_value_msat) & ~1);
	CHECK_ACCESS(min_value_msat_ptr);
	LDKCOption_u64Z min_value_msat_conv = *(LDKCOption_u64Z*)(min_value_msat_ptr);
	min_value_msat_conv = COption_u64Z_clone((LDKCOption_u64Z*)(((uint64_t)min_value_msat) & ~1));
	LDKC2Tuple_PaymentHashPaymentSecretZ* ret_conv = MALLOC(sizeof(LDKC2Tuple_PaymentHashPaymentSecretZ), "LDKC2Tuple_PaymentHashPaymentSecretZ");
	*ret_conv = ChannelManager_create_inbound_payment(&this_arg_conv, min_value_msat_conv, invoice_expiry_delta_secs, user_payment_id);
	return ((uint64_t)ret_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelManager_1create_1inbound_1payment_1for_1hash(JNIEnv *env, jclass clz, int64_t this_arg, int8_tArray payment_hash, int64_t min_value_msat, int32_t invoice_expiry_delta_secs, int64_t user_payment_id) {
	LDKChannelManager this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKThirtyTwoBytes payment_hash_ref;
	CHECK((*env)->GetArrayLength(env, payment_hash) == 32);
	(*env)->GetByteArrayRegion(env, payment_hash, 0, 32, payment_hash_ref.data);
	void* min_value_msat_ptr = (void*)(((uint64_t)min_value_msat) & ~1);
	CHECK_ACCESS(min_value_msat_ptr);
	LDKCOption_u64Z min_value_msat_conv = *(LDKCOption_u64Z*)(min_value_msat_ptr);
	min_value_msat_conv = COption_u64Z_clone((LDKCOption_u64Z*)(((uint64_t)min_value_msat) & ~1));
	LDKCResult_PaymentSecretAPIErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_PaymentSecretAPIErrorZ), "LDKCResult_PaymentSecretAPIErrorZ");
	*ret_conv = ChannelManager_create_inbound_payment_for_hash(&this_arg_conv, payment_hash_ref, min_value_msat_conv, invoice_expiry_delta_secs, user_payment_id);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelManager_1as_1MessageSendEventsProvider(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKChannelManager this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKMessageSendEventsProvider* ret_ret = MALLOC(sizeof(LDKMessageSendEventsProvider), "LDKMessageSendEventsProvider");
	*ret_ret = ChannelManager_as_MessageSendEventsProvider(&this_arg_conv);
	return (uint64_t)ret_ret;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelManager_1as_1EventsProvider(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKChannelManager this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKEventsProvider* ret_ret = MALLOC(sizeof(LDKEventsProvider), "LDKEventsProvider");
	*ret_ret = ChannelManager_as_EventsProvider(&this_arg_conv);
	return (uint64_t)ret_ret;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelManager_1as_1Listen(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKChannelManager this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKListen* ret_ret = MALLOC(sizeof(LDKListen), "LDKListen");
	*ret_ret = ChannelManager_as_Listen(&this_arg_conv);
	return (uint64_t)ret_ret;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelManager_1as_1Confirm(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKChannelManager this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKConfirm* ret_ret = MALLOC(sizeof(LDKConfirm), "LDKConfirm");
	*ret_ret = ChannelManager_as_Confirm(&this_arg_conv);
	return (uint64_t)ret_ret;
}

JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_ChannelManager_1await_1persistable_1update_1timeout(JNIEnv *env, jclass clz, int64_t this_arg, int64_t max_wait) {
	LDKChannelManager this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	jboolean ret_val = ChannelManager_await_persistable_update_timeout(&this_arg_conv, max_wait);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelManager_1await_1persistable_1update(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKChannelManager this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	ChannelManager_await_persistable_update(&this_arg_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelManager_1current_1best_1block(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKChannelManager this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKBestBlock ret_var = ChannelManager_current_best_block(&this_arg_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelManager_1as_1ChannelMessageHandler(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKChannelManager this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKChannelMessageHandler* ret_ret = MALLOC(sizeof(LDKChannelMessageHandler), "LDKChannelMessageHandler");
	*ret_ret = ChannelManager_as_ChannelMessageHandler(&this_arg_conv);
	return (uint64_t)ret_ret;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_ChannelManager_1write(JNIEnv *env, jclass clz, int64_t obj) {
	LDKChannelManager obj_conv;
	obj_conv.inner = (void*)(obj & (~1));
	obj_conv.is_owned = false;
	LDKCVec_u8Z ret_var = ChannelManager_write(&obj_conv);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	CVec_u8Z_free(ret_var);
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelManagerReadArgs_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKChannelManagerReadArgs this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	ChannelManagerReadArgs_free(this_obj_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelManagerReadArgs_1get_1keys_1manager(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKChannelManagerReadArgs this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	uint64_t ret_ret = ((uint64_t)ChannelManagerReadArgs_get_keys_manager(&this_ptr_conv))|1;
	return ret_ret;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelManagerReadArgs_1set_1keys_1manager(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKChannelManagerReadArgs this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	void* val_ptr = (void*)(((uint64_t)val) & ~1);
	CHECK_ACCESS(val_ptr);
	LDKKeysInterface val_conv = *(LDKKeysInterface*)(val_ptr);
	if (val_conv.free == LDKKeysInterface_JCalls_free) {
		// If this_arg is a JCalls struct, then we need to increment the refcnt in it.
		LDKKeysInterface_JCalls_cloned(&val_conv);
	}
	ChannelManagerReadArgs_set_keys_manager(&this_ptr_conv, val_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelManagerReadArgs_1get_1fee_1estimator(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKChannelManagerReadArgs this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	uint64_t ret_ret = ((uint64_t)ChannelManagerReadArgs_get_fee_estimator(&this_ptr_conv))|1;
	return ret_ret;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelManagerReadArgs_1set_1fee_1estimator(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKChannelManagerReadArgs this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	void* val_ptr = (void*)(((uint64_t)val) & ~1);
	CHECK_ACCESS(val_ptr);
	LDKFeeEstimator val_conv = *(LDKFeeEstimator*)(val_ptr);
	if (val_conv.free == LDKFeeEstimator_JCalls_free) {
		// If this_arg is a JCalls struct, then we need to increment the refcnt in it.
		LDKFeeEstimator_JCalls_cloned(&val_conv);
	}
	ChannelManagerReadArgs_set_fee_estimator(&this_ptr_conv, val_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelManagerReadArgs_1get_1chain_1monitor(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKChannelManagerReadArgs this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	uint64_t ret_ret = ((uint64_t)ChannelManagerReadArgs_get_chain_monitor(&this_ptr_conv))|1;
	return ret_ret;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelManagerReadArgs_1set_1chain_1monitor(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKChannelManagerReadArgs this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	void* val_ptr = (void*)(((uint64_t)val) & ~1);
	CHECK_ACCESS(val_ptr);
	LDKWatch val_conv = *(LDKWatch*)(val_ptr);
	if (val_conv.free == LDKWatch_JCalls_free) {
		// If this_arg is a JCalls struct, then we need to increment the refcnt in it.
		LDKWatch_JCalls_cloned(&val_conv);
	}
	ChannelManagerReadArgs_set_chain_monitor(&this_ptr_conv, val_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelManagerReadArgs_1get_1tx_1broadcaster(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKChannelManagerReadArgs this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	uint64_t ret_ret = ((uint64_t)ChannelManagerReadArgs_get_tx_broadcaster(&this_ptr_conv))|1;
	return ret_ret;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelManagerReadArgs_1set_1tx_1broadcaster(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKChannelManagerReadArgs this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	void* val_ptr = (void*)(((uint64_t)val) & ~1);
	CHECK_ACCESS(val_ptr);
	LDKBroadcasterInterface val_conv = *(LDKBroadcasterInterface*)(val_ptr);
	if (val_conv.free == LDKBroadcasterInterface_JCalls_free) {
		// If this_arg is a JCalls struct, then we need to increment the refcnt in it.
		LDKBroadcasterInterface_JCalls_cloned(&val_conv);
	}
	ChannelManagerReadArgs_set_tx_broadcaster(&this_ptr_conv, val_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelManagerReadArgs_1get_1logger(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKChannelManagerReadArgs this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	uint64_t ret_ret = ((uint64_t)ChannelManagerReadArgs_get_logger(&this_ptr_conv))|1;
	return ret_ret;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelManagerReadArgs_1set_1logger(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKChannelManagerReadArgs this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	void* val_ptr = (void*)(((uint64_t)val) & ~1);
	CHECK_ACCESS(val_ptr);
	LDKLogger val_conv = *(LDKLogger*)(val_ptr);
	if (val_conv.free == LDKLogger_JCalls_free) {
		// If this_arg is a JCalls struct, then we need to increment the refcnt in it.
		LDKLogger_JCalls_cloned(&val_conv);
	}
	ChannelManagerReadArgs_set_logger(&this_ptr_conv, val_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelManagerReadArgs_1get_1default_1config(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKChannelManagerReadArgs this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKUserConfig ret_var = ChannelManagerReadArgs_get_default_config(&this_ptr_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelManagerReadArgs_1set_1default_1config(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKChannelManagerReadArgs this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKUserConfig val_conv;
	val_conv.inner = (void*)(val & (~1));
	val_conv.is_owned = (val & 1) || (val == 0);
	val_conv = UserConfig_clone(&val_conv);
	ChannelManagerReadArgs_set_default_config(&this_ptr_conv, val_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelManagerReadArgs_1new(JNIEnv *env, jclass clz, int64_t keys_manager, int64_t fee_estimator, int64_t chain_monitor, int64_t tx_broadcaster, int64_t logger, int64_t default_config, int64_tArray channel_monitors) {
	void* keys_manager_ptr = (void*)(((uint64_t)keys_manager) & ~1);
	CHECK_ACCESS(keys_manager_ptr);
	LDKKeysInterface keys_manager_conv = *(LDKKeysInterface*)(keys_manager_ptr);
	if (keys_manager_conv.free == LDKKeysInterface_JCalls_free) {
		// If this_arg is a JCalls struct, then we need to increment the refcnt in it.
		LDKKeysInterface_JCalls_cloned(&keys_manager_conv);
	}
	void* fee_estimator_ptr = (void*)(((uint64_t)fee_estimator) & ~1);
	CHECK_ACCESS(fee_estimator_ptr);
	LDKFeeEstimator fee_estimator_conv = *(LDKFeeEstimator*)(fee_estimator_ptr);
	if (fee_estimator_conv.free == LDKFeeEstimator_JCalls_free) {
		// If this_arg is a JCalls struct, then we need to increment the refcnt in it.
		LDKFeeEstimator_JCalls_cloned(&fee_estimator_conv);
	}
	void* chain_monitor_ptr = (void*)(((uint64_t)chain_monitor) & ~1);
	CHECK_ACCESS(chain_monitor_ptr);
	LDKWatch chain_monitor_conv = *(LDKWatch*)(chain_monitor_ptr);
	if (chain_monitor_conv.free == LDKWatch_JCalls_free) {
		// If this_arg is a JCalls struct, then we need to increment the refcnt in it.
		LDKWatch_JCalls_cloned(&chain_monitor_conv);
	}
	void* tx_broadcaster_ptr = (void*)(((uint64_t)tx_broadcaster) & ~1);
	CHECK_ACCESS(tx_broadcaster_ptr);
	LDKBroadcasterInterface tx_broadcaster_conv = *(LDKBroadcasterInterface*)(tx_broadcaster_ptr);
	if (tx_broadcaster_conv.free == LDKBroadcasterInterface_JCalls_free) {
		// If this_arg is a JCalls struct, then we need to increment the refcnt in it.
		LDKBroadcasterInterface_JCalls_cloned(&tx_broadcaster_conv);
	}
	void* logger_ptr = (void*)(((uint64_t)logger) & ~1);
	CHECK_ACCESS(logger_ptr);
	LDKLogger logger_conv = *(LDKLogger*)(logger_ptr);
	if (logger_conv.free == LDKLogger_JCalls_free) {
		// If this_arg is a JCalls struct, then we need to increment the refcnt in it.
		LDKLogger_JCalls_cloned(&logger_conv);
	}
	LDKUserConfig default_config_conv;
	default_config_conv.inner = (void*)(default_config & (~1));
	default_config_conv.is_owned = (default_config & 1) || (default_config == 0);
	default_config_conv = UserConfig_clone(&default_config_conv);
	LDKCVec_ChannelMonitorZ channel_monitors_constr;
	channel_monitors_constr.datalen = (*env)->GetArrayLength(env, channel_monitors);
	if (channel_monitors_constr.datalen > 0)
		channel_monitors_constr.data = MALLOC(channel_monitors_constr.datalen * sizeof(LDKChannelMonitor), "LDKCVec_ChannelMonitorZ Elements");
	else
		channel_monitors_constr.data = NULL;
	int64_t* channel_monitors_vals = (*env)->GetLongArrayElements (env, channel_monitors, NULL);
	for (size_t q = 0; q < channel_monitors_constr.datalen; q++) {
		int64_t channel_monitors_conv_16 = channel_monitors_vals[q];
		LDKChannelMonitor channel_monitors_conv_16_conv;
		channel_monitors_conv_16_conv.inner = (void*)(channel_monitors_conv_16 & (~1));
		channel_monitors_conv_16_conv.is_owned = (channel_monitors_conv_16 & 1) || (channel_monitors_conv_16 == 0);
		channel_monitors_constr.data[q] = channel_monitors_conv_16_conv;
	}
	(*env)->ReleaseLongArrayElements(env, channel_monitors, channel_monitors_vals, 0);
	LDKChannelManagerReadArgs ret_var = ChannelManagerReadArgs_new(keys_manager_conv, fee_estimator_conv, chain_monitor_conv, tx_broadcaster_conv, logger_conv, default_config_conv, channel_monitors_constr);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_C2Tuple_1BlockHashChannelManagerZ_1read(JNIEnv *env, jclass clz, int8_tArray ser, int64_t arg) {
	LDKu8slice ser_ref;
	ser_ref.datalen = (*env)->GetArrayLength(env, ser);
	ser_ref.data = (*env)->GetByteArrayElements (env, ser, NULL);
	LDKChannelManagerReadArgs arg_conv;
	arg_conv.inner = (void*)(arg & (~1));
	arg_conv.is_owned = (arg & 1) || (arg == 0);
	// Warning: we need a move here but no clone is available for LDKChannelManagerReadArgs
	LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ), "LDKCResult_C2Tuple_BlockHashChannelManagerZDecodeErrorZ");
	*ret_conv = C2Tuple_BlockHashChannelManagerZ_read(ser_ref, arg_conv);
	(*env)->ReleaseByteArrayElements(env, ser, (int8_t*)ser_ref.data, 0);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_DecodeError_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKDecodeError this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	DecodeError_free(this_obj_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_DecodeError_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKDecodeError orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKDecodeError ret_var = DecodeError_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_Init_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKInit this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	Init_free(this_obj_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_Init_1get_1features(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKInit this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKInitFeatures ret_var = Init_get_features(&this_ptr_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_Init_1set_1features(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKInit this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKInitFeatures val_conv;
	val_conv.inner = (void*)(val & (~1));
	val_conv.is_owned = (val & 1) || (val == 0);
	val_conv = InitFeatures_clone(&val_conv);
	Init_set_features(&this_ptr_conv, val_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_Init_1new(JNIEnv *env, jclass clz, int64_t features_arg) {
	LDKInitFeatures features_arg_conv;
	features_arg_conv.inner = (void*)(features_arg & (~1));
	features_arg_conv.is_owned = (features_arg & 1) || (features_arg == 0);
	features_arg_conv = InitFeatures_clone(&features_arg_conv);
	LDKInit ret_var = Init_new(features_arg_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_Init_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKInit orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKInit ret_var = Init_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ErrorMessage_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKErrorMessage this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	ErrorMessage_free(this_obj_conv);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_ErrorMessage_1get_1channel_1id(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKErrorMessage this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 32);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 32, *ErrorMessage_get_channel_id(&this_ptr_conv));
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ErrorMessage_1set_1channel_1id(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKErrorMessage this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKThirtyTwoBytes val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 32);
	(*env)->GetByteArrayRegion(env, val, 0, 32, val_ref.data);
	ErrorMessage_set_channel_id(&this_ptr_conv, val_ref);
}

JNIEXPORT jstring JNICALL Java_org_ldk_impl_bindings_ErrorMessage_1get_1data(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKErrorMessage this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKStr ret_str = ErrorMessage_get_data(&this_ptr_conv);
	jstring ret_conv = str_ref_to_java(env, ret_str.chars, ret_str.len);
	Str_free(ret_str);
	return ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ErrorMessage_1set_1data(JNIEnv *env, jclass clz, int64_t this_ptr, jstring val) {
	LDKErrorMessage this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKStr val_conv = java_to_owned_str(env, val);
	ErrorMessage_set_data(&this_ptr_conv, val_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ErrorMessage_1new(JNIEnv *env, jclass clz, int8_tArray channel_id_arg, jstring data_arg) {
	LDKThirtyTwoBytes channel_id_arg_ref;
	CHECK((*env)->GetArrayLength(env, channel_id_arg) == 32);
	(*env)->GetByteArrayRegion(env, channel_id_arg, 0, 32, channel_id_arg_ref.data);
	LDKStr data_arg_conv = java_to_owned_str(env, data_arg);
	LDKErrorMessage ret_var = ErrorMessage_new(channel_id_arg_ref, data_arg_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ErrorMessage_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKErrorMessage orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKErrorMessage ret_var = ErrorMessage_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_Ping_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKPing this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	Ping_free(this_obj_conv);
}

JNIEXPORT int16_t JNICALL Java_org_ldk_impl_bindings_Ping_1get_1ponglen(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKPing this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int16_t ret_val = Ping_get_ponglen(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_Ping_1set_1ponglen(JNIEnv *env, jclass clz, int64_t this_ptr, int16_t val) {
	LDKPing this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	Ping_set_ponglen(&this_ptr_conv, val);
}

JNIEXPORT int16_t JNICALL Java_org_ldk_impl_bindings_Ping_1get_1byteslen(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKPing this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int16_t ret_val = Ping_get_byteslen(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_Ping_1set_1byteslen(JNIEnv *env, jclass clz, int64_t this_ptr, int16_t val) {
	LDKPing this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	Ping_set_byteslen(&this_ptr_conv, val);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_Ping_1new(JNIEnv *env, jclass clz, int16_t ponglen_arg, int16_t byteslen_arg) {
	LDKPing ret_var = Ping_new(ponglen_arg, byteslen_arg);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_Ping_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKPing orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKPing ret_var = Ping_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_Pong_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKPong this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	Pong_free(this_obj_conv);
}

JNIEXPORT int16_t JNICALL Java_org_ldk_impl_bindings_Pong_1get_1byteslen(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKPong this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int16_t ret_val = Pong_get_byteslen(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_Pong_1set_1byteslen(JNIEnv *env, jclass clz, int64_t this_ptr, int16_t val) {
	LDKPong this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	Pong_set_byteslen(&this_ptr_conv, val);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_Pong_1new(JNIEnv *env, jclass clz, int16_t byteslen_arg) {
	LDKPong ret_var = Pong_new(byteslen_arg);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_Pong_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKPong orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKPong ret_var = Pong_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_OpenChannel_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKOpenChannel this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	OpenChannel_free(this_obj_conv);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_OpenChannel_1get_1chain_1hash(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKOpenChannel this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 32);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 32, *OpenChannel_get_chain_hash(&this_ptr_conv));
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_OpenChannel_1set_1chain_1hash(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKOpenChannel this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKThirtyTwoBytes val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 32);
	(*env)->GetByteArrayRegion(env, val, 0, 32, val_ref.data);
	OpenChannel_set_chain_hash(&this_ptr_conv, val_ref);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_OpenChannel_1get_1temporary_1channel_1id(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKOpenChannel this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 32);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 32, *OpenChannel_get_temporary_channel_id(&this_ptr_conv));
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_OpenChannel_1set_1temporary_1channel_1id(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKOpenChannel this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKThirtyTwoBytes val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 32);
	(*env)->GetByteArrayRegion(env, val, 0, 32, val_ref.data);
	OpenChannel_set_temporary_channel_id(&this_ptr_conv, val_ref);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_OpenChannel_1get_1funding_1satoshis(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKOpenChannel this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int64_t ret_val = OpenChannel_get_funding_satoshis(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_OpenChannel_1set_1funding_1satoshis(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKOpenChannel this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	OpenChannel_set_funding_satoshis(&this_ptr_conv, val);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_OpenChannel_1get_1push_1msat(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKOpenChannel this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int64_t ret_val = OpenChannel_get_push_msat(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_OpenChannel_1set_1push_1msat(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKOpenChannel this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	OpenChannel_set_push_msat(&this_ptr_conv, val);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_OpenChannel_1get_1dust_1limit_1satoshis(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKOpenChannel this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int64_t ret_val = OpenChannel_get_dust_limit_satoshis(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_OpenChannel_1set_1dust_1limit_1satoshis(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKOpenChannel this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	OpenChannel_set_dust_limit_satoshis(&this_ptr_conv, val);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_OpenChannel_1get_1max_1htlc_1value_1in_1flight_1msat(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKOpenChannel this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int64_t ret_val = OpenChannel_get_max_htlc_value_in_flight_msat(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_OpenChannel_1set_1max_1htlc_1value_1in_1flight_1msat(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKOpenChannel this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	OpenChannel_set_max_htlc_value_in_flight_msat(&this_ptr_conv, val);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_OpenChannel_1get_1channel_1reserve_1satoshis(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKOpenChannel this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int64_t ret_val = OpenChannel_get_channel_reserve_satoshis(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_OpenChannel_1set_1channel_1reserve_1satoshis(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKOpenChannel this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	OpenChannel_set_channel_reserve_satoshis(&this_ptr_conv, val);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_OpenChannel_1get_1htlc_1minimum_1msat(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKOpenChannel this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int64_t ret_val = OpenChannel_get_htlc_minimum_msat(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_OpenChannel_1set_1htlc_1minimum_1msat(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKOpenChannel this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	OpenChannel_set_htlc_minimum_msat(&this_ptr_conv, val);
}

JNIEXPORT int32_t JNICALL Java_org_ldk_impl_bindings_OpenChannel_1get_1feerate_1per_1kw(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKOpenChannel this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int32_t ret_val = OpenChannel_get_feerate_per_kw(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_OpenChannel_1set_1feerate_1per_1kw(JNIEnv *env, jclass clz, int64_t this_ptr, int32_t val) {
	LDKOpenChannel this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	OpenChannel_set_feerate_per_kw(&this_ptr_conv, val);
}

JNIEXPORT int16_t JNICALL Java_org_ldk_impl_bindings_OpenChannel_1get_1to_1self_1delay(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKOpenChannel this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int16_t ret_val = OpenChannel_get_to_self_delay(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_OpenChannel_1set_1to_1self_1delay(JNIEnv *env, jclass clz, int64_t this_ptr, int16_t val) {
	LDKOpenChannel this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	OpenChannel_set_to_self_delay(&this_ptr_conv, val);
}

JNIEXPORT int16_t JNICALL Java_org_ldk_impl_bindings_OpenChannel_1get_1max_1accepted_1htlcs(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKOpenChannel this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int16_t ret_val = OpenChannel_get_max_accepted_htlcs(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_OpenChannel_1set_1max_1accepted_1htlcs(JNIEnv *env, jclass clz, int64_t this_ptr, int16_t val) {
	LDKOpenChannel this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	OpenChannel_set_max_accepted_htlcs(&this_ptr_conv, val);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_OpenChannel_1get_1funding_1pubkey(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKOpenChannel this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 33);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 33, OpenChannel_get_funding_pubkey(&this_ptr_conv).compressed_form);
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_OpenChannel_1set_1funding_1pubkey(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKOpenChannel this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKPublicKey val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 33);
	(*env)->GetByteArrayRegion(env, val, 0, 33, val_ref.compressed_form);
	OpenChannel_set_funding_pubkey(&this_ptr_conv, val_ref);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_OpenChannel_1get_1revocation_1basepoint(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKOpenChannel this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 33);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 33, OpenChannel_get_revocation_basepoint(&this_ptr_conv).compressed_form);
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_OpenChannel_1set_1revocation_1basepoint(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKOpenChannel this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKPublicKey val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 33);
	(*env)->GetByteArrayRegion(env, val, 0, 33, val_ref.compressed_form);
	OpenChannel_set_revocation_basepoint(&this_ptr_conv, val_ref);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_OpenChannel_1get_1payment_1point(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKOpenChannel this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 33);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 33, OpenChannel_get_payment_point(&this_ptr_conv).compressed_form);
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_OpenChannel_1set_1payment_1point(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKOpenChannel this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKPublicKey val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 33);
	(*env)->GetByteArrayRegion(env, val, 0, 33, val_ref.compressed_form);
	OpenChannel_set_payment_point(&this_ptr_conv, val_ref);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_OpenChannel_1get_1delayed_1payment_1basepoint(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKOpenChannel this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 33);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 33, OpenChannel_get_delayed_payment_basepoint(&this_ptr_conv).compressed_form);
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_OpenChannel_1set_1delayed_1payment_1basepoint(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKOpenChannel this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKPublicKey val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 33);
	(*env)->GetByteArrayRegion(env, val, 0, 33, val_ref.compressed_form);
	OpenChannel_set_delayed_payment_basepoint(&this_ptr_conv, val_ref);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_OpenChannel_1get_1htlc_1basepoint(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKOpenChannel this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 33);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 33, OpenChannel_get_htlc_basepoint(&this_ptr_conv).compressed_form);
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_OpenChannel_1set_1htlc_1basepoint(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKOpenChannel this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKPublicKey val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 33);
	(*env)->GetByteArrayRegion(env, val, 0, 33, val_ref.compressed_form);
	OpenChannel_set_htlc_basepoint(&this_ptr_conv, val_ref);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_OpenChannel_1get_1first_1per_1commitment_1point(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKOpenChannel this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 33);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 33, OpenChannel_get_first_per_commitment_point(&this_ptr_conv).compressed_form);
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_OpenChannel_1set_1first_1per_1commitment_1point(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKOpenChannel this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKPublicKey val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 33);
	(*env)->GetByteArrayRegion(env, val, 0, 33, val_ref.compressed_form);
	OpenChannel_set_first_per_commitment_point(&this_ptr_conv, val_ref);
}

JNIEXPORT int8_t JNICALL Java_org_ldk_impl_bindings_OpenChannel_1get_1channel_1flags(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKOpenChannel this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_t ret_val = OpenChannel_get_channel_flags(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_OpenChannel_1set_1channel_1flags(JNIEnv *env, jclass clz, int64_t this_ptr, int8_t val) {
	LDKOpenChannel this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	OpenChannel_set_channel_flags(&this_ptr_conv, val);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_OpenChannel_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKOpenChannel orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKOpenChannel ret_var = OpenChannel_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_AcceptChannel_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKAcceptChannel this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	AcceptChannel_free(this_obj_conv);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_AcceptChannel_1get_1temporary_1channel_1id(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKAcceptChannel this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 32);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 32, *AcceptChannel_get_temporary_channel_id(&this_ptr_conv));
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_AcceptChannel_1set_1temporary_1channel_1id(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKAcceptChannel this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKThirtyTwoBytes val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 32);
	(*env)->GetByteArrayRegion(env, val, 0, 32, val_ref.data);
	AcceptChannel_set_temporary_channel_id(&this_ptr_conv, val_ref);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_AcceptChannel_1get_1dust_1limit_1satoshis(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKAcceptChannel this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int64_t ret_val = AcceptChannel_get_dust_limit_satoshis(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_AcceptChannel_1set_1dust_1limit_1satoshis(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKAcceptChannel this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	AcceptChannel_set_dust_limit_satoshis(&this_ptr_conv, val);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_AcceptChannel_1get_1max_1htlc_1value_1in_1flight_1msat(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKAcceptChannel this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int64_t ret_val = AcceptChannel_get_max_htlc_value_in_flight_msat(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_AcceptChannel_1set_1max_1htlc_1value_1in_1flight_1msat(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKAcceptChannel this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	AcceptChannel_set_max_htlc_value_in_flight_msat(&this_ptr_conv, val);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_AcceptChannel_1get_1channel_1reserve_1satoshis(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKAcceptChannel this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int64_t ret_val = AcceptChannel_get_channel_reserve_satoshis(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_AcceptChannel_1set_1channel_1reserve_1satoshis(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKAcceptChannel this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	AcceptChannel_set_channel_reserve_satoshis(&this_ptr_conv, val);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_AcceptChannel_1get_1htlc_1minimum_1msat(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKAcceptChannel this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int64_t ret_val = AcceptChannel_get_htlc_minimum_msat(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_AcceptChannel_1set_1htlc_1minimum_1msat(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKAcceptChannel this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	AcceptChannel_set_htlc_minimum_msat(&this_ptr_conv, val);
}

JNIEXPORT int32_t JNICALL Java_org_ldk_impl_bindings_AcceptChannel_1get_1minimum_1depth(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKAcceptChannel this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int32_t ret_val = AcceptChannel_get_minimum_depth(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_AcceptChannel_1set_1minimum_1depth(JNIEnv *env, jclass clz, int64_t this_ptr, int32_t val) {
	LDKAcceptChannel this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	AcceptChannel_set_minimum_depth(&this_ptr_conv, val);
}

JNIEXPORT int16_t JNICALL Java_org_ldk_impl_bindings_AcceptChannel_1get_1to_1self_1delay(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKAcceptChannel this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int16_t ret_val = AcceptChannel_get_to_self_delay(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_AcceptChannel_1set_1to_1self_1delay(JNIEnv *env, jclass clz, int64_t this_ptr, int16_t val) {
	LDKAcceptChannel this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	AcceptChannel_set_to_self_delay(&this_ptr_conv, val);
}

JNIEXPORT int16_t JNICALL Java_org_ldk_impl_bindings_AcceptChannel_1get_1max_1accepted_1htlcs(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKAcceptChannel this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int16_t ret_val = AcceptChannel_get_max_accepted_htlcs(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_AcceptChannel_1set_1max_1accepted_1htlcs(JNIEnv *env, jclass clz, int64_t this_ptr, int16_t val) {
	LDKAcceptChannel this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	AcceptChannel_set_max_accepted_htlcs(&this_ptr_conv, val);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_AcceptChannel_1get_1funding_1pubkey(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKAcceptChannel this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 33);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 33, AcceptChannel_get_funding_pubkey(&this_ptr_conv).compressed_form);
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_AcceptChannel_1set_1funding_1pubkey(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKAcceptChannel this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKPublicKey val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 33);
	(*env)->GetByteArrayRegion(env, val, 0, 33, val_ref.compressed_form);
	AcceptChannel_set_funding_pubkey(&this_ptr_conv, val_ref);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_AcceptChannel_1get_1revocation_1basepoint(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKAcceptChannel this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 33);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 33, AcceptChannel_get_revocation_basepoint(&this_ptr_conv).compressed_form);
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_AcceptChannel_1set_1revocation_1basepoint(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKAcceptChannel this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKPublicKey val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 33);
	(*env)->GetByteArrayRegion(env, val, 0, 33, val_ref.compressed_form);
	AcceptChannel_set_revocation_basepoint(&this_ptr_conv, val_ref);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_AcceptChannel_1get_1payment_1point(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKAcceptChannel this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 33);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 33, AcceptChannel_get_payment_point(&this_ptr_conv).compressed_form);
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_AcceptChannel_1set_1payment_1point(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKAcceptChannel this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKPublicKey val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 33);
	(*env)->GetByteArrayRegion(env, val, 0, 33, val_ref.compressed_form);
	AcceptChannel_set_payment_point(&this_ptr_conv, val_ref);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_AcceptChannel_1get_1delayed_1payment_1basepoint(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKAcceptChannel this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 33);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 33, AcceptChannel_get_delayed_payment_basepoint(&this_ptr_conv).compressed_form);
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_AcceptChannel_1set_1delayed_1payment_1basepoint(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKAcceptChannel this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKPublicKey val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 33);
	(*env)->GetByteArrayRegion(env, val, 0, 33, val_ref.compressed_form);
	AcceptChannel_set_delayed_payment_basepoint(&this_ptr_conv, val_ref);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_AcceptChannel_1get_1htlc_1basepoint(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKAcceptChannel this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 33);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 33, AcceptChannel_get_htlc_basepoint(&this_ptr_conv).compressed_form);
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_AcceptChannel_1set_1htlc_1basepoint(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKAcceptChannel this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKPublicKey val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 33);
	(*env)->GetByteArrayRegion(env, val, 0, 33, val_ref.compressed_form);
	AcceptChannel_set_htlc_basepoint(&this_ptr_conv, val_ref);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_AcceptChannel_1get_1first_1per_1commitment_1point(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKAcceptChannel this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 33);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 33, AcceptChannel_get_first_per_commitment_point(&this_ptr_conv).compressed_form);
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_AcceptChannel_1set_1first_1per_1commitment_1point(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKAcceptChannel this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKPublicKey val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 33);
	(*env)->GetByteArrayRegion(env, val, 0, 33, val_ref.compressed_form);
	AcceptChannel_set_first_per_commitment_point(&this_ptr_conv, val_ref);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_AcceptChannel_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKAcceptChannel orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKAcceptChannel ret_var = AcceptChannel_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_FundingCreated_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKFundingCreated this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	FundingCreated_free(this_obj_conv);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_FundingCreated_1get_1temporary_1channel_1id(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKFundingCreated this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 32);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 32, *FundingCreated_get_temporary_channel_id(&this_ptr_conv));
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_FundingCreated_1set_1temporary_1channel_1id(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKFundingCreated this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKThirtyTwoBytes val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 32);
	(*env)->GetByteArrayRegion(env, val, 0, 32, val_ref.data);
	FundingCreated_set_temporary_channel_id(&this_ptr_conv, val_ref);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_FundingCreated_1get_1funding_1txid(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKFundingCreated this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 32);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 32, *FundingCreated_get_funding_txid(&this_ptr_conv));
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_FundingCreated_1set_1funding_1txid(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKFundingCreated this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKThirtyTwoBytes val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 32);
	(*env)->GetByteArrayRegion(env, val, 0, 32, val_ref.data);
	FundingCreated_set_funding_txid(&this_ptr_conv, val_ref);
}

JNIEXPORT int16_t JNICALL Java_org_ldk_impl_bindings_FundingCreated_1get_1funding_1output_1index(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKFundingCreated this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int16_t ret_val = FundingCreated_get_funding_output_index(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_FundingCreated_1set_1funding_1output_1index(JNIEnv *env, jclass clz, int64_t this_ptr, int16_t val) {
	LDKFundingCreated this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	FundingCreated_set_funding_output_index(&this_ptr_conv, val);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_FundingCreated_1get_1signature(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKFundingCreated this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 64);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 64, FundingCreated_get_signature(&this_ptr_conv).compact_form);
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_FundingCreated_1set_1signature(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKFundingCreated this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKSignature val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 64);
	(*env)->GetByteArrayRegion(env, val, 0, 64, val_ref.compact_form);
	FundingCreated_set_signature(&this_ptr_conv, val_ref);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_FundingCreated_1new(JNIEnv *env, jclass clz, int8_tArray temporary_channel_id_arg, int8_tArray funding_txid_arg, int16_t funding_output_index_arg, int8_tArray signature_arg) {
	LDKThirtyTwoBytes temporary_channel_id_arg_ref;
	CHECK((*env)->GetArrayLength(env, temporary_channel_id_arg) == 32);
	(*env)->GetByteArrayRegion(env, temporary_channel_id_arg, 0, 32, temporary_channel_id_arg_ref.data);
	LDKThirtyTwoBytes funding_txid_arg_ref;
	CHECK((*env)->GetArrayLength(env, funding_txid_arg) == 32);
	(*env)->GetByteArrayRegion(env, funding_txid_arg, 0, 32, funding_txid_arg_ref.data);
	LDKSignature signature_arg_ref;
	CHECK((*env)->GetArrayLength(env, signature_arg) == 64);
	(*env)->GetByteArrayRegion(env, signature_arg, 0, 64, signature_arg_ref.compact_form);
	LDKFundingCreated ret_var = FundingCreated_new(temporary_channel_id_arg_ref, funding_txid_arg_ref, funding_output_index_arg, signature_arg_ref);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_FundingCreated_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKFundingCreated orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKFundingCreated ret_var = FundingCreated_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_FundingSigned_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKFundingSigned this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	FundingSigned_free(this_obj_conv);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_FundingSigned_1get_1channel_1id(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKFundingSigned this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 32);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 32, *FundingSigned_get_channel_id(&this_ptr_conv));
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_FundingSigned_1set_1channel_1id(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKFundingSigned this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKThirtyTwoBytes val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 32);
	(*env)->GetByteArrayRegion(env, val, 0, 32, val_ref.data);
	FundingSigned_set_channel_id(&this_ptr_conv, val_ref);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_FundingSigned_1get_1signature(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKFundingSigned this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 64);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 64, FundingSigned_get_signature(&this_ptr_conv).compact_form);
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_FundingSigned_1set_1signature(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKFundingSigned this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKSignature val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 64);
	(*env)->GetByteArrayRegion(env, val, 0, 64, val_ref.compact_form);
	FundingSigned_set_signature(&this_ptr_conv, val_ref);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_FundingSigned_1new(JNIEnv *env, jclass clz, int8_tArray channel_id_arg, int8_tArray signature_arg) {
	LDKThirtyTwoBytes channel_id_arg_ref;
	CHECK((*env)->GetArrayLength(env, channel_id_arg) == 32);
	(*env)->GetByteArrayRegion(env, channel_id_arg, 0, 32, channel_id_arg_ref.data);
	LDKSignature signature_arg_ref;
	CHECK((*env)->GetArrayLength(env, signature_arg) == 64);
	(*env)->GetByteArrayRegion(env, signature_arg, 0, 64, signature_arg_ref.compact_form);
	LDKFundingSigned ret_var = FundingSigned_new(channel_id_arg_ref, signature_arg_ref);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_FundingSigned_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKFundingSigned orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKFundingSigned ret_var = FundingSigned_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_FundingLocked_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKFundingLocked this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	FundingLocked_free(this_obj_conv);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_FundingLocked_1get_1channel_1id(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKFundingLocked this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 32);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 32, *FundingLocked_get_channel_id(&this_ptr_conv));
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_FundingLocked_1set_1channel_1id(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKFundingLocked this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKThirtyTwoBytes val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 32);
	(*env)->GetByteArrayRegion(env, val, 0, 32, val_ref.data);
	FundingLocked_set_channel_id(&this_ptr_conv, val_ref);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_FundingLocked_1get_1next_1per_1commitment_1point(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKFundingLocked this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 33);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 33, FundingLocked_get_next_per_commitment_point(&this_ptr_conv).compressed_form);
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_FundingLocked_1set_1next_1per_1commitment_1point(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKFundingLocked this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKPublicKey val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 33);
	(*env)->GetByteArrayRegion(env, val, 0, 33, val_ref.compressed_form);
	FundingLocked_set_next_per_commitment_point(&this_ptr_conv, val_ref);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_FundingLocked_1new(JNIEnv *env, jclass clz, int8_tArray channel_id_arg, int8_tArray next_per_commitment_point_arg) {
	LDKThirtyTwoBytes channel_id_arg_ref;
	CHECK((*env)->GetArrayLength(env, channel_id_arg) == 32);
	(*env)->GetByteArrayRegion(env, channel_id_arg, 0, 32, channel_id_arg_ref.data);
	LDKPublicKey next_per_commitment_point_arg_ref;
	CHECK((*env)->GetArrayLength(env, next_per_commitment_point_arg) == 33);
	(*env)->GetByteArrayRegion(env, next_per_commitment_point_arg, 0, 33, next_per_commitment_point_arg_ref.compressed_form);
	LDKFundingLocked ret_var = FundingLocked_new(channel_id_arg_ref, next_per_commitment_point_arg_ref);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_FundingLocked_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKFundingLocked orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKFundingLocked ret_var = FundingLocked_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_Shutdown_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKShutdown this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	Shutdown_free(this_obj_conv);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_Shutdown_1get_1channel_1id(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKShutdown this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 32);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 32, *Shutdown_get_channel_id(&this_ptr_conv));
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_Shutdown_1set_1channel_1id(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKShutdown this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKThirtyTwoBytes val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 32);
	(*env)->GetByteArrayRegion(env, val, 0, 32, val_ref.data);
	Shutdown_set_channel_id(&this_ptr_conv, val_ref);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_Shutdown_1get_1scriptpubkey(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKShutdown this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKu8slice ret_var = Shutdown_get_scriptpubkey(&this_ptr_conv);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_Shutdown_1set_1scriptpubkey(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKShutdown this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKCVec_u8Z val_ref;
	val_ref.datalen = (*env)->GetArrayLength(env, val);
	val_ref.data = MALLOC(val_ref.datalen, "LDKCVec_u8Z Bytes");
	(*env)->GetByteArrayRegion(env, val, 0, val_ref.datalen, val_ref.data);
	Shutdown_set_scriptpubkey(&this_ptr_conv, val_ref);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_Shutdown_1new(JNIEnv *env, jclass clz, int8_tArray channel_id_arg, int8_tArray scriptpubkey_arg) {
	LDKThirtyTwoBytes channel_id_arg_ref;
	CHECK((*env)->GetArrayLength(env, channel_id_arg) == 32);
	(*env)->GetByteArrayRegion(env, channel_id_arg, 0, 32, channel_id_arg_ref.data);
	LDKCVec_u8Z scriptpubkey_arg_ref;
	scriptpubkey_arg_ref.datalen = (*env)->GetArrayLength(env, scriptpubkey_arg);
	scriptpubkey_arg_ref.data = MALLOC(scriptpubkey_arg_ref.datalen, "LDKCVec_u8Z Bytes");
	(*env)->GetByteArrayRegion(env, scriptpubkey_arg, 0, scriptpubkey_arg_ref.datalen, scriptpubkey_arg_ref.data);
	LDKShutdown ret_var = Shutdown_new(channel_id_arg_ref, scriptpubkey_arg_ref);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_Shutdown_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKShutdown orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKShutdown ret_var = Shutdown_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ClosingSignedFeeRange_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKClosingSignedFeeRange this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	ClosingSignedFeeRange_free(this_obj_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ClosingSignedFeeRange_1get_1min_1fee_1satoshis(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKClosingSignedFeeRange this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int64_t ret_val = ClosingSignedFeeRange_get_min_fee_satoshis(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ClosingSignedFeeRange_1set_1min_1fee_1satoshis(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKClosingSignedFeeRange this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	ClosingSignedFeeRange_set_min_fee_satoshis(&this_ptr_conv, val);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ClosingSignedFeeRange_1get_1max_1fee_1satoshis(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKClosingSignedFeeRange this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int64_t ret_val = ClosingSignedFeeRange_get_max_fee_satoshis(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ClosingSignedFeeRange_1set_1max_1fee_1satoshis(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKClosingSignedFeeRange this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	ClosingSignedFeeRange_set_max_fee_satoshis(&this_ptr_conv, val);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ClosingSignedFeeRange_1new(JNIEnv *env, jclass clz, int64_t min_fee_satoshis_arg, int64_t max_fee_satoshis_arg) {
	LDKClosingSignedFeeRange ret_var = ClosingSignedFeeRange_new(min_fee_satoshis_arg, max_fee_satoshis_arg);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ClosingSignedFeeRange_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKClosingSignedFeeRange orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKClosingSignedFeeRange ret_var = ClosingSignedFeeRange_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ClosingSigned_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKClosingSigned this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	ClosingSigned_free(this_obj_conv);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_ClosingSigned_1get_1channel_1id(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKClosingSigned this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 32);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 32, *ClosingSigned_get_channel_id(&this_ptr_conv));
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ClosingSigned_1set_1channel_1id(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKClosingSigned this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKThirtyTwoBytes val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 32);
	(*env)->GetByteArrayRegion(env, val, 0, 32, val_ref.data);
	ClosingSigned_set_channel_id(&this_ptr_conv, val_ref);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ClosingSigned_1get_1fee_1satoshis(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKClosingSigned this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int64_t ret_val = ClosingSigned_get_fee_satoshis(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ClosingSigned_1set_1fee_1satoshis(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKClosingSigned this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	ClosingSigned_set_fee_satoshis(&this_ptr_conv, val);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_ClosingSigned_1get_1signature(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKClosingSigned this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 64);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 64, ClosingSigned_get_signature(&this_ptr_conv).compact_form);
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ClosingSigned_1set_1signature(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKClosingSigned this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKSignature val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 64);
	(*env)->GetByteArrayRegion(env, val, 0, 64, val_ref.compact_form);
	ClosingSigned_set_signature(&this_ptr_conv, val_ref);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ClosingSigned_1get_1fee_1range(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKClosingSigned this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKClosingSignedFeeRange ret_var = ClosingSigned_get_fee_range(&this_ptr_conv);
	uint64_t ret_ref = 0;
	if ((uint64_t)ret_var.inner > 4096) {
		CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
		CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
		ret_ref = (uint64_t)ret_var.inner;
		if (ret_var.is_owned) {
			ret_ref |= 1;
		}
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ClosingSigned_1set_1fee_1range(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKClosingSigned this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKClosingSignedFeeRange val_conv;
	val_conv.inner = (void*)(val & (~1));
	val_conv.is_owned = (val & 1) || (val == 0);
	val_conv = ClosingSignedFeeRange_clone(&val_conv);
	ClosingSigned_set_fee_range(&this_ptr_conv, val_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ClosingSigned_1new(JNIEnv *env, jclass clz, int8_tArray channel_id_arg, int64_t fee_satoshis_arg, int8_tArray signature_arg, int64_t fee_range_arg) {
	LDKThirtyTwoBytes channel_id_arg_ref;
	CHECK((*env)->GetArrayLength(env, channel_id_arg) == 32);
	(*env)->GetByteArrayRegion(env, channel_id_arg, 0, 32, channel_id_arg_ref.data);
	LDKSignature signature_arg_ref;
	CHECK((*env)->GetArrayLength(env, signature_arg) == 64);
	(*env)->GetByteArrayRegion(env, signature_arg, 0, 64, signature_arg_ref.compact_form);
	LDKClosingSignedFeeRange fee_range_arg_conv;
	fee_range_arg_conv.inner = (void*)(fee_range_arg & (~1));
	fee_range_arg_conv.is_owned = (fee_range_arg & 1) || (fee_range_arg == 0);
	fee_range_arg_conv = ClosingSignedFeeRange_clone(&fee_range_arg_conv);
	LDKClosingSigned ret_var = ClosingSigned_new(channel_id_arg_ref, fee_satoshis_arg, signature_arg_ref, fee_range_arg_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ClosingSigned_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKClosingSigned orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKClosingSigned ret_var = ClosingSigned_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_UpdateAddHTLC_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKUpdateAddHTLC this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	UpdateAddHTLC_free(this_obj_conv);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_UpdateAddHTLC_1get_1channel_1id(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKUpdateAddHTLC this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 32);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 32, *UpdateAddHTLC_get_channel_id(&this_ptr_conv));
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_UpdateAddHTLC_1set_1channel_1id(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKUpdateAddHTLC this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKThirtyTwoBytes val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 32);
	(*env)->GetByteArrayRegion(env, val, 0, 32, val_ref.data);
	UpdateAddHTLC_set_channel_id(&this_ptr_conv, val_ref);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_UpdateAddHTLC_1get_1htlc_1id(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKUpdateAddHTLC this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int64_t ret_val = UpdateAddHTLC_get_htlc_id(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_UpdateAddHTLC_1set_1htlc_1id(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKUpdateAddHTLC this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	UpdateAddHTLC_set_htlc_id(&this_ptr_conv, val);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_UpdateAddHTLC_1get_1amount_1msat(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKUpdateAddHTLC this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int64_t ret_val = UpdateAddHTLC_get_amount_msat(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_UpdateAddHTLC_1set_1amount_1msat(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKUpdateAddHTLC this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	UpdateAddHTLC_set_amount_msat(&this_ptr_conv, val);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_UpdateAddHTLC_1get_1payment_1hash(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKUpdateAddHTLC this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 32);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 32, *UpdateAddHTLC_get_payment_hash(&this_ptr_conv));
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_UpdateAddHTLC_1set_1payment_1hash(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKUpdateAddHTLC this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKThirtyTwoBytes val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 32);
	(*env)->GetByteArrayRegion(env, val, 0, 32, val_ref.data);
	UpdateAddHTLC_set_payment_hash(&this_ptr_conv, val_ref);
}

JNIEXPORT int32_t JNICALL Java_org_ldk_impl_bindings_UpdateAddHTLC_1get_1cltv_1expiry(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKUpdateAddHTLC this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int32_t ret_val = UpdateAddHTLC_get_cltv_expiry(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_UpdateAddHTLC_1set_1cltv_1expiry(JNIEnv *env, jclass clz, int64_t this_ptr, int32_t val) {
	LDKUpdateAddHTLC this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	UpdateAddHTLC_set_cltv_expiry(&this_ptr_conv, val);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_UpdateAddHTLC_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKUpdateAddHTLC orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKUpdateAddHTLC ret_var = UpdateAddHTLC_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_UpdateFulfillHTLC_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKUpdateFulfillHTLC this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	UpdateFulfillHTLC_free(this_obj_conv);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_UpdateFulfillHTLC_1get_1channel_1id(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKUpdateFulfillHTLC this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 32);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 32, *UpdateFulfillHTLC_get_channel_id(&this_ptr_conv));
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_UpdateFulfillHTLC_1set_1channel_1id(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKUpdateFulfillHTLC this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKThirtyTwoBytes val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 32);
	(*env)->GetByteArrayRegion(env, val, 0, 32, val_ref.data);
	UpdateFulfillHTLC_set_channel_id(&this_ptr_conv, val_ref);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_UpdateFulfillHTLC_1get_1htlc_1id(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKUpdateFulfillHTLC this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int64_t ret_val = UpdateFulfillHTLC_get_htlc_id(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_UpdateFulfillHTLC_1set_1htlc_1id(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKUpdateFulfillHTLC this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	UpdateFulfillHTLC_set_htlc_id(&this_ptr_conv, val);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_UpdateFulfillHTLC_1get_1payment_1preimage(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKUpdateFulfillHTLC this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 32);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 32, *UpdateFulfillHTLC_get_payment_preimage(&this_ptr_conv));
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_UpdateFulfillHTLC_1set_1payment_1preimage(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKUpdateFulfillHTLC this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKThirtyTwoBytes val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 32);
	(*env)->GetByteArrayRegion(env, val, 0, 32, val_ref.data);
	UpdateFulfillHTLC_set_payment_preimage(&this_ptr_conv, val_ref);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_UpdateFulfillHTLC_1new(JNIEnv *env, jclass clz, int8_tArray channel_id_arg, int64_t htlc_id_arg, int8_tArray payment_preimage_arg) {
	LDKThirtyTwoBytes channel_id_arg_ref;
	CHECK((*env)->GetArrayLength(env, channel_id_arg) == 32);
	(*env)->GetByteArrayRegion(env, channel_id_arg, 0, 32, channel_id_arg_ref.data);
	LDKThirtyTwoBytes payment_preimage_arg_ref;
	CHECK((*env)->GetArrayLength(env, payment_preimage_arg) == 32);
	(*env)->GetByteArrayRegion(env, payment_preimage_arg, 0, 32, payment_preimage_arg_ref.data);
	LDKUpdateFulfillHTLC ret_var = UpdateFulfillHTLC_new(channel_id_arg_ref, htlc_id_arg, payment_preimage_arg_ref);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_UpdateFulfillHTLC_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKUpdateFulfillHTLC orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKUpdateFulfillHTLC ret_var = UpdateFulfillHTLC_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_UpdateFailHTLC_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKUpdateFailHTLC this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	UpdateFailHTLC_free(this_obj_conv);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_UpdateFailHTLC_1get_1channel_1id(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKUpdateFailHTLC this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 32);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 32, *UpdateFailHTLC_get_channel_id(&this_ptr_conv));
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_UpdateFailHTLC_1set_1channel_1id(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKUpdateFailHTLC this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKThirtyTwoBytes val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 32);
	(*env)->GetByteArrayRegion(env, val, 0, 32, val_ref.data);
	UpdateFailHTLC_set_channel_id(&this_ptr_conv, val_ref);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_UpdateFailHTLC_1get_1htlc_1id(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKUpdateFailHTLC this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int64_t ret_val = UpdateFailHTLC_get_htlc_id(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_UpdateFailHTLC_1set_1htlc_1id(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKUpdateFailHTLC this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	UpdateFailHTLC_set_htlc_id(&this_ptr_conv, val);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_UpdateFailHTLC_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKUpdateFailHTLC orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKUpdateFailHTLC ret_var = UpdateFailHTLC_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_UpdateFailMalformedHTLC_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKUpdateFailMalformedHTLC this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	UpdateFailMalformedHTLC_free(this_obj_conv);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_UpdateFailMalformedHTLC_1get_1channel_1id(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKUpdateFailMalformedHTLC this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 32);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 32, *UpdateFailMalformedHTLC_get_channel_id(&this_ptr_conv));
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_UpdateFailMalformedHTLC_1set_1channel_1id(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKUpdateFailMalformedHTLC this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKThirtyTwoBytes val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 32);
	(*env)->GetByteArrayRegion(env, val, 0, 32, val_ref.data);
	UpdateFailMalformedHTLC_set_channel_id(&this_ptr_conv, val_ref);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_UpdateFailMalformedHTLC_1get_1htlc_1id(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKUpdateFailMalformedHTLC this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int64_t ret_val = UpdateFailMalformedHTLC_get_htlc_id(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_UpdateFailMalformedHTLC_1set_1htlc_1id(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKUpdateFailMalformedHTLC this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	UpdateFailMalformedHTLC_set_htlc_id(&this_ptr_conv, val);
}

JNIEXPORT int16_t JNICALL Java_org_ldk_impl_bindings_UpdateFailMalformedHTLC_1get_1failure_1code(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKUpdateFailMalformedHTLC this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int16_t ret_val = UpdateFailMalformedHTLC_get_failure_code(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_UpdateFailMalformedHTLC_1set_1failure_1code(JNIEnv *env, jclass clz, int64_t this_ptr, int16_t val) {
	LDKUpdateFailMalformedHTLC this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	UpdateFailMalformedHTLC_set_failure_code(&this_ptr_conv, val);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_UpdateFailMalformedHTLC_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKUpdateFailMalformedHTLC orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKUpdateFailMalformedHTLC ret_var = UpdateFailMalformedHTLC_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CommitmentSigned_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKCommitmentSigned this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	CommitmentSigned_free(this_obj_conv);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_CommitmentSigned_1get_1channel_1id(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKCommitmentSigned this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 32);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 32, *CommitmentSigned_get_channel_id(&this_ptr_conv));
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CommitmentSigned_1set_1channel_1id(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKCommitmentSigned this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKThirtyTwoBytes val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 32);
	(*env)->GetByteArrayRegion(env, val, 0, 32, val_ref.data);
	CommitmentSigned_set_channel_id(&this_ptr_conv, val_ref);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_CommitmentSigned_1get_1signature(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKCommitmentSigned this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 64);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 64, CommitmentSigned_get_signature(&this_ptr_conv).compact_form);
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CommitmentSigned_1set_1signature(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKCommitmentSigned this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKSignature val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 64);
	(*env)->GetByteArrayRegion(env, val, 0, 64, val_ref.compact_form);
	CommitmentSigned_set_signature(&this_ptr_conv, val_ref);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CommitmentSigned_1set_1htlc_1signatures(JNIEnv *env, jclass clz, int64_t this_ptr, jobjectArray val) {
	LDKCommitmentSigned this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKCVec_SignatureZ val_constr;
	val_constr.datalen = (*env)->GetArrayLength(env, val);
	if (val_constr.datalen > 0)
		val_constr.data = MALLOC(val_constr.datalen * sizeof(LDKSignature), "LDKCVec_SignatureZ Elements");
	else
		val_constr.data = NULL;
	for (size_t i = 0; i < val_constr.datalen; i++) {
		int8_tArray val_conv_8 = (*env)->GetObjectArrayElement(env, val, i);
		LDKSignature val_conv_8_ref;
		CHECK((*env)->GetArrayLength(env, val_conv_8) == 64);
		(*env)->GetByteArrayRegion(env, val_conv_8, 0, 64, val_conv_8_ref.compact_form);
		val_constr.data[i] = val_conv_8_ref;
	}
	CommitmentSigned_set_htlc_signatures(&this_ptr_conv, val_constr);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CommitmentSigned_1new(JNIEnv *env, jclass clz, int8_tArray channel_id_arg, int8_tArray signature_arg, jobjectArray htlc_signatures_arg) {
	LDKThirtyTwoBytes channel_id_arg_ref;
	CHECK((*env)->GetArrayLength(env, channel_id_arg) == 32);
	(*env)->GetByteArrayRegion(env, channel_id_arg, 0, 32, channel_id_arg_ref.data);
	LDKSignature signature_arg_ref;
	CHECK((*env)->GetArrayLength(env, signature_arg) == 64);
	(*env)->GetByteArrayRegion(env, signature_arg, 0, 64, signature_arg_ref.compact_form);
	LDKCVec_SignatureZ htlc_signatures_arg_constr;
	htlc_signatures_arg_constr.datalen = (*env)->GetArrayLength(env, htlc_signatures_arg);
	if (htlc_signatures_arg_constr.datalen > 0)
		htlc_signatures_arg_constr.data = MALLOC(htlc_signatures_arg_constr.datalen * sizeof(LDKSignature), "LDKCVec_SignatureZ Elements");
	else
		htlc_signatures_arg_constr.data = NULL;
	for (size_t i = 0; i < htlc_signatures_arg_constr.datalen; i++) {
		int8_tArray htlc_signatures_arg_conv_8 = (*env)->GetObjectArrayElement(env, htlc_signatures_arg, i);
		LDKSignature htlc_signatures_arg_conv_8_ref;
		CHECK((*env)->GetArrayLength(env, htlc_signatures_arg_conv_8) == 64);
		(*env)->GetByteArrayRegion(env, htlc_signatures_arg_conv_8, 0, 64, htlc_signatures_arg_conv_8_ref.compact_form);
		htlc_signatures_arg_constr.data[i] = htlc_signatures_arg_conv_8_ref;
	}
	LDKCommitmentSigned ret_var = CommitmentSigned_new(channel_id_arg_ref, signature_arg_ref, htlc_signatures_arg_constr);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CommitmentSigned_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCommitmentSigned orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKCommitmentSigned ret_var = CommitmentSigned_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_RevokeAndACK_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKRevokeAndACK this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	RevokeAndACK_free(this_obj_conv);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_RevokeAndACK_1get_1channel_1id(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKRevokeAndACK this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 32);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 32, *RevokeAndACK_get_channel_id(&this_ptr_conv));
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_RevokeAndACK_1set_1channel_1id(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKRevokeAndACK this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKThirtyTwoBytes val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 32);
	(*env)->GetByteArrayRegion(env, val, 0, 32, val_ref.data);
	RevokeAndACK_set_channel_id(&this_ptr_conv, val_ref);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_RevokeAndACK_1get_1per_1commitment_1secret(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKRevokeAndACK this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 32);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 32, *RevokeAndACK_get_per_commitment_secret(&this_ptr_conv));
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_RevokeAndACK_1set_1per_1commitment_1secret(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKRevokeAndACK this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKThirtyTwoBytes val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 32);
	(*env)->GetByteArrayRegion(env, val, 0, 32, val_ref.data);
	RevokeAndACK_set_per_commitment_secret(&this_ptr_conv, val_ref);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_RevokeAndACK_1get_1next_1per_1commitment_1point(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKRevokeAndACK this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 33);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 33, RevokeAndACK_get_next_per_commitment_point(&this_ptr_conv).compressed_form);
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_RevokeAndACK_1set_1next_1per_1commitment_1point(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKRevokeAndACK this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKPublicKey val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 33);
	(*env)->GetByteArrayRegion(env, val, 0, 33, val_ref.compressed_form);
	RevokeAndACK_set_next_per_commitment_point(&this_ptr_conv, val_ref);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_RevokeAndACK_1new(JNIEnv *env, jclass clz, int8_tArray channel_id_arg, int8_tArray per_commitment_secret_arg, int8_tArray next_per_commitment_point_arg) {
	LDKThirtyTwoBytes channel_id_arg_ref;
	CHECK((*env)->GetArrayLength(env, channel_id_arg) == 32);
	(*env)->GetByteArrayRegion(env, channel_id_arg, 0, 32, channel_id_arg_ref.data);
	LDKThirtyTwoBytes per_commitment_secret_arg_ref;
	CHECK((*env)->GetArrayLength(env, per_commitment_secret_arg) == 32);
	(*env)->GetByteArrayRegion(env, per_commitment_secret_arg, 0, 32, per_commitment_secret_arg_ref.data);
	LDKPublicKey next_per_commitment_point_arg_ref;
	CHECK((*env)->GetArrayLength(env, next_per_commitment_point_arg) == 33);
	(*env)->GetByteArrayRegion(env, next_per_commitment_point_arg, 0, 33, next_per_commitment_point_arg_ref.compressed_form);
	LDKRevokeAndACK ret_var = RevokeAndACK_new(channel_id_arg_ref, per_commitment_secret_arg_ref, next_per_commitment_point_arg_ref);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_RevokeAndACK_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKRevokeAndACK orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKRevokeAndACK ret_var = RevokeAndACK_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_UpdateFee_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKUpdateFee this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	UpdateFee_free(this_obj_conv);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_UpdateFee_1get_1channel_1id(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKUpdateFee this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 32);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 32, *UpdateFee_get_channel_id(&this_ptr_conv));
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_UpdateFee_1set_1channel_1id(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKUpdateFee this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKThirtyTwoBytes val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 32);
	(*env)->GetByteArrayRegion(env, val, 0, 32, val_ref.data);
	UpdateFee_set_channel_id(&this_ptr_conv, val_ref);
}

JNIEXPORT int32_t JNICALL Java_org_ldk_impl_bindings_UpdateFee_1get_1feerate_1per_1kw(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKUpdateFee this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int32_t ret_val = UpdateFee_get_feerate_per_kw(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_UpdateFee_1set_1feerate_1per_1kw(JNIEnv *env, jclass clz, int64_t this_ptr, int32_t val) {
	LDKUpdateFee this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	UpdateFee_set_feerate_per_kw(&this_ptr_conv, val);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_UpdateFee_1new(JNIEnv *env, jclass clz, int8_tArray channel_id_arg, int32_t feerate_per_kw_arg) {
	LDKThirtyTwoBytes channel_id_arg_ref;
	CHECK((*env)->GetArrayLength(env, channel_id_arg) == 32);
	(*env)->GetByteArrayRegion(env, channel_id_arg, 0, 32, channel_id_arg_ref.data);
	LDKUpdateFee ret_var = UpdateFee_new(channel_id_arg_ref, feerate_per_kw_arg);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_UpdateFee_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKUpdateFee orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKUpdateFee ret_var = UpdateFee_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_DataLossProtect_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKDataLossProtect this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	DataLossProtect_free(this_obj_conv);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_DataLossProtect_1get_1your_1last_1per_1commitment_1secret(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKDataLossProtect this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 32);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 32, *DataLossProtect_get_your_last_per_commitment_secret(&this_ptr_conv));
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_DataLossProtect_1set_1your_1last_1per_1commitment_1secret(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKDataLossProtect this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKThirtyTwoBytes val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 32);
	(*env)->GetByteArrayRegion(env, val, 0, 32, val_ref.data);
	DataLossProtect_set_your_last_per_commitment_secret(&this_ptr_conv, val_ref);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_DataLossProtect_1get_1my_1current_1per_1commitment_1point(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKDataLossProtect this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 33);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 33, DataLossProtect_get_my_current_per_commitment_point(&this_ptr_conv).compressed_form);
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_DataLossProtect_1set_1my_1current_1per_1commitment_1point(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKDataLossProtect this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKPublicKey val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 33);
	(*env)->GetByteArrayRegion(env, val, 0, 33, val_ref.compressed_form);
	DataLossProtect_set_my_current_per_commitment_point(&this_ptr_conv, val_ref);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_DataLossProtect_1new(JNIEnv *env, jclass clz, int8_tArray your_last_per_commitment_secret_arg, int8_tArray my_current_per_commitment_point_arg) {
	LDKThirtyTwoBytes your_last_per_commitment_secret_arg_ref;
	CHECK((*env)->GetArrayLength(env, your_last_per_commitment_secret_arg) == 32);
	(*env)->GetByteArrayRegion(env, your_last_per_commitment_secret_arg, 0, 32, your_last_per_commitment_secret_arg_ref.data);
	LDKPublicKey my_current_per_commitment_point_arg_ref;
	CHECK((*env)->GetArrayLength(env, my_current_per_commitment_point_arg) == 33);
	(*env)->GetByteArrayRegion(env, my_current_per_commitment_point_arg, 0, 33, my_current_per_commitment_point_arg_ref.compressed_form);
	LDKDataLossProtect ret_var = DataLossProtect_new(your_last_per_commitment_secret_arg_ref, my_current_per_commitment_point_arg_ref);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_DataLossProtect_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKDataLossProtect orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKDataLossProtect ret_var = DataLossProtect_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelReestablish_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKChannelReestablish this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	ChannelReestablish_free(this_obj_conv);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_ChannelReestablish_1get_1channel_1id(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKChannelReestablish this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 32);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 32, *ChannelReestablish_get_channel_id(&this_ptr_conv));
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelReestablish_1set_1channel_1id(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKChannelReestablish this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKThirtyTwoBytes val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 32);
	(*env)->GetByteArrayRegion(env, val, 0, 32, val_ref.data);
	ChannelReestablish_set_channel_id(&this_ptr_conv, val_ref);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelReestablish_1get_1next_1local_1commitment_1number(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKChannelReestablish this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int64_t ret_val = ChannelReestablish_get_next_local_commitment_number(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelReestablish_1set_1next_1local_1commitment_1number(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKChannelReestablish this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	ChannelReestablish_set_next_local_commitment_number(&this_ptr_conv, val);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelReestablish_1get_1next_1remote_1commitment_1number(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKChannelReestablish this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int64_t ret_val = ChannelReestablish_get_next_remote_commitment_number(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelReestablish_1set_1next_1remote_1commitment_1number(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKChannelReestablish this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	ChannelReestablish_set_next_remote_commitment_number(&this_ptr_conv, val);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelReestablish_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKChannelReestablish orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKChannelReestablish ret_var = ChannelReestablish_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_AnnouncementSignatures_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKAnnouncementSignatures this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	AnnouncementSignatures_free(this_obj_conv);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_AnnouncementSignatures_1get_1channel_1id(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKAnnouncementSignatures this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 32);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 32, *AnnouncementSignatures_get_channel_id(&this_ptr_conv));
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_AnnouncementSignatures_1set_1channel_1id(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKAnnouncementSignatures this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKThirtyTwoBytes val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 32);
	(*env)->GetByteArrayRegion(env, val, 0, 32, val_ref.data);
	AnnouncementSignatures_set_channel_id(&this_ptr_conv, val_ref);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_AnnouncementSignatures_1get_1short_1channel_1id(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKAnnouncementSignatures this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int64_t ret_val = AnnouncementSignatures_get_short_channel_id(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_AnnouncementSignatures_1set_1short_1channel_1id(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKAnnouncementSignatures this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	AnnouncementSignatures_set_short_channel_id(&this_ptr_conv, val);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_AnnouncementSignatures_1get_1node_1signature(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKAnnouncementSignatures this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 64);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 64, AnnouncementSignatures_get_node_signature(&this_ptr_conv).compact_form);
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_AnnouncementSignatures_1set_1node_1signature(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKAnnouncementSignatures this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKSignature val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 64);
	(*env)->GetByteArrayRegion(env, val, 0, 64, val_ref.compact_form);
	AnnouncementSignatures_set_node_signature(&this_ptr_conv, val_ref);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_AnnouncementSignatures_1get_1bitcoin_1signature(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKAnnouncementSignatures this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 64);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 64, AnnouncementSignatures_get_bitcoin_signature(&this_ptr_conv).compact_form);
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_AnnouncementSignatures_1set_1bitcoin_1signature(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKAnnouncementSignatures this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKSignature val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 64);
	(*env)->GetByteArrayRegion(env, val, 0, 64, val_ref.compact_form);
	AnnouncementSignatures_set_bitcoin_signature(&this_ptr_conv, val_ref);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_AnnouncementSignatures_1new(JNIEnv *env, jclass clz, int8_tArray channel_id_arg, int64_t short_channel_id_arg, int8_tArray node_signature_arg, int8_tArray bitcoin_signature_arg) {
	LDKThirtyTwoBytes channel_id_arg_ref;
	CHECK((*env)->GetArrayLength(env, channel_id_arg) == 32);
	(*env)->GetByteArrayRegion(env, channel_id_arg, 0, 32, channel_id_arg_ref.data);
	LDKSignature node_signature_arg_ref;
	CHECK((*env)->GetArrayLength(env, node_signature_arg) == 64);
	(*env)->GetByteArrayRegion(env, node_signature_arg, 0, 64, node_signature_arg_ref.compact_form);
	LDKSignature bitcoin_signature_arg_ref;
	CHECK((*env)->GetArrayLength(env, bitcoin_signature_arg) == 64);
	(*env)->GetByteArrayRegion(env, bitcoin_signature_arg, 0, 64, bitcoin_signature_arg_ref.compact_form);
	LDKAnnouncementSignatures ret_var = AnnouncementSignatures_new(channel_id_arg_ref, short_channel_id_arg, node_signature_arg_ref, bitcoin_signature_arg_ref);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_AnnouncementSignatures_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKAnnouncementSignatures orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKAnnouncementSignatures ret_var = AnnouncementSignatures_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_NetAddress_1free(JNIEnv *env, jclass clz, int64_t this_ptr) {
	if ((this_ptr & 1) != 0) return;
	void* this_ptr_ptr = (void*)(((uint64_t)this_ptr) & ~1);
	CHECK_ACCESS(this_ptr_ptr);
	LDKNetAddress this_ptr_conv = *(LDKNetAddress*)(this_ptr_ptr);
	FREE((void*)this_ptr);
	NetAddress_free(this_ptr_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_NetAddress_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKNetAddress* orig_conv = (LDKNetAddress*)orig;
	LDKNetAddress *ret_copy = MALLOC(sizeof(LDKNetAddress), "LDKNetAddress");
	*ret_copy = NetAddress_clone(orig_conv);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_NetAddress_1ipv4(JNIEnv *env, jclass clz, int8_tArray addr, int16_t port) {
	LDKFourBytes addr_ref;
	CHECK((*env)->GetArrayLength(env, addr) == 4);
	(*env)->GetByteArrayRegion(env, addr, 0, 4, addr_ref.data);
	LDKNetAddress *ret_copy = MALLOC(sizeof(LDKNetAddress), "LDKNetAddress");
	*ret_copy = NetAddress_ipv4(addr_ref, port);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_NetAddress_1ipv6(JNIEnv *env, jclass clz, int8_tArray addr, int16_t port) {
	LDKSixteenBytes addr_ref;
	CHECK((*env)->GetArrayLength(env, addr) == 16);
	(*env)->GetByteArrayRegion(env, addr, 0, 16, addr_ref.data);
	LDKNetAddress *ret_copy = MALLOC(sizeof(LDKNetAddress), "LDKNetAddress");
	*ret_copy = NetAddress_ipv6(addr_ref, port);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_NetAddress_1onion_1v2(JNIEnv *env, jclass clz, int8_tArray addr, int16_t port) {
	LDKTenBytes addr_ref;
	CHECK((*env)->GetArrayLength(env, addr) == 10);
	(*env)->GetByteArrayRegion(env, addr, 0, 10, addr_ref.data);
	LDKNetAddress *ret_copy = MALLOC(sizeof(LDKNetAddress), "LDKNetAddress");
	*ret_copy = NetAddress_onion_v2(addr_ref, port);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_NetAddress_1onion_1v3(JNIEnv *env, jclass clz, int8_tArray ed25519_pubkey, int16_t checksum, int8_t version, int16_t port) {
	LDKThirtyTwoBytes ed25519_pubkey_ref;
	CHECK((*env)->GetArrayLength(env, ed25519_pubkey) == 32);
	(*env)->GetByteArrayRegion(env, ed25519_pubkey, 0, 32, ed25519_pubkey_ref.data);
	LDKNetAddress *ret_copy = MALLOC(sizeof(LDKNetAddress), "LDKNetAddress");
	*ret_copy = NetAddress_onion_v3(ed25519_pubkey_ref, checksum, version, port);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_NetAddress_1write(JNIEnv *env, jclass clz, int64_t obj) {
	LDKNetAddress* obj_conv = (LDKNetAddress*)obj;
	LDKCVec_u8Z ret_var = NetAddress_write(obj_conv);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	CVec_u8Z_free(ret_var);
	return ret_arr;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_NetAddress_1read(JNIEnv *env, jclass clz, int8_tArray ser) {
	LDKu8slice ser_ref;
	ser_ref.datalen = (*env)->GetArrayLength(env, ser);
	ser_ref.data = (*env)->GetByteArrayElements (env, ser, NULL);
	LDKCResult_NetAddressDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_NetAddressDecodeErrorZ), "LDKCResult_NetAddressDecodeErrorZ");
	*ret_conv = NetAddress_read(ser_ref);
	(*env)->ReleaseByteArrayElements(env, ser, (int8_t*)ser_ref.data, 0);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_UnsignedNodeAnnouncement_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKUnsignedNodeAnnouncement this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	UnsignedNodeAnnouncement_free(this_obj_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_UnsignedNodeAnnouncement_1get_1features(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKUnsignedNodeAnnouncement this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKNodeFeatures ret_var = UnsignedNodeAnnouncement_get_features(&this_ptr_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_UnsignedNodeAnnouncement_1set_1features(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKUnsignedNodeAnnouncement this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKNodeFeatures val_conv;
	val_conv.inner = (void*)(val & (~1));
	val_conv.is_owned = (val & 1) || (val == 0);
	val_conv = NodeFeatures_clone(&val_conv);
	UnsignedNodeAnnouncement_set_features(&this_ptr_conv, val_conv);
}

JNIEXPORT int32_t JNICALL Java_org_ldk_impl_bindings_UnsignedNodeAnnouncement_1get_1timestamp(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKUnsignedNodeAnnouncement this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int32_t ret_val = UnsignedNodeAnnouncement_get_timestamp(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_UnsignedNodeAnnouncement_1set_1timestamp(JNIEnv *env, jclass clz, int64_t this_ptr, int32_t val) {
	LDKUnsignedNodeAnnouncement this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	UnsignedNodeAnnouncement_set_timestamp(&this_ptr_conv, val);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_UnsignedNodeAnnouncement_1get_1node_1id(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKUnsignedNodeAnnouncement this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 33);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 33, UnsignedNodeAnnouncement_get_node_id(&this_ptr_conv).compressed_form);
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_UnsignedNodeAnnouncement_1set_1node_1id(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKUnsignedNodeAnnouncement this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKPublicKey val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 33);
	(*env)->GetByteArrayRegion(env, val, 0, 33, val_ref.compressed_form);
	UnsignedNodeAnnouncement_set_node_id(&this_ptr_conv, val_ref);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_UnsignedNodeAnnouncement_1get_1rgb(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKUnsignedNodeAnnouncement this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 3);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 3, *UnsignedNodeAnnouncement_get_rgb(&this_ptr_conv));
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_UnsignedNodeAnnouncement_1set_1rgb(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKUnsignedNodeAnnouncement this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKThreeBytes val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 3);
	(*env)->GetByteArrayRegion(env, val, 0, 3, val_ref.data);
	UnsignedNodeAnnouncement_set_rgb(&this_ptr_conv, val_ref);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_UnsignedNodeAnnouncement_1get_1alias(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKUnsignedNodeAnnouncement this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 32);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 32, *UnsignedNodeAnnouncement_get_alias(&this_ptr_conv));
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_UnsignedNodeAnnouncement_1set_1alias(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKUnsignedNodeAnnouncement this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKThirtyTwoBytes val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 32);
	(*env)->GetByteArrayRegion(env, val, 0, 32, val_ref.data);
	UnsignedNodeAnnouncement_set_alias(&this_ptr_conv, val_ref);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_UnsignedNodeAnnouncement_1set_1addresses(JNIEnv *env, jclass clz, int64_t this_ptr, int64_tArray val) {
	LDKUnsignedNodeAnnouncement this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKCVec_NetAddressZ val_constr;
	val_constr.datalen = (*env)->GetArrayLength(env, val);
	if (val_constr.datalen > 0)
		val_constr.data = MALLOC(val_constr.datalen * sizeof(LDKNetAddress), "LDKCVec_NetAddressZ Elements");
	else
		val_constr.data = NULL;
	int64_t* val_vals = (*env)->GetLongArrayElements (env, val, NULL);
	for (size_t m = 0; m < val_constr.datalen; m++) {
		int64_t val_conv_12 = val_vals[m];
		void* val_conv_12_ptr = (void*)(((uint64_t)val_conv_12) & ~1);
		CHECK_ACCESS(val_conv_12_ptr);
		LDKNetAddress val_conv_12_conv = *(LDKNetAddress*)(val_conv_12_ptr);
		val_conv_12_conv = NetAddress_clone((LDKNetAddress*)(((uint64_t)val_conv_12) & ~1));
		val_constr.data[m] = val_conv_12_conv;
	}
	(*env)->ReleaseLongArrayElements(env, val, val_vals, 0);
	UnsignedNodeAnnouncement_set_addresses(&this_ptr_conv, val_constr);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_UnsignedNodeAnnouncement_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKUnsignedNodeAnnouncement orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKUnsignedNodeAnnouncement ret_var = UnsignedNodeAnnouncement_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_NodeAnnouncement_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKNodeAnnouncement this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	NodeAnnouncement_free(this_obj_conv);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_NodeAnnouncement_1get_1signature(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKNodeAnnouncement this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 64);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 64, NodeAnnouncement_get_signature(&this_ptr_conv).compact_form);
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_NodeAnnouncement_1set_1signature(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKNodeAnnouncement this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKSignature val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 64);
	(*env)->GetByteArrayRegion(env, val, 0, 64, val_ref.compact_form);
	NodeAnnouncement_set_signature(&this_ptr_conv, val_ref);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_NodeAnnouncement_1get_1contents(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKNodeAnnouncement this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKUnsignedNodeAnnouncement ret_var = NodeAnnouncement_get_contents(&this_ptr_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_NodeAnnouncement_1set_1contents(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKNodeAnnouncement this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKUnsignedNodeAnnouncement val_conv;
	val_conv.inner = (void*)(val & (~1));
	val_conv.is_owned = (val & 1) || (val == 0);
	val_conv = UnsignedNodeAnnouncement_clone(&val_conv);
	NodeAnnouncement_set_contents(&this_ptr_conv, val_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_NodeAnnouncement_1new(JNIEnv *env, jclass clz, int8_tArray signature_arg, int64_t contents_arg) {
	LDKSignature signature_arg_ref;
	CHECK((*env)->GetArrayLength(env, signature_arg) == 64);
	(*env)->GetByteArrayRegion(env, signature_arg, 0, 64, signature_arg_ref.compact_form);
	LDKUnsignedNodeAnnouncement contents_arg_conv;
	contents_arg_conv.inner = (void*)(contents_arg & (~1));
	contents_arg_conv.is_owned = (contents_arg & 1) || (contents_arg == 0);
	contents_arg_conv = UnsignedNodeAnnouncement_clone(&contents_arg_conv);
	LDKNodeAnnouncement ret_var = NodeAnnouncement_new(signature_arg_ref, contents_arg_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_NodeAnnouncement_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKNodeAnnouncement orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKNodeAnnouncement ret_var = NodeAnnouncement_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_UnsignedChannelAnnouncement_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKUnsignedChannelAnnouncement this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	UnsignedChannelAnnouncement_free(this_obj_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_UnsignedChannelAnnouncement_1get_1features(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKUnsignedChannelAnnouncement this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKChannelFeatures ret_var = UnsignedChannelAnnouncement_get_features(&this_ptr_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_UnsignedChannelAnnouncement_1set_1features(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKUnsignedChannelAnnouncement this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKChannelFeatures val_conv;
	val_conv.inner = (void*)(val & (~1));
	val_conv.is_owned = (val & 1) || (val == 0);
	val_conv = ChannelFeatures_clone(&val_conv);
	UnsignedChannelAnnouncement_set_features(&this_ptr_conv, val_conv);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_UnsignedChannelAnnouncement_1get_1chain_1hash(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKUnsignedChannelAnnouncement this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 32);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 32, *UnsignedChannelAnnouncement_get_chain_hash(&this_ptr_conv));
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_UnsignedChannelAnnouncement_1set_1chain_1hash(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKUnsignedChannelAnnouncement this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKThirtyTwoBytes val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 32);
	(*env)->GetByteArrayRegion(env, val, 0, 32, val_ref.data);
	UnsignedChannelAnnouncement_set_chain_hash(&this_ptr_conv, val_ref);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_UnsignedChannelAnnouncement_1get_1short_1channel_1id(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKUnsignedChannelAnnouncement this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int64_t ret_val = UnsignedChannelAnnouncement_get_short_channel_id(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_UnsignedChannelAnnouncement_1set_1short_1channel_1id(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKUnsignedChannelAnnouncement this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	UnsignedChannelAnnouncement_set_short_channel_id(&this_ptr_conv, val);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_UnsignedChannelAnnouncement_1get_1node_1id_11(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKUnsignedChannelAnnouncement this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 33);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 33, UnsignedChannelAnnouncement_get_node_id_1(&this_ptr_conv).compressed_form);
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_UnsignedChannelAnnouncement_1set_1node_1id_11(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKUnsignedChannelAnnouncement this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKPublicKey val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 33);
	(*env)->GetByteArrayRegion(env, val, 0, 33, val_ref.compressed_form);
	UnsignedChannelAnnouncement_set_node_id_1(&this_ptr_conv, val_ref);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_UnsignedChannelAnnouncement_1get_1node_1id_12(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKUnsignedChannelAnnouncement this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 33);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 33, UnsignedChannelAnnouncement_get_node_id_2(&this_ptr_conv).compressed_form);
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_UnsignedChannelAnnouncement_1set_1node_1id_12(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKUnsignedChannelAnnouncement this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKPublicKey val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 33);
	(*env)->GetByteArrayRegion(env, val, 0, 33, val_ref.compressed_form);
	UnsignedChannelAnnouncement_set_node_id_2(&this_ptr_conv, val_ref);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_UnsignedChannelAnnouncement_1get_1bitcoin_1key_11(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKUnsignedChannelAnnouncement this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 33);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 33, UnsignedChannelAnnouncement_get_bitcoin_key_1(&this_ptr_conv).compressed_form);
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_UnsignedChannelAnnouncement_1set_1bitcoin_1key_11(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKUnsignedChannelAnnouncement this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKPublicKey val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 33);
	(*env)->GetByteArrayRegion(env, val, 0, 33, val_ref.compressed_form);
	UnsignedChannelAnnouncement_set_bitcoin_key_1(&this_ptr_conv, val_ref);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_UnsignedChannelAnnouncement_1get_1bitcoin_1key_12(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKUnsignedChannelAnnouncement this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 33);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 33, UnsignedChannelAnnouncement_get_bitcoin_key_2(&this_ptr_conv).compressed_form);
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_UnsignedChannelAnnouncement_1set_1bitcoin_1key_12(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKUnsignedChannelAnnouncement this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKPublicKey val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 33);
	(*env)->GetByteArrayRegion(env, val, 0, 33, val_ref.compressed_form);
	UnsignedChannelAnnouncement_set_bitcoin_key_2(&this_ptr_conv, val_ref);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_UnsignedChannelAnnouncement_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKUnsignedChannelAnnouncement orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKUnsignedChannelAnnouncement ret_var = UnsignedChannelAnnouncement_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelAnnouncement_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKChannelAnnouncement this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	ChannelAnnouncement_free(this_obj_conv);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_ChannelAnnouncement_1get_1node_1signature_11(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKChannelAnnouncement this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 64);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 64, ChannelAnnouncement_get_node_signature_1(&this_ptr_conv).compact_form);
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelAnnouncement_1set_1node_1signature_11(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKChannelAnnouncement this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKSignature val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 64);
	(*env)->GetByteArrayRegion(env, val, 0, 64, val_ref.compact_form);
	ChannelAnnouncement_set_node_signature_1(&this_ptr_conv, val_ref);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_ChannelAnnouncement_1get_1node_1signature_12(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKChannelAnnouncement this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 64);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 64, ChannelAnnouncement_get_node_signature_2(&this_ptr_conv).compact_form);
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelAnnouncement_1set_1node_1signature_12(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKChannelAnnouncement this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKSignature val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 64);
	(*env)->GetByteArrayRegion(env, val, 0, 64, val_ref.compact_form);
	ChannelAnnouncement_set_node_signature_2(&this_ptr_conv, val_ref);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_ChannelAnnouncement_1get_1bitcoin_1signature_11(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKChannelAnnouncement this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 64);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 64, ChannelAnnouncement_get_bitcoin_signature_1(&this_ptr_conv).compact_form);
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelAnnouncement_1set_1bitcoin_1signature_11(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKChannelAnnouncement this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKSignature val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 64);
	(*env)->GetByteArrayRegion(env, val, 0, 64, val_ref.compact_form);
	ChannelAnnouncement_set_bitcoin_signature_1(&this_ptr_conv, val_ref);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_ChannelAnnouncement_1get_1bitcoin_1signature_12(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKChannelAnnouncement this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 64);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 64, ChannelAnnouncement_get_bitcoin_signature_2(&this_ptr_conv).compact_form);
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelAnnouncement_1set_1bitcoin_1signature_12(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKChannelAnnouncement this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKSignature val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 64);
	(*env)->GetByteArrayRegion(env, val, 0, 64, val_ref.compact_form);
	ChannelAnnouncement_set_bitcoin_signature_2(&this_ptr_conv, val_ref);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelAnnouncement_1get_1contents(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKChannelAnnouncement this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKUnsignedChannelAnnouncement ret_var = ChannelAnnouncement_get_contents(&this_ptr_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelAnnouncement_1set_1contents(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKChannelAnnouncement this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKUnsignedChannelAnnouncement val_conv;
	val_conv.inner = (void*)(val & (~1));
	val_conv.is_owned = (val & 1) || (val == 0);
	val_conv = UnsignedChannelAnnouncement_clone(&val_conv);
	ChannelAnnouncement_set_contents(&this_ptr_conv, val_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelAnnouncement_1new(JNIEnv *env, jclass clz, int8_tArray node_signature_1_arg, int8_tArray node_signature_2_arg, int8_tArray bitcoin_signature_1_arg, int8_tArray bitcoin_signature_2_arg, int64_t contents_arg) {
	LDKSignature node_signature_1_arg_ref;
	CHECK((*env)->GetArrayLength(env, node_signature_1_arg) == 64);
	(*env)->GetByteArrayRegion(env, node_signature_1_arg, 0, 64, node_signature_1_arg_ref.compact_form);
	LDKSignature node_signature_2_arg_ref;
	CHECK((*env)->GetArrayLength(env, node_signature_2_arg) == 64);
	(*env)->GetByteArrayRegion(env, node_signature_2_arg, 0, 64, node_signature_2_arg_ref.compact_form);
	LDKSignature bitcoin_signature_1_arg_ref;
	CHECK((*env)->GetArrayLength(env, bitcoin_signature_1_arg) == 64);
	(*env)->GetByteArrayRegion(env, bitcoin_signature_1_arg, 0, 64, bitcoin_signature_1_arg_ref.compact_form);
	LDKSignature bitcoin_signature_2_arg_ref;
	CHECK((*env)->GetArrayLength(env, bitcoin_signature_2_arg) == 64);
	(*env)->GetByteArrayRegion(env, bitcoin_signature_2_arg, 0, 64, bitcoin_signature_2_arg_ref.compact_form);
	LDKUnsignedChannelAnnouncement contents_arg_conv;
	contents_arg_conv.inner = (void*)(contents_arg & (~1));
	contents_arg_conv.is_owned = (contents_arg & 1) || (contents_arg == 0);
	contents_arg_conv = UnsignedChannelAnnouncement_clone(&contents_arg_conv);
	LDKChannelAnnouncement ret_var = ChannelAnnouncement_new(node_signature_1_arg_ref, node_signature_2_arg_ref, bitcoin_signature_1_arg_ref, bitcoin_signature_2_arg_ref, contents_arg_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelAnnouncement_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKChannelAnnouncement orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKChannelAnnouncement ret_var = ChannelAnnouncement_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_UnsignedChannelUpdate_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKUnsignedChannelUpdate this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	UnsignedChannelUpdate_free(this_obj_conv);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_UnsignedChannelUpdate_1get_1chain_1hash(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKUnsignedChannelUpdate this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 32);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 32, *UnsignedChannelUpdate_get_chain_hash(&this_ptr_conv));
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_UnsignedChannelUpdate_1set_1chain_1hash(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKUnsignedChannelUpdate this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKThirtyTwoBytes val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 32);
	(*env)->GetByteArrayRegion(env, val, 0, 32, val_ref.data);
	UnsignedChannelUpdate_set_chain_hash(&this_ptr_conv, val_ref);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_UnsignedChannelUpdate_1get_1short_1channel_1id(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKUnsignedChannelUpdate this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int64_t ret_val = UnsignedChannelUpdate_get_short_channel_id(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_UnsignedChannelUpdate_1set_1short_1channel_1id(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKUnsignedChannelUpdate this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	UnsignedChannelUpdate_set_short_channel_id(&this_ptr_conv, val);
}

JNIEXPORT int32_t JNICALL Java_org_ldk_impl_bindings_UnsignedChannelUpdate_1get_1timestamp(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKUnsignedChannelUpdate this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int32_t ret_val = UnsignedChannelUpdate_get_timestamp(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_UnsignedChannelUpdate_1set_1timestamp(JNIEnv *env, jclass clz, int64_t this_ptr, int32_t val) {
	LDKUnsignedChannelUpdate this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	UnsignedChannelUpdate_set_timestamp(&this_ptr_conv, val);
}

JNIEXPORT int8_t JNICALL Java_org_ldk_impl_bindings_UnsignedChannelUpdate_1get_1flags(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKUnsignedChannelUpdate this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_t ret_val = UnsignedChannelUpdate_get_flags(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_UnsignedChannelUpdate_1set_1flags(JNIEnv *env, jclass clz, int64_t this_ptr, int8_t val) {
	LDKUnsignedChannelUpdate this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	UnsignedChannelUpdate_set_flags(&this_ptr_conv, val);
}

JNIEXPORT int16_t JNICALL Java_org_ldk_impl_bindings_UnsignedChannelUpdate_1get_1cltv_1expiry_1delta(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKUnsignedChannelUpdate this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int16_t ret_val = UnsignedChannelUpdate_get_cltv_expiry_delta(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_UnsignedChannelUpdate_1set_1cltv_1expiry_1delta(JNIEnv *env, jclass clz, int64_t this_ptr, int16_t val) {
	LDKUnsignedChannelUpdate this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	UnsignedChannelUpdate_set_cltv_expiry_delta(&this_ptr_conv, val);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_UnsignedChannelUpdate_1get_1htlc_1minimum_1msat(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKUnsignedChannelUpdate this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int64_t ret_val = UnsignedChannelUpdate_get_htlc_minimum_msat(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_UnsignedChannelUpdate_1set_1htlc_1minimum_1msat(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKUnsignedChannelUpdate this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	UnsignedChannelUpdate_set_htlc_minimum_msat(&this_ptr_conv, val);
}

JNIEXPORT int32_t JNICALL Java_org_ldk_impl_bindings_UnsignedChannelUpdate_1get_1fee_1base_1msat(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKUnsignedChannelUpdate this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int32_t ret_val = UnsignedChannelUpdate_get_fee_base_msat(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_UnsignedChannelUpdate_1set_1fee_1base_1msat(JNIEnv *env, jclass clz, int64_t this_ptr, int32_t val) {
	LDKUnsignedChannelUpdate this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	UnsignedChannelUpdate_set_fee_base_msat(&this_ptr_conv, val);
}

JNIEXPORT int32_t JNICALL Java_org_ldk_impl_bindings_UnsignedChannelUpdate_1get_1fee_1proportional_1millionths(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKUnsignedChannelUpdate this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int32_t ret_val = UnsignedChannelUpdate_get_fee_proportional_millionths(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_UnsignedChannelUpdate_1set_1fee_1proportional_1millionths(JNIEnv *env, jclass clz, int64_t this_ptr, int32_t val) {
	LDKUnsignedChannelUpdate this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	UnsignedChannelUpdate_set_fee_proportional_millionths(&this_ptr_conv, val);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_UnsignedChannelUpdate_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKUnsignedChannelUpdate orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKUnsignedChannelUpdate ret_var = UnsignedChannelUpdate_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelUpdate_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKChannelUpdate this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	ChannelUpdate_free(this_obj_conv);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_ChannelUpdate_1get_1signature(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKChannelUpdate this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 64);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 64, ChannelUpdate_get_signature(&this_ptr_conv).compact_form);
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelUpdate_1set_1signature(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKChannelUpdate this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKSignature val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 64);
	(*env)->GetByteArrayRegion(env, val, 0, 64, val_ref.compact_form);
	ChannelUpdate_set_signature(&this_ptr_conv, val_ref);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelUpdate_1get_1contents(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKChannelUpdate this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKUnsignedChannelUpdate ret_var = ChannelUpdate_get_contents(&this_ptr_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelUpdate_1set_1contents(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKChannelUpdate this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKUnsignedChannelUpdate val_conv;
	val_conv.inner = (void*)(val & (~1));
	val_conv.is_owned = (val & 1) || (val == 0);
	val_conv = UnsignedChannelUpdate_clone(&val_conv);
	ChannelUpdate_set_contents(&this_ptr_conv, val_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelUpdate_1new(JNIEnv *env, jclass clz, int8_tArray signature_arg, int64_t contents_arg) {
	LDKSignature signature_arg_ref;
	CHECK((*env)->GetArrayLength(env, signature_arg) == 64);
	(*env)->GetByteArrayRegion(env, signature_arg, 0, 64, signature_arg_ref.compact_form);
	LDKUnsignedChannelUpdate contents_arg_conv;
	contents_arg_conv.inner = (void*)(contents_arg & (~1));
	contents_arg_conv.is_owned = (contents_arg & 1) || (contents_arg == 0);
	contents_arg_conv = UnsignedChannelUpdate_clone(&contents_arg_conv);
	LDKChannelUpdate ret_var = ChannelUpdate_new(signature_arg_ref, contents_arg_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelUpdate_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKChannelUpdate orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKChannelUpdate ret_var = ChannelUpdate_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_QueryChannelRange_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKQueryChannelRange this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	QueryChannelRange_free(this_obj_conv);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_QueryChannelRange_1get_1chain_1hash(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKQueryChannelRange this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 32);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 32, *QueryChannelRange_get_chain_hash(&this_ptr_conv));
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_QueryChannelRange_1set_1chain_1hash(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKQueryChannelRange this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKThirtyTwoBytes val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 32);
	(*env)->GetByteArrayRegion(env, val, 0, 32, val_ref.data);
	QueryChannelRange_set_chain_hash(&this_ptr_conv, val_ref);
}

JNIEXPORT int32_t JNICALL Java_org_ldk_impl_bindings_QueryChannelRange_1get_1first_1blocknum(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKQueryChannelRange this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int32_t ret_val = QueryChannelRange_get_first_blocknum(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_QueryChannelRange_1set_1first_1blocknum(JNIEnv *env, jclass clz, int64_t this_ptr, int32_t val) {
	LDKQueryChannelRange this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	QueryChannelRange_set_first_blocknum(&this_ptr_conv, val);
}

JNIEXPORT int32_t JNICALL Java_org_ldk_impl_bindings_QueryChannelRange_1get_1number_1of_1blocks(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKQueryChannelRange this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int32_t ret_val = QueryChannelRange_get_number_of_blocks(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_QueryChannelRange_1set_1number_1of_1blocks(JNIEnv *env, jclass clz, int64_t this_ptr, int32_t val) {
	LDKQueryChannelRange this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	QueryChannelRange_set_number_of_blocks(&this_ptr_conv, val);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_QueryChannelRange_1new(JNIEnv *env, jclass clz, int8_tArray chain_hash_arg, int32_t first_blocknum_arg, int32_t number_of_blocks_arg) {
	LDKThirtyTwoBytes chain_hash_arg_ref;
	CHECK((*env)->GetArrayLength(env, chain_hash_arg) == 32);
	(*env)->GetByteArrayRegion(env, chain_hash_arg, 0, 32, chain_hash_arg_ref.data);
	LDKQueryChannelRange ret_var = QueryChannelRange_new(chain_hash_arg_ref, first_blocknum_arg, number_of_blocks_arg);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_QueryChannelRange_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKQueryChannelRange orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKQueryChannelRange ret_var = QueryChannelRange_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ReplyChannelRange_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKReplyChannelRange this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	ReplyChannelRange_free(this_obj_conv);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_ReplyChannelRange_1get_1chain_1hash(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKReplyChannelRange this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 32);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 32, *ReplyChannelRange_get_chain_hash(&this_ptr_conv));
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ReplyChannelRange_1set_1chain_1hash(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKReplyChannelRange this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKThirtyTwoBytes val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 32);
	(*env)->GetByteArrayRegion(env, val, 0, 32, val_ref.data);
	ReplyChannelRange_set_chain_hash(&this_ptr_conv, val_ref);
}

JNIEXPORT int32_t JNICALL Java_org_ldk_impl_bindings_ReplyChannelRange_1get_1first_1blocknum(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKReplyChannelRange this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int32_t ret_val = ReplyChannelRange_get_first_blocknum(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ReplyChannelRange_1set_1first_1blocknum(JNIEnv *env, jclass clz, int64_t this_ptr, int32_t val) {
	LDKReplyChannelRange this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	ReplyChannelRange_set_first_blocknum(&this_ptr_conv, val);
}

JNIEXPORT int32_t JNICALL Java_org_ldk_impl_bindings_ReplyChannelRange_1get_1number_1of_1blocks(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKReplyChannelRange this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int32_t ret_val = ReplyChannelRange_get_number_of_blocks(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ReplyChannelRange_1set_1number_1of_1blocks(JNIEnv *env, jclass clz, int64_t this_ptr, int32_t val) {
	LDKReplyChannelRange this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	ReplyChannelRange_set_number_of_blocks(&this_ptr_conv, val);
}

JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_ReplyChannelRange_1get_1sync_1complete(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKReplyChannelRange this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	jboolean ret_val = ReplyChannelRange_get_sync_complete(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ReplyChannelRange_1set_1sync_1complete(JNIEnv *env, jclass clz, int64_t this_ptr, jboolean val) {
	LDKReplyChannelRange this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	ReplyChannelRange_set_sync_complete(&this_ptr_conv, val);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ReplyChannelRange_1set_1short_1channel_1ids(JNIEnv *env, jclass clz, int64_t this_ptr, int64_tArray val) {
	LDKReplyChannelRange this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKCVec_u64Z val_constr;
	val_constr.datalen = (*env)->GetArrayLength(env, val);
	if (val_constr.datalen > 0)
		val_constr.data = MALLOC(val_constr.datalen * sizeof(int64_t), "LDKCVec_u64Z Elements");
	else
		val_constr.data = NULL;
	int64_t* val_vals = (*env)->GetLongArrayElements (env, val, NULL);
	for (size_t g = 0; g < val_constr.datalen; g++) {
		int64_t val_conv_6 = val_vals[g];
		val_constr.data[g] = val_conv_6;
	}
	(*env)->ReleaseLongArrayElements(env, val, val_vals, 0);
	ReplyChannelRange_set_short_channel_ids(&this_ptr_conv, val_constr);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ReplyChannelRange_1new(JNIEnv *env, jclass clz, int8_tArray chain_hash_arg, int32_t first_blocknum_arg, int32_t number_of_blocks_arg, jboolean sync_complete_arg, int64_tArray short_channel_ids_arg) {
	LDKThirtyTwoBytes chain_hash_arg_ref;
	CHECK((*env)->GetArrayLength(env, chain_hash_arg) == 32);
	(*env)->GetByteArrayRegion(env, chain_hash_arg, 0, 32, chain_hash_arg_ref.data);
	LDKCVec_u64Z short_channel_ids_arg_constr;
	short_channel_ids_arg_constr.datalen = (*env)->GetArrayLength(env, short_channel_ids_arg);
	if (short_channel_ids_arg_constr.datalen > 0)
		short_channel_ids_arg_constr.data = MALLOC(short_channel_ids_arg_constr.datalen * sizeof(int64_t), "LDKCVec_u64Z Elements");
	else
		short_channel_ids_arg_constr.data = NULL;
	int64_t* short_channel_ids_arg_vals = (*env)->GetLongArrayElements (env, short_channel_ids_arg, NULL);
	for (size_t g = 0; g < short_channel_ids_arg_constr.datalen; g++) {
		int64_t short_channel_ids_arg_conv_6 = short_channel_ids_arg_vals[g];
		short_channel_ids_arg_constr.data[g] = short_channel_ids_arg_conv_6;
	}
	(*env)->ReleaseLongArrayElements(env, short_channel_ids_arg, short_channel_ids_arg_vals, 0);
	LDKReplyChannelRange ret_var = ReplyChannelRange_new(chain_hash_arg_ref, first_blocknum_arg, number_of_blocks_arg, sync_complete_arg, short_channel_ids_arg_constr);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ReplyChannelRange_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKReplyChannelRange orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKReplyChannelRange ret_var = ReplyChannelRange_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_QueryShortChannelIds_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKQueryShortChannelIds this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	QueryShortChannelIds_free(this_obj_conv);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_QueryShortChannelIds_1get_1chain_1hash(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKQueryShortChannelIds this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 32);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 32, *QueryShortChannelIds_get_chain_hash(&this_ptr_conv));
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_QueryShortChannelIds_1set_1chain_1hash(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKQueryShortChannelIds this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKThirtyTwoBytes val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 32);
	(*env)->GetByteArrayRegion(env, val, 0, 32, val_ref.data);
	QueryShortChannelIds_set_chain_hash(&this_ptr_conv, val_ref);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_QueryShortChannelIds_1set_1short_1channel_1ids(JNIEnv *env, jclass clz, int64_t this_ptr, int64_tArray val) {
	LDKQueryShortChannelIds this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKCVec_u64Z val_constr;
	val_constr.datalen = (*env)->GetArrayLength(env, val);
	if (val_constr.datalen > 0)
		val_constr.data = MALLOC(val_constr.datalen * sizeof(int64_t), "LDKCVec_u64Z Elements");
	else
		val_constr.data = NULL;
	int64_t* val_vals = (*env)->GetLongArrayElements (env, val, NULL);
	for (size_t g = 0; g < val_constr.datalen; g++) {
		int64_t val_conv_6 = val_vals[g];
		val_constr.data[g] = val_conv_6;
	}
	(*env)->ReleaseLongArrayElements(env, val, val_vals, 0);
	QueryShortChannelIds_set_short_channel_ids(&this_ptr_conv, val_constr);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_QueryShortChannelIds_1new(JNIEnv *env, jclass clz, int8_tArray chain_hash_arg, int64_tArray short_channel_ids_arg) {
	LDKThirtyTwoBytes chain_hash_arg_ref;
	CHECK((*env)->GetArrayLength(env, chain_hash_arg) == 32);
	(*env)->GetByteArrayRegion(env, chain_hash_arg, 0, 32, chain_hash_arg_ref.data);
	LDKCVec_u64Z short_channel_ids_arg_constr;
	short_channel_ids_arg_constr.datalen = (*env)->GetArrayLength(env, short_channel_ids_arg);
	if (short_channel_ids_arg_constr.datalen > 0)
		short_channel_ids_arg_constr.data = MALLOC(short_channel_ids_arg_constr.datalen * sizeof(int64_t), "LDKCVec_u64Z Elements");
	else
		short_channel_ids_arg_constr.data = NULL;
	int64_t* short_channel_ids_arg_vals = (*env)->GetLongArrayElements (env, short_channel_ids_arg, NULL);
	for (size_t g = 0; g < short_channel_ids_arg_constr.datalen; g++) {
		int64_t short_channel_ids_arg_conv_6 = short_channel_ids_arg_vals[g];
		short_channel_ids_arg_constr.data[g] = short_channel_ids_arg_conv_6;
	}
	(*env)->ReleaseLongArrayElements(env, short_channel_ids_arg, short_channel_ids_arg_vals, 0);
	LDKQueryShortChannelIds ret_var = QueryShortChannelIds_new(chain_hash_arg_ref, short_channel_ids_arg_constr);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_QueryShortChannelIds_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKQueryShortChannelIds orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKQueryShortChannelIds ret_var = QueryShortChannelIds_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ReplyShortChannelIdsEnd_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKReplyShortChannelIdsEnd this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	ReplyShortChannelIdsEnd_free(this_obj_conv);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_ReplyShortChannelIdsEnd_1get_1chain_1hash(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKReplyShortChannelIdsEnd this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 32);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 32, *ReplyShortChannelIdsEnd_get_chain_hash(&this_ptr_conv));
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ReplyShortChannelIdsEnd_1set_1chain_1hash(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKReplyShortChannelIdsEnd this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKThirtyTwoBytes val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 32);
	(*env)->GetByteArrayRegion(env, val, 0, 32, val_ref.data);
	ReplyShortChannelIdsEnd_set_chain_hash(&this_ptr_conv, val_ref);
}

JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_ReplyShortChannelIdsEnd_1get_1full_1information(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKReplyShortChannelIdsEnd this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	jboolean ret_val = ReplyShortChannelIdsEnd_get_full_information(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ReplyShortChannelIdsEnd_1set_1full_1information(JNIEnv *env, jclass clz, int64_t this_ptr, jboolean val) {
	LDKReplyShortChannelIdsEnd this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	ReplyShortChannelIdsEnd_set_full_information(&this_ptr_conv, val);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ReplyShortChannelIdsEnd_1new(JNIEnv *env, jclass clz, int8_tArray chain_hash_arg, jboolean full_information_arg) {
	LDKThirtyTwoBytes chain_hash_arg_ref;
	CHECK((*env)->GetArrayLength(env, chain_hash_arg) == 32);
	(*env)->GetByteArrayRegion(env, chain_hash_arg, 0, 32, chain_hash_arg_ref.data);
	LDKReplyShortChannelIdsEnd ret_var = ReplyShortChannelIdsEnd_new(chain_hash_arg_ref, full_information_arg);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ReplyShortChannelIdsEnd_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKReplyShortChannelIdsEnd orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKReplyShortChannelIdsEnd ret_var = ReplyShortChannelIdsEnd_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_GossipTimestampFilter_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKGossipTimestampFilter this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	GossipTimestampFilter_free(this_obj_conv);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_GossipTimestampFilter_1get_1chain_1hash(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKGossipTimestampFilter this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 32);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 32, *GossipTimestampFilter_get_chain_hash(&this_ptr_conv));
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_GossipTimestampFilter_1set_1chain_1hash(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKGossipTimestampFilter this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKThirtyTwoBytes val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 32);
	(*env)->GetByteArrayRegion(env, val, 0, 32, val_ref.data);
	GossipTimestampFilter_set_chain_hash(&this_ptr_conv, val_ref);
}

JNIEXPORT int32_t JNICALL Java_org_ldk_impl_bindings_GossipTimestampFilter_1get_1first_1timestamp(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKGossipTimestampFilter this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int32_t ret_val = GossipTimestampFilter_get_first_timestamp(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_GossipTimestampFilter_1set_1first_1timestamp(JNIEnv *env, jclass clz, int64_t this_ptr, int32_t val) {
	LDKGossipTimestampFilter this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	GossipTimestampFilter_set_first_timestamp(&this_ptr_conv, val);
}

JNIEXPORT int32_t JNICALL Java_org_ldk_impl_bindings_GossipTimestampFilter_1get_1timestamp_1range(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKGossipTimestampFilter this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int32_t ret_val = GossipTimestampFilter_get_timestamp_range(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_GossipTimestampFilter_1set_1timestamp_1range(JNIEnv *env, jclass clz, int64_t this_ptr, int32_t val) {
	LDKGossipTimestampFilter this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	GossipTimestampFilter_set_timestamp_range(&this_ptr_conv, val);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_GossipTimestampFilter_1new(JNIEnv *env, jclass clz, int8_tArray chain_hash_arg, int32_t first_timestamp_arg, int32_t timestamp_range_arg) {
	LDKThirtyTwoBytes chain_hash_arg_ref;
	CHECK((*env)->GetArrayLength(env, chain_hash_arg) == 32);
	(*env)->GetByteArrayRegion(env, chain_hash_arg, 0, 32, chain_hash_arg_ref.data);
	LDKGossipTimestampFilter ret_var = GossipTimestampFilter_new(chain_hash_arg_ref, first_timestamp_arg, timestamp_range_arg);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_GossipTimestampFilter_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKGossipTimestampFilter orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKGossipTimestampFilter ret_var = GossipTimestampFilter_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ErrorAction_1free(JNIEnv *env, jclass clz, int64_t this_ptr) {
	if ((this_ptr & 1) != 0) return;
	void* this_ptr_ptr = (void*)(((uint64_t)this_ptr) & ~1);
	CHECK_ACCESS(this_ptr_ptr);
	LDKErrorAction this_ptr_conv = *(LDKErrorAction*)(this_ptr_ptr);
	FREE((void*)this_ptr);
	ErrorAction_free(this_ptr_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ErrorAction_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKErrorAction* orig_conv = (LDKErrorAction*)orig;
	LDKErrorAction *ret_copy = MALLOC(sizeof(LDKErrorAction), "LDKErrorAction");
	*ret_copy = ErrorAction_clone(orig_conv);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ErrorAction_1disconnect_1peer(JNIEnv *env, jclass clz, int64_t msg) {
	LDKErrorMessage msg_conv;
	msg_conv.inner = (void*)(msg & (~1));
	msg_conv.is_owned = (msg & 1) || (msg == 0);
	msg_conv = ErrorMessage_clone(&msg_conv);
	LDKErrorAction *ret_copy = MALLOC(sizeof(LDKErrorAction), "LDKErrorAction");
	*ret_copy = ErrorAction_disconnect_peer(msg_conv);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ErrorAction_1ignore_1error(JNIEnv *env, jclass clz) {
	LDKErrorAction *ret_copy = MALLOC(sizeof(LDKErrorAction), "LDKErrorAction");
	*ret_copy = ErrorAction_ignore_error();
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ErrorAction_1ignore_1and_1log(JNIEnv *env, jclass clz, jclass a) {
	LDKLevel a_conv = LDKLevel_from_java(env, a);
	LDKErrorAction *ret_copy = MALLOC(sizeof(LDKErrorAction), "LDKErrorAction");
	*ret_copy = ErrorAction_ignore_and_log(a_conv);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ErrorAction_1send_1error_1message(JNIEnv *env, jclass clz, int64_t msg) {
	LDKErrorMessage msg_conv;
	msg_conv.inner = (void*)(msg & (~1));
	msg_conv.is_owned = (msg & 1) || (msg == 0);
	msg_conv = ErrorMessage_clone(&msg_conv);
	LDKErrorAction *ret_copy = MALLOC(sizeof(LDKErrorAction), "LDKErrorAction");
	*ret_copy = ErrorAction_send_error_message(msg_conv);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_LightningError_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKLightningError this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	LightningError_free(this_obj_conv);
}

JNIEXPORT jstring JNICALL Java_org_ldk_impl_bindings_LightningError_1get_1err(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKLightningError this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKStr ret_str = LightningError_get_err(&this_ptr_conv);
	jstring ret_conv = str_ref_to_java(env, ret_str.chars, ret_str.len);
	Str_free(ret_str);
	return ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_LightningError_1set_1err(JNIEnv *env, jclass clz, int64_t this_ptr, jstring val) {
	LDKLightningError this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKStr val_conv = java_to_owned_str(env, val);
	LightningError_set_err(&this_ptr_conv, val_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LightningError_1get_1action(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKLightningError this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKErrorAction *ret_copy = MALLOC(sizeof(LDKErrorAction), "LDKErrorAction");
	*ret_copy = LightningError_get_action(&this_ptr_conv);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_LightningError_1set_1action(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKLightningError this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	void* val_ptr = (void*)(((uint64_t)val) & ~1);
	CHECK_ACCESS(val_ptr);
	LDKErrorAction val_conv = *(LDKErrorAction*)(val_ptr);
	val_conv = ErrorAction_clone((LDKErrorAction*)(((uint64_t)val) & ~1));
	LightningError_set_action(&this_ptr_conv, val_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LightningError_1new(JNIEnv *env, jclass clz, jstring err_arg, int64_t action_arg) {
	LDKStr err_arg_conv = java_to_owned_str(env, err_arg);
	void* action_arg_ptr = (void*)(((uint64_t)action_arg) & ~1);
	CHECK_ACCESS(action_arg_ptr);
	LDKErrorAction action_arg_conv = *(LDKErrorAction*)(action_arg_ptr);
	action_arg_conv = ErrorAction_clone((LDKErrorAction*)(((uint64_t)action_arg) & ~1));
	LDKLightningError ret_var = LightningError_new(err_arg_conv, action_arg_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LightningError_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKLightningError orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKLightningError ret_var = LightningError_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CommitmentUpdate_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKCommitmentUpdate this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	CommitmentUpdate_free(this_obj_conv);
}

JNIEXPORT int64_tArray JNICALL Java_org_ldk_impl_bindings_CommitmentUpdate_1get_1update_1add_1htlcs(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKCommitmentUpdate this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKCVec_UpdateAddHTLCZ ret_var = CommitmentUpdate_get_update_add_htlcs(&this_ptr_conv);
	int64_tArray ret_arr = NULL;
	ret_arr = (*env)->NewLongArray(env, ret_var.datalen);
	int64_t *ret_arr_ptr = (*env)->GetPrimitiveArrayCritical(env, ret_arr, NULL);
	for (size_t p = 0; p < ret_var.datalen; p++) {
		LDKUpdateAddHTLC ret_conv_15_var = ret_var.data[p];
		uint64_t ret_conv_15_ref = 0;
		CHECK((((uint64_t)ret_conv_15_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
		CHECK((((uint64_t)&ret_conv_15_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
		ret_conv_15_ref = (uint64_t)ret_conv_15_var.inner;
		if (ret_conv_15_var.is_owned) {
			ret_conv_15_ref |= 1;
		}
		ret_arr_ptr[p] = ret_conv_15_ref;
	}
	(*env)->ReleasePrimitiveArrayCritical(env, ret_arr, ret_arr_ptr, 0);
	FREE(ret_var.data);
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CommitmentUpdate_1set_1update_1add_1htlcs(JNIEnv *env, jclass clz, int64_t this_ptr, int64_tArray val) {
	LDKCommitmentUpdate this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKCVec_UpdateAddHTLCZ val_constr;
	val_constr.datalen = (*env)->GetArrayLength(env, val);
	if (val_constr.datalen > 0)
		val_constr.data = MALLOC(val_constr.datalen * sizeof(LDKUpdateAddHTLC), "LDKCVec_UpdateAddHTLCZ Elements");
	else
		val_constr.data = NULL;
	int64_t* val_vals = (*env)->GetLongArrayElements (env, val, NULL);
	for (size_t p = 0; p < val_constr.datalen; p++) {
		int64_t val_conv_15 = val_vals[p];
		LDKUpdateAddHTLC val_conv_15_conv;
		val_conv_15_conv.inner = (void*)(val_conv_15 & (~1));
		val_conv_15_conv.is_owned = (val_conv_15 & 1) || (val_conv_15 == 0);
		val_conv_15_conv = UpdateAddHTLC_clone(&val_conv_15_conv);
		val_constr.data[p] = val_conv_15_conv;
	}
	(*env)->ReleaseLongArrayElements(env, val, val_vals, 0);
	CommitmentUpdate_set_update_add_htlcs(&this_ptr_conv, val_constr);
}

JNIEXPORT int64_tArray JNICALL Java_org_ldk_impl_bindings_CommitmentUpdate_1get_1update_1fulfill_1htlcs(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKCommitmentUpdate this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKCVec_UpdateFulfillHTLCZ ret_var = CommitmentUpdate_get_update_fulfill_htlcs(&this_ptr_conv);
	int64_tArray ret_arr = NULL;
	ret_arr = (*env)->NewLongArray(env, ret_var.datalen);
	int64_t *ret_arr_ptr = (*env)->GetPrimitiveArrayCritical(env, ret_arr, NULL);
	for (size_t t = 0; t < ret_var.datalen; t++) {
		LDKUpdateFulfillHTLC ret_conv_19_var = ret_var.data[t];
		uint64_t ret_conv_19_ref = 0;
		CHECK((((uint64_t)ret_conv_19_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
		CHECK((((uint64_t)&ret_conv_19_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
		ret_conv_19_ref = (uint64_t)ret_conv_19_var.inner;
		if (ret_conv_19_var.is_owned) {
			ret_conv_19_ref |= 1;
		}
		ret_arr_ptr[t] = ret_conv_19_ref;
	}
	(*env)->ReleasePrimitiveArrayCritical(env, ret_arr, ret_arr_ptr, 0);
	FREE(ret_var.data);
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CommitmentUpdate_1set_1update_1fulfill_1htlcs(JNIEnv *env, jclass clz, int64_t this_ptr, int64_tArray val) {
	LDKCommitmentUpdate this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKCVec_UpdateFulfillHTLCZ val_constr;
	val_constr.datalen = (*env)->GetArrayLength(env, val);
	if (val_constr.datalen > 0)
		val_constr.data = MALLOC(val_constr.datalen * sizeof(LDKUpdateFulfillHTLC), "LDKCVec_UpdateFulfillHTLCZ Elements");
	else
		val_constr.data = NULL;
	int64_t* val_vals = (*env)->GetLongArrayElements (env, val, NULL);
	for (size_t t = 0; t < val_constr.datalen; t++) {
		int64_t val_conv_19 = val_vals[t];
		LDKUpdateFulfillHTLC val_conv_19_conv;
		val_conv_19_conv.inner = (void*)(val_conv_19 & (~1));
		val_conv_19_conv.is_owned = (val_conv_19 & 1) || (val_conv_19 == 0);
		val_conv_19_conv = UpdateFulfillHTLC_clone(&val_conv_19_conv);
		val_constr.data[t] = val_conv_19_conv;
	}
	(*env)->ReleaseLongArrayElements(env, val, val_vals, 0);
	CommitmentUpdate_set_update_fulfill_htlcs(&this_ptr_conv, val_constr);
}

JNIEXPORT int64_tArray JNICALL Java_org_ldk_impl_bindings_CommitmentUpdate_1get_1update_1fail_1htlcs(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKCommitmentUpdate this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKCVec_UpdateFailHTLCZ ret_var = CommitmentUpdate_get_update_fail_htlcs(&this_ptr_conv);
	int64_tArray ret_arr = NULL;
	ret_arr = (*env)->NewLongArray(env, ret_var.datalen);
	int64_t *ret_arr_ptr = (*env)->GetPrimitiveArrayCritical(env, ret_arr, NULL);
	for (size_t q = 0; q < ret_var.datalen; q++) {
		LDKUpdateFailHTLC ret_conv_16_var = ret_var.data[q];
		uint64_t ret_conv_16_ref = 0;
		CHECK((((uint64_t)ret_conv_16_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
		CHECK((((uint64_t)&ret_conv_16_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
		ret_conv_16_ref = (uint64_t)ret_conv_16_var.inner;
		if (ret_conv_16_var.is_owned) {
			ret_conv_16_ref |= 1;
		}
		ret_arr_ptr[q] = ret_conv_16_ref;
	}
	(*env)->ReleasePrimitiveArrayCritical(env, ret_arr, ret_arr_ptr, 0);
	FREE(ret_var.data);
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CommitmentUpdate_1set_1update_1fail_1htlcs(JNIEnv *env, jclass clz, int64_t this_ptr, int64_tArray val) {
	LDKCommitmentUpdate this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKCVec_UpdateFailHTLCZ val_constr;
	val_constr.datalen = (*env)->GetArrayLength(env, val);
	if (val_constr.datalen > 0)
		val_constr.data = MALLOC(val_constr.datalen * sizeof(LDKUpdateFailHTLC), "LDKCVec_UpdateFailHTLCZ Elements");
	else
		val_constr.data = NULL;
	int64_t* val_vals = (*env)->GetLongArrayElements (env, val, NULL);
	for (size_t q = 0; q < val_constr.datalen; q++) {
		int64_t val_conv_16 = val_vals[q];
		LDKUpdateFailHTLC val_conv_16_conv;
		val_conv_16_conv.inner = (void*)(val_conv_16 & (~1));
		val_conv_16_conv.is_owned = (val_conv_16 & 1) || (val_conv_16 == 0);
		val_conv_16_conv = UpdateFailHTLC_clone(&val_conv_16_conv);
		val_constr.data[q] = val_conv_16_conv;
	}
	(*env)->ReleaseLongArrayElements(env, val, val_vals, 0);
	CommitmentUpdate_set_update_fail_htlcs(&this_ptr_conv, val_constr);
}

JNIEXPORT int64_tArray JNICALL Java_org_ldk_impl_bindings_CommitmentUpdate_1get_1update_1fail_1malformed_1htlcs(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKCommitmentUpdate this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKCVec_UpdateFailMalformedHTLCZ ret_var = CommitmentUpdate_get_update_fail_malformed_htlcs(&this_ptr_conv);
	int64_tArray ret_arr = NULL;
	ret_arr = (*env)->NewLongArray(env, ret_var.datalen);
	int64_t *ret_arr_ptr = (*env)->GetPrimitiveArrayCritical(env, ret_arr, NULL);
	for (size_t z = 0; z < ret_var.datalen; z++) {
		LDKUpdateFailMalformedHTLC ret_conv_25_var = ret_var.data[z];
		uint64_t ret_conv_25_ref = 0;
		CHECK((((uint64_t)ret_conv_25_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
		CHECK((((uint64_t)&ret_conv_25_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
		ret_conv_25_ref = (uint64_t)ret_conv_25_var.inner;
		if (ret_conv_25_var.is_owned) {
			ret_conv_25_ref |= 1;
		}
		ret_arr_ptr[z] = ret_conv_25_ref;
	}
	(*env)->ReleasePrimitiveArrayCritical(env, ret_arr, ret_arr_ptr, 0);
	FREE(ret_var.data);
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CommitmentUpdate_1set_1update_1fail_1malformed_1htlcs(JNIEnv *env, jclass clz, int64_t this_ptr, int64_tArray val) {
	LDKCommitmentUpdate this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKCVec_UpdateFailMalformedHTLCZ val_constr;
	val_constr.datalen = (*env)->GetArrayLength(env, val);
	if (val_constr.datalen > 0)
		val_constr.data = MALLOC(val_constr.datalen * sizeof(LDKUpdateFailMalformedHTLC), "LDKCVec_UpdateFailMalformedHTLCZ Elements");
	else
		val_constr.data = NULL;
	int64_t* val_vals = (*env)->GetLongArrayElements (env, val, NULL);
	for (size_t z = 0; z < val_constr.datalen; z++) {
		int64_t val_conv_25 = val_vals[z];
		LDKUpdateFailMalformedHTLC val_conv_25_conv;
		val_conv_25_conv.inner = (void*)(val_conv_25 & (~1));
		val_conv_25_conv.is_owned = (val_conv_25 & 1) || (val_conv_25 == 0);
		val_conv_25_conv = UpdateFailMalformedHTLC_clone(&val_conv_25_conv);
		val_constr.data[z] = val_conv_25_conv;
	}
	(*env)->ReleaseLongArrayElements(env, val, val_vals, 0);
	CommitmentUpdate_set_update_fail_malformed_htlcs(&this_ptr_conv, val_constr);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CommitmentUpdate_1get_1update_1fee(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKCommitmentUpdate this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKUpdateFee ret_var = CommitmentUpdate_get_update_fee(&this_ptr_conv);
	uint64_t ret_ref = 0;
	if ((uint64_t)ret_var.inner > 4096) {
		CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
		CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
		ret_ref = (uint64_t)ret_var.inner;
		if (ret_var.is_owned) {
			ret_ref |= 1;
		}
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CommitmentUpdate_1set_1update_1fee(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKCommitmentUpdate this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKUpdateFee val_conv;
	val_conv.inner = (void*)(val & (~1));
	val_conv.is_owned = (val & 1) || (val == 0);
	val_conv = UpdateFee_clone(&val_conv);
	CommitmentUpdate_set_update_fee(&this_ptr_conv, val_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CommitmentUpdate_1get_1commitment_1signed(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKCommitmentUpdate this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKCommitmentSigned ret_var = CommitmentUpdate_get_commitment_signed(&this_ptr_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CommitmentUpdate_1set_1commitment_1signed(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKCommitmentUpdate this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKCommitmentSigned val_conv;
	val_conv.inner = (void*)(val & (~1));
	val_conv.is_owned = (val & 1) || (val == 0);
	val_conv = CommitmentSigned_clone(&val_conv);
	CommitmentUpdate_set_commitment_signed(&this_ptr_conv, val_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CommitmentUpdate_1new(JNIEnv *env, jclass clz, int64_tArray update_add_htlcs_arg, int64_tArray update_fulfill_htlcs_arg, int64_tArray update_fail_htlcs_arg, int64_tArray update_fail_malformed_htlcs_arg, int64_t update_fee_arg, int64_t commitment_signed_arg) {
	LDKCVec_UpdateAddHTLCZ update_add_htlcs_arg_constr;
	update_add_htlcs_arg_constr.datalen = (*env)->GetArrayLength(env, update_add_htlcs_arg);
	if (update_add_htlcs_arg_constr.datalen > 0)
		update_add_htlcs_arg_constr.data = MALLOC(update_add_htlcs_arg_constr.datalen * sizeof(LDKUpdateAddHTLC), "LDKCVec_UpdateAddHTLCZ Elements");
	else
		update_add_htlcs_arg_constr.data = NULL;
	int64_t* update_add_htlcs_arg_vals = (*env)->GetLongArrayElements (env, update_add_htlcs_arg, NULL);
	for (size_t p = 0; p < update_add_htlcs_arg_constr.datalen; p++) {
		int64_t update_add_htlcs_arg_conv_15 = update_add_htlcs_arg_vals[p];
		LDKUpdateAddHTLC update_add_htlcs_arg_conv_15_conv;
		update_add_htlcs_arg_conv_15_conv.inner = (void*)(update_add_htlcs_arg_conv_15 & (~1));
		update_add_htlcs_arg_conv_15_conv.is_owned = (update_add_htlcs_arg_conv_15 & 1) || (update_add_htlcs_arg_conv_15 == 0);
		update_add_htlcs_arg_conv_15_conv = UpdateAddHTLC_clone(&update_add_htlcs_arg_conv_15_conv);
		update_add_htlcs_arg_constr.data[p] = update_add_htlcs_arg_conv_15_conv;
	}
	(*env)->ReleaseLongArrayElements(env, update_add_htlcs_arg, update_add_htlcs_arg_vals, 0);
	LDKCVec_UpdateFulfillHTLCZ update_fulfill_htlcs_arg_constr;
	update_fulfill_htlcs_arg_constr.datalen = (*env)->GetArrayLength(env, update_fulfill_htlcs_arg);
	if (update_fulfill_htlcs_arg_constr.datalen > 0)
		update_fulfill_htlcs_arg_constr.data = MALLOC(update_fulfill_htlcs_arg_constr.datalen * sizeof(LDKUpdateFulfillHTLC), "LDKCVec_UpdateFulfillHTLCZ Elements");
	else
		update_fulfill_htlcs_arg_constr.data = NULL;
	int64_t* update_fulfill_htlcs_arg_vals = (*env)->GetLongArrayElements (env, update_fulfill_htlcs_arg, NULL);
	for (size_t t = 0; t < update_fulfill_htlcs_arg_constr.datalen; t++) {
		int64_t update_fulfill_htlcs_arg_conv_19 = update_fulfill_htlcs_arg_vals[t];
		LDKUpdateFulfillHTLC update_fulfill_htlcs_arg_conv_19_conv;
		update_fulfill_htlcs_arg_conv_19_conv.inner = (void*)(update_fulfill_htlcs_arg_conv_19 & (~1));
		update_fulfill_htlcs_arg_conv_19_conv.is_owned = (update_fulfill_htlcs_arg_conv_19 & 1) || (update_fulfill_htlcs_arg_conv_19 == 0);
		update_fulfill_htlcs_arg_conv_19_conv = UpdateFulfillHTLC_clone(&update_fulfill_htlcs_arg_conv_19_conv);
		update_fulfill_htlcs_arg_constr.data[t] = update_fulfill_htlcs_arg_conv_19_conv;
	}
	(*env)->ReleaseLongArrayElements(env, update_fulfill_htlcs_arg, update_fulfill_htlcs_arg_vals, 0);
	LDKCVec_UpdateFailHTLCZ update_fail_htlcs_arg_constr;
	update_fail_htlcs_arg_constr.datalen = (*env)->GetArrayLength(env, update_fail_htlcs_arg);
	if (update_fail_htlcs_arg_constr.datalen > 0)
		update_fail_htlcs_arg_constr.data = MALLOC(update_fail_htlcs_arg_constr.datalen * sizeof(LDKUpdateFailHTLC), "LDKCVec_UpdateFailHTLCZ Elements");
	else
		update_fail_htlcs_arg_constr.data = NULL;
	int64_t* update_fail_htlcs_arg_vals = (*env)->GetLongArrayElements (env, update_fail_htlcs_arg, NULL);
	for (size_t q = 0; q < update_fail_htlcs_arg_constr.datalen; q++) {
		int64_t update_fail_htlcs_arg_conv_16 = update_fail_htlcs_arg_vals[q];
		LDKUpdateFailHTLC update_fail_htlcs_arg_conv_16_conv;
		update_fail_htlcs_arg_conv_16_conv.inner = (void*)(update_fail_htlcs_arg_conv_16 & (~1));
		update_fail_htlcs_arg_conv_16_conv.is_owned = (update_fail_htlcs_arg_conv_16 & 1) || (update_fail_htlcs_arg_conv_16 == 0);
		update_fail_htlcs_arg_conv_16_conv = UpdateFailHTLC_clone(&update_fail_htlcs_arg_conv_16_conv);
		update_fail_htlcs_arg_constr.data[q] = update_fail_htlcs_arg_conv_16_conv;
	}
	(*env)->ReleaseLongArrayElements(env, update_fail_htlcs_arg, update_fail_htlcs_arg_vals, 0);
	LDKCVec_UpdateFailMalformedHTLCZ update_fail_malformed_htlcs_arg_constr;
	update_fail_malformed_htlcs_arg_constr.datalen = (*env)->GetArrayLength(env, update_fail_malformed_htlcs_arg);
	if (update_fail_malformed_htlcs_arg_constr.datalen > 0)
		update_fail_malformed_htlcs_arg_constr.data = MALLOC(update_fail_malformed_htlcs_arg_constr.datalen * sizeof(LDKUpdateFailMalformedHTLC), "LDKCVec_UpdateFailMalformedHTLCZ Elements");
	else
		update_fail_malformed_htlcs_arg_constr.data = NULL;
	int64_t* update_fail_malformed_htlcs_arg_vals = (*env)->GetLongArrayElements (env, update_fail_malformed_htlcs_arg, NULL);
	for (size_t z = 0; z < update_fail_malformed_htlcs_arg_constr.datalen; z++) {
		int64_t update_fail_malformed_htlcs_arg_conv_25 = update_fail_malformed_htlcs_arg_vals[z];
		LDKUpdateFailMalformedHTLC update_fail_malformed_htlcs_arg_conv_25_conv;
		update_fail_malformed_htlcs_arg_conv_25_conv.inner = (void*)(update_fail_malformed_htlcs_arg_conv_25 & (~1));
		update_fail_malformed_htlcs_arg_conv_25_conv.is_owned = (update_fail_malformed_htlcs_arg_conv_25 & 1) || (update_fail_malformed_htlcs_arg_conv_25 == 0);
		update_fail_malformed_htlcs_arg_conv_25_conv = UpdateFailMalformedHTLC_clone(&update_fail_malformed_htlcs_arg_conv_25_conv);
		update_fail_malformed_htlcs_arg_constr.data[z] = update_fail_malformed_htlcs_arg_conv_25_conv;
	}
	(*env)->ReleaseLongArrayElements(env, update_fail_malformed_htlcs_arg, update_fail_malformed_htlcs_arg_vals, 0);
	LDKUpdateFee update_fee_arg_conv;
	update_fee_arg_conv.inner = (void*)(update_fee_arg & (~1));
	update_fee_arg_conv.is_owned = (update_fee_arg & 1) || (update_fee_arg == 0);
	update_fee_arg_conv = UpdateFee_clone(&update_fee_arg_conv);
	LDKCommitmentSigned commitment_signed_arg_conv;
	commitment_signed_arg_conv.inner = (void*)(commitment_signed_arg & (~1));
	commitment_signed_arg_conv.is_owned = (commitment_signed_arg & 1) || (commitment_signed_arg == 0);
	commitment_signed_arg_conv = CommitmentSigned_clone(&commitment_signed_arg_conv);
	LDKCommitmentUpdate ret_var = CommitmentUpdate_new(update_add_htlcs_arg_constr, update_fulfill_htlcs_arg_constr, update_fail_htlcs_arg_constr, update_fail_malformed_htlcs_arg_constr, update_fee_arg_conv, commitment_signed_arg_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CommitmentUpdate_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCommitmentUpdate orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKCommitmentUpdate ret_var = CommitmentUpdate_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelMessageHandler_1free(JNIEnv *env, jclass clz, int64_t this_ptr) {
	if ((this_ptr & 1) != 0) return;
	void* this_ptr_ptr = (void*)(((uint64_t)this_ptr) & ~1);
	CHECK_ACCESS(this_ptr_ptr);
	LDKChannelMessageHandler this_ptr_conv = *(LDKChannelMessageHandler*)(this_ptr_ptr);
	FREE((void*)this_ptr);
	ChannelMessageHandler_free(this_ptr_conv);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_RoutingMessageHandler_1free(JNIEnv *env, jclass clz, int64_t this_ptr) {
	if ((this_ptr & 1) != 0) return;
	void* this_ptr_ptr = (void*)(((uint64_t)this_ptr) & ~1);
	CHECK_ACCESS(this_ptr_ptr);
	LDKRoutingMessageHandler this_ptr_conv = *(LDKRoutingMessageHandler*)(this_ptr_ptr);
	FREE((void*)this_ptr);
	RoutingMessageHandler_free(this_ptr_conv);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_AcceptChannel_1write(JNIEnv *env, jclass clz, int64_t obj) {
	LDKAcceptChannel obj_conv;
	obj_conv.inner = (void*)(obj & (~1));
	obj_conv.is_owned = false;
	LDKCVec_u8Z ret_var = AcceptChannel_write(&obj_conv);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	CVec_u8Z_free(ret_var);
	return ret_arr;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_AcceptChannel_1read(JNIEnv *env, jclass clz, int8_tArray ser) {
	LDKu8slice ser_ref;
	ser_ref.datalen = (*env)->GetArrayLength(env, ser);
	ser_ref.data = (*env)->GetByteArrayElements (env, ser, NULL);
	LDKCResult_AcceptChannelDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_AcceptChannelDecodeErrorZ), "LDKCResult_AcceptChannelDecodeErrorZ");
	*ret_conv = AcceptChannel_read(ser_ref);
	(*env)->ReleaseByteArrayElements(env, ser, (int8_t*)ser_ref.data, 0);
	return (uint64_t)ret_conv;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_AnnouncementSignatures_1write(JNIEnv *env, jclass clz, int64_t obj) {
	LDKAnnouncementSignatures obj_conv;
	obj_conv.inner = (void*)(obj & (~1));
	obj_conv.is_owned = false;
	LDKCVec_u8Z ret_var = AnnouncementSignatures_write(&obj_conv);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	CVec_u8Z_free(ret_var);
	return ret_arr;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_AnnouncementSignatures_1read(JNIEnv *env, jclass clz, int8_tArray ser) {
	LDKu8slice ser_ref;
	ser_ref.datalen = (*env)->GetArrayLength(env, ser);
	ser_ref.data = (*env)->GetByteArrayElements (env, ser, NULL);
	LDKCResult_AnnouncementSignaturesDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_AnnouncementSignaturesDecodeErrorZ), "LDKCResult_AnnouncementSignaturesDecodeErrorZ");
	*ret_conv = AnnouncementSignatures_read(ser_ref);
	(*env)->ReleaseByteArrayElements(env, ser, (int8_t*)ser_ref.data, 0);
	return (uint64_t)ret_conv;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_ChannelReestablish_1write(JNIEnv *env, jclass clz, int64_t obj) {
	LDKChannelReestablish obj_conv;
	obj_conv.inner = (void*)(obj & (~1));
	obj_conv.is_owned = false;
	LDKCVec_u8Z ret_var = ChannelReestablish_write(&obj_conv);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	CVec_u8Z_free(ret_var);
	return ret_arr;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelReestablish_1read(JNIEnv *env, jclass clz, int8_tArray ser) {
	LDKu8slice ser_ref;
	ser_ref.datalen = (*env)->GetArrayLength(env, ser);
	ser_ref.data = (*env)->GetByteArrayElements (env, ser, NULL);
	LDKCResult_ChannelReestablishDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_ChannelReestablishDecodeErrorZ), "LDKCResult_ChannelReestablishDecodeErrorZ");
	*ret_conv = ChannelReestablish_read(ser_ref);
	(*env)->ReleaseByteArrayElements(env, ser, (int8_t*)ser_ref.data, 0);
	return (uint64_t)ret_conv;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_ClosingSigned_1write(JNIEnv *env, jclass clz, int64_t obj) {
	LDKClosingSigned obj_conv;
	obj_conv.inner = (void*)(obj & (~1));
	obj_conv.is_owned = false;
	LDKCVec_u8Z ret_var = ClosingSigned_write(&obj_conv);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	CVec_u8Z_free(ret_var);
	return ret_arr;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ClosingSigned_1read(JNIEnv *env, jclass clz, int8_tArray ser) {
	LDKu8slice ser_ref;
	ser_ref.datalen = (*env)->GetArrayLength(env, ser);
	ser_ref.data = (*env)->GetByteArrayElements (env, ser, NULL);
	LDKCResult_ClosingSignedDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_ClosingSignedDecodeErrorZ), "LDKCResult_ClosingSignedDecodeErrorZ");
	*ret_conv = ClosingSigned_read(ser_ref);
	(*env)->ReleaseByteArrayElements(env, ser, (int8_t*)ser_ref.data, 0);
	return (uint64_t)ret_conv;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_ClosingSignedFeeRange_1write(JNIEnv *env, jclass clz, int64_t obj) {
	LDKClosingSignedFeeRange obj_conv;
	obj_conv.inner = (void*)(obj & (~1));
	obj_conv.is_owned = false;
	LDKCVec_u8Z ret_var = ClosingSignedFeeRange_write(&obj_conv);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	CVec_u8Z_free(ret_var);
	return ret_arr;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ClosingSignedFeeRange_1read(JNIEnv *env, jclass clz, int8_tArray ser) {
	LDKu8slice ser_ref;
	ser_ref.datalen = (*env)->GetArrayLength(env, ser);
	ser_ref.data = (*env)->GetByteArrayElements (env, ser, NULL);
	LDKCResult_ClosingSignedFeeRangeDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_ClosingSignedFeeRangeDecodeErrorZ), "LDKCResult_ClosingSignedFeeRangeDecodeErrorZ");
	*ret_conv = ClosingSignedFeeRange_read(ser_ref);
	(*env)->ReleaseByteArrayElements(env, ser, (int8_t*)ser_ref.data, 0);
	return (uint64_t)ret_conv;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_CommitmentSigned_1write(JNIEnv *env, jclass clz, int64_t obj) {
	LDKCommitmentSigned obj_conv;
	obj_conv.inner = (void*)(obj & (~1));
	obj_conv.is_owned = false;
	LDKCVec_u8Z ret_var = CommitmentSigned_write(&obj_conv);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	CVec_u8Z_free(ret_var);
	return ret_arr;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CommitmentSigned_1read(JNIEnv *env, jclass clz, int8_tArray ser) {
	LDKu8slice ser_ref;
	ser_ref.datalen = (*env)->GetArrayLength(env, ser);
	ser_ref.data = (*env)->GetByteArrayElements (env, ser, NULL);
	LDKCResult_CommitmentSignedDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_CommitmentSignedDecodeErrorZ), "LDKCResult_CommitmentSignedDecodeErrorZ");
	*ret_conv = CommitmentSigned_read(ser_ref);
	(*env)->ReleaseByteArrayElements(env, ser, (int8_t*)ser_ref.data, 0);
	return (uint64_t)ret_conv;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_FundingCreated_1write(JNIEnv *env, jclass clz, int64_t obj) {
	LDKFundingCreated obj_conv;
	obj_conv.inner = (void*)(obj & (~1));
	obj_conv.is_owned = false;
	LDKCVec_u8Z ret_var = FundingCreated_write(&obj_conv);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	CVec_u8Z_free(ret_var);
	return ret_arr;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_FundingCreated_1read(JNIEnv *env, jclass clz, int8_tArray ser) {
	LDKu8slice ser_ref;
	ser_ref.datalen = (*env)->GetArrayLength(env, ser);
	ser_ref.data = (*env)->GetByteArrayElements (env, ser, NULL);
	LDKCResult_FundingCreatedDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_FundingCreatedDecodeErrorZ), "LDKCResult_FundingCreatedDecodeErrorZ");
	*ret_conv = FundingCreated_read(ser_ref);
	(*env)->ReleaseByteArrayElements(env, ser, (int8_t*)ser_ref.data, 0);
	return (uint64_t)ret_conv;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_FundingSigned_1write(JNIEnv *env, jclass clz, int64_t obj) {
	LDKFundingSigned obj_conv;
	obj_conv.inner = (void*)(obj & (~1));
	obj_conv.is_owned = false;
	LDKCVec_u8Z ret_var = FundingSigned_write(&obj_conv);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	CVec_u8Z_free(ret_var);
	return ret_arr;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_FundingSigned_1read(JNIEnv *env, jclass clz, int8_tArray ser) {
	LDKu8slice ser_ref;
	ser_ref.datalen = (*env)->GetArrayLength(env, ser);
	ser_ref.data = (*env)->GetByteArrayElements (env, ser, NULL);
	LDKCResult_FundingSignedDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_FundingSignedDecodeErrorZ), "LDKCResult_FundingSignedDecodeErrorZ");
	*ret_conv = FundingSigned_read(ser_ref);
	(*env)->ReleaseByteArrayElements(env, ser, (int8_t*)ser_ref.data, 0);
	return (uint64_t)ret_conv;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_FundingLocked_1write(JNIEnv *env, jclass clz, int64_t obj) {
	LDKFundingLocked obj_conv;
	obj_conv.inner = (void*)(obj & (~1));
	obj_conv.is_owned = false;
	LDKCVec_u8Z ret_var = FundingLocked_write(&obj_conv);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	CVec_u8Z_free(ret_var);
	return ret_arr;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_FundingLocked_1read(JNIEnv *env, jclass clz, int8_tArray ser) {
	LDKu8slice ser_ref;
	ser_ref.datalen = (*env)->GetArrayLength(env, ser);
	ser_ref.data = (*env)->GetByteArrayElements (env, ser, NULL);
	LDKCResult_FundingLockedDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_FundingLockedDecodeErrorZ), "LDKCResult_FundingLockedDecodeErrorZ");
	*ret_conv = FundingLocked_read(ser_ref);
	(*env)->ReleaseByteArrayElements(env, ser, (int8_t*)ser_ref.data, 0);
	return (uint64_t)ret_conv;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_Init_1write(JNIEnv *env, jclass clz, int64_t obj) {
	LDKInit obj_conv;
	obj_conv.inner = (void*)(obj & (~1));
	obj_conv.is_owned = false;
	LDKCVec_u8Z ret_var = Init_write(&obj_conv);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	CVec_u8Z_free(ret_var);
	return ret_arr;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_Init_1read(JNIEnv *env, jclass clz, int8_tArray ser) {
	LDKu8slice ser_ref;
	ser_ref.datalen = (*env)->GetArrayLength(env, ser);
	ser_ref.data = (*env)->GetByteArrayElements (env, ser, NULL);
	LDKCResult_InitDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_InitDecodeErrorZ), "LDKCResult_InitDecodeErrorZ");
	*ret_conv = Init_read(ser_ref);
	(*env)->ReleaseByteArrayElements(env, ser, (int8_t*)ser_ref.data, 0);
	return (uint64_t)ret_conv;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_OpenChannel_1write(JNIEnv *env, jclass clz, int64_t obj) {
	LDKOpenChannel obj_conv;
	obj_conv.inner = (void*)(obj & (~1));
	obj_conv.is_owned = false;
	LDKCVec_u8Z ret_var = OpenChannel_write(&obj_conv);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	CVec_u8Z_free(ret_var);
	return ret_arr;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_OpenChannel_1read(JNIEnv *env, jclass clz, int8_tArray ser) {
	LDKu8slice ser_ref;
	ser_ref.datalen = (*env)->GetArrayLength(env, ser);
	ser_ref.data = (*env)->GetByteArrayElements (env, ser, NULL);
	LDKCResult_OpenChannelDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_OpenChannelDecodeErrorZ), "LDKCResult_OpenChannelDecodeErrorZ");
	*ret_conv = OpenChannel_read(ser_ref);
	(*env)->ReleaseByteArrayElements(env, ser, (int8_t*)ser_ref.data, 0);
	return (uint64_t)ret_conv;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_RevokeAndACK_1write(JNIEnv *env, jclass clz, int64_t obj) {
	LDKRevokeAndACK obj_conv;
	obj_conv.inner = (void*)(obj & (~1));
	obj_conv.is_owned = false;
	LDKCVec_u8Z ret_var = RevokeAndACK_write(&obj_conv);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	CVec_u8Z_free(ret_var);
	return ret_arr;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_RevokeAndACK_1read(JNIEnv *env, jclass clz, int8_tArray ser) {
	LDKu8slice ser_ref;
	ser_ref.datalen = (*env)->GetArrayLength(env, ser);
	ser_ref.data = (*env)->GetByteArrayElements (env, ser, NULL);
	LDKCResult_RevokeAndACKDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_RevokeAndACKDecodeErrorZ), "LDKCResult_RevokeAndACKDecodeErrorZ");
	*ret_conv = RevokeAndACK_read(ser_ref);
	(*env)->ReleaseByteArrayElements(env, ser, (int8_t*)ser_ref.data, 0);
	return (uint64_t)ret_conv;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_Shutdown_1write(JNIEnv *env, jclass clz, int64_t obj) {
	LDKShutdown obj_conv;
	obj_conv.inner = (void*)(obj & (~1));
	obj_conv.is_owned = false;
	LDKCVec_u8Z ret_var = Shutdown_write(&obj_conv);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	CVec_u8Z_free(ret_var);
	return ret_arr;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_Shutdown_1read(JNIEnv *env, jclass clz, int8_tArray ser) {
	LDKu8slice ser_ref;
	ser_ref.datalen = (*env)->GetArrayLength(env, ser);
	ser_ref.data = (*env)->GetByteArrayElements (env, ser, NULL);
	LDKCResult_ShutdownDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_ShutdownDecodeErrorZ), "LDKCResult_ShutdownDecodeErrorZ");
	*ret_conv = Shutdown_read(ser_ref);
	(*env)->ReleaseByteArrayElements(env, ser, (int8_t*)ser_ref.data, 0);
	return (uint64_t)ret_conv;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_UpdateFailHTLC_1write(JNIEnv *env, jclass clz, int64_t obj) {
	LDKUpdateFailHTLC obj_conv;
	obj_conv.inner = (void*)(obj & (~1));
	obj_conv.is_owned = false;
	LDKCVec_u8Z ret_var = UpdateFailHTLC_write(&obj_conv);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	CVec_u8Z_free(ret_var);
	return ret_arr;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_UpdateFailHTLC_1read(JNIEnv *env, jclass clz, int8_tArray ser) {
	LDKu8slice ser_ref;
	ser_ref.datalen = (*env)->GetArrayLength(env, ser);
	ser_ref.data = (*env)->GetByteArrayElements (env, ser, NULL);
	LDKCResult_UpdateFailHTLCDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_UpdateFailHTLCDecodeErrorZ), "LDKCResult_UpdateFailHTLCDecodeErrorZ");
	*ret_conv = UpdateFailHTLC_read(ser_ref);
	(*env)->ReleaseByteArrayElements(env, ser, (int8_t*)ser_ref.data, 0);
	return (uint64_t)ret_conv;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_UpdateFailMalformedHTLC_1write(JNIEnv *env, jclass clz, int64_t obj) {
	LDKUpdateFailMalformedHTLC obj_conv;
	obj_conv.inner = (void*)(obj & (~1));
	obj_conv.is_owned = false;
	LDKCVec_u8Z ret_var = UpdateFailMalformedHTLC_write(&obj_conv);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	CVec_u8Z_free(ret_var);
	return ret_arr;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_UpdateFailMalformedHTLC_1read(JNIEnv *env, jclass clz, int8_tArray ser) {
	LDKu8slice ser_ref;
	ser_ref.datalen = (*env)->GetArrayLength(env, ser);
	ser_ref.data = (*env)->GetByteArrayElements (env, ser, NULL);
	LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ), "LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ");
	*ret_conv = UpdateFailMalformedHTLC_read(ser_ref);
	(*env)->ReleaseByteArrayElements(env, ser, (int8_t*)ser_ref.data, 0);
	return (uint64_t)ret_conv;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_UpdateFee_1write(JNIEnv *env, jclass clz, int64_t obj) {
	LDKUpdateFee obj_conv;
	obj_conv.inner = (void*)(obj & (~1));
	obj_conv.is_owned = false;
	LDKCVec_u8Z ret_var = UpdateFee_write(&obj_conv);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	CVec_u8Z_free(ret_var);
	return ret_arr;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_UpdateFee_1read(JNIEnv *env, jclass clz, int8_tArray ser) {
	LDKu8slice ser_ref;
	ser_ref.datalen = (*env)->GetArrayLength(env, ser);
	ser_ref.data = (*env)->GetByteArrayElements (env, ser, NULL);
	LDKCResult_UpdateFeeDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_UpdateFeeDecodeErrorZ), "LDKCResult_UpdateFeeDecodeErrorZ");
	*ret_conv = UpdateFee_read(ser_ref);
	(*env)->ReleaseByteArrayElements(env, ser, (int8_t*)ser_ref.data, 0);
	return (uint64_t)ret_conv;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_UpdateFulfillHTLC_1write(JNIEnv *env, jclass clz, int64_t obj) {
	LDKUpdateFulfillHTLC obj_conv;
	obj_conv.inner = (void*)(obj & (~1));
	obj_conv.is_owned = false;
	LDKCVec_u8Z ret_var = UpdateFulfillHTLC_write(&obj_conv);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	CVec_u8Z_free(ret_var);
	return ret_arr;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_UpdateFulfillHTLC_1read(JNIEnv *env, jclass clz, int8_tArray ser) {
	LDKu8slice ser_ref;
	ser_ref.datalen = (*env)->GetArrayLength(env, ser);
	ser_ref.data = (*env)->GetByteArrayElements (env, ser, NULL);
	LDKCResult_UpdateFulfillHTLCDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_UpdateFulfillHTLCDecodeErrorZ), "LDKCResult_UpdateFulfillHTLCDecodeErrorZ");
	*ret_conv = UpdateFulfillHTLC_read(ser_ref);
	(*env)->ReleaseByteArrayElements(env, ser, (int8_t*)ser_ref.data, 0);
	return (uint64_t)ret_conv;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_UpdateAddHTLC_1write(JNIEnv *env, jclass clz, int64_t obj) {
	LDKUpdateAddHTLC obj_conv;
	obj_conv.inner = (void*)(obj & (~1));
	obj_conv.is_owned = false;
	LDKCVec_u8Z ret_var = UpdateAddHTLC_write(&obj_conv);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	CVec_u8Z_free(ret_var);
	return ret_arr;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_UpdateAddHTLC_1read(JNIEnv *env, jclass clz, int8_tArray ser) {
	LDKu8slice ser_ref;
	ser_ref.datalen = (*env)->GetArrayLength(env, ser);
	ser_ref.data = (*env)->GetByteArrayElements (env, ser, NULL);
	LDKCResult_UpdateAddHTLCDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_UpdateAddHTLCDecodeErrorZ), "LDKCResult_UpdateAddHTLCDecodeErrorZ");
	*ret_conv = UpdateAddHTLC_read(ser_ref);
	(*env)->ReleaseByteArrayElements(env, ser, (int8_t*)ser_ref.data, 0);
	return (uint64_t)ret_conv;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_Ping_1write(JNIEnv *env, jclass clz, int64_t obj) {
	LDKPing obj_conv;
	obj_conv.inner = (void*)(obj & (~1));
	obj_conv.is_owned = false;
	LDKCVec_u8Z ret_var = Ping_write(&obj_conv);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	CVec_u8Z_free(ret_var);
	return ret_arr;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_Ping_1read(JNIEnv *env, jclass clz, int8_tArray ser) {
	LDKu8slice ser_ref;
	ser_ref.datalen = (*env)->GetArrayLength(env, ser);
	ser_ref.data = (*env)->GetByteArrayElements (env, ser, NULL);
	LDKCResult_PingDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_PingDecodeErrorZ), "LDKCResult_PingDecodeErrorZ");
	*ret_conv = Ping_read(ser_ref);
	(*env)->ReleaseByteArrayElements(env, ser, (int8_t*)ser_ref.data, 0);
	return (uint64_t)ret_conv;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_Pong_1write(JNIEnv *env, jclass clz, int64_t obj) {
	LDKPong obj_conv;
	obj_conv.inner = (void*)(obj & (~1));
	obj_conv.is_owned = false;
	LDKCVec_u8Z ret_var = Pong_write(&obj_conv);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	CVec_u8Z_free(ret_var);
	return ret_arr;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_Pong_1read(JNIEnv *env, jclass clz, int8_tArray ser) {
	LDKu8slice ser_ref;
	ser_ref.datalen = (*env)->GetArrayLength(env, ser);
	ser_ref.data = (*env)->GetByteArrayElements (env, ser, NULL);
	LDKCResult_PongDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_PongDecodeErrorZ), "LDKCResult_PongDecodeErrorZ");
	*ret_conv = Pong_read(ser_ref);
	(*env)->ReleaseByteArrayElements(env, ser, (int8_t*)ser_ref.data, 0);
	return (uint64_t)ret_conv;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_UnsignedChannelAnnouncement_1write(JNIEnv *env, jclass clz, int64_t obj) {
	LDKUnsignedChannelAnnouncement obj_conv;
	obj_conv.inner = (void*)(obj & (~1));
	obj_conv.is_owned = false;
	LDKCVec_u8Z ret_var = UnsignedChannelAnnouncement_write(&obj_conv);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	CVec_u8Z_free(ret_var);
	return ret_arr;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_UnsignedChannelAnnouncement_1read(JNIEnv *env, jclass clz, int8_tArray ser) {
	LDKu8slice ser_ref;
	ser_ref.datalen = (*env)->GetArrayLength(env, ser);
	ser_ref.data = (*env)->GetByteArrayElements (env, ser, NULL);
	LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ), "LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ");
	*ret_conv = UnsignedChannelAnnouncement_read(ser_ref);
	(*env)->ReleaseByteArrayElements(env, ser, (int8_t*)ser_ref.data, 0);
	return (uint64_t)ret_conv;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_ChannelAnnouncement_1write(JNIEnv *env, jclass clz, int64_t obj) {
	LDKChannelAnnouncement obj_conv;
	obj_conv.inner = (void*)(obj & (~1));
	obj_conv.is_owned = false;
	LDKCVec_u8Z ret_var = ChannelAnnouncement_write(&obj_conv);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	CVec_u8Z_free(ret_var);
	return ret_arr;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelAnnouncement_1read(JNIEnv *env, jclass clz, int8_tArray ser) {
	LDKu8slice ser_ref;
	ser_ref.datalen = (*env)->GetArrayLength(env, ser);
	ser_ref.data = (*env)->GetByteArrayElements (env, ser, NULL);
	LDKCResult_ChannelAnnouncementDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_ChannelAnnouncementDecodeErrorZ), "LDKCResult_ChannelAnnouncementDecodeErrorZ");
	*ret_conv = ChannelAnnouncement_read(ser_ref);
	(*env)->ReleaseByteArrayElements(env, ser, (int8_t*)ser_ref.data, 0);
	return (uint64_t)ret_conv;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_UnsignedChannelUpdate_1write(JNIEnv *env, jclass clz, int64_t obj) {
	LDKUnsignedChannelUpdate obj_conv;
	obj_conv.inner = (void*)(obj & (~1));
	obj_conv.is_owned = false;
	LDKCVec_u8Z ret_var = UnsignedChannelUpdate_write(&obj_conv);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	CVec_u8Z_free(ret_var);
	return ret_arr;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_UnsignedChannelUpdate_1read(JNIEnv *env, jclass clz, int8_tArray ser) {
	LDKu8slice ser_ref;
	ser_ref.datalen = (*env)->GetArrayLength(env, ser);
	ser_ref.data = (*env)->GetByteArrayElements (env, ser, NULL);
	LDKCResult_UnsignedChannelUpdateDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_UnsignedChannelUpdateDecodeErrorZ), "LDKCResult_UnsignedChannelUpdateDecodeErrorZ");
	*ret_conv = UnsignedChannelUpdate_read(ser_ref);
	(*env)->ReleaseByteArrayElements(env, ser, (int8_t*)ser_ref.data, 0);
	return (uint64_t)ret_conv;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_ChannelUpdate_1write(JNIEnv *env, jclass clz, int64_t obj) {
	LDKChannelUpdate obj_conv;
	obj_conv.inner = (void*)(obj & (~1));
	obj_conv.is_owned = false;
	LDKCVec_u8Z ret_var = ChannelUpdate_write(&obj_conv);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	CVec_u8Z_free(ret_var);
	return ret_arr;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelUpdate_1read(JNIEnv *env, jclass clz, int8_tArray ser) {
	LDKu8slice ser_ref;
	ser_ref.datalen = (*env)->GetArrayLength(env, ser);
	ser_ref.data = (*env)->GetByteArrayElements (env, ser, NULL);
	LDKCResult_ChannelUpdateDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_ChannelUpdateDecodeErrorZ), "LDKCResult_ChannelUpdateDecodeErrorZ");
	*ret_conv = ChannelUpdate_read(ser_ref);
	(*env)->ReleaseByteArrayElements(env, ser, (int8_t*)ser_ref.data, 0);
	return (uint64_t)ret_conv;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_ErrorMessage_1write(JNIEnv *env, jclass clz, int64_t obj) {
	LDKErrorMessage obj_conv;
	obj_conv.inner = (void*)(obj & (~1));
	obj_conv.is_owned = false;
	LDKCVec_u8Z ret_var = ErrorMessage_write(&obj_conv);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	CVec_u8Z_free(ret_var);
	return ret_arr;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ErrorMessage_1read(JNIEnv *env, jclass clz, int8_tArray ser) {
	LDKu8slice ser_ref;
	ser_ref.datalen = (*env)->GetArrayLength(env, ser);
	ser_ref.data = (*env)->GetByteArrayElements (env, ser, NULL);
	LDKCResult_ErrorMessageDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_ErrorMessageDecodeErrorZ), "LDKCResult_ErrorMessageDecodeErrorZ");
	*ret_conv = ErrorMessage_read(ser_ref);
	(*env)->ReleaseByteArrayElements(env, ser, (int8_t*)ser_ref.data, 0);
	return (uint64_t)ret_conv;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_UnsignedNodeAnnouncement_1write(JNIEnv *env, jclass clz, int64_t obj) {
	LDKUnsignedNodeAnnouncement obj_conv;
	obj_conv.inner = (void*)(obj & (~1));
	obj_conv.is_owned = false;
	LDKCVec_u8Z ret_var = UnsignedNodeAnnouncement_write(&obj_conv);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	CVec_u8Z_free(ret_var);
	return ret_arr;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_UnsignedNodeAnnouncement_1read(JNIEnv *env, jclass clz, int8_tArray ser) {
	LDKu8slice ser_ref;
	ser_ref.datalen = (*env)->GetArrayLength(env, ser);
	ser_ref.data = (*env)->GetByteArrayElements (env, ser, NULL);
	LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ), "LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ");
	*ret_conv = UnsignedNodeAnnouncement_read(ser_ref);
	(*env)->ReleaseByteArrayElements(env, ser, (int8_t*)ser_ref.data, 0);
	return (uint64_t)ret_conv;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_NodeAnnouncement_1write(JNIEnv *env, jclass clz, int64_t obj) {
	LDKNodeAnnouncement obj_conv;
	obj_conv.inner = (void*)(obj & (~1));
	obj_conv.is_owned = false;
	LDKCVec_u8Z ret_var = NodeAnnouncement_write(&obj_conv);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	CVec_u8Z_free(ret_var);
	return ret_arr;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_NodeAnnouncement_1read(JNIEnv *env, jclass clz, int8_tArray ser) {
	LDKu8slice ser_ref;
	ser_ref.datalen = (*env)->GetArrayLength(env, ser);
	ser_ref.data = (*env)->GetByteArrayElements (env, ser, NULL);
	LDKCResult_NodeAnnouncementDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_NodeAnnouncementDecodeErrorZ), "LDKCResult_NodeAnnouncementDecodeErrorZ");
	*ret_conv = NodeAnnouncement_read(ser_ref);
	(*env)->ReleaseByteArrayElements(env, ser, (int8_t*)ser_ref.data, 0);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_QueryShortChannelIds_1read(JNIEnv *env, jclass clz, int8_tArray ser) {
	LDKu8slice ser_ref;
	ser_ref.datalen = (*env)->GetArrayLength(env, ser);
	ser_ref.data = (*env)->GetByteArrayElements (env, ser, NULL);
	LDKCResult_QueryShortChannelIdsDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_QueryShortChannelIdsDecodeErrorZ), "LDKCResult_QueryShortChannelIdsDecodeErrorZ");
	*ret_conv = QueryShortChannelIds_read(ser_ref);
	(*env)->ReleaseByteArrayElements(env, ser, (int8_t*)ser_ref.data, 0);
	return (uint64_t)ret_conv;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_QueryShortChannelIds_1write(JNIEnv *env, jclass clz, int64_t obj) {
	LDKQueryShortChannelIds obj_conv;
	obj_conv.inner = (void*)(obj & (~1));
	obj_conv.is_owned = false;
	LDKCVec_u8Z ret_var = QueryShortChannelIds_write(&obj_conv);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	CVec_u8Z_free(ret_var);
	return ret_arr;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_ReplyShortChannelIdsEnd_1write(JNIEnv *env, jclass clz, int64_t obj) {
	LDKReplyShortChannelIdsEnd obj_conv;
	obj_conv.inner = (void*)(obj & (~1));
	obj_conv.is_owned = false;
	LDKCVec_u8Z ret_var = ReplyShortChannelIdsEnd_write(&obj_conv);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	CVec_u8Z_free(ret_var);
	return ret_arr;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ReplyShortChannelIdsEnd_1read(JNIEnv *env, jclass clz, int8_tArray ser) {
	LDKu8slice ser_ref;
	ser_ref.datalen = (*env)->GetArrayLength(env, ser);
	ser_ref.data = (*env)->GetByteArrayElements (env, ser, NULL);
	LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ), "LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ");
	*ret_conv = ReplyShortChannelIdsEnd_read(ser_ref);
	(*env)->ReleaseByteArrayElements(env, ser, (int8_t*)ser_ref.data, 0);
	return (uint64_t)ret_conv;
}

JNIEXPORT int32_t JNICALL Java_org_ldk_impl_bindings_QueryChannelRange_1end_1blocknum(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKQueryChannelRange this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	int32_t ret_val = QueryChannelRange_end_blocknum(&this_arg_conv);
	return ret_val;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_QueryChannelRange_1write(JNIEnv *env, jclass clz, int64_t obj) {
	LDKQueryChannelRange obj_conv;
	obj_conv.inner = (void*)(obj & (~1));
	obj_conv.is_owned = false;
	LDKCVec_u8Z ret_var = QueryChannelRange_write(&obj_conv);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	CVec_u8Z_free(ret_var);
	return ret_arr;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_QueryChannelRange_1read(JNIEnv *env, jclass clz, int8_tArray ser) {
	LDKu8slice ser_ref;
	ser_ref.datalen = (*env)->GetArrayLength(env, ser);
	ser_ref.data = (*env)->GetByteArrayElements (env, ser, NULL);
	LDKCResult_QueryChannelRangeDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_QueryChannelRangeDecodeErrorZ), "LDKCResult_QueryChannelRangeDecodeErrorZ");
	*ret_conv = QueryChannelRange_read(ser_ref);
	(*env)->ReleaseByteArrayElements(env, ser, (int8_t*)ser_ref.data, 0);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ReplyChannelRange_1read(JNIEnv *env, jclass clz, int8_tArray ser) {
	LDKu8slice ser_ref;
	ser_ref.datalen = (*env)->GetArrayLength(env, ser);
	ser_ref.data = (*env)->GetByteArrayElements (env, ser, NULL);
	LDKCResult_ReplyChannelRangeDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_ReplyChannelRangeDecodeErrorZ), "LDKCResult_ReplyChannelRangeDecodeErrorZ");
	*ret_conv = ReplyChannelRange_read(ser_ref);
	(*env)->ReleaseByteArrayElements(env, ser, (int8_t*)ser_ref.data, 0);
	return (uint64_t)ret_conv;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_ReplyChannelRange_1write(JNIEnv *env, jclass clz, int64_t obj) {
	LDKReplyChannelRange obj_conv;
	obj_conv.inner = (void*)(obj & (~1));
	obj_conv.is_owned = false;
	LDKCVec_u8Z ret_var = ReplyChannelRange_write(&obj_conv);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	CVec_u8Z_free(ret_var);
	return ret_arr;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_GossipTimestampFilter_1write(JNIEnv *env, jclass clz, int64_t obj) {
	LDKGossipTimestampFilter obj_conv;
	obj_conv.inner = (void*)(obj & (~1));
	obj_conv.is_owned = false;
	LDKCVec_u8Z ret_var = GossipTimestampFilter_write(&obj_conv);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	CVec_u8Z_free(ret_var);
	return ret_arr;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_GossipTimestampFilter_1read(JNIEnv *env, jclass clz, int8_tArray ser) {
	LDKu8slice ser_ref;
	ser_ref.datalen = (*env)->GetArrayLength(env, ser);
	ser_ref.data = (*env)->GetByteArrayElements (env, ser, NULL);
	LDKCResult_GossipTimestampFilterDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_GossipTimestampFilterDecodeErrorZ), "LDKCResult_GossipTimestampFilterDecodeErrorZ");
	*ret_conv = GossipTimestampFilter_read(ser_ref);
	(*env)->ReleaseByteArrayElements(env, ser, (int8_t*)ser_ref.data, 0);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CustomMessageHandler_1free(JNIEnv *env, jclass clz, int64_t this_ptr) {
	if ((this_ptr & 1) != 0) return;
	void* this_ptr_ptr = (void*)(((uint64_t)this_ptr) & ~1);
	CHECK_ACCESS(this_ptr_ptr);
	LDKCustomMessageHandler this_ptr_conv = *(LDKCustomMessageHandler*)(this_ptr_ptr);
	FREE((void*)this_ptr);
	CustomMessageHandler_free(this_ptr_conv);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_IgnoringMessageHandler_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKIgnoringMessageHandler this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	IgnoringMessageHandler_free(this_obj_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_IgnoringMessageHandler_1new(JNIEnv *env, jclass clz) {
	LDKIgnoringMessageHandler ret_var = IgnoringMessageHandler_new();
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_IgnoringMessageHandler_1as_1MessageSendEventsProvider(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKIgnoringMessageHandler this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKMessageSendEventsProvider* ret_ret = MALLOC(sizeof(LDKMessageSendEventsProvider), "LDKMessageSendEventsProvider");
	*ret_ret = IgnoringMessageHandler_as_MessageSendEventsProvider(&this_arg_conv);
	return (uint64_t)ret_ret;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_IgnoringMessageHandler_1as_1RoutingMessageHandler(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKIgnoringMessageHandler this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKRoutingMessageHandler* ret_ret = MALLOC(sizeof(LDKRoutingMessageHandler), "LDKRoutingMessageHandler");
	*ret_ret = IgnoringMessageHandler_as_RoutingMessageHandler(&this_arg_conv);
	return (uint64_t)ret_ret;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_IgnoringMessageHandler_1as_1CustomMessageReader(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKIgnoringMessageHandler this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKCustomMessageReader* ret_ret = MALLOC(sizeof(LDKCustomMessageReader), "LDKCustomMessageReader");
	*ret_ret = IgnoringMessageHandler_as_CustomMessageReader(&this_arg_conv);
	return (uint64_t)ret_ret;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_IgnoringMessageHandler_1as_1CustomMessageHandler(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKIgnoringMessageHandler this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKCustomMessageHandler* ret_ret = MALLOC(sizeof(LDKCustomMessageHandler), "LDKCustomMessageHandler");
	*ret_ret = IgnoringMessageHandler_as_CustomMessageHandler(&this_arg_conv);
	return (uint64_t)ret_ret;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ErroringMessageHandler_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKErroringMessageHandler this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	ErroringMessageHandler_free(this_obj_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ErroringMessageHandler_1new(JNIEnv *env, jclass clz) {
	LDKErroringMessageHandler ret_var = ErroringMessageHandler_new();
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ErroringMessageHandler_1as_1MessageSendEventsProvider(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKErroringMessageHandler this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKMessageSendEventsProvider* ret_ret = MALLOC(sizeof(LDKMessageSendEventsProvider), "LDKMessageSendEventsProvider");
	*ret_ret = ErroringMessageHandler_as_MessageSendEventsProvider(&this_arg_conv);
	return (uint64_t)ret_ret;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ErroringMessageHandler_1as_1ChannelMessageHandler(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKErroringMessageHandler this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKChannelMessageHandler* ret_ret = MALLOC(sizeof(LDKChannelMessageHandler), "LDKChannelMessageHandler");
	*ret_ret = ErroringMessageHandler_as_ChannelMessageHandler(&this_arg_conv);
	return (uint64_t)ret_ret;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_MessageHandler_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKMessageHandler this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	MessageHandler_free(this_obj_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_MessageHandler_1get_1chan_1handler(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKMessageHandler this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	uint64_t ret_ret = ((uint64_t)MessageHandler_get_chan_handler(&this_ptr_conv))|1;
	return ret_ret;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_MessageHandler_1set_1chan_1handler(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKMessageHandler this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	void* val_ptr = (void*)(((uint64_t)val) & ~1);
	CHECK_ACCESS(val_ptr);
	LDKChannelMessageHandler val_conv = *(LDKChannelMessageHandler*)(val_ptr);
	if (val_conv.free == LDKChannelMessageHandler_JCalls_free) {
		// If this_arg is a JCalls struct, then we need to increment the refcnt in it.
		LDKChannelMessageHandler_JCalls_cloned(&val_conv);
	}
	MessageHandler_set_chan_handler(&this_ptr_conv, val_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_MessageHandler_1get_1route_1handler(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKMessageHandler this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	uint64_t ret_ret = ((uint64_t)MessageHandler_get_route_handler(&this_ptr_conv))|1;
	return ret_ret;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_MessageHandler_1set_1route_1handler(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKMessageHandler this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	void* val_ptr = (void*)(((uint64_t)val) & ~1);
	CHECK_ACCESS(val_ptr);
	LDKRoutingMessageHandler val_conv = *(LDKRoutingMessageHandler*)(val_ptr);
	if (val_conv.free == LDKRoutingMessageHandler_JCalls_free) {
		// If this_arg is a JCalls struct, then we need to increment the refcnt in it.
		LDKRoutingMessageHandler_JCalls_cloned(&val_conv);
	}
	MessageHandler_set_route_handler(&this_ptr_conv, val_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_MessageHandler_1new(JNIEnv *env, jclass clz, int64_t chan_handler_arg, int64_t route_handler_arg) {
	void* chan_handler_arg_ptr = (void*)(((uint64_t)chan_handler_arg) & ~1);
	CHECK_ACCESS(chan_handler_arg_ptr);
	LDKChannelMessageHandler chan_handler_arg_conv = *(LDKChannelMessageHandler*)(chan_handler_arg_ptr);
	if (chan_handler_arg_conv.free == LDKChannelMessageHandler_JCalls_free) {
		// If this_arg is a JCalls struct, then we need to increment the refcnt in it.
		LDKChannelMessageHandler_JCalls_cloned(&chan_handler_arg_conv);
	}
	void* route_handler_arg_ptr = (void*)(((uint64_t)route_handler_arg) & ~1);
	CHECK_ACCESS(route_handler_arg_ptr);
	LDKRoutingMessageHandler route_handler_arg_conv = *(LDKRoutingMessageHandler*)(route_handler_arg_ptr);
	if (route_handler_arg_conv.free == LDKRoutingMessageHandler_JCalls_free) {
		// If this_arg is a JCalls struct, then we need to increment the refcnt in it.
		LDKRoutingMessageHandler_JCalls_cloned(&route_handler_arg_conv);
	}
	LDKMessageHandler ret_var = MessageHandler_new(chan_handler_arg_conv, route_handler_arg_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_SocketDescriptor_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	void* orig_ptr = (void*)(((uint64_t)orig) & ~1);
	if (!(orig & 1)) { CHECK_ACCESS(orig_ptr); }
	LDKSocketDescriptor* orig_conv = (LDKSocketDescriptor*)orig_ptr;
	LDKSocketDescriptor* ret_ret = MALLOC(sizeof(LDKSocketDescriptor), "LDKSocketDescriptor");
	*ret_ret = SocketDescriptor_clone(orig_conv);
	return (uint64_t)ret_ret;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_SocketDescriptor_1free(JNIEnv *env, jclass clz, int64_t this_ptr) {
	if ((this_ptr & 1) != 0) return;
	void* this_ptr_ptr = (void*)(((uint64_t)this_ptr) & ~1);
	CHECK_ACCESS(this_ptr_ptr);
	LDKSocketDescriptor this_ptr_conv = *(LDKSocketDescriptor*)(this_ptr_ptr);
	FREE((void*)this_ptr);
	SocketDescriptor_free(this_ptr_conv);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_PeerHandleError_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKPeerHandleError this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	PeerHandleError_free(this_obj_conv);
}

JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_PeerHandleError_1get_1no_1connection_1possible(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKPeerHandleError this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	jboolean ret_val = PeerHandleError_get_no_connection_possible(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_PeerHandleError_1set_1no_1connection_1possible(JNIEnv *env, jclass clz, int64_t this_ptr, jboolean val) {
	LDKPeerHandleError this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	PeerHandleError_set_no_connection_possible(&this_ptr_conv, val);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_PeerHandleError_1new(JNIEnv *env, jclass clz, jboolean no_connection_possible_arg) {
	LDKPeerHandleError ret_var = PeerHandleError_new(no_connection_possible_arg);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_PeerHandleError_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKPeerHandleError orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKPeerHandleError ret_var = PeerHandleError_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_PeerManager_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKPeerManager this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	PeerManager_free(this_obj_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_PeerManager_1new(JNIEnv *env, jclass clz, int64_t message_handler, int8_tArray our_node_secret, int8_tArray ephemeral_random_data, int64_t logger, int64_t custom_message_handler) {
	LDKMessageHandler message_handler_conv;
	message_handler_conv.inner = (void*)(message_handler & (~1));
	message_handler_conv.is_owned = (message_handler & 1) || (message_handler == 0);
	// Warning: we need a move here but no clone is available for LDKMessageHandler
	LDKSecretKey our_node_secret_ref;
	CHECK((*env)->GetArrayLength(env, our_node_secret) == 32);
	(*env)->GetByteArrayRegion(env, our_node_secret, 0, 32, our_node_secret_ref.bytes);
	unsigned char ephemeral_random_data_arr[32];
	CHECK((*env)->GetArrayLength(env, ephemeral_random_data) == 32);
	(*env)->GetByteArrayRegion(env, ephemeral_random_data, 0, 32, ephemeral_random_data_arr);
	unsigned char (*ephemeral_random_data_ref)[32] = &ephemeral_random_data_arr;
	void* logger_ptr = (void*)(((uint64_t)logger) & ~1);
	CHECK_ACCESS(logger_ptr);
	LDKLogger logger_conv = *(LDKLogger*)(logger_ptr);
	if (logger_conv.free == LDKLogger_JCalls_free) {
		// If this_arg is a JCalls struct, then we need to increment the refcnt in it.
		LDKLogger_JCalls_cloned(&logger_conv);
	}
	void* custom_message_handler_ptr = (void*)(((uint64_t)custom_message_handler) & ~1);
	CHECK_ACCESS(custom_message_handler_ptr);
	LDKCustomMessageHandler custom_message_handler_conv = *(LDKCustomMessageHandler*)(custom_message_handler_ptr);
	if (custom_message_handler_conv.free == LDKCustomMessageHandler_JCalls_free) {
		// If this_arg is a JCalls struct, then we need to increment the refcnt in it.
		LDKCustomMessageHandler_JCalls_cloned(&custom_message_handler_conv);
	}
	LDKPeerManager ret_var = PeerManager_new(message_handler_conv, our_node_secret_ref, ephemeral_random_data_ref, logger_conv, custom_message_handler_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT jobjectArray JNICALL Java_org_ldk_impl_bindings_PeerManager_1get_1peer_1node_1ids(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKPeerManager this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKCVec_PublicKeyZ ret_var = PeerManager_get_peer_node_ids(&this_arg_conv);
	jobjectArray ret_arr = NULL;
	ret_arr = (*env)->NewObjectArray(env, ret_var.datalen, arr_of_B_clz, NULL);
	;
	for (size_t i = 0; i < ret_var.datalen; i++) {
		int8_tArray ret_conv_8_arr = (*env)->NewByteArray(env, 33);
		(*env)->SetByteArrayRegion(env, ret_conv_8_arr, 0, 33, ret_var.data[i].compressed_form);
		(*env)->SetObjectArrayElement(env, ret_arr, i, ret_conv_8_arr);
	}
	
	FREE(ret_var.data);
	return ret_arr;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_PeerManager_1new_1outbound_1connection(JNIEnv *env, jclass clz, int64_t this_arg, int8_tArray their_node_id, int64_t descriptor) {
	LDKPeerManager this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKPublicKey their_node_id_ref;
	CHECK((*env)->GetArrayLength(env, their_node_id) == 33);
	(*env)->GetByteArrayRegion(env, their_node_id, 0, 33, their_node_id_ref.compressed_form);
	void* descriptor_ptr = (void*)(((uint64_t)descriptor) & ~1);
	CHECK_ACCESS(descriptor_ptr);
	LDKSocketDescriptor descriptor_conv = *(LDKSocketDescriptor*)(descriptor_ptr);
	if (descriptor_conv.free == LDKSocketDescriptor_JCalls_free) {
		// If this_arg is a JCalls struct, then we need to increment the refcnt in it.
		LDKSocketDescriptor_JCalls_cloned(&descriptor_conv);
	}
	LDKCResult_CVec_u8ZPeerHandleErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_CVec_u8ZPeerHandleErrorZ), "LDKCResult_CVec_u8ZPeerHandleErrorZ");
	*ret_conv = PeerManager_new_outbound_connection(&this_arg_conv, their_node_id_ref, descriptor_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_PeerManager_1new_1inbound_1connection(JNIEnv *env, jclass clz, int64_t this_arg, int64_t descriptor) {
	LDKPeerManager this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	void* descriptor_ptr = (void*)(((uint64_t)descriptor) & ~1);
	CHECK_ACCESS(descriptor_ptr);
	LDKSocketDescriptor descriptor_conv = *(LDKSocketDescriptor*)(descriptor_ptr);
	if (descriptor_conv.free == LDKSocketDescriptor_JCalls_free) {
		// If this_arg is a JCalls struct, then we need to increment the refcnt in it.
		LDKSocketDescriptor_JCalls_cloned(&descriptor_conv);
	}
	LDKCResult_NonePeerHandleErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_NonePeerHandleErrorZ), "LDKCResult_NonePeerHandleErrorZ");
	*ret_conv = PeerManager_new_inbound_connection(&this_arg_conv, descriptor_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_PeerManager_1write_1buffer_1space_1avail(JNIEnv *env, jclass clz, int64_t this_arg, int64_t descriptor) {
	LDKPeerManager this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	void* descriptor_ptr = (void*)(((uint64_t)descriptor) & ~1);
	if (!(descriptor & 1)) { CHECK_ACCESS(descriptor_ptr); }
	LDKSocketDescriptor* descriptor_conv = (LDKSocketDescriptor*)descriptor_ptr;
	LDKCResult_NonePeerHandleErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_NonePeerHandleErrorZ), "LDKCResult_NonePeerHandleErrorZ");
	*ret_conv = PeerManager_write_buffer_space_avail(&this_arg_conv, descriptor_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_PeerManager_1read_1event(JNIEnv *env, jclass clz, int64_t this_arg, int64_t peer_descriptor, int8_tArray data) {
	LDKPeerManager this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	void* peer_descriptor_ptr = (void*)(((uint64_t)peer_descriptor) & ~1);
	if (!(peer_descriptor & 1)) { CHECK_ACCESS(peer_descriptor_ptr); }
	LDKSocketDescriptor* peer_descriptor_conv = (LDKSocketDescriptor*)peer_descriptor_ptr;
	LDKu8slice data_ref;
	data_ref.datalen = (*env)->GetArrayLength(env, data);
	data_ref.data = (*env)->GetByteArrayElements (env, data, NULL);
	LDKCResult_boolPeerHandleErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_boolPeerHandleErrorZ), "LDKCResult_boolPeerHandleErrorZ");
	*ret_conv = PeerManager_read_event(&this_arg_conv, peer_descriptor_conv, data_ref);
	(*env)->ReleaseByteArrayElements(env, data, (int8_t*)data_ref.data, 0);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_PeerManager_1process_1events(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKPeerManager this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	PeerManager_process_events(&this_arg_conv);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_PeerManager_1socket_1disconnected(JNIEnv *env, jclass clz, int64_t this_arg, int64_t descriptor) {
	LDKPeerManager this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	void* descriptor_ptr = (void*)(((uint64_t)descriptor) & ~1);
	if (!(descriptor & 1)) { CHECK_ACCESS(descriptor_ptr); }
	LDKSocketDescriptor* descriptor_conv = (LDKSocketDescriptor*)descriptor_ptr;
	PeerManager_socket_disconnected(&this_arg_conv, descriptor_conv);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_PeerManager_1disconnect_1by_1node_1id(JNIEnv *env, jclass clz, int64_t this_arg, int8_tArray node_id, jboolean no_connection_possible) {
	LDKPeerManager this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKPublicKey node_id_ref;
	CHECK((*env)->GetArrayLength(env, node_id) == 33);
	(*env)->GetByteArrayRegion(env, node_id, 0, 33, node_id_ref.compressed_form);
	PeerManager_disconnect_by_node_id(&this_arg_conv, node_id_ref, no_connection_possible);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_PeerManager_1disconnect_1all_1peers(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKPeerManager this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	PeerManager_disconnect_all_peers(&this_arg_conv);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_PeerManager_1timer_1tick_1occurred(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKPeerManager this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	PeerManager_timer_tick_occurred(&this_arg_conv);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_build_1commitment_1secret(JNIEnv *env, jclass clz, int8_tArray commitment_seed, int64_t idx) {
	unsigned char commitment_seed_arr[32];
	CHECK((*env)->GetArrayLength(env, commitment_seed) == 32);
	(*env)->GetByteArrayRegion(env, commitment_seed, 0, 32, commitment_seed_arr);
	unsigned char (*commitment_seed_ref)[32] = &commitment_seed_arr;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 32);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 32, build_commitment_secret(commitment_seed_ref, idx).data);
	return ret_arr;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_build_1closing_1transaction(JNIEnv *env, jclass clz, int64_t to_holder_value_sat, int64_t to_counterparty_value_sat, int8_tArray to_holder_script, int8_tArray to_counterparty_script, int64_t funding_outpoint) {
	LDKCVec_u8Z to_holder_script_ref;
	to_holder_script_ref.datalen = (*env)->GetArrayLength(env, to_holder_script);
	to_holder_script_ref.data = MALLOC(to_holder_script_ref.datalen, "LDKCVec_u8Z Bytes");
	(*env)->GetByteArrayRegion(env, to_holder_script, 0, to_holder_script_ref.datalen, to_holder_script_ref.data);
	LDKCVec_u8Z to_counterparty_script_ref;
	to_counterparty_script_ref.datalen = (*env)->GetArrayLength(env, to_counterparty_script);
	to_counterparty_script_ref.data = MALLOC(to_counterparty_script_ref.datalen, "LDKCVec_u8Z Bytes");
	(*env)->GetByteArrayRegion(env, to_counterparty_script, 0, to_counterparty_script_ref.datalen, to_counterparty_script_ref.data);
	LDKOutPoint funding_outpoint_conv;
	funding_outpoint_conv.inner = (void*)(funding_outpoint & (~1));
	funding_outpoint_conv.is_owned = (funding_outpoint & 1) || (funding_outpoint == 0);
	funding_outpoint_conv = OutPoint_clone(&funding_outpoint_conv);
	LDKTransaction ret_var = build_closing_transaction(to_holder_value_sat, to_counterparty_value_sat, to_holder_script_ref, to_counterparty_script_ref, funding_outpoint_conv);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	Transaction_free(ret_var);
	return ret_arr;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_derive_1private_1key(JNIEnv *env, jclass clz, int8_tArray per_commitment_point, int8_tArray base_secret) {
	LDKPublicKey per_commitment_point_ref;
	CHECK((*env)->GetArrayLength(env, per_commitment_point) == 33);
	(*env)->GetByteArrayRegion(env, per_commitment_point, 0, 33, per_commitment_point_ref.compressed_form);
	unsigned char base_secret_arr[32];
	CHECK((*env)->GetArrayLength(env, base_secret) == 32);
	(*env)->GetByteArrayRegion(env, base_secret, 0, 32, base_secret_arr);
	unsigned char (*base_secret_ref)[32] = &base_secret_arr;
	LDKCResult_SecretKeyErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_SecretKeyErrorZ), "LDKCResult_SecretKeyErrorZ");
	*ret_conv = derive_private_key(per_commitment_point_ref, base_secret_ref);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_derive_1public_1key(JNIEnv *env, jclass clz, int8_tArray per_commitment_point, int8_tArray base_point) {
	LDKPublicKey per_commitment_point_ref;
	CHECK((*env)->GetArrayLength(env, per_commitment_point) == 33);
	(*env)->GetByteArrayRegion(env, per_commitment_point, 0, 33, per_commitment_point_ref.compressed_form);
	LDKPublicKey base_point_ref;
	CHECK((*env)->GetArrayLength(env, base_point) == 33);
	(*env)->GetByteArrayRegion(env, base_point, 0, 33, base_point_ref.compressed_form);
	LDKCResult_PublicKeyErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_PublicKeyErrorZ), "LDKCResult_PublicKeyErrorZ");
	*ret_conv = derive_public_key(per_commitment_point_ref, base_point_ref);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_derive_1private_1revocation_1key(JNIEnv *env, jclass clz, int8_tArray per_commitment_secret, int8_tArray countersignatory_revocation_base_secret) {
	unsigned char per_commitment_secret_arr[32];
	CHECK((*env)->GetArrayLength(env, per_commitment_secret) == 32);
	(*env)->GetByteArrayRegion(env, per_commitment_secret, 0, 32, per_commitment_secret_arr);
	unsigned char (*per_commitment_secret_ref)[32] = &per_commitment_secret_arr;
	unsigned char countersignatory_revocation_base_secret_arr[32];
	CHECK((*env)->GetArrayLength(env, countersignatory_revocation_base_secret) == 32);
	(*env)->GetByteArrayRegion(env, countersignatory_revocation_base_secret, 0, 32, countersignatory_revocation_base_secret_arr);
	unsigned char (*countersignatory_revocation_base_secret_ref)[32] = &countersignatory_revocation_base_secret_arr;
	LDKCResult_SecretKeyErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_SecretKeyErrorZ), "LDKCResult_SecretKeyErrorZ");
	*ret_conv = derive_private_revocation_key(per_commitment_secret_ref, countersignatory_revocation_base_secret_ref);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_derive_1public_1revocation_1key(JNIEnv *env, jclass clz, int8_tArray per_commitment_point, int8_tArray countersignatory_revocation_base_point) {
	LDKPublicKey per_commitment_point_ref;
	CHECK((*env)->GetArrayLength(env, per_commitment_point) == 33);
	(*env)->GetByteArrayRegion(env, per_commitment_point, 0, 33, per_commitment_point_ref.compressed_form);
	LDKPublicKey countersignatory_revocation_base_point_ref;
	CHECK((*env)->GetArrayLength(env, countersignatory_revocation_base_point) == 33);
	(*env)->GetByteArrayRegion(env, countersignatory_revocation_base_point, 0, 33, countersignatory_revocation_base_point_ref.compressed_form);
	LDKCResult_PublicKeyErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_PublicKeyErrorZ), "LDKCResult_PublicKeyErrorZ");
	*ret_conv = derive_public_revocation_key(per_commitment_point_ref, countersignatory_revocation_base_point_ref);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_TxCreationKeys_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKTxCreationKeys this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	TxCreationKeys_free(this_obj_conv);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_TxCreationKeys_1get_1per_1commitment_1point(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKTxCreationKeys this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 33);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 33, TxCreationKeys_get_per_commitment_point(&this_ptr_conv).compressed_form);
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_TxCreationKeys_1set_1per_1commitment_1point(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKTxCreationKeys this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKPublicKey val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 33);
	(*env)->GetByteArrayRegion(env, val, 0, 33, val_ref.compressed_form);
	TxCreationKeys_set_per_commitment_point(&this_ptr_conv, val_ref);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_TxCreationKeys_1get_1revocation_1key(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKTxCreationKeys this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 33);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 33, TxCreationKeys_get_revocation_key(&this_ptr_conv).compressed_form);
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_TxCreationKeys_1set_1revocation_1key(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKTxCreationKeys this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKPublicKey val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 33);
	(*env)->GetByteArrayRegion(env, val, 0, 33, val_ref.compressed_form);
	TxCreationKeys_set_revocation_key(&this_ptr_conv, val_ref);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_TxCreationKeys_1get_1broadcaster_1htlc_1key(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKTxCreationKeys this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 33);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 33, TxCreationKeys_get_broadcaster_htlc_key(&this_ptr_conv).compressed_form);
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_TxCreationKeys_1set_1broadcaster_1htlc_1key(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKTxCreationKeys this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKPublicKey val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 33);
	(*env)->GetByteArrayRegion(env, val, 0, 33, val_ref.compressed_form);
	TxCreationKeys_set_broadcaster_htlc_key(&this_ptr_conv, val_ref);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_TxCreationKeys_1get_1countersignatory_1htlc_1key(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKTxCreationKeys this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 33);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 33, TxCreationKeys_get_countersignatory_htlc_key(&this_ptr_conv).compressed_form);
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_TxCreationKeys_1set_1countersignatory_1htlc_1key(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKTxCreationKeys this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKPublicKey val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 33);
	(*env)->GetByteArrayRegion(env, val, 0, 33, val_ref.compressed_form);
	TxCreationKeys_set_countersignatory_htlc_key(&this_ptr_conv, val_ref);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_TxCreationKeys_1get_1broadcaster_1delayed_1payment_1key(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKTxCreationKeys this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 33);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 33, TxCreationKeys_get_broadcaster_delayed_payment_key(&this_ptr_conv).compressed_form);
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_TxCreationKeys_1set_1broadcaster_1delayed_1payment_1key(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKTxCreationKeys this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKPublicKey val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 33);
	(*env)->GetByteArrayRegion(env, val, 0, 33, val_ref.compressed_form);
	TxCreationKeys_set_broadcaster_delayed_payment_key(&this_ptr_conv, val_ref);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_TxCreationKeys_1new(JNIEnv *env, jclass clz, int8_tArray per_commitment_point_arg, int8_tArray revocation_key_arg, int8_tArray broadcaster_htlc_key_arg, int8_tArray countersignatory_htlc_key_arg, int8_tArray broadcaster_delayed_payment_key_arg) {
	LDKPublicKey per_commitment_point_arg_ref;
	CHECK((*env)->GetArrayLength(env, per_commitment_point_arg) == 33);
	(*env)->GetByteArrayRegion(env, per_commitment_point_arg, 0, 33, per_commitment_point_arg_ref.compressed_form);
	LDKPublicKey revocation_key_arg_ref;
	CHECK((*env)->GetArrayLength(env, revocation_key_arg) == 33);
	(*env)->GetByteArrayRegion(env, revocation_key_arg, 0, 33, revocation_key_arg_ref.compressed_form);
	LDKPublicKey broadcaster_htlc_key_arg_ref;
	CHECK((*env)->GetArrayLength(env, broadcaster_htlc_key_arg) == 33);
	(*env)->GetByteArrayRegion(env, broadcaster_htlc_key_arg, 0, 33, broadcaster_htlc_key_arg_ref.compressed_form);
	LDKPublicKey countersignatory_htlc_key_arg_ref;
	CHECK((*env)->GetArrayLength(env, countersignatory_htlc_key_arg) == 33);
	(*env)->GetByteArrayRegion(env, countersignatory_htlc_key_arg, 0, 33, countersignatory_htlc_key_arg_ref.compressed_form);
	LDKPublicKey broadcaster_delayed_payment_key_arg_ref;
	CHECK((*env)->GetArrayLength(env, broadcaster_delayed_payment_key_arg) == 33);
	(*env)->GetByteArrayRegion(env, broadcaster_delayed_payment_key_arg, 0, 33, broadcaster_delayed_payment_key_arg_ref.compressed_form);
	LDKTxCreationKeys ret_var = TxCreationKeys_new(per_commitment_point_arg_ref, revocation_key_arg_ref, broadcaster_htlc_key_arg_ref, countersignatory_htlc_key_arg_ref, broadcaster_delayed_payment_key_arg_ref);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_TxCreationKeys_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKTxCreationKeys orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKTxCreationKeys ret_var = TxCreationKeys_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_TxCreationKeys_1write(JNIEnv *env, jclass clz, int64_t obj) {
	LDKTxCreationKeys obj_conv;
	obj_conv.inner = (void*)(obj & (~1));
	obj_conv.is_owned = false;
	LDKCVec_u8Z ret_var = TxCreationKeys_write(&obj_conv);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	CVec_u8Z_free(ret_var);
	return ret_arr;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_TxCreationKeys_1read(JNIEnv *env, jclass clz, int8_tArray ser) {
	LDKu8slice ser_ref;
	ser_ref.datalen = (*env)->GetArrayLength(env, ser);
	ser_ref.data = (*env)->GetByteArrayElements (env, ser, NULL);
	LDKCResult_TxCreationKeysDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_TxCreationKeysDecodeErrorZ), "LDKCResult_TxCreationKeysDecodeErrorZ");
	*ret_conv = TxCreationKeys_read(ser_ref);
	(*env)->ReleaseByteArrayElements(env, ser, (int8_t*)ser_ref.data, 0);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelPublicKeys_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKChannelPublicKeys this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	ChannelPublicKeys_free(this_obj_conv);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_ChannelPublicKeys_1get_1funding_1pubkey(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKChannelPublicKeys this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 33);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 33, ChannelPublicKeys_get_funding_pubkey(&this_ptr_conv).compressed_form);
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelPublicKeys_1set_1funding_1pubkey(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKChannelPublicKeys this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKPublicKey val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 33);
	(*env)->GetByteArrayRegion(env, val, 0, 33, val_ref.compressed_form);
	ChannelPublicKeys_set_funding_pubkey(&this_ptr_conv, val_ref);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_ChannelPublicKeys_1get_1revocation_1basepoint(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKChannelPublicKeys this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 33);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 33, ChannelPublicKeys_get_revocation_basepoint(&this_ptr_conv).compressed_form);
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelPublicKeys_1set_1revocation_1basepoint(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKChannelPublicKeys this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKPublicKey val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 33);
	(*env)->GetByteArrayRegion(env, val, 0, 33, val_ref.compressed_form);
	ChannelPublicKeys_set_revocation_basepoint(&this_ptr_conv, val_ref);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_ChannelPublicKeys_1get_1payment_1point(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKChannelPublicKeys this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 33);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 33, ChannelPublicKeys_get_payment_point(&this_ptr_conv).compressed_form);
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelPublicKeys_1set_1payment_1point(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKChannelPublicKeys this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKPublicKey val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 33);
	(*env)->GetByteArrayRegion(env, val, 0, 33, val_ref.compressed_form);
	ChannelPublicKeys_set_payment_point(&this_ptr_conv, val_ref);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_ChannelPublicKeys_1get_1delayed_1payment_1basepoint(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKChannelPublicKeys this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 33);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 33, ChannelPublicKeys_get_delayed_payment_basepoint(&this_ptr_conv).compressed_form);
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelPublicKeys_1set_1delayed_1payment_1basepoint(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKChannelPublicKeys this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKPublicKey val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 33);
	(*env)->GetByteArrayRegion(env, val, 0, 33, val_ref.compressed_form);
	ChannelPublicKeys_set_delayed_payment_basepoint(&this_ptr_conv, val_ref);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_ChannelPublicKeys_1get_1htlc_1basepoint(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKChannelPublicKeys this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 33);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 33, ChannelPublicKeys_get_htlc_basepoint(&this_ptr_conv).compressed_form);
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelPublicKeys_1set_1htlc_1basepoint(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKChannelPublicKeys this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKPublicKey val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 33);
	(*env)->GetByteArrayRegion(env, val, 0, 33, val_ref.compressed_form);
	ChannelPublicKeys_set_htlc_basepoint(&this_ptr_conv, val_ref);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelPublicKeys_1new(JNIEnv *env, jclass clz, int8_tArray funding_pubkey_arg, int8_tArray revocation_basepoint_arg, int8_tArray payment_point_arg, int8_tArray delayed_payment_basepoint_arg, int8_tArray htlc_basepoint_arg) {
	LDKPublicKey funding_pubkey_arg_ref;
	CHECK((*env)->GetArrayLength(env, funding_pubkey_arg) == 33);
	(*env)->GetByteArrayRegion(env, funding_pubkey_arg, 0, 33, funding_pubkey_arg_ref.compressed_form);
	LDKPublicKey revocation_basepoint_arg_ref;
	CHECK((*env)->GetArrayLength(env, revocation_basepoint_arg) == 33);
	(*env)->GetByteArrayRegion(env, revocation_basepoint_arg, 0, 33, revocation_basepoint_arg_ref.compressed_form);
	LDKPublicKey payment_point_arg_ref;
	CHECK((*env)->GetArrayLength(env, payment_point_arg) == 33);
	(*env)->GetByteArrayRegion(env, payment_point_arg, 0, 33, payment_point_arg_ref.compressed_form);
	LDKPublicKey delayed_payment_basepoint_arg_ref;
	CHECK((*env)->GetArrayLength(env, delayed_payment_basepoint_arg) == 33);
	(*env)->GetByteArrayRegion(env, delayed_payment_basepoint_arg, 0, 33, delayed_payment_basepoint_arg_ref.compressed_form);
	LDKPublicKey htlc_basepoint_arg_ref;
	CHECK((*env)->GetArrayLength(env, htlc_basepoint_arg) == 33);
	(*env)->GetByteArrayRegion(env, htlc_basepoint_arg, 0, 33, htlc_basepoint_arg_ref.compressed_form);
	LDKChannelPublicKeys ret_var = ChannelPublicKeys_new(funding_pubkey_arg_ref, revocation_basepoint_arg_ref, payment_point_arg_ref, delayed_payment_basepoint_arg_ref, htlc_basepoint_arg_ref);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelPublicKeys_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKChannelPublicKeys orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKChannelPublicKeys ret_var = ChannelPublicKeys_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_ChannelPublicKeys_1write(JNIEnv *env, jclass clz, int64_t obj) {
	LDKChannelPublicKeys obj_conv;
	obj_conv.inner = (void*)(obj & (~1));
	obj_conv.is_owned = false;
	LDKCVec_u8Z ret_var = ChannelPublicKeys_write(&obj_conv);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	CVec_u8Z_free(ret_var);
	return ret_arr;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelPublicKeys_1read(JNIEnv *env, jclass clz, int8_tArray ser) {
	LDKu8slice ser_ref;
	ser_ref.datalen = (*env)->GetArrayLength(env, ser);
	ser_ref.data = (*env)->GetByteArrayElements (env, ser, NULL);
	LDKCResult_ChannelPublicKeysDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_ChannelPublicKeysDecodeErrorZ), "LDKCResult_ChannelPublicKeysDecodeErrorZ");
	*ret_conv = ChannelPublicKeys_read(ser_ref);
	(*env)->ReleaseByteArrayElements(env, ser, (int8_t*)ser_ref.data, 0);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_TxCreationKeys_1derive_1new(JNIEnv *env, jclass clz, int8_tArray per_commitment_point, int8_tArray broadcaster_delayed_payment_base, int8_tArray broadcaster_htlc_base, int8_tArray countersignatory_revocation_base, int8_tArray countersignatory_htlc_base) {
	LDKPublicKey per_commitment_point_ref;
	CHECK((*env)->GetArrayLength(env, per_commitment_point) == 33);
	(*env)->GetByteArrayRegion(env, per_commitment_point, 0, 33, per_commitment_point_ref.compressed_form);
	LDKPublicKey broadcaster_delayed_payment_base_ref;
	CHECK((*env)->GetArrayLength(env, broadcaster_delayed_payment_base) == 33);
	(*env)->GetByteArrayRegion(env, broadcaster_delayed_payment_base, 0, 33, broadcaster_delayed_payment_base_ref.compressed_form);
	LDKPublicKey broadcaster_htlc_base_ref;
	CHECK((*env)->GetArrayLength(env, broadcaster_htlc_base) == 33);
	(*env)->GetByteArrayRegion(env, broadcaster_htlc_base, 0, 33, broadcaster_htlc_base_ref.compressed_form);
	LDKPublicKey countersignatory_revocation_base_ref;
	CHECK((*env)->GetArrayLength(env, countersignatory_revocation_base) == 33);
	(*env)->GetByteArrayRegion(env, countersignatory_revocation_base, 0, 33, countersignatory_revocation_base_ref.compressed_form);
	LDKPublicKey countersignatory_htlc_base_ref;
	CHECK((*env)->GetArrayLength(env, countersignatory_htlc_base) == 33);
	(*env)->GetByteArrayRegion(env, countersignatory_htlc_base, 0, 33, countersignatory_htlc_base_ref.compressed_form);
	LDKCResult_TxCreationKeysErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_TxCreationKeysErrorZ), "LDKCResult_TxCreationKeysErrorZ");
	*ret_conv = TxCreationKeys_derive_new(per_commitment_point_ref, broadcaster_delayed_payment_base_ref, broadcaster_htlc_base_ref, countersignatory_revocation_base_ref, countersignatory_htlc_base_ref);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_TxCreationKeys_1from_1channel_1static_1keys(JNIEnv *env, jclass clz, int8_tArray per_commitment_point, int64_t broadcaster_keys, int64_t countersignatory_keys) {
	LDKPublicKey per_commitment_point_ref;
	CHECK((*env)->GetArrayLength(env, per_commitment_point) == 33);
	(*env)->GetByteArrayRegion(env, per_commitment_point, 0, 33, per_commitment_point_ref.compressed_form);
	LDKChannelPublicKeys broadcaster_keys_conv;
	broadcaster_keys_conv.inner = (void*)(broadcaster_keys & (~1));
	broadcaster_keys_conv.is_owned = false;
	LDKChannelPublicKeys countersignatory_keys_conv;
	countersignatory_keys_conv.inner = (void*)(countersignatory_keys & (~1));
	countersignatory_keys_conv.is_owned = false;
	LDKCResult_TxCreationKeysErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_TxCreationKeysErrorZ), "LDKCResult_TxCreationKeysErrorZ");
	*ret_conv = TxCreationKeys_from_channel_static_keys(per_commitment_point_ref, &broadcaster_keys_conv, &countersignatory_keys_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_get_1revokeable_1redeemscript(JNIEnv *env, jclass clz, int8_tArray revocation_key, int16_t contest_delay, int8_tArray broadcaster_delayed_payment_key) {
	LDKPublicKey revocation_key_ref;
	CHECK((*env)->GetArrayLength(env, revocation_key) == 33);
	(*env)->GetByteArrayRegion(env, revocation_key, 0, 33, revocation_key_ref.compressed_form);
	LDKPublicKey broadcaster_delayed_payment_key_ref;
	CHECK((*env)->GetArrayLength(env, broadcaster_delayed_payment_key) == 33);
	(*env)->GetByteArrayRegion(env, broadcaster_delayed_payment_key, 0, 33, broadcaster_delayed_payment_key_ref.compressed_form);
	LDKCVec_u8Z ret_var = get_revokeable_redeemscript(revocation_key_ref, contest_delay, broadcaster_delayed_payment_key_ref);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	CVec_u8Z_free(ret_var);
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_HTLCOutputInCommitment_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKHTLCOutputInCommitment this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	HTLCOutputInCommitment_free(this_obj_conv);
}

JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_HTLCOutputInCommitment_1get_1offered(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKHTLCOutputInCommitment this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	jboolean ret_val = HTLCOutputInCommitment_get_offered(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_HTLCOutputInCommitment_1set_1offered(JNIEnv *env, jclass clz, int64_t this_ptr, jboolean val) {
	LDKHTLCOutputInCommitment this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	HTLCOutputInCommitment_set_offered(&this_ptr_conv, val);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_HTLCOutputInCommitment_1get_1amount_1msat(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKHTLCOutputInCommitment this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int64_t ret_val = HTLCOutputInCommitment_get_amount_msat(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_HTLCOutputInCommitment_1set_1amount_1msat(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKHTLCOutputInCommitment this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	HTLCOutputInCommitment_set_amount_msat(&this_ptr_conv, val);
}

JNIEXPORT int32_t JNICALL Java_org_ldk_impl_bindings_HTLCOutputInCommitment_1get_1cltv_1expiry(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKHTLCOutputInCommitment this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int32_t ret_val = HTLCOutputInCommitment_get_cltv_expiry(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_HTLCOutputInCommitment_1set_1cltv_1expiry(JNIEnv *env, jclass clz, int64_t this_ptr, int32_t val) {
	LDKHTLCOutputInCommitment this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	HTLCOutputInCommitment_set_cltv_expiry(&this_ptr_conv, val);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_HTLCOutputInCommitment_1get_1payment_1hash(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKHTLCOutputInCommitment this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 32);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 32, *HTLCOutputInCommitment_get_payment_hash(&this_ptr_conv));
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_HTLCOutputInCommitment_1set_1payment_1hash(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKHTLCOutputInCommitment this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKThirtyTwoBytes val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 32);
	(*env)->GetByteArrayRegion(env, val, 0, 32, val_ref.data);
	HTLCOutputInCommitment_set_payment_hash(&this_ptr_conv, val_ref);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_HTLCOutputInCommitment_1get_1transaction_1output_1index(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKHTLCOutputInCommitment this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKCOption_u32Z *ret_copy = MALLOC(sizeof(LDKCOption_u32Z), "LDKCOption_u32Z");
	*ret_copy = HTLCOutputInCommitment_get_transaction_output_index(&this_ptr_conv);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_HTLCOutputInCommitment_1set_1transaction_1output_1index(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKHTLCOutputInCommitment this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	void* val_ptr = (void*)(((uint64_t)val) & ~1);
	CHECK_ACCESS(val_ptr);
	LDKCOption_u32Z val_conv = *(LDKCOption_u32Z*)(val_ptr);
	val_conv = COption_u32Z_clone((LDKCOption_u32Z*)(((uint64_t)val) & ~1));
	HTLCOutputInCommitment_set_transaction_output_index(&this_ptr_conv, val_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_HTLCOutputInCommitment_1new(JNIEnv *env, jclass clz, jboolean offered_arg, int64_t amount_msat_arg, int32_t cltv_expiry_arg, int8_tArray payment_hash_arg, int64_t transaction_output_index_arg) {
	LDKThirtyTwoBytes payment_hash_arg_ref;
	CHECK((*env)->GetArrayLength(env, payment_hash_arg) == 32);
	(*env)->GetByteArrayRegion(env, payment_hash_arg, 0, 32, payment_hash_arg_ref.data);
	void* transaction_output_index_arg_ptr = (void*)(((uint64_t)transaction_output_index_arg) & ~1);
	CHECK_ACCESS(transaction_output_index_arg_ptr);
	LDKCOption_u32Z transaction_output_index_arg_conv = *(LDKCOption_u32Z*)(transaction_output_index_arg_ptr);
	transaction_output_index_arg_conv = COption_u32Z_clone((LDKCOption_u32Z*)(((uint64_t)transaction_output_index_arg) & ~1));
	LDKHTLCOutputInCommitment ret_var = HTLCOutputInCommitment_new(offered_arg, amount_msat_arg, cltv_expiry_arg, payment_hash_arg_ref, transaction_output_index_arg_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_HTLCOutputInCommitment_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKHTLCOutputInCommitment orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKHTLCOutputInCommitment ret_var = HTLCOutputInCommitment_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_HTLCOutputInCommitment_1write(JNIEnv *env, jclass clz, int64_t obj) {
	LDKHTLCOutputInCommitment obj_conv;
	obj_conv.inner = (void*)(obj & (~1));
	obj_conv.is_owned = false;
	LDKCVec_u8Z ret_var = HTLCOutputInCommitment_write(&obj_conv);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	CVec_u8Z_free(ret_var);
	return ret_arr;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_HTLCOutputInCommitment_1read(JNIEnv *env, jclass clz, int8_tArray ser) {
	LDKu8slice ser_ref;
	ser_ref.datalen = (*env)->GetArrayLength(env, ser);
	ser_ref.data = (*env)->GetByteArrayElements (env, ser, NULL);
	LDKCResult_HTLCOutputInCommitmentDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_HTLCOutputInCommitmentDecodeErrorZ), "LDKCResult_HTLCOutputInCommitmentDecodeErrorZ");
	*ret_conv = HTLCOutputInCommitment_read(ser_ref);
	(*env)->ReleaseByteArrayElements(env, ser, (int8_t*)ser_ref.data, 0);
	return (uint64_t)ret_conv;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_get_1htlc_1redeemscript(JNIEnv *env, jclass clz, int64_t htlc, int64_t keys) {
	LDKHTLCOutputInCommitment htlc_conv;
	htlc_conv.inner = (void*)(htlc & (~1));
	htlc_conv.is_owned = false;
	LDKTxCreationKeys keys_conv;
	keys_conv.inner = (void*)(keys & (~1));
	keys_conv.is_owned = false;
	LDKCVec_u8Z ret_var = get_htlc_redeemscript(&htlc_conv, &keys_conv);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	CVec_u8Z_free(ret_var);
	return ret_arr;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_make_1funding_1redeemscript(JNIEnv *env, jclass clz, int8_tArray broadcaster, int8_tArray countersignatory) {
	LDKPublicKey broadcaster_ref;
	CHECK((*env)->GetArrayLength(env, broadcaster) == 33);
	(*env)->GetByteArrayRegion(env, broadcaster, 0, 33, broadcaster_ref.compressed_form);
	LDKPublicKey countersignatory_ref;
	CHECK((*env)->GetArrayLength(env, countersignatory) == 33);
	(*env)->GetByteArrayRegion(env, countersignatory, 0, 33, countersignatory_ref.compressed_form);
	LDKCVec_u8Z ret_var = make_funding_redeemscript(broadcaster_ref, countersignatory_ref);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	CVec_u8Z_free(ret_var);
	return ret_arr;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_build_1htlc_1transaction(JNIEnv *env, jclass clz, int8_tArray commitment_txid, int32_t feerate_per_kw, int16_t contest_delay, int64_t htlc, int8_tArray broadcaster_delayed_payment_key, int8_tArray revocation_key) {
	unsigned char commitment_txid_arr[32];
	CHECK((*env)->GetArrayLength(env, commitment_txid) == 32);
	(*env)->GetByteArrayRegion(env, commitment_txid, 0, 32, commitment_txid_arr);
	unsigned char (*commitment_txid_ref)[32] = &commitment_txid_arr;
	LDKHTLCOutputInCommitment htlc_conv;
	htlc_conv.inner = (void*)(htlc & (~1));
	htlc_conv.is_owned = false;
	LDKPublicKey broadcaster_delayed_payment_key_ref;
	CHECK((*env)->GetArrayLength(env, broadcaster_delayed_payment_key) == 33);
	(*env)->GetByteArrayRegion(env, broadcaster_delayed_payment_key, 0, 33, broadcaster_delayed_payment_key_ref.compressed_form);
	LDKPublicKey revocation_key_ref;
	CHECK((*env)->GetArrayLength(env, revocation_key) == 33);
	(*env)->GetByteArrayRegion(env, revocation_key, 0, 33, revocation_key_ref.compressed_form);
	LDKTransaction ret_var = build_htlc_transaction(commitment_txid_ref, feerate_per_kw, contest_delay, &htlc_conv, broadcaster_delayed_payment_key_ref, revocation_key_ref);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	Transaction_free(ret_var);
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelTransactionParameters_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKChannelTransactionParameters this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	ChannelTransactionParameters_free(this_obj_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelTransactionParameters_1get_1holder_1pubkeys(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKChannelTransactionParameters this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKChannelPublicKeys ret_var = ChannelTransactionParameters_get_holder_pubkeys(&this_ptr_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelTransactionParameters_1set_1holder_1pubkeys(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKChannelTransactionParameters this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKChannelPublicKeys val_conv;
	val_conv.inner = (void*)(val & (~1));
	val_conv.is_owned = (val & 1) || (val == 0);
	val_conv = ChannelPublicKeys_clone(&val_conv);
	ChannelTransactionParameters_set_holder_pubkeys(&this_ptr_conv, val_conv);
}

JNIEXPORT int16_t JNICALL Java_org_ldk_impl_bindings_ChannelTransactionParameters_1get_1holder_1selected_1contest_1delay(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKChannelTransactionParameters this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int16_t ret_val = ChannelTransactionParameters_get_holder_selected_contest_delay(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelTransactionParameters_1set_1holder_1selected_1contest_1delay(JNIEnv *env, jclass clz, int64_t this_ptr, int16_t val) {
	LDKChannelTransactionParameters this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	ChannelTransactionParameters_set_holder_selected_contest_delay(&this_ptr_conv, val);
}

JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_ChannelTransactionParameters_1get_1is_1outbound_1from_1holder(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKChannelTransactionParameters this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	jboolean ret_val = ChannelTransactionParameters_get_is_outbound_from_holder(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelTransactionParameters_1set_1is_1outbound_1from_1holder(JNIEnv *env, jclass clz, int64_t this_ptr, jboolean val) {
	LDKChannelTransactionParameters this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	ChannelTransactionParameters_set_is_outbound_from_holder(&this_ptr_conv, val);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelTransactionParameters_1get_1counterparty_1parameters(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKChannelTransactionParameters this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKCounterpartyChannelTransactionParameters ret_var = ChannelTransactionParameters_get_counterparty_parameters(&this_ptr_conv);
	uint64_t ret_ref = 0;
	if ((uint64_t)ret_var.inner > 4096) {
		CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
		CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
		ret_ref = (uint64_t)ret_var.inner;
		if (ret_var.is_owned) {
			ret_ref |= 1;
		}
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelTransactionParameters_1set_1counterparty_1parameters(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKChannelTransactionParameters this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKCounterpartyChannelTransactionParameters val_conv;
	val_conv.inner = (void*)(val & (~1));
	val_conv.is_owned = (val & 1) || (val == 0);
	val_conv = CounterpartyChannelTransactionParameters_clone(&val_conv);
	ChannelTransactionParameters_set_counterparty_parameters(&this_ptr_conv, val_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelTransactionParameters_1get_1funding_1outpoint(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKChannelTransactionParameters this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKOutPoint ret_var = ChannelTransactionParameters_get_funding_outpoint(&this_ptr_conv);
	uint64_t ret_ref = 0;
	if ((uint64_t)ret_var.inner > 4096) {
		CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
		CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
		ret_ref = (uint64_t)ret_var.inner;
		if (ret_var.is_owned) {
			ret_ref |= 1;
		}
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelTransactionParameters_1set_1funding_1outpoint(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKChannelTransactionParameters this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKOutPoint val_conv;
	val_conv.inner = (void*)(val & (~1));
	val_conv.is_owned = (val & 1) || (val == 0);
	val_conv = OutPoint_clone(&val_conv);
	ChannelTransactionParameters_set_funding_outpoint(&this_ptr_conv, val_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelTransactionParameters_1new(JNIEnv *env, jclass clz, int64_t holder_pubkeys_arg, int16_t holder_selected_contest_delay_arg, jboolean is_outbound_from_holder_arg, int64_t counterparty_parameters_arg, int64_t funding_outpoint_arg) {
	LDKChannelPublicKeys holder_pubkeys_arg_conv;
	holder_pubkeys_arg_conv.inner = (void*)(holder_pubkeys_arg & (~1));
	holder_pubkeys_arg_conv.is_owned = (holder_pubkeys_arg & 1) || (holder_pubkeys_arg == 0);
	holder_pubkeys_arg_conv = ChannelPublicKeys_clone(&holder_pubkeys_arg_conv);
	LDKCounterpartyChannelTransactionParameters counterparty_parameters_arg_conv;
	counterparty_parameters_arg_conv.inner = (void*)(counterparty_parameters_arg & (~1));
	counterparty_parameters_arg_conv.is_owned = (counterparty_parameters_arg & 1) || (counterparty_parameters_arg == 0);
	counterparty_parameters_arg_conv = CounterpartyChannelTransactionParameters_clone(&counterparty_parameters_arg_conv);
	LDKOutPoint funding_outpoint_arg_conv;
	funding_outpoint_arg_conv.inner = (void*)(funding_outpoint_arg & (~1));
	funding_outpoint_arg_conv.is_owned = (funding_outpoint_arg & 1) || (funding_outpoint_arg == 0);
	funding_outpoint_arg_conv = OutPoint_clone(&funding_outpoint_arg_conv);
	LDKChannelTransactionParameters ret_var = ChannelTransactionParameters_new(holder_pubkeys_arg_conv, holder_selected_contest_delay_arg, is_outbound_from_holder_arg, counterparty_parameters_arg_conv, funding_outpoint_arg_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelTransactionParameters_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKChannelTransactionParameters orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKChannelTransactionParameters ret_var = ChannelTransactionParameters_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CounterpartyChannelTransactionParameters_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKCounterpartyChannelTransactionParameters this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	CounterpartyChannelTransactionParameters_free(this_obj_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CounterpartyChannelTransactionParameters_1get_1pubkeys(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKCounterpartyChannelTransactionParameters this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKChannelPublicKeys ret_var = CounterpartyChannelTransactionParameters_get_pubkeys(&this_ptr_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CounterpartyChannelTransactionParameters_1set_1pubkeys(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKCounterpartyChannelTransactionParameters this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKChannelPublicKeys val_conv;
	val_conv.inner = (void*)(val & (~1));
	val_conv.is_owned = (val & 1) || (val == 0);
	val_conv = ChannelPublicKeys_clone(&val_conv);
	CounterpartyChannelTransactionParameters_set_pubkeys(&this_ptr_conv, val_conv);
}

JNIEXPORT int16_t JNICALL Java_org_ldk_impl_bindings_CounterpartyChannelTransactionParameters_1get_1selected_1contest_1delay(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKCounterpartyChannelTransactionParameters this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int16_t ret_val = CounterpartyChannelTransactionParameters_get_selected_contest_delay(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CounterpartyChannelTransactionParameters_1set_1selected_1contest_1delay(JNIEnv *env, jclass clz, int64_t this_ptr, int16_t val) {
	LDKCounterpartyChannelTransactionParameters this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	CounterpartyChannelTransactionParameters_set_selected_contest_delay(&this_ptr_conv, val);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CounterpartyChannelTransactionParameters_1new(JNIEnv *env, jclass clz, int64_t pubkeys_arg, int16_t selected_contest_delay_arg) {
	LDKChannelPublicKeys pubkeys_arg_conv;
	pubkeys_arg_conv.inner = (void*)(pubkeys_arg & (~1));
	pubkeys_arg_conv.is_owned = (pubkeys_arg & 1) || (pubkeys_arg == 0);
	pubkeys_arg_conv = ChannelPublicKeys_clone(&pubkeys_arg_conv);
	LDKCounterpartyChannelTransactionParameters ret_var = CounterpartyChannelTransactionParameters_new(pubkeys_arg_conv, selected_contest_delay_arg);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CounterpartyChannelTransactionParameters_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCounterpartyChannelTransactionParameters orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKCounterpartyChannelTransactionParameters ret_var = CounterpartyChannelTransactionParameters_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_ChannelTransactionParameters_1is_1populated(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKChannelTransactionParameters this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	jboolean ret_val = ChannelTransactionParameters_is_populated(&this_arg_conv);
	return ret_val;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelTransactionParameters_1as_1holder_1broadcastable(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKChannelTransactionParameters this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKDirectedChannelTransactionParameters ret_var = ChannelTransactionParameters_as_holder_broadcastable(&this_arg_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelTransactionParameters_1as_1counterparty_1broadcastable(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKChannelTransactionParameters this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKDirectedChannelTransactionParameters ret_var = ChannelTransactionParameters_as_counterparty_broadcastable(&this_arg_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_CounterpartyChannelTransactionParameters_1write(JNIEnv *env, jclass clz, int64_t obj) {
	LDKCounterpartyChannelTransactionParameters obj_conv;
	obj_conv.inner = (void*)(obj & (~1));
	obj_conv.is_owned = false;
	LDKCVec_u8Z ret_var = CounterpartyChannelTransactionParameters_write(&obj_conv);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	CVec_u8Z_free(ret_var);
	return ret_arr;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CounterpartyChannelTransactionParameters_1read(JNIEnv *env, jclass clz, int8_tArray ser) {
	LDKu8slice ser_ref;
	ser_ref.datalen = (*env)->GetArrayLength(env, ser);
	ser_ref.data = (*env)->GetByteArrayElements (env, ser, NULL);
	LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ), "LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ");
	*ret_conv = CounterpartyChannelTransactionParameters_read(ser_ref);
	(*env)->ReleaseByteArrayElements(env, ser, (int8_t*)ser_ref.data, 0);
	return (uint64_t)ret_conv;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_ChannelTransactionParameters_1write(JNIEnv *env, jclass clz, int64_t obj) {
	LDKChannelTransactionParameters obj_conv;
	obj_conv.inner = (void*)(obj & (~1));
	obj_conv.is_owned = false;
	LDKCVec_u8Z ret_var = ChannelTransactionParameters_write(&obj_conv);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	CVec_u8Z_free(ret_var);
	return ret_arr;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelTransactionParameters_1read(JNIEnv *env, jclass clz, int8_tArray ser) {
	LDKu8slice ser_ref;
	ser_ref.datalen = (*env)->GetArrayLength(env, ser);
	ser_ref.data = (*env)->GetByteArrayElements (env, ser, NULL);
	LDKCResult_ChannelTransactionParametersDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_ChannelTransactionParametersDecodeErrorZ), "LDKCResult_ChannelTransactionParametersDecodeErrorZ");
	*ret_conv = ChannelTransactionParameters_read(ser_ref);
	(*env)->ReleaseByteArrayElements(env, ser, (int8_t*)ser_ref.data, 0);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_DirectedChannelTransactionParameters_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKDirectedChannelTransactionParameters this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	DirectedChannelTransactionParameters_free(this_obj_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_DirectedChannelTransactionParameters_1broadcaster_1pubkeys(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKDirectedChannelTransactionParameters this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKChannelPublicKeys ret_var = DirectedChannelTransactionParameters_broadcaster_pubkeys(&this_arg_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_DirectedChannelTransactionParameters_1countersignatory_1pubkeys(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKDirectedChannelTransactionParameters this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKChannelPublicKeys ret_var = DirectedChannelTransactionParameters_countersignatory_pubkeys(&this_arg_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int16_t JNICALL Java_org_ldk_impl_bindings_DirectedChannelTransactionParameters_1contest_1delay(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKDirectedChannelTransactionParameters this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	int16_t ret_val = DirectedChannelTransactionParameters_contest_delay(&this_arg_conv);
	return ret_val;
}

JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_DirectedChannelTransactionParameters_1is_1outbound(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKDirectedChannelTransactionParameters this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	jboolean ret_val = DirectedChannelTransactionParameters_is_outbound(&this_arg_conv);
	return ret_val;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_DirectedChannelTransactionParameters_1funding_1outpoint(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKDirectedChannelTransactionParameters this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKOutPoint ret_var = DirectedChannelTransactionParameters_funding_outpoint(&this_arg_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_HolderCommitmentTransaction_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKHolderCommitmentTransaction this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	HolderCommitmentTransaction_free(this_obj_conv);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_HolderCommitmentTransaction_1get_1counterparty_1sig(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKHolderCommitmentTransaction this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 64);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 64, HolderCommitmentTransaction_get_counterparty_sig(&this_ptr_conv).compact_form);
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_HolderCommitmentTransaction_1set_1counterparty_1sig(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKHolderCommitmentTransaction this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKSignature val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 64);
	(*env)->GetByteArrayRegion(env, val, 0, 64, val_ref.compact_form);
	HolderCommitmentTransaction_set_counterparty_sig(&this_ptr_conv, val_ref);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_HolderCommitmentTransaction_1set_1counterparty_1htlc_1sigs(JNIEnv *env, jclass clz, int64_t this_ptr, jobjectArray val) {
	LDKHolderCommitmentTransaction this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKCVec_SignatureZ val_constr;
	val_constr.datalen = (*env)->GetArrayLength(env, val);
	if (val_constr.datalen > 0)
		val_constr.data = MALLOC(val_constr.datalen * sizeof(LDKSignature), "LDKCVec_SignatureZ Elements");
	else
		val_constr.data = NULL;
	for (size_t i = 0; i < val_constr.datalen; i++) {
		int8_tArray val_conv_8 = (*env)->GetObjectArrayElement(env, val, i);
		LDKSignature val_conv_8_ref;
		CHECK((*env)->GetArrayLength(env, val_conv_8) == 64);
		(*env)->GetByteArrayRegion(env, val_conv_8, 0, 64, val_conv_8_ref.compact_form);
		val_constr.data[i] = val_conv_8_ref;
	}
	HolderCommitmentTransaction_set_counterparty_htlc_sigs(&this_ptr_conv, val_constr);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_HolderCommitmentTransaction_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKHolderCommitmentTransaction orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKHolderCommitmentTransaction ret_var = HolderCommitmentTransaction_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_HolderCommitmentTransaction_1write(JNIEnv *env, jclass clz, int64_t obj) {
	LDKHolderCommitmentTransaction obj_conv;
	obj_conv.inner = (void*)(obj & (~1));
	obj_conv.is_owned = false;
	LDKCVec_u8Z ret_var = HolderCommitmentTransaction_write(&obj_conv);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	CVec_u8Z_free(ret_var);
	return ret_arr;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_HolderCommitmentTransaction_1read(JNIEnv *env, jclass clz, int8_tArray ser) {
	LDKu8slice ser_ref;
	ser_ref.datalen = (*env)->GetArrayLength(env, ser);
	ser_ref.data = (*env)->GetByteArrayElements (env, ser, NULL);
	LDKCResult_HolderCommitmentTransactionDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_HolderCommitmentTransactionDecodeErrorZ), "LDKCResult_HolderCommitmentTransactionDecodeErrorZ");
	*ret_conv = HolderCommitmentTransaction_read(ser_ref);
	(*env)->ReleaseByteArrayElements(env, ser, (int8_t*)ser_ref.data, 0);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_HolderCommitmentTransaction_1new(JNIEnv *env, jclass clz, int64_t commitment_tx, int8_tArray counterparty_sig, jobjectArray counterparty_htlc_sigs, int8_tArray holder_funding_key, int8_tArray counterparty_funding_key) {
	LDKCommitmentTransaction commitment_tx_conv;
	commitment_tx_conv.inner = (void*)(commitment_tx & (~1));
	commitment_tx_conv.is_owned = (commitment_tx & 1) || (commitment_tx == 0);
	commitment_tx_conv = CommitmentTransaction_clone(&commitment_tx_conv);
	LDKSignature counterparty_sig_ref;
	CHECK((*env)->GetArrayLength(env, counterparty_sig) == 64);
	(*env)->GetByteArrayRegion(env, counterparty_sig, 0, 64, counterparty_sig_ref.compact_form);
	LDKCVec_SignatureZ counterparty_htlc_sigs_constr;
	counterparty_htlc_sigs_constr.datalen = (*env)->GetArrayLength(env, counterparty_htlc_sigs);
	if (counterparty_htlc_sigs_constr.datalen > 0)
		counterparty_htlc_sigs_constr.data = MALLOC(counterparty_htlc_sigs_constr.datalen * sizeof(LDKSignature), "LDKCVec_SignatureZ Elements");
	else
		counterparty_htlc_sigs_constr.data = NULL;
	for (size_t i = 0; i < counterparty_htlc_sigs_constr.datalen; i++) {
		int8_tArray counterparty_htlc_sigs_conv_8 = (*env)->GetObjectArrayElement(env, counterparty_htlc_sigs, i);
		LDKSignature counterparty_htlc_sigs_conv_8_ref;
		CHECK((*env)->GetArrayLength(env, counterparty_htlc_sigs_conv_8) == 64);
		(*env)->GetByteArrayRegion(env, counterparty_htlc_sigs_conv_8, 0, 64, counterparty_htlc_sigs_conv_8_ref.compact_form);
		counterparty_htlc_sigs_constr.data[i] = counterparty_htlc_sigs_conv_8_ref;
	}
	LDKPublicKey holder_funding_key_ref;
	CHECK((*env)->GetArrayLength(env, holder_funding_key) == 33);
	(*env)->GetByteArrayRegion(env, holder_funding_key, 0, 33, holder_funding_key_ref.compressed_form);
	LDKPublicKey counterparty_funding_key_ref;
	CHECK((*env)->GetArrayLength(env, counterparty_funding_key) == 33);
	(*env)->GetByteArrayRegion(env, counterparty_funding_key, 0, 33, counterparty_funding_key_ref.compressed_form);
	LDKHolderCommitmentTransaction ret_var = HolderCommitmentTransaction_new(commitment_tx_conv, counterparty_sig_ref, counterparty_htlc_sigs_constr, holder_funding_key_ref, counterparty_funding_key_ref);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_BuiltCommitmentTransaction_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKBuiltCommitmentTransaction this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	BuiltCommitmentTransaction_free(this_obj_conv);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_BuiltCommitmentTransaction_1get_1transaction(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKBuiltCommitmentTransaction this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKTransaction ret_var = BuiltCommitmentTransaction_get_transaction(&this_ptr_conv);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	Transaction_free(ret_var);
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_BuiltCommitmentTransaction_1set_1transaction(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKBuiltCommitmentTransaction this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKTransaction val_ref;
	val_ref.datalen = (*env)->GetArrayLength(env, val);
	val_ref.data = MALLOC(val_ref.datalen, "LDKTransaction Bytes");
	(*env)->GetByteArrayRegion(env, val, 0, val_ref.datalen, val_ref.data);
	val_ref.data_is_owned = true;
	BuiltCommitmentTransaction_set_transaction(&this_ptr_conv, val_ref);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_BuiltCommitmentTransaction_1get_1txid(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKBuiltCommitmentTransaction this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 32);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 32, *BuiltCommitmentTransaction_get_txid(&this_ptr_conv));
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_BuiltCommitmentTransaction_1set_1txid(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKBuiltCommitmentTransaction this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKThirtyTwoBytes val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 32);
	(*env)->GetByteArrayRegion(env, val, 0, 32, val_ref.data);
	BuiltCommitmentTransaction_set_txid(&this_ptr_conv, val_ref);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_BuiltCommitmentTransaction_1new(JNIEnv *env, jclass clz, int8_tArray transaction_arg, int8_tArray txid_arg) {
	LDKTransaction transaction_arg_ref;
	transaction_arg_ref.datalen = (*env)->GetArrayLength(env, transaction_arg);
	transaction_arg_ref.data = MALLOC(transaction_arg_ref.datalen, "LDKTransaction Bytes");
	(*env)->GetByteArrayRegion(env, transaction_arg, 0, transaction_arg_ref.datalen, transaction_arg_ref.data);
	transaction_arg_ref.data_is_owned = true;
	LDKThirtyTwoBytes txid_arg_ref;
	CHECK((*env)->GetArrayLength(env, txid_arg) == 32);
	(*env)->GetByteArrayRegion(env, txid_arg, 0, 32, txid_arg_ref.data);
	LDKBuiltCommitmentTransaction ret_var = BuiltCommitmentTransaction_new(transaction_arg_ref, txid_arg_ref);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_BuiltCommitmentTransaction_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKBuiltCommitmentTransaction orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKBuiltCommitmentTransaction ret_var = BuiltCommitmentTransaction_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_BuiltCommitmentTransaction_1write(JNIEnv *env, jclass clz, int64_t obj) {
	LDKBuiltCommitmentTransaction obj_conv;
	obj_conv.inner = (void*)(obj & (~1));
	obj_conv.is_owned = false;
	LDKCVec_u8Z ret_var = BuiltCommitmentTransaction_write(&obj_conv);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	CVec_u8Z_free(ret_var);
	return ret_arr;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_BuiltCommitmentTransaction_1read(JNIEnv *env, jclass clz, int8_tArray ser) {
	LDKu8slice ser_ref;
	ser_ref.datalen = (*env)->GetArrayLength(env, ser);
	ser_ref.data = (*env)->GetByteArrayElements (env, ser, NULL);
	LDKCResult_BuiltCommitmentTransactionDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_BuiltCommitmentTransactionDecodeErrorZ), "LDKCResult_BuiltCommitmentTransactionDecodeErrorZ");
	*ret_conv = BuiltCommitmentTransaction_read(ser_ref);
	(*env)->ReleaseByteArrayElements(env, ser, (int8_t*)ser_ref.data, 0);
	return (uint64_t)ret_conv;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_BuiltCommitmentTransaction_1get_1sighash_1all(JNIEnv *env, jclass clz, int64_t this_arg, int8_tArray funding_redeemscript, int64_t channel_value_satoshis) {
	LDKBuiltCommitmentTransaction this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKu8slice funding_redeemscript_ref;
	funding_redeemscript_ref.datalen = (*env)->GetArrayLength(env, funding_redeemscript);
	funding_redeemscript_ref.data = (*env)->GetByteArrayElements (env, funding_redeemscript, NULL);
	int8_tArray ret_arr = (*env)->NewByteArray(env, 32);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 32, BuiltCommitmentTransaction_get_sighash_all(&this_arg_conv, funding_redeemscript_ref, channel_value_satoshis).data);
	(*env)->ReleaseByteArrayElements(env, funding_redeemscript, (int8_t*)funding_redeemscript_ref.data, 0);
	return ret_arr;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_BuiltCommitmentTransaction_1sign(JNIEnv *env, jclass clz, int64_t this_arg, int8_tArray funding_key, int8_tArray funding_redeemscript, int64_t channel_value_satoshis) {
	LDKBuiltCommitmentTransaction this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	unsigned char funding_key_arr[32];
	CHECK((*env)->GetArrayLength(env, funding_key) == 32);
	(*env)->GetByteArrayRegion(env, funding_key, 0, 32, funding_key_arr);
	unsigned char (*funding_key_ref)[32] = &funding_key_arr;
	LDKu8slice funding_redeemscript_ref;
	funding_redeemscript_ref.datalen = (*env)->GetArrayLength(env, funding_redeemscript);
	funding_redeemscript_ref.data = (*env)->GetByteArrayElements (env, funding_redeemscript, NULL);
	int8_tArray ret_arr = (*env)->NewByteArray(env, 64);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 64, BuiltCommitmentTransaction_sign(&this_arg_conv, funding_key_ref, funding_redeemscript_ref, channel_value_satoshis).compact_form);
	(*env)->ReleaseByteArrayElements(env, funding_redeemscript, (int8_t*)funding_redeemscript_ref.data, 0);
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ClosingTransaction_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKClosingTransaction this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	ClosingTransaction_free(this_obj_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ClosingTransaction_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKClosingTransaction orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKClosingTransaction ret_var = ClosingTransaction_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ClosingTransaction_1hash(JNIEnv *env, jclass clz, int64_t o) {
	LDKClosingTransaction o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = false;
	int64_t ret_val = ClosingTransaction_hash(&o_conv);
	return ret_val;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ClosingTransaction_1new(JNIEnv *env, jclass clz, int64_t to_holder_value_sat, int64_t to_counterparty_value_sat, int8_tArray to_holder_script, int8_tArray to_counterparty_script, int64_t funding_outpoint) {
	LDKCVec_u8Z to_holder_script_ref;
	to_holder_script_ref.datalen = (*env)->GetArrayLength(env, to_holder_script);
	to_holder_script_ref.data = MALLOC(to_holder_script_ref.datalen, "LDKCVec_u8Z Bytes");
	(*env)->GetByteArrayRegion(env, to_holder_script, 0, to_holder_script_ref.datalen, to_holder_script_ref.data);
	LDKCVec_u8Z to_counterparty_script_ref;
	to_counterparty_script_ref.datalen = (*env)->GetArrayLength(env, to_counterparty_script);
	to_counterparty_script_ref.data = MALLOC(to_counterparty_script_ref.datalen, "LDKCVec_u8Z Bytes");
	(*env)->GetByteArrayRegion(env, to_counterparty_script, 0, to_counterparty_script_ref.datalen, to_counterparty_script_ref.data);
	LDKOutPoint funding_outpoint_conv;
	funding_outpoint_conv.inner = (void*)(funding_outpoint & (~1));
	funding_outpoint_conv.is_owned = (funding_outpoint & 1) || (funding_outpoint == 0);
	funding_outpoint_conv = OutPoint_clone(&funding_outpoint_conv);
	LDKClosingTransaction ret_var = ClosingTransaction_new(to_holder_value_sat, to_counterparty_value_sat, to_holder_script_ref, to_counterparty_script_ref, funding_outpoint_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ClosingTransaction_1trust(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKClosingTransaction this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKTrustedClosingTransaction ret_var = ClosingTransaction_trust(&this_arg_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ClosingTransaction_1verify(JNIEnv *env, jclass clz, int64_t this_arg, int64_t funding_outpoint) {
	LDKClosingTransaction this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKOutPoint funding_outpoint_conv;
	funding_outpoint_conv.inner = (void*)(funding_outpoint & (~1));
	funding_outpoint_conv.is_owned = (funding_outpoint & 1) || (funding_outpoint == 0);
	funding_outpoint_conv = OutPoint_clone(&funding_outpoint_conv);
	LDKCResult_TrustedClosingTransactionNoneZ* ret_conv = MALLOC(sizeof(LDKCResult_TrustedClosingTransactionNoneZ), "LDKCResult_TrustedClosingTransactionNoneZ");
	*ret_conv = ClosingTransaction_verify(&this_arg_conv, funding_outpoint_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ClosingTransaction_1to_1holder_1value_1sat(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKClosingTransaction this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	int64_t ret_val = ClosingTransaction_to_holder_value_sat(&this_arg_conv);
	return ret_val;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ClosingTransaction_1to_1counterparty_1value_1sat(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKClosingTransaction this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	int64_t ret_val = ClosingTransaction_to_counterparty_value_sat(&this_arg_conv);
	return ret_val;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_ClosingTransaction_1to_1holder_1script(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKClosingTransaction this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKu8slice ret_var = ClosingTransaction_to_holder_script(&this_arg_conv);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	return ret_arr;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_ClosingTransaction_1to_1counterparty_1script(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKClosingTransaction this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKu8slice ret_var = ClosingTransaction_to_counterparty_script(&this_arg_conv);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_TrustedClosingTransaction_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKTrustedClosingTransaction this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	TrustedClosingTransaction_free(this_obj_conv);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_TrustedClosingTransaction_1built_1transaction(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKTrustedClosingTransaction this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKTransaction ret_var = TrustedClosingTransaction_built_transaction(&this_arg_conv);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	Transaction_free(ret_var);
	return ret_arr;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_TrustedClosingTransaction_1get_1sighash_1all(JNIEnv *env, jclass clz, int64_t this_arg, int8_tArray funding_redeemscript, int64_t channel_value_satoshis) {
	LDKTrustedClosingTransaction this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKu8slice funding_redeemscript_ref;
	funding_redeemscript_ref.datalen = (*env)->GetArrayLength(env, funding_redeemscript);
	funding_redeemscript_ref.data = (*env)->GetByteArrayElements (env, funding_redeemscript, NULL);
	int8_tArray ret_arr = (*env)->NewByteArray(env, 32);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 32, TrustedClosingTransaction_get_sighash_all(&this_arg_conv, funding_redeemscript_ref, channel_value_satoshis).data);
	(*env)->ReleaseByteArrayElements(env, funding_redeemscript, (int8_t*)funding_redeemscript_ref.data, 0);
	return ret_arr;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_TrustedClosingTransaction_1sign(JNIEnv *env, jclass clz, int64_t this_arg, int8_tArray funding_key, int8_tArray funding_redeemscript, int64_t channel_value_satoshis) {
	LDKTrustedClosingTransaction this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	unsigned char funding_key_arr[32];
	CHECK((*env)->GetArrayLength(env, funding_key) == 32);
	(*env)->GetByteArrayRegion(env, funding_key, 0, 32, funding_key_arr);
	unsigned char (*funding_key_ref)[32] = &funding_key_arr;
	LDKu8slice funding_redeemscript_ref;
	funding_redeemscript_ref.datalen = (*env)->GetArrayLength(env, funding_redeemscript);
	funding_redeemscript_ref.data = (*env)->GetByteArrayElements (env, funding_redeemscript, NULL);
	int8_tArray ret_arr = (*env)->NewByteArray(env, 64);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 64, TrustedClosingTransaction_sign(&this_arg_conv, funding_key_ref, funding_redeemscript_ref, channel_value_satoshis).compact_form);
	(*env)->ReleaseByteArrayElements(env, funding_redeemscript, (int8_t*)funding_redeemscript_ref.data, 0);
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CommitmentTransaction_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKCommitmentTransaction this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	CommitmentTransaction_free(this_obj_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CommitmentTransaction_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCommitmentTransaction orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKCommitmentTransaction ret_var = CommitmentTransaction_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_CommitmentTransaction_1write(JNIEnv *env, jclass clz, int64_t obj) {
	LDKCommitmentTransaction obj_conv;
	obj_conv.inner = (void*)(obj & (~1));
	obj_conv.is_owned = false;
	LDKCVec_u8Z ret_var = CommitmentTransaction_write(&obj_conv);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	CVec_u8Z_free(ret_var);
	return ret_arr;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CommitmentTransaction_1read(JNIEnv *env, jclass clz, int8_tArray ser) {
	LDKu8slice ser_ref;
	ser_ref.datalen = (*env)->GetArrayLength(env, ser);
	ser_ref.data = (*env)->GetByteArrayElements (env, ser, NULL);
	LDKCResult_CommitmentTransactionDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_CommitmentTransactionDecodeErrorZ), "LDKCResult_CommitmentTransactionDecodeErrorZ");
	*ret_conv = CommitmentTransaction_read(ser_ref);
	(*env)->ReleaseByteArrayElements(env, ser, (int8_t*)ser_ref.data, 0);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CommitmentTransaction_1commitment_1number(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKCommitmentTransaction this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	int64_t ret_val = CommitmentTransaction_commitment_number(&this_arg_conv);
	return ret_val;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CommitmentTransaction_1to_1broadcaster_1value_1sat(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKCommitmentTransaction this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	int64_t ret_val = CommitmentTransaction_to_broadcaster_value_sat(&this_arg_conv);
	return ret_val;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CommitmentTransaction_1to_1countersignatory_1value_1sat(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKCommitmentTransaction this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	int64_t ret_val = CommitmentTransaction_to_countersignatory_value_sat(&this_arg_conv);
	return ret_val;
}

JNIEXPORT int32_t JNICALL Java_org_ldk_impl_bindings_CommitmentTransaction_1feerate_1per_1kw(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKCommitmentTransaction this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	int32_t ret_val = CommitmentTransaction_feerate_per_kw(&this_arg_conv);
	return ret_val;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CommitmentTransaction_1trust(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKCommitmentTransaction this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKTrustedCommitmentTransaction ret_var = CommitmentTransaction_trust(&this_arg_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_CommitmentTransaction_1verify(JNIEnv *env, jclass clz, int64_t this_arg, int64_t channel_parameters, int64_t broadcaster_keys, int64_t countersignatory_keys) {
	LDKCommitmentTransaction this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKDirectedChannelTransactionParameters channel_parameters_conv;
	channel_parameters_conv.inner = (void*)(channel_parameters & (~1));
	channel_parameters_conv.is_owned = false;
	LDKChannelPublicKeys broadcaster_keys_conv;
	broadcaster_keys_conv.inner = (void*)(broadcaster_keys & (~1));
	broadcaster_keys_conv.is_owned = false;
	LDKChannelPublicKeys countersignatory_keys_conv;
	countersignatory_keys_conv.inner = (void*)(countersignatory_keys & (~1));
	countersignatory_keys_conv.is_owned = false;
	LDKCResult_TrustedCommitmentTransactionNoneZ* ret_conv = MALLOC(sizeof(LDKCResult_TrustedCommitmentTransactionNoneZ), "LDKCResult_TrustedCommitmentTransactionNoneZ");
	*ret_conv = CommitmentTransaction_verify(&this_arg_conv, &channel_parameters_conv, &broadcaster_keys_conv, &countersignatory_keys_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_TrustedCommitmentTransaction_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKTrustedCommitmentTransaction this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	TrustedCommitmentTransaction_free(this_obj_conv);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_TrustedCommitmentTransaction_1txid(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKTrustedCommitmentTransaction this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 32);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 32, TrustedCommitmentTransaction_txid(&this_arg_conv).data);
	return ret_arr;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_TrustedCommitmentTransaction_1built_1transaction(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKTrustedCommitmentTransaction this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKBuiltCommitmentTransaction ret_var = TrustedCommitmentTransaction_built_transaction(&this_arg_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_TrustedCommitmentTransaction_1keys(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKTrustedCommitmentTransaction this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKTxCreationKeys ret_var = TrustedCommitmentTransaction_keys(&this_arg_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_TrustedCommitmentTransaction_1get_1htlc_1sigs(JNIEnv *env, jclass clz, int64_t this_arg, int8_tArray htlc_base_key, int64_t channel_parameters) {
	LDKTrustedCommitmentTransaction this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	unsigned char htlc_base_key_arr[32];
	CHECK((*env)->GetArrayLength(env, htlc_base_key) == 32);
	(*env)->GetByteArrayRegion(env, htlc_base_key, 0, 32, htlc_base_key_arr);
	unsigned char (*htlc_base_key_ref)[32] = &htlc_base_key_arr;
	LDKDirectedChannelTransactionParameters channel_parameters_conv;
	channel_parameters_conv.inner = (void*)(channel_parameters & (~1));
	channel_parameters_conv.is_owned = false;
	LDKCResult_CVec_SignatureZNoneZ* ret_conv = MALLOC(sizeof(LDKCResult_CVec_SignatureZNoneZ), "LDKCResult_CVec_SignatureZNoneZ");
	*ret_conv = TrustedCommitmentTransaction_get_htlc_sigs(&this_arg_conv, htlc_base_key_ref, &channel_parameters_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_get_1commitment_1transaction_1number_1obscure_1factor(JNIEnv *env, jclass clz, int8_tArray broadcaster_payment_basepoint, int8_tArray countersignatory_payment_basepoint, jboolean outbound_from_broadcaster) {
	LDKPublicKey broadcaster_payment_basepoint_ref;
	CHECK((*env)->GetArrayLength(env, broadcaster_payment_basepoint) == 33);
	(*env)->GetByteArrayRegion(env, broadcaster_payment_basepoint, 0, 33, broadcaster_payment_basepoint_ref.compressed_form);
	LDKPublicKey countersignatory_payment_basepoint_ref;
	CHECK((*env)->GetArrayLength(env, countersignatory_payment_basepoint) == 33);
	(*env)->GetByteArrayRegion(env, countersignatory_payment_basepoint, 0, 33, countersignatory_payment_basepoint_ref.compressed_form);
	int64_t ret_val = get_commitment_transaction_number_obscure_factor(broadcaster_payment_basepoint_ref, countersignatory_payment_basepoint_ref, outbound_from_broadcaster);
	return ret_val;
}

JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_InitFeatures_1eq(JNIEnv *env, jclass clz, int64_t a, int64_t b) {
	LDKInitFeatures a_conv;
	a_conv.inner = (void*)(a & (~1));
	a_conv.is_owned = false;
	LDKInitFeatures b_conv;
	b_conv.inner = (void*)(b & (~1));
	b_conv.is_owned = false;
	jboolean ret_val = InitFeatures_eq(&a_conv, &b_conv);
	return ret_val;
}

JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_NodeFeatures_1eq(JNIEnv *env, jclass clz, int64_t a, int64_t b) {
	LDKNodeFeatures a_conv;
	a_conv.inner = (void*)(a & (~1));
	a_conv.is_owned = false;
	LDKNodeFeatures b_conv;
	b_conv.inner = (void*)(b & (~1));
	b_conv.is_owned = false;
	jboolean ret_val = NodeFeatures_eq(&a_conv, &b_conv);
	return ret_val;
}

JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_ChannelFeatures_1eq(JNIEnv *env, jclass clz, int64_t a, int64_t b) {
	LDKChannelFeatures a_conv;
	a_conv.inner = (void*)(a & (~1));
	a_conv.is_owned = false;
	LDKChannelFeatures b_conv;
	b_conv.inner = (void*)(b & (~1));
	b_conv.is_owned = false;
	jboolean ret_val = ChannelFeatures_eq(&a_conv, &b_conv);
	return ret_val;
}

JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_InvoiceFeatures_1eq(JNIEnv *env, jclass clz, int64_t a, int64_t b) {
	LDKInvoiceFeatures a_conv;
	a_conv.inner = (void*)(a & (~1));
	a_conv.is_owned = false;
	LDKInvoiceFeatures b_conv;
	b_conv.inner = (void*)(b & (~1));
	b_conv.is_owned = false;
	jboolean ret_val = InvoiceFeatures_eq(&a_conv, &b_conv);
	return ret_val;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_InitFeatures_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKInitFeatures orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKInitFeatures ret_var = InitFeatures_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_NodeFeatures_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKNodeFeatures orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKNodeFeatures ret_var = NodeFeatures_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelFeatures_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKChannelFeatures orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKChannelFeatures ret_var = ChannelFeatures_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_InvoiceFeatures_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKInvoiceFeatures orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKInvoiceFeatures ret_var = InvoiceFeatures_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_InitFeatures_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKInitFeatures this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	InitFeatures_free(this_obj_conv);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_NodeFeatures_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKNodeFeatures this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	NodeFeatures_free(this_obj_conv);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelFeatures_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKChannelFeatures this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	ChannelFeatures_free(this_obj_conv);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_InvoiceFeatures_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKInvoiceFeatures this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	InvoiceFeatures_free(this_obj_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_InitFeatures_1empty(JNIEnv *env, jclass clz) {
	LDKInitFeatures ret_var = InitFeatures_empty();
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_InitFeatures_1known(JNIEnv *env, jclass clz) {
	LDKInitFeatures ret_var = InitFeatures_known();
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_InitFeatures_1requires_1unknown_1bits(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKInitFeatures this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	jboolean ret_val = InitFeatures_requires_unknown_bits(&this_arg_conv);
	return ret_val;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_NodeFeatures_1empty(JNIEnv *env, jclass clz) {
	LDKNodeFeatures ret_var = NodeFeatures_empty();
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_NodeFeatures_1known(JNIEnv *env, jclass clz) {
	LDKNodeFeatures ret_var = NodeFeatures_known();
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_NodeFeatures_1requires_1unknown_1bits(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKNodeFeatures this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	jboolean ret_val = NodeFeatures_requires_unknown_bits(&this_arg_conv);
	return ret_val;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelFeatures_1empty(JNIEnv *env, jclass clz) {
	LDKChannelFeatures ret_var = ChannelFeatures_empty();
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelFeatures_1known(JNIEnv *env, jclass clz) {
	LDKChannelFeatures ret_var = ChannelFeatures_known();
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_ChannelFeatures_1requires_1unknown_1bits(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKChannelFeatures this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	jboolean ret_val = ChannelFeatures_requires_unknown_bits(&this_arg_conv);
	return ret_val;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_InvoiceFeatures_1empty(JNIEnv *env, jclass clz) {
	LDKInvoiceFeatures ret_var = InvoiceFeatures_empty();
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_InvoiceFeatures_1known(JNIEnv *env, jclass clz) {
	LDKInvoiceFeatures ret_var = InvoiceFeatures_known();
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_InvoiceFeatures_1requires_1unknown_1bits(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKInvoiceFeatures this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	jboolean ret_val = InvoiceFeatures_requires_unknown_bits(&this_arg_conv);
	return ret_val;
}

JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_InitFeatures_1supports_1payment_1secret(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKInitFeatures this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	jboolean ret_val = InitFeatures_supports_payment_secret(&this_arg_conv);
	return ret_val;
}

JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_NodeFeatures_1supports_1payment_1secret(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKNodeFeatures this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	jboolean ret_val = NodeFeatures_supports_payment_secret(&this_arg_conv);
	return ret_val;
}

JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_InvoiceFeatures_1supports_1payment_1secret(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKInvoiceFeatures this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	jboolean ret_val = InvoiceFeatures_supports_payment_secret(&this_arg_conv);
	return ret_val;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_InitFeatures_1write(JNIEnv *env, jclass clz, int64_t obj) {
	LDKInitFeatures obj_conv;
	obj_conv.inner = (void*)(obj & (~1));
	obj_conv.is_owned = false;
	LDKCVec_u8Z ret_var = InitFeatures_write(&obj_conv);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	CVec_u8Z_free(ret_var);
	return ret_arr;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_NodeFeatures_1write(JNIEnv *env, jclass clz, int64_t obj) {
	LDKNodeFeatures obj_conv;
	obj_conv.inner = (void*)(obj & (~1));
	obj_conv.is_owned = false;
	LDKCVec_u8Z ret_var = NodeFeatures_write(&obj_conv);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	CVec_u8Z_free(ret_var);
	return ret_arr;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_ChannelFeatures_1write(JNIEnv *env, jclass clz, int64_t obj) {
	LDKChannelFeatures obj_conv;
	obj_conv.inner = (void*)(obj & (~1));
	obj_conv.is_owned = false;
	LDKCVec_u8Z ret_var = ChannelFeatures_write(&obj_conv);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	CVec_u8Z_free(ret_var);
	return ret_arr;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_InvoiceFeatures_1write(JNIEnv *env, jclass clz, int64_t obj) {
	LDKInvoiceFeatures obj_conv;
	obj_conv.inner = (void*)(obj & (~1));
	obj_conv.is_owned = false;
	LDKCVec_u8Z ret_var = InvoiceFeatures_write(&obj_conv);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	CVec_u8Z_free(ret_var);
	return ret_arr;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_InitFeatures_1read(JNIEnv *env, jclass clz, int8_tArray ser) {
	LDKu8slice ser_ref;
	ser_ref.datalen = (*env)->GetArrayLength(env, ser);
	ser_ref.data = (*env)->GetByteArrayElements (env, ser, NULL);
	LDKCResult_InitFeaturesDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_InitFeaturesDecodeErrorZ), "LDKCResult_InitFeaturesDecodeErrorZ");
	*ret_conv = InitFeatures_read(ser_ref);
	(*env)->ReleaseByteArrayElements(env, ser, (int8_t*)ser_ref.data, 0);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_NodeFeatures_1read(JNIEnv *env, jclass clz, int8_tArray ser) {
	LDKu8slice ser_ref;
	ser_ref.datalen = (*env)->GetArrayLength(env, ser);
	ser_ref.data = (*env)->GetByteArrayElements (env, ser, NULL);
	LDKCResult_NodeFeaturesDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_NodeFeaturesDecodeErrorZ), "LDKCResult_NodeFeaturesDecodeErrorZ");
	*ret_conv = NodeFeatures_read(ser_ref);
	(*env)->ReleaseByteArrayElements(env, ser, (int8_t*)ser_ref.data, 0);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelFeatures_1read(JNIEnv *env, jclass clz, int8_tArray ser) {
	LDKu8slice ser_ref;
	ser_ref.datalen = (*env)->GetArrayLength(env, ser);
	ser_ref.data = (*env)->GetByteArrayElements (env, ser, NULL);
	LDKCResult_ChannelFeaturesDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_ChannelFeaturesDecodeErrorZ), "LDKCResult_ChannelFeaturesDecodeErrorZ");
	*ret_conv = ChannelFeatures_read(ser_ref);
	(*env)->ReleaseByteArrayElements(env, ser, (int8_t*)ser_ref.data, 0);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_InvoiceFeatures_1read(JNIEnv *env, jclass clz, int8_tArray ser) {
	LDKu8slice ser_ref;
	ser_ref.datalen = (*env)->GetArrayLength(env, ser);
	ser_ref.data = (*env)->GetByteArrayElements (env, ser, NULL);
	LDKCResult_InvoiceFeaturesDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_InvoiceFeaturesDecodeErrorZ), "LDKCResult_InvoiceFeaturesDecodeErrorZ");
	*ret_conv = InvoiceFeatures_read(ser_ref);
	(*env)->ReleaseByteArrayElements(env, ser, (int8_t*)ser_ref.data, 0);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ShutdownScript_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKShutdownScript this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	ShutdownScript_free(this_obj_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ShutdownScript_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKShutdownScript orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKShutdownScript ret_var = ShutdownScript_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_InvalidShutdownScript_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKInvalidShutdownScript this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	InvalidShutdownScript_free(this_obj_conv);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_InvalidShutdownScript_1get_1script(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKInvalidShutdownScript this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKu8slice ret_var = InvalidShutdownScript_get_script(&this_ptr_conv);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_InvalidShutdownScript_1set_1script(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKInvalidShutdownScript this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKCVec_u8Z val_ref;
	val_ref.datalen = (*env)->GetArrayLength(env, val);
	val_ref.data = MALLOC(val_ref.datalen, "LDKCVec_u8Z Bytes");
	(*env)->GetByteArrayRegion(env, val, 0, val_ref.datalen, val_ref.data);
	InvalidShutdownScript_set_script(&this_ptr_conv, val_ref);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_InvalidShutdownScript_1new(JNIEnv *env, jclass clz, int8_tArray script_arg) {
	LDKCVec_u8Z script_arg_ref;
	script_arg_ref.datalen = (*env)->GetArrayLength(env, script_arg);
	script_arg_ref.data = MALLOC(script_arg_ref.datalen, "LDKCVec_u8Z Bytes");
	(*env)->GetByteArrayRegion(env, script_arg, 0, script_arg_ref.datalen, script_arg_ref.data);
	LDKInvalidShutdownScript ret_var = InvalidShutdownScript_new(script_arg_ref);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_InvalidShutdownScript_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKInvalidShutdownScript orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKInvalidShutdownScript ret_var = InvalidShutdownScript_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_ShutdownScript_1write(JNIEnv *env, jclass clz, int64_t obj) {
	LDKShutdownScript obj_conv;
	obj_conv.inner = (void*)(obj & (~1));
	obj_conv.is_owned = false;
	LDKCVec_u8Z ret_var = ShutdownScript_write(&obj_conv);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	CVec_u8Z_free(ret_var);
	return ret_arr;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ShutdownScript_1read(JNIEnv *env, jclass clz, int8_tArray ser) {
	LDKu8slice ser_ref;
	ser_ref.datalen = (*env)->GetArrayLength(env, ser);
	ser_ref.data = (*env)->GetByteArrayElements (env, ser, NULL);
	LDKCResult_ShutdownScriptDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_ShutdownScriptDecodeErrorZ), "LDKCResult_ShutdownScriptDecodeErrorZ");
	*ret_conv = ShutdownScript_read(ser_ref);
	(*env)->ReleaseByteArrayElements(env, ser, (int8_t*)ser_ref.data, 0);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ShutdownScript_1new_1p2wpkh(JNIEnv *env, jclass clz, int8_tArray pubkey_hash) {
	unsigned char pubkey_hash_arr[20];
	CHECK((*env)->GetArrayLength(env, pubkey_hash) == 20);
	(*env)->GetByteArrayRegion(env, pubkey_hash, 0, 20, pubkey_hash_arr);
	unsigned char (*pubkey_hash_ref)[20] = &pubkey_hash_arr;
	LDKShutdownScript ret_var = ShutdownScript_new_p2wpkh(pubkey_hash_ref);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ShutdownScript_1new_1p2wsh(JNIEnv *env, jclass clz, int8_tArray script_hash) {
	unsigned char script_hash_arr[32];
	CHECK((*env)->GetArrayLength(env, script_hash) == 32);
	(*env)->GetByteArrayRegion(env, script_hash, 0, 32, script_hash_arr);
	unsigned char (*script_hash_ref)[32] = &script_hash_arr;
	LDKShutdownScript ret_var = ShutdownScript_new_p2wsh(script_hash_ref);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ShutdownScript_1new_1witness_1program(JNIEnv *env, jclass clz, int8_t version, int8_tArray program) {
	LDKu8slice program_ref;
	program_ref.datalen = (*env)->GetArrayLength(env, program);
	program_ref.data = (*env)->GetByteArrayElements (env, program, NULL);
	LDKCResult_ShutdownScriptInvalidShutdownScriptZ* ret_conv = MALLOC(sizeof(LDKCResult_ShutdownScriptInvalidShutdownScriptZ), "LDKCResult_ShutdownScriptInvalidShutdownScriptZ");
	*ret_conv = ShutdownScript_new_witness_program(version, program_ref);
	(*env)->ReleaseByteArrayElements(env, program, (int8_t*)program_ref.data, 0);
	return (uint64_t)ret_conv;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_ShutdownScript_1into_1inner(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKShutdownScript this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = (this_arg & 1) || (this_arg == 0);
	this_arg_conv = ShutdownScript_clone(&this_arg_conv);
	LDKCVec_u8Z ret_var = ShutdownScript_into_inner(this_arg_conv);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	CVec_u8Z_free(ret_var);
	return ret_arr;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_ShutdownScript_1as_1legacy_1pubkey(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKShutdownScript this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 33);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 33, ShutdownScript_as_legacy_pubkey(&this_arg_conv).compressed_form);
	return ret_arr;
}

JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_ShutdownScript_1is_1compatible(JNIEnv *env, jclass clz, int64_t this_arg, int64_t features) {
	LDKShutdownScript this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKInitFeatures features_conv;
	features_conv.inner = (void*)(features & (~1));
	features_conv.is_owned = false;
	jboolean ret_val = ShutdownScript_is_compatible(&this_arg_conv, &features_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_CustomMessageReader_1free(JNIEnv *env, jclass clz, int64_t this_ptr) {
	if ((this_ptr & 1) != 0) return;
	void* this_ptr_ptr = (void*)(((uint64_t)this_ptr) & ~1);
	CHECK_ACCESS(this_ptr_ptr);
	LDKCustomMessageReader this_ptr_conv = *(LDKCustomMessageReader*)(this_ptr_ptr);
	FREE((void*)this_ptr);
	CustomMessageReader_free(this_ptr_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_Type_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	void* orig_ptr = (void*)(((uint64_t)orig) & ~1);
	if (!(orig & 1)) { CHECK_ACCESS(orig_ptr); }
	LDKType* orig_conv = (LDKType*)orig_ptr;
	LDKType* ret_ret = MALLOC(sizeof(LDKType), "LDKType");
	*ret_ret = Type_clone(orig_conv);
	return (uint64_t)ret_ret;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_Type_1free(JNIEnv *env, jclass clz, int64_t this_ptr) {
	if ((this_ptr & 1) != 0) return;
	void* this_ptr_ptr = (void*)(((uint64_t)this_ptr) & ~1);
	CHECK_ACCESS(this_ptr_ptr);
	LDKType this_ptr_conv = *(LDKType*)(this_ptr_ptr);
	FREE((void*)this_ptr);
	Type_free(this_ptr_conv);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_Score_1free(JNIEnv *env, jclass clz, int64_t this_ptr) {
	if ((this_ptr & 1) != 0) return;
	void* this_ptr_ptr = (void*)(((uint64_t)this_ptr) & ~1);
	CHECK_ACCESS(this_ptr_ptr);
	LDKScore this_ptr_conv = *(LDKScore*)(this_ptr_ptr);
	FREE((void*)this_ptr);
	Score_free(this_ptr_conv);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_LockableScore_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKLockableScore this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	LockableScore_free(this_obj_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_LockableScore_1new(JNIEnv *env, jclass clz, int64_t score) {
	void* score_ptr = (void*)(((uint64_t)score) & ~1);
	CHECK_ACCESS(score_ptr);
	LDKScore score_conv = *(LDKScore*)(score_ptr);
	if (score_conv.free == LDKScore_JCalls_free) {
		// If this_arg is a JCalls struct, then we need to increment the refcnt in it.
		LDKScore_JCalls_cloned(&score_conv);
	}
	LDKLockableScore ret_var = LockableScore_new(score_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_NodeId_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKNodeId this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	NodeId_free(this_obj_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_NodeId_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKNodeId orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKNodeId ret_var = NodeId_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_NodeId_1from_1pubkey(JNIEnv *env, jclass clz, int8_tArray pubkey) {
	LDKPublicKey pubkey_ref;
	CHECK((*env)->GetArrayLength(env, pubkey) == 33);
	(*env)->GetByteArrayRegion(env, pubkey, 0, 33, pubkey_ref.compressed_form);
	LDKNodeId ret_var = NodeId_from_pubkey(pubkey_ref);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_NodeId_1as_1slice(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKNodeId this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKu8slice ret_var = NodeId_as_slice(&this_arg_conv);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	return ret_arr;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_NodeId_1hash(JNIEnv *env, jclass clz, int64_t o) {
	LDKNodeId o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = false;
	int64_t ret_val = NodeId_hash(&o_conv);
	return ret_val;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_NodeId_1write(JNIEnv *env, jclass clz, int64_t obj) {
	LDKNodeId obj_conv;
	obj_conv.inner = (void*)(obj & (~1));
	obj_conv.is_owned = false;
	LDKCVec_u8Z ret_var = NodeId_write(&obj_conv);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	CVec_u8Z_free(ret_var);
	return ret_arr;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_NodeId_1read(JNIEnv *env, jclass clz, int8_tArray ser) {
	LDKu8slice ser_ref;
	ser_ref.datalen = (*env)->GetArrayLength(env, ser);
	ser_ref.data = (*env)->GetByteArrayElements (env, ser, NULL);
	LDKCResult_NodeIdDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_NodeIdDecodeErrorZ), "LDKCResult_NodeIdDecodeErrorZ");
	*ret_conv = NodeId_read(ser_ref);
	(*env)->ReleaseByteArrayElements(env, ser, (int8_t*)ser_ref.data, 0);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_NetworkGraph_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKNetworkGraph this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	NetworkGraph_free(this_obj_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_NetworkGraph_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKNetworkGraph orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKNetworkGraph ret_var = NetworkGraph_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ReadOnlyNetworkGraph_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKReadOnlyNetworkGraph this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	ReadOnlyNetworkGraph_free(this_obj_conv);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_NetworkUpdate_1free(JNIEnv *env, jclass clz, int64_t this_ptr) {
	if ((this_ptr & 1) != 0) return;
	void* this_ptr_ptr = (void*)(((uint64_t)this_ptr) & ~1);
	CHECK_ACCESS(this_ptr_ptr);
	LDKNetworkUpdate this_ptr_conv = *(LDKNetworkUpdate*)(this_ptr_ptr);
	FREE((void*)this_ptr);
	NetworkUpdate_free(this_ptr_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_NetworkUpdate_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKNetworkUpdate* orig_conv = (LDKNetworkUpdate*)orig;
	LDKNetworkUpdate *ret_copy = MALLOC(sizeof(LDKNetworkUpdate), "LDKNetworkUpdate");
	*ret_copy = NetworkUpdate_clone(orig_conv);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_NetworkUpdate_1channel_1update_1message(JNIEnv *env, jclass clz, int64_t msg) {
	LDKChannelUpdate msg_conv;
	msg_conv.inner = (void*)(msg & (~1));
	msg_conv.is_owned = (msg & 1) || (msg == 0);
	msg_conv = ChannelUpdate_clone(&msg_conv);
	LDKNetworkUpdate *ret_copy = MALLOC(sizeof(LDKNetworkUpdate), "LDKNetworkUpdate");
	*ret_copy = NetworkUpdate_channel_update_message(msg_conv);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_NetworkUpdate_1channel_1closed(JNIEnv *env, jclass clz, int64_t short_channel_id, jboolean is_permanent) {
	LDKNetworkUpdate *ret_copy = MALLOC(sizeof(LDKNetworkUpdate), "LDKNetworkUpdate");
	*ret_copy = NetworkUpdate_channel_closed(short_channel_id, is_permanent);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_NetworkUpdate_1node_1failure(JNIEnv *env, jclass clz, int8_tArray node_id, jboolean is_permanent) {
	LDKPublicKey node_id_ref;
	CHECK((*env)->GetArrayLength(env, node_id) == 33);
	(*env)->GetByteArrayRegion(env, node_id, 0, 33, node_id_ref.compressed_form);
	LDKNetworkUpdate *ret_copy = MALLOC(sizeof(LDKNetworkUpdate), "LDKNetworkUpdate");
	*ret_copy = NetworkUpdate_node_failure(node_id_ref, is_permanent);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_NetworkUpdate_1write(JNIEnv *env, jclass clz, int64_t obj) {
	LDKNetworkUpdate* obj_conv = (LDKNetworkUpdate*)obj;
	LDKCVec_u8Z ret_var = NetworkUpdate_write(obj_conv);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	CVec_u8Z_free(ret_var);
	return ret_arr;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_NetGraphMsgHandler_1as_1EventHandler(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKNetGraphMsgHandler this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKEventHandler* ret_ret = MALLOC(sizeof(LDKEventHandler), "LDKEventHandler");
	*ret_ret = NetGraphMsgHandler_as_EventHandler(&this_arg_conv);
	return (uint64_t)ret_ret;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_NetGraphMsgHandler_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKNetGraphMsgHandler this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	NetGraphMsgHandler_free(this_obj_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_NetGraphMsgHandler_1new(JNIEnv *env, jclass clz, int64_t network_graph, int64_t chain_access, int64_t logger) {
	LDKNetworkGraph network_graph_conv;
	network_graph_conv.inner = (void*)(network_graph & (~1));
	network_graph_conv.is_owned = false;
	void* chain_access_ptr = (void*)(((uint64_t)chain_access) & ~1);
	CHECK_ACCESS(chain_access_ptr);
	LDKCOption_AccessZ chain_access_conv = *(LDKCOption_AccessZ*)(chain_access_ptr);
	// Warning: we may need a move here but no clone is available for LDKCOption_AccessZ
	if (chain_access_conv.tag == LDKCOption_AccessZ_Some) {
		// Manually implement clone for Java trait instances
		if (chain_access_conv.some.free == LDKAccess_JCalls_free) {
			// If this_arg is a JCalls struct, then we need to increment the refcnt in it.
			LDKAccess_JCalls_cloned(&chain_access_conv.some);
		}
	}
	void* logger_ptr = (void*)(((uint64_t)logger) & ~1);
	CHECK_ACCESS(logger_ptr);
	LDKLogger logger_conv = *(LDKLogger*)(logger_ptr);
	if (logger_conv.free == LDKLogger_JCalls_free) {
		// If this_arg is a JCalls struct, then we need to increment the refcnt in it.
		LDKLogger_JCalls_cloned(&logger_conv);
	}
	LDKNetGraphMsgHandler ret_var = NetGraphMsgHandler_new(&network_graph_conv, chain_access_conv, logger_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_NetGraphMsgHandler_1add_1chain_1access(JNIEnv *env, jclass clz, int64_t this_arg, int64_t chain_access) {
	LDKNetGraphMsgHandler this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	void* chain_access_ptr = (void*)(((uint64_t)chain_access) & ~1);
	CHECK_ACCESS(chain_access_ptr);
	LDKCOption_AccessZ chain_access_conv = *(LDKCOption_AccessZ*)(chain_access_ptr);
	// Warning: we may need a move here but no clone is available for LDKCOption_AccessZ
	if (chain_access_conv.tag == LDKCOption_AccessZ_Some) {
		// Manually implement clone for Java trait instances
		if (chain_access_conv.some.free == LDKAccess_JCalls_free) {
			// If this_arg is a JCalls struct, then we need to increment the refcnt in it.
			LDKAccess_JCalls_cloned(&chain_access_conv.some);
		}
	}
	NetGraphMsgHandler_add_chain_access(&this_arg_conv, chain_access_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_NetGraphMsgHandler_1as_1RoutingMessageHandler(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKNetGraphMsgHandler this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKRoutingMessageHandler* ret_ret = MALLOC(sizeof(LDKRoutingMessageHandler), "LDKRoutingMessageHandler");
	*ret_ret = NetGraphMsgHandler_as_RoutingMessageHandler(&this_arg_conv);
	return (uint64_t)ret_ret;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_NetGraphMsgHandler_1as_1MessageSendEventsProvider(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKNetGraphMsgHandler this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKMessageSendEventsProvider* ret_ret = MALLOC(sizeof(LDKMessageSendEventsProvider), "LDKMessageSendEventsProvider");
	*ret_ret = NetGraphMsgHandler_as_MessageSendEventsProvider(&this_arg_conv);
	return (uint64_t)ret_ret;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_DirectionalChannelInfo_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKDirectionalChannelInfo this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	DirectionalChannelInfo_free(this_obj_conv);
}

JNIEXPORT int32_t JNICALL Java_org_ldk_impl_bindings_DirectionalChannelInfo_1get_1last_1update(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKDirectionalChannelInfo this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int32_t ret_val = DirectionalChannelInfo_get_last_update(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_DirectionalChannelInfo_1set_1last_1update(JNIEnv *env, jclass clz, int64_t this_ptr, int32_t val) {
	LDKDirectionalChannelInfo this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	DirectionalChannelInfo_set_last_update(&this_ptr_conv, val);
}

JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_DirectionalChannelInfo_1get_1enabled(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKDirectionalChannelInfo this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	jboolean ret_val = DirectionalChannelInfo_get_enabled(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_DirectionalChannelInfo_1set_1enabled(JNIEnv *env, jclass clz, int64_t this_ptr, jboolean val) {
	LDKDirectionalChannelInfo this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	DirectionalChannelInfo_set_enabled(&this_ptr_conv, val);
}

JNIEXPORT int16_t JNICALL Java_org_ldk_impl_bindings_DirectionalChannelInfo_1get_1cltv_1expiry_1delta(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKDirectionalChannelInfo this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int16_t ret_val = DirectionalChannelInfo_get_cltv_expiry_delta(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_DirectionalChannelInfo_1set_1cltv_1expiry_1delta(JNIEnv *env, jclass clz, int64_t this_ptr, int16_t val) {
	LDKDirectionalChannelInfo this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	DirectionalChannelInfo_set_cltv_expiry_delta(&this_ptr_conv, val);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_DirectionalChannelInfo_1get_1htlc_1minimum_1msat(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKDirectionalChannelInfo this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int64_t ret_val = DirectionalChannelInfo_get_htlc_minimum_msat(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_DirectionalChannelInfo_1set_1htlc_1minimum_1msat(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKDirectionalChannelInfo this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	DirectionalChannelInfo_set_htlc_minimum_msat(&this_ptr_conv, val);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_DirectionalChannelInfo_1get_1htlc_1maximum_1msat(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKDirectionalChannelInfo this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKCOption_u64Z *ret_copy = MALLOC(sizeof(LDKCOption_u64Z), "LDKCOption_u64Z");
	*ret_copy = DirectionalChannelInfo_get_htlc_maximum_msat(&this_ptr_conv);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_DirectionalChannelInfo_1set_1htlc_1maximum_1msat(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKDirectionalChannelInfo this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	void* val_ptr = (void*)(((uint64_t)val) & ~1);
	CHECK_ACCESS(val_ptr);
	LDKCOption_u64Z val_conv = *(LDKCOption_u64Z*)(val_ptr);
	val_conv = COption_u64Z_clone((LDKCOption_u64Z*)(((uint64_t)val) & ~1));
	DirectionalChannelInfo_set_htlc_maximum_msat(&this_ptr_conv, val_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_DirectionalChannelInfo_1get_1fees(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKDirectionalChannelInfo this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKRoutingFees ret_var = DirectionalChannelInfo_get_fees(&this_ptr_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_DirectionalChannelInfo_1set_1fees(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKDirectionalChannelInfo this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKRoutingFees val_conv;
	val_conv.inner = (void*)(val & (~1));
	val_conv.is_owned = (val & 1) || (val == 0);
	val_conv = RoutingFees_clone(&val_conv);
	DirectionalChannelInfo_set_fees(&this_ptr_conv, val_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_DirectionalChannelInfo_1get_1last_1update_1message(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKDirectionalChannelInfo this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKChannelUpdate ret_var = DirectionalChannelInfo_get_last_update_message(&this_ptr_conv);
	uint64_t ret_ref = 0;
	if ((uint64_t)ret_var.inner > 4096) {
		CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
		CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
		ret_ref = (uint64_t)ret_var.inner;
		if (ret_var.is_owned) {
			ret_ref |= 1;
		}
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_DirectionalChannelInfo_1set_1last_1update_1message(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKDirectionalChannelInfo this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKChannelUpdate val_conv;
	val_conv.inner = (void*)(val & (~1));
	val_conv.is_owned = (val & 1) || (val == 0);
	val_conv = ChannelUpdate_clone(&val_conv);
	DirectionalChannelInfo_set_last_update_message(&this_ptr_conv, val_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_DirectionalChannelInfo_1new(JNIEnv *env, jclass clz, int32_t last_update_arg, jboolean enabled_arg, int16_t cltv_expiry_delta_arg, int64_t htlc_minimum_msat_arg, int64_t htlc_maximum_msat_arg, int64_t fees_arg, int64_t last_update_message_arg) {
	void* htlc_maximum_msat_arg_ptr = (void*)(((uint64_t)htlc_maximum_msat_arg) & ~1);
	CHECK_ACCESS(htlc_maximum_msat_arg_ptr);
	LDKCOption_u64Z htlc_maximum_msat_arg_conv = *(LDKCOption_u64Z*)(htlc_maximum_msat_arg_ptr);
	htlc_maximum_msat_arg_conv = COption_u64Z_clone((LDKCOption_u64Z*)(((uint64_t)htlc_maximum_msat_arg) & ~1));
	LDKRoutingFees fees_arg_conv;
	fees_arg_conv.inner = (void*)(fees_arg & (~1));
	fees_arg_conv.is_owned = (fees_arg & 1) || (fees_arg == 0);
	fees_arg_conv = RoutingFees_clone(&fees_arg_conv);
	LDKChannelUpdate last_update_message_arg_conv;
	last_update_message_arg_conv.inner = (void*)(last_update_message_arg & (~1));
	last_update_message_arg_conv.is_owned = (last_update_message_arg & 1) || (last_update_message_arg == 0);
	last_update_message_arg_conv = ChannelUpdate_clone(&last_update_message_arg_conv);
	LDKDirectionalChannelInfo ret_var = DirectionalChannelInfo_new(last_update_arg, enabled_arg, cltv_expiry_delta_arg, htlc_minimum_msat_arg, htlc_maximum_msat_arg_conv, fees_arg_conv, last_update_message_arg_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_DirectionalChannelInfo_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKDirectionalChannelInfo orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKDirectionalChannelInfo ret_var = DirectionalChannelInfo_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_DirectionalChannelInfo_1write(JNIEnv *env, jclass clz, int64_t obj) {
	LDKDirectionalChannelInfo obj_conv;
	obj_conv.inner = (void*)(obj & (~1));
	obj_conv.is_owned = false;
	LDKCVec_u8Z ret_var = DirectionalChannelInfo_write(&obj_conv);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	CVec_u8Z_free(ret_var);
	return ret_arr;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_DirectionalChannelInfo_1read(JNIEnv *env, jclass clz, int8_tArray ser) {
	LDKu8slice ser_ref;
	ser_ref.datalen = (*env)->GetArrayLength(env, ser);
	ser_ref.data = (*env)->GetByteArrayElements (env, ser, NULL);
	LDKCResult_DirectionalChannelInfoDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_DirectionalChannelInfoDecodeErrorZ), "LDKCResult_DirectionalChannelInfoDecodeErrorZ");
	*ret_conv = DirectionalChannelInfo_read(ser_ref);
	(*env)->ReleaseByteArrayElements(env, ser, (int8_t*)ser_ref.data, 0);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelInfo_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKChannelInfo this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	ChannelInfo_free(this_obj_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelInfo_1get_1features(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKChannelInfo this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKChannelFeatures ret_var = ChannelInfo_get_features(&this_ptr_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelInfo_1set_1features(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKChannelInfo this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKChannelFeatures val_conv;
	val_conv.inner = (void*)(val & (~1));
	val_conv.is_owned = (val & 1) || (val == 0);
	val_conv = ChannelFeatures_clone(&val_conv);
	ChannelInfo_set_features(&this_ptr_conv, val_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelInfo_1get_1node_1one(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKChannelInfo this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKNodeId ret_var = ChannelInfo_get_node_one(&this_ptr_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelInfo_1set_1node_1one(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKChannelInfo this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKNodeId val_conv;
	val_conv.inner = (void*)(val & (~1));
	val_conv.is_owned = (val & 1) || (val == 0);
	val_conv = NodeId_clone(&val_conv);
	ChannelInfo_set_node_one(&this_ptr_conv, val_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelInfo_1get_1one_1to_1two(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKChannelInfo this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKDirectionalChannelInfo ret_var = ChannelInfo_get_one_to_two(&this_ptr_conv);
	uint64_t ret_ref = 0;
	if ((uint64_t)ret_var.inner > 4096) {
		CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
		CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
		ret_ref = (uint64_t)ret_var.inner;
		if (ret_var.is_owned) {
			ret_ref |= 1;
		}
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelInfo_1set_1one_1to_1two(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKChannelInfo this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKDirectionalChannelInfo val_conv;
	val_conv.inner = (void*)(val & (~1));
	val_conv.is_owned = (val & 1) || (val == 0);
	val_conv = DirectionalChannelInfo_clone(&val_conv);
	ChannelInfo_set_one_to_two(&this_ptr_conv, val_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelInfo_1get_1node_1two(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKChannelInfo this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKNodeId ret_var = ChannelInfo_get_node_two(&this_ptr_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelInfo_1set_1node_1two(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKChannelInfo this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKNodeId val_conv;
	val_conv.inner = (void*)(val & (~1));
	val_conv.is_owned = (val & 1) || (val == 0);
	val_conv = NodeId_clone(&val_conv);
	ChannelInfo_set_node_two(&this_ptr_conv, val_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelInfo_1get_1two_1to_1one(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKChannelInfo this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKDirectionalChannelInfo ret_var = ChannelInfo_get_two_to_one(&this_ptr_conv);
	uint64_t ret_ref = 0;
	if ((uint64_t)ret_var.inner > 4096) {
		CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
		CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
		ret_ref = (uint64_t)ret_var.inner;
		if (ret_var.is_owned) {
			ret_ref |= 1;
		}
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelInfo_1set_1two_1to_1one(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKChannelInfo this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKDirectionalChannelInfo val_conv;
	val_conv.inner = (void*)(val & (~1));
	val_conv.is_owned = (val & 1) || (val == 0);
	val_conv = DirectionalChannelInfo_clone(&val_conv);
	ChannelInfo_set_two_to_one(&this_ptr_conv, val_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelInfo_1get_1capacity_1sats(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKChannelInfo this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKCOption_u64Z *ret_copy = MALLOC(sizeof(LDKCOption_u64Z), "LDKCOption_u64Z");
	*ret_copy = ChannelInfo_get_capacity_sats(&this_ptr_conv);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelInfo_1set_1capacity_1sats(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKChannelInfo this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	void* val_ptr = (void*)(((uint64_t)val) & ~1);
	CHECK_ACCESS(val_ptr);
	LDKCOption_u64Z val_conv = *(LDKCOption_u64Z*)(val_ptr);
	val_conv = COption_u64Z_clone((LDKCOption_u64Z*)(((uint64_t)val) & ~1));
	ChannelInfo_set_capacity_sats(&this_ptr_conv, val_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelInfo_1get_1announcement_1message(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKChannelInfo this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKChannelAnnouncement ret_var = ChannelInfo_get_announcement_message(&this_ptr_conv);
	uint64_t ret_ref = 0;
	if ((uint64_t)ret_var.inner > 4096) {
		CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
		CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
		ret_ref = (uint64_t)ret_var.inner;
		if (ret_var.is_owned) {
			ret_ref |= 1;
		}
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelInfo_1set_1announcement_1message(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKChannelInfo this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKChannelAnnouncement val_conv;
	val_conv.inner = (void*)(val & (~1));
	val_conv.is_owned = (val & 1) || (val == 0);
	val_conv = ChannelAnnouncement_clone(&val_conv);
	ChannelInfo_set_announcement_message(&this_ptr_conv, val_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelInfo_1new(JNIEnv *env, jclass clz, int64_t features_arg, int64_t node_one_arg, int64_t one_to_two_arg, int64_t node_two_arg, int64_t two_to_one_arg, int64_t capacity_sats_arg, int64_t announcement_message_arg) {
	LDKChannelFeatures features_arg_conv;
	features_arg_conv.inner = (void*)(features_arg & (~1));
	features_arg_conv.is_owned = (features_arg & 1) || (features_arg == 0);
	features_arg_conv = ChannelFeatures_clone(&features_arg_conv);
	LDKNodeId node_one_arg_conv;
	node_one_arg_conv.inner = (void*)(node_one_arg & (~1));
	node_one_arg_conv.is_owned = (node_one_arg & 1) || (node_one_arg == 0);
	node_one_arg_conv = NodeId_clone(&node_one_arg_conv);
	LDKDirectionalChannelInfo one_to_two_arg_conv;
	one_to_two_arg_conv.inner = (void*)(one_to_two_arg & (~1));
	one_to_two_arg_conv.is_owned = (one_to_two_arg & 1) || (one_to_two_arg == 0);
	one_to_two_arg_conv = DirectionalChannelInfo_clone(&one_to_two_arg_conv);
	LDKNodeId node_two_arg_conv;
	node_two_arg_conv.inner = (void*)(node_two_arg & (~1));
	node_two_arg_conv.is_owned = (node_two_arg & 1) || (node_two_arg == 0);
	node_two_arg_conv = NodeId_clone(&node_two_arg_conv);
	LDKDirectionalChannelInfo two_to_one_arg_conv;
	two_to_one_arg_conv.inner = (void*)(two_to_one_arg & (~1));
	two_to_one_arg_conv.is_owned = (two_to_one_arg & 1) || (two_to_one_arg == 0);
	two_to_one_arg_conv = DirectionalChannelInfo_clone(&two_to_one_arg_conv);
	void* capacity_sats_arg_ptr = (void*)(((uint64_t)capacity_sats_arg) & ~1);
	CHECK_ACCESS(capacity_sats_arg_ptr);
	LDKCOption_u64Z capacity_sats_arg_conv = *(LDKCOption_u64Z*)(capacity_sats_arg_ptr);
	capacity_sats_arg_conv = COption_u64Z_clone((LDKCOption_u64Z*)(((uint64_t)capacity_sats_arg) & ~1));
	LDKChannelAnnouncement announcement_message_arg_conv;
	announcement_message_arg_conv.inner = (void*)(announcement_message_arg & (~1));
	announcement_message_arg_conv.is_owned = (announcement_message_arg & 1) || (announcement_message_arg == 0);
	announcement_message_arg_conv = ChannelAnnouncement_clone(&announcement_message_arg_conv);
	LDKChannelInfo ret_var = ChannelInfo_new(features_arg_conv, node_one_arg_conv, one_to_two_arg_conv, node_two_arg_conv, two_to_one_arg_conv, capacity_sats_arg_conv, announcement_message_arg_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelInfo_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKChannelInfo orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKChannelInfo ret_var = ChannelInfo_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_ChannelInfo_1write(JNIEnv *env, jclass clz, int64_t obj) {
	LDKChannelInfo obj_conv;
	obj_conv.inner = (void*)(obj & (~1));
	obj_conv.is_owned = false;
	LDKCVec_u8Z ret_var = ChannelInfo_write(&obj_conv);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	CVec_u8Z_free(ret_var);
	return ret_arr;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelInfo_1read(JNIEnv *env, jclass clz, int8_tArray ser) {
	LDKu8slice ser_ref;
	ser_ref.datalen = (*env)->GetArrayLength(env, ser);
	ser_ref.data = (*env)->GetByteArrayElements (env, ser, NULL);
	LDKCResult_ChannelInfoDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_ChannelInfoDecodeErrorZ), "LDKCResult_ChannelInfoDecodeErrorZ");
	*ret_conv = ChannelInfo_read(ser_ref);
	(*env)->ReleaseByteArrayElements(env, ser, (int8_t*)ser_ref.data, 0);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_RoutingFees_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKRoutingFees this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	RoutingFees_free(this_obj_conv);
}

JNIEXPORT int32_t JNICALL Java_org_ldk_impl_bindings_RoutingFees_1get_1base_1msat(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKRoutingFees this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int32_t ret_val = RoutingFees_get_base_msat(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_RoutingFees_1set_1base_1msat(JNIEnv *env, jclass clz, int64_t this_ptr, int32_t val) {
	LDKRoutingFees this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	RoutingFees_set_base_msat(&this_ptr_conv, val);
}

JNIEXPORT int32_t JNICALL Java_org_ldk_impl_bindings_RoutingFees_1get_1proportional_1millionths(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKRoutingFees this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int32_t ret_val = RoutingFees_get_proportional_millionths(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_RoutingFees_1set_1proportional_1millionths(JNIEnv *env, jclass clz, int64_t this_ptr, int32_t val) {
	LDKRoutingFees this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	RoutingFees_set_proportional_millionths(&this_ptr_conv, val);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_RoutingFees_1new(JNIEnv *env, jclass clz, int32_t base_msat_arg, int32_t proportional_millionths_arg) {
	LDKRoutingFees ret_var = RoutingFees_new(base_msat_arg, proportional_millionths_arg);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_RoutingFees_1eq(JNIEnv *env, jclass clz, int64_t a, int64_t b) {
	LDKRoutingFees a_conv;
	a_conv.inner = (void*)(a & (~1));
	a_conv.is_owned = false;
	LDKRoutingFees b_conv;
	b_conv.inner = (void*)(b & (~1));
	b_conv.is_owned = false;
	jboolean ret_val = RoutingFees_eq(&a_conv, &b_conv);
	return ret_val;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_RoutingFees_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKRoutingFees orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKRoutingFees ret_var = RoutingFees_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_RoutingFees_1hash(JNIEnv *env, jclass clz, int64_t o) {
	LDKRoutingFees o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = false;
	int64_t ret_val = RoutingFees_hash(&o_conv);
	return ret_val;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_RoutingFees_1write(JNIEnv *env, jclass clz, int64_t obj) {
	LDKRoutingFees obj_conv;
	obj_conv.inner = (void*)(obj & (~1));
	obj_conv.is_owned = false;
	LDKCVec_u8Z ret_var = RoutingFees_write(&obj_conv);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	CVec_u8Z_free(ret_var);
	return ret_arr;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_RoutingFees_1read(JNIEnv *env, jclass clz, int8_tArray ser) {
	LDKu8slice ser_ref;
	ser_ref.datalen = (*env)->GetArrayLength(env, ser);
	ser_ref.data = (*env)->GetByteArrayElements (env, ser, NULL);
	LDKCResult_RoutingFeesDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_RoutingFeesDecodeErrorZ), "LDKCResult_RoutingFeesDecodeErrorZ");
	*ret_conv = RoutingFees_read(ser_ref);
	(*env)->ReleaseByteArrayElements(env, ser, (int8_t*)ser_ref.data, 0);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_NodeAnnouncementInfo_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKNodeAnnouncementInfo this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	NodeAnnouncementInfo_free(this_obj_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_NodeAnnouncementInfo_1get_1features(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKNodeAnnouncementInfo this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKNodeFeatures ret_var = NodeAnnouncementInfo_get_features(&this_ptr_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_NodeAnnouncementInfo_1set_1features(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKNodeAnnouncementInfo this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKNodeFeatures val_conv;
	val_conv.inner = (void*)(val & (~1));
	val_conv.is_owned = (val & 1) || (val == 0);
	val_conv = NodeFeatures_clone(&val_conv);
	NodeAnnouncementInfo_set_features(&this_ptr_conv, val_conv);
}

JNIEXPORT int32_t JNICALL Java_org_ldk_impl_bindings_NodeAnnouncementInfo_1get_1last_1update(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKNodeAnnouncementInfo this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int32_t ret_val = NodeAnnouncementInfo_get_last_update(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_NodeAnnouncementInfo_1set_1last_1update(JNIEnv *env, jclass clz, int64_t this_ptr, int32_t val) {
	LDKNodeAnnouncementInfo this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	NodeAnnouncementInfo_set_last_update(&this_ptr_conv, val);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_NodeAnnouncementInfo_1get_1rgb(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKNodeAnnouncementInfo this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 3);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 3, *NodeAnnouncementInfo_get_rgb(&this_ptr_conv));
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_NodeAnnouncementInfo_1set_1rgb(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKNodeAnnouncementInfo this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKThreeBytes val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 3);
	(*env)->GetByteArrayRegion(env, val, 0, 3, val_ref.data);
	NodeAnnouncementInfo_set_rgb(&this_ptr_conv, val_ref);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_NodeAnnouncementInfo_1get_1alias(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKNodeAnnouncementInfo this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 32);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 32, *NodeAnnouncementInfo_get_alias(&this_ptr_conv));
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_NodeAnnouncementInfo_1set_1alias(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKNodeAnnouncementInfo this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKThirtyTwoBytes val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 32);
	(*env)->GetByteArrayRegion(env, val, 0, 32, val_ref.data);
	NodeAnnouncementInfo_set_alias(&this_ptr_conv, val_ref);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_NodeAnnouncementInfo_1set_1addresses(JNIEnv *env, jclass clz, int64_t this_ptr, int64_tArray val) {
	LDKNodeAnnouncementInfo this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKCVec_NetAddressZ val_constr;
	val_constr.datalen = (*env)->GetArrayLength(env, val);
	if (val_constr.datalen > 0)
		val_constr.data = MALLOC(val_constr.datalen * sizeof(LDKNetAddress), "LDKCVec_NetAddressZ Elements");
	else
		val_constr.data = NULL;
	int64_t* val_vals = (*env)->GetLongArrayElements (env, val, NULL);
	for (size_t m = 0; m < val_constr.datalen; m++) {
		int64_t val_conv_12 = val_vals[m];
		void* val_conv_12_ptr = (void*)(((uint64_t)val_conv_12) & ~1);
		CHECK_ACCESS(val_conv_12_ptr);
		LDKNetAddress val_conv_12_conv = *(LDKNetAddress*)(val_conv_12_ptr);
		val_conv_12_conv = NetAddress_clone((LDKNetAddress*)(((uint64_t)val_conv_12) & ~1));
		val_constr.data[m] = val_conv_12_conv;
	}
	(*env)->ReleaseLongArrayElements(env, val, val_vals, 0);
	NodeAnnouncementInfo_set_addresses(&this_ptr_conv, val_constr);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_NodeAnnouncementInfo_1get_1announcement_1message(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKNodeAnnouncementInfo this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKNodeAnnouncement ret_var = NodeAnnouncementInfo_get_announcement_message(&this_ptr_conv);
	uint64_t ret_ref = 0;
	if ((uint64_t)ret_var.inner > 4096) {
		CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
		CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
		ret_ref = (uint64_t)ret_var.inner;
		if (ret_var.is_owned) {
			ret_ref |= 1;
		}
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_NodeAnnouncementInfo_1set_1announcement_1message(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKNodeAnnouncementInfo this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKNodeAnnouncement val_conv;
	val_conv.inner = (void*)(val & (~1));
	val_conv.is_owned = (val & 1) || (val == 0);
	val_conv = NodeAnnouncement_clone(&val_conv);
	NodeAnnouncementInfo_set_announcement_message(&this_ptr_conv, val_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_NodeAnnouncementInfo_1new(JNIEnv *env, jclass clz, int64_t features_arg, int32_t last_update_arg, int8_tArray rgb_arg, int8_tArray alias_arg, int64_tArray addresses_arg, int64_t announcement_message_arg) {
	LDKNodeFeatures features_arg_conv;
	features_arg_conv.inner = (void*)(features_arg & (~1));
	features_arg_conv.is_owned = (features_arg & 1) || (features_arg == 0);
	features_arg_conv = NodeFeatures_clone(&features_arg_conv);
	LDKThreeBytes rgb_arg_ref;
	CHECK((*env)->GetArrayLength(env, rgb_arg) == 3);
	(*env)->GetByteArrayRegion(env, rgb_arg, 0, 3, rgb_arg_ref.data);
	LDKThirtyTwoBytes alias_arg_ref;
	CHECK((*env)->GetArrayLength(env, alias_arg) == 32);
	(*env)->GetByteArrayRegion(env, alias_arg, 0, 32, alias_arg_ref.data);
	LDKCVec_NetAddressZ addresses_arg_constr;
	addresses_arg_constr.datalen = (*env)->GetArrayLength(env, addresses_arg);
	if (addresses_arg_constr.datalen > 0)
		addresses_arg_constr.data = MALLOC(addresses_arg_constr.datalen * sizeof(LDKNetAddress), "LDKCVec_NetAddressZ Elements");
	else
		addresses_arg_constr.data = NULL;
	int64_t* addresses_arg_vals = (*env)->GetLongArrayElements (env, addresses_arg, NULL);
	for (size_t m = 0; m < addresses_arg_constr.datalen; m++) {
		int64_t addresses_arg_conv_12 = addresses_arg_vals[m];
		void* addresses_arg_conv_12_ptr = (void*)(((uint64_t)addresses_arg_conv_12) & ~1);
		CHECK_ACCESS(addresses_arg_conv_12_ptr);
		LDKNetAddress addresses_arg_conv_12_conv = *(LDKNetAddress*)(addresses_arg_conv_12_ptr);
		addresses_arg_constr.data[m] = addresses_arg_conv_12_conv;
	}
	(*env)->ReleaseLongArrayElements(env, addresses_arg, addresses_arg_vals, 0);
	LDKNodeAnnouncement announcement_message_arg_conv;
	announcement_message_arg_conv.inner = (void*)(announcement_message_arg & (~1));
	announcement_message_arg_conv.is_owned = (announcement_message_arg & 1) || (announcement_message_arg == 0);
	announcement_message_arg_conv = NodeAnnouncement_clone(&announcement_message_arg_conv);
	LDKNodeAnnouncementInfo ret_var = NodeAnnouncementInfo_new(features_arg_conv, last_update_arg, rgb_arg_ref, alias_arg_ref, addresses_arg_constr, announcement_message_arg_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_NodeAnnouncementInfo_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKNodeAnnouncementInfo orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKNodeAnnouncementInfo ret_var = NodeAnnouncementInfo_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_NodeAnnouncementInfo_1write(JNIEnv *env, jclass clz, int64_t obj) {
	LDKNodeAnnouncementInfo obj_conv;
	obj_conv.inner = (void*)(obj & (~1));
	obj_conv.is_owned = false;
	LDKCVec_u8Z ret_var = NodeAnnouncementInfo_write(&obj_conv);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	CVec_u8Z_free(ret_var);
	return ret_arr;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_NodeAnnouncementInfo_1read(JNIEnv *env, jclass clz, int8_tArray ser) {
	LDKu8slice ser_ref;
	ser_ref.datalen = (*env)->GetArrayLength(env, ser);
	ser_ref.data = (*env)->GetByteArrayElements (env, ser, NULL);
	LDKCResult_NodeAnnouncementInfoDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_NodeAnnouncementInfoDecodeErrorZ), "LDKCResult_NodeAnnouncementInfoDecodeErrorZ");
	*ret_conv = NodeAnnouncementInfo_read(ser_ref);
	(*env)->ReleaseByteArrayElements(env, ser, (int8_t*)ser_ref.data, 0);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_NodeInfo_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKNodeInfo this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	NodeInfo_free(this_obj_conv);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_NodeInfo_1set_1channels(JNIEnv *env, jclass clz, int64_t this_ptr, int64_tArray val) {
	LDKNodeInfo this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKCVec_u64Z val_constr;
	val_constr.datalen = (*env)->GetArrayLength(env, val);
	if (val_constr.datalen > 0)
		val_constr.data = MALLOC(val_constr.datalen * sizeof(int64_t), "LDKCVec_u64Z Elements");
	else
		val_constr.data = NULL;
	int64_t* val_vals = (*env)->GetLongArrayElements (env, val, NULL);
	for (size_t g = 0; g < val_constr.datalen; g++) {
		int64_t val_conv_6 = val_vals[g];
		val_constr.data[g] = val_conv_6;
	}
	(*env)->ReleaseLongArrayElements(env, val, val_vals, 0);
	NodeInfo_set_channels(&this_ptr_conv, val_constr);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_NodeInfo_1get_1lowest_1inbound_1channel_1fees(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKNodeInfo this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKRoutingFees ret_var = NodeInfo_get_lowest_inbound_channel_fees(&this_ptr_conv);
	uint64_t ret_ref = 0;
	if ((uint64_t)ret_var.inner > 4096) {
		CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
		CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
		ret_ref = (uint64_t)ret_var.inner;
		if (ret_var.is_owned) {
			ret_ref |= 1;
		}
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_NodeInfo_1set_1lowest_1inbound_1channel_1fees(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKNodeInfo this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKRoutingFees val_conv;
	val_conv.inner = (void*)(val & (~1));
	val_conv.is_owned = (val & 1) || (val == 0);
	val_conv = RoutingFees_clone(&val_conv);
	NodeInfo_set_lowest_inbound_channel_fees(&this_ptr_conv, val_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_NodeInfo_1get_1announcement_1info(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKNodeInfo this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKNodeAnnouncementInfo ret_var = NodeInfo_get_announcement_info(&this_ptr_conv);
	uint64_t ret_ref = 0;
	if ((uint64_t)ret_var.inner > 4096) {
		CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
		CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
		ret_ref = (uint64_t)ret_var.inner;
		if (ret_var.is_owned) {
			ret_ref |= 1;
		}
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_NodeInfo_1set_1announcement_1info(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKNodeInfo this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKNodeAnnouncementInfo val_conv;
	val_conv.inner = (void*)(val & (~1));
	val_conv.is_owned = (val & 1) || (val == 0);
	val_conv = NodeAnnouncementInfo_clone(&val_conv);
	NodeInfo_set_announcement_info(&this_ptr_conv, val_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_NodeInfo_1new(JNIEnv *env, jclass clz, int64_tArray channels_arg, int64_t lowest_inbound_channel_fees_arg, int64_t announcement_info_arg) {
	LDKCVec_u64Z channels_arg_constr;
	channels_arg_constr.datalen = (*env)->GetArrayLength(env, channels_arg);
	if (channels_arg_constr.datalen > 0)
		channels_arg_constr.data = MALLOC(channels_arg_constr.datalen * sizeof(int64_t), "LDKCVec_u64Z Elements");
	else
		channels_arg_constr.data = NULL;
	int64_t* channels_arg_vals = (*env)->GetLongArrayElements (env, channels_arg, NULL);
	for (size_t g = 0; g < channels_arg_constr.datalen; g++) {
		int64_t channels_arg_conv_6 = channels_arg_vals[g];
		channels_arg_constr.data[g] = channels_arg_conv_6;
	}
	(*env)->ReleaseLongArrayElements(env, channels_arg, channels_arg_vals, 0);
	LDKRoutingFees lowest_inbound_channel_fees_arg_conv;
	lowest_inbound_channel_fees_arg_conv.inner = (void*)(lowest_inbound_channel_fees_arg & (~1));
	lowest_inbound_channel_fees_arg_conv.is_owned = (lowest_inbound_channel_fees_arg & 1) || (lowest_inbound_channel_fees_arg == 0);
	lowest_inbound_channel_fees_arg_conv = RoutingFees_clone(&lowest_inbound_channel_fees_arg_conv);
	LDKNodeAnnouncementInfo announcement_info_arg_conv;
	announcement_info_arg_conv.inner = (void*)(announcement_info_arg & (~1));
	announcement_info_arg_conv.is_owned = (announcement_info_arg & 1) || (announcement_info_arg == 0);
	announcement_info_arg_conv = NodeAnnouncementInfo_clone(&announcement_info_arg_conv);
	LDKNodeInfo ret_var = NodeInfo_new(channels_arg_constr, lowest_inbound_channel_fees_arg_conv, announcement_info_arg_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_NodeInfo_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKNodeInfo orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKNodeInfo ret_var = NodeInfo_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_NodeInfo_1write(JNIEnv *env, jclass clz, int64_t obj) {
	LDKNodeInfo obj_conv;
	obj_conv.inner = (void*)(obj & (~1));
	obj_conv.is_owned = false;
	LDKCVec_u8Z ret_var = NodeInfo_write(&obj_conv);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	CVec_u8Z_free(ret_var);
	return ret_arr;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_NodeInfo_1read(JNIEnv *env, jclass clz, int8_tArray ser) {
	LDKu8slice ser_ref;
	ser_ref.datalen = (*env)->GetArrayLength(env, ser);
	ser_ref.data = (*env)->GetByteArrayElements (env, ser, NULL);
	LDKCResult_NodeInfoDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_NodeInfoDecodeErrorZ), "LDKCResult_NodeInfoDecodeErrorZ");
	*ret_conv = NodeInfo_read(ser_ref);
	(*env)->ReleaseByteArrayElements(env, ser, (int8_t*)ser_ref.data, 0);
	return (uint64_t)ret_conv;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_NetworkGraph_1write(JNIEnv *env, jclass clz, int64_t obj) {
	LDKNetworkGraph obj_conv;
	obj_conv.inner = (void*)(obj & (~1));
	obj_conv.is_owned = false;
	LDKCVec_u8Z ret_var = NetworkGraph_write(&obj_conv);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	CVec_u8Z_free(ret_var);
	return ret_arr;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_NetworkGraph_1read(JNIEnv *env, jclass clz, int8_tArray ser) {
	LDKu8slice ser_ref;
	ser_ref.datalen = (*env)->GetArrayLength(env, ser);
	ser_ref.data = (*env)->GetByteArrayElements (env, ser, NULL);
	LDKCResult_NetworkGraphDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_NetworkGraphDecodeErrorZ), "LDKCResult_NetworkGraphDecodeErrorZ");
	*ret_conv = NetworkGraph_read(ser_ref);
	(*env)->ReleaseByteArrayElements(env, ser, (int8_t*)ser_ref.data, 0);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_NetworkGraph_1new(JNIEnv *env, jclass clz, int8_tArray genesis_hash) {
	LDKThirtyTwoBytes genesis_hash_ref;
	CHECK((*env)->GetArrayLength(env, genesis_hash) == 32);
	(*env)->GetByteArrayRegion(env, genesis_hash, 0, 32, genesis_hash_ref.data);
	LDKNetworkGraph ret_var = NetworkGraph_new(genesis_hash_ref);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_NetworkGraph_1read_1only(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKNetworkGraph this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKReadOnlyNetworkGraph ret_var = NetworkGraph_read_only(&this_arg_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_NetworkGraph_1update_1node_1from_1announcement(JNIEnv *env, jclass clz, int64_t this_arg, int64_t msg) {
	LDKNetworkGraph this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKNodeAnnouncement msg_conv;
	msg_conv.inner = (void*)(msg & (~1));
	msg_conv.is_owned = false;
	LDKCResult_NoneLightningErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_NoneLightningErrorZ), "LDKCResult_NoneLightningErrorZ");
	*ret_conv = NetworkGraph_update_node_from_announcement(&this_arg_conv, &msg_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_NetworkGraph_1update_1node_1from_1unsigned_1announcement(JNIEnv *env, jclass clz, int64_t this_arg, int64_t msg) {
	LDKNetworkGraph this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKUnsignedNodeAnnouncement msg_conv;
	msg_conv.inner = (void*)(msg & (~1));
	msg_conv.is_owned = false;
	LDKCResult_NoneLightningErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_NoneLightningErrorZ), "LDKCResult_NoneLightningErrorZ");
	*ret_conv = NetworkGraph_update_node_from_unsigned_announcement(&this_arg_conv, &msg_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_NetworkGraph_1update_1channel_1from_1announcement(JNIEnv *env, jclass clz, int64_t this_arg, int64_t msg, int64_t chain_access) {
	LDKNetworkGraph this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKChannelAnnouncement msg_conv;
	msg_conv.inner = (void*)(msg & (~1));
	msg_conv.is_owned = false;
	void* chain_access_ptr = (void*)(((uint64_t)chain_access) & ~1);
	CHECK_ACCESS(chain_access_ptr);
	LDKCOption_AccessZ chain_access_conv = *(LDKCOption_AccessZ*)(chain_access_ptr);
	// Warning: we may need a move here but no clone is available for LDKCOption_AccessZ
	if (chain_access_conv.tag == LDKCOption_AccessZ_Some) {
		// Manually implement clone for Java trait instances
		if (chain_access_conv.some.free == LDKAccess_JCalls_free) {
			// If this_arg is a JCalls struct, then we need to increment the refcnt in it.
			LDKAccess_JCalls_cloned(&chain_access_conv.some);
		}
	}
	LDKCResult_NoneLightningErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_NoneLightningErrorZ), "LDKCResult_NoneLightningErrorZ");
	*ret_conv = NetworkGraph_update_channel_from_announcement(&this_arg_conv, &msg_conv, chain_access_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_NetworkGraph_1update_1channel_1from_1unsigned_1announcement(JNIEnv *env, jclass clz, int64_t this_arg, int64_t msg, int64_t chain_access) {
	LDKNetworkGraph this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKUnsignedChannelAnnouncement msg_conv;
	msg_conv.inner = (void*)(msg & (~1));
	msg_conv.is_owned = false;
	void* chain_access_ptr = (void*)(((uint64_t)chain_access) & ~1);
	CHECK_ACCESS(chain_access_ptr);
	LDKCOption_AccessZ chain_access_conv = *(LDKCOption_AccessZ*)(chain_access_ptr);
	// Warning: we may need a move here but no clone is available for LDKCOption_AccessZ
	if (chain_access_conv.tag == LDKCOption_AccessZ_Some) {
		// Manually implement clone for Java trait instances
		if (chain_access_conv.some.free == LDKAccess_JCalls_free) {
			// If this_arg is a JCalls struct, then we need to increment the refcnt in it.
			LDKAccess_JCalls_cloned(&chain_access_conv.some);
		}
	}
	LDKCResult_NoneLightningErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_NoneLightningErrorZ), "LDKCResult_NoneLightningErrorZ");
	*ret_conv = NetworkGraph_update_channel_from_unsigned_announcement(&this_arg_conv, &msg_conv, chain_access_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_NetworkGraph_1close_1channel_1from_1update(JNIEnv *env, jclass clz, int64_t this_arg, int64_t short_channel_id, jboolean is_permanent) {
	LDKNetworkGraph this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	NetworkGraph_close_channel_from_update(&this_arg_conv, short_channel_id, is_permanent);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_NetworkGraph_1fail_1node(JNIEnv *env, jclass clz, int64_t this_arg, int8_tArray _node_id, jboolean is_permanent) {
	LDKNetworkGraph this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKPublicKey _node_id_ref;
	CHECK((*env)->GetArrayLength(env, _node_id) == 33);
	(*env)->GetByteArrayRegion(env, _node_id, 0, 33, _node_id_ref.compressed_form);
	NetworkGraph_fail_node(&this_arg_conv, _node_id_ref, is_permanent);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_NetworkGraph_1update_1channel(JNIEnv *env, jclass clz, int64_t this_arg, int64_t msg) {
	LDKNetworkGraph this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKChannelUpdate msg_conv;
	msg_conv.inner = (void*)(msg & (~1));
	msg_conv.is_owned = false;
	LDKCResult_NoneLightningErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_NoneLightningErrorZ), "LDKCResult_NoneLightningErrorZ");
	*ret_conv = NetworkGraph_update_channel(&this_arg_conv, &msg_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_NetworkGraph_1update_1channel_1unsigned(JNIEnv *env, jclass clz, int64_t this_arg, int64_t msg) {
	LDKNetworkGraph this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKUnsignedChannelUpdate msg_conv;
	msg_conv.inner = (void*)(msg & (~1));
	msg_conv.is_owned = false;
	LDKCResult_NoneLightningErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_NoneLightningErrorZ), "LDKCResult_NoneLightningErrorZ");
	*ret_conv = NetworkGraph_update_channel_unsigned(&this_arg_conv, &msg_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ReadOnlyNetworkGraph_1get_1addresses(JNIEnv *env, jclass clz, int64_t this_arg, int8_tArray pubkey) {
	LDKReadOnlyNetworkGraph this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKPublicKey pubkey_ref;
	CHECK((*env)->GetArrayLength(env, pubkey) == 33);
	(*env)->GetByteArrayRegion(env, pubkey, 0, 33, pubkey_ref.compressed_form);
	LDKCOption_CVec_NetAddressZZ *ret_copy = MALLOC(sizeof(LDKCOption_CVec_NetAddressZZ), "LDKCOption_CVec_NetAddressZZ");
	*ret_copy = ReadOnlyNetworkGraph_get_addresses(&this_arg_conv, pubkey_ref);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_RouteHop_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKRouteHop this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	RouteHop_free(this_obj_conv);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_RouteHop_1get_1pubkey(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKRouteHop this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 33);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 33, RouteHop_get_pubkey(&this_ptr_conv).compressed_form);
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_RouteHop_1set_1pubkey(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKRouteHop this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKPublicKey val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 33);
	(*env)->GetByteArrayRegion(env, val, 0, 33, val_ref.compressed_form);
	RouteHop_set_pubkey(&this_ptr_conv, val_ref);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_RouteHop_1get_1node_1features(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKRouteHop this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKNodeFeatures ret_var = RouteHop_get_node_features(&this_ptr_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_RouteHop_1set_1node_1features(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKRouteHop this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKNodeFeatures val_conv;
	val_conv.inner = (void*)(val & (~1));
	val_conv.is_owned = (val & 1) || (val == 0);
	val_conv = NodeFeatures_clone(&val_conv);
	RouteHop_set_node_features(&this_ptr_conv, val_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_RouteHop_1get_1short_1channel_1id(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKRouteHop this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int64_t ret_val = RouteHop_get_short_channel_id(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_RouteHop_1set_1short_1channel_1id(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKRouteHop this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	RouteHop_set_short_channel_id(&this_ptr_conv, val);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_RouteHop_1get_1channel_1features(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKRouteHop this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKChannelFeatures ret_var = RouteHop_get_channel_features(&this_ptr_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_RouteHop_1set_1channel_1features(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKRouteHop this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKChannelFeatures val_conv;
	val_conv.inner = (void*)(val & (~1));
	val_conv.is_owned = (val & 1) || (val == 0);
	val_conv = ChannelFeatures_clone(&val_conv);
	RouteHop_set_channel_features(&this_ptr_conv, val_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_RouteHop_1get_1fee_1msat(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKRouteHop this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int64_t ret_val = RouteHop_get_fee_msat(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_RouteHop_1set_1fee_1msat(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKRouteHop this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	RouteHop_set_fee_msat(&this_ptr_conv, val);
}

JNIEXPORT int32_t JNICALL Java_org_ldk_impl_bindings_RouteHop_1get_1cltv_1expiry_1delta(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKRouteHop this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int32_t ret_val = RouteHop_get_cltv_expiry_delta(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_RouteHop_1set_1cltv_1expiry_1delta(JNIEnv *env, jclass clz, int64_t this_ptr, int32_t val) {
	LDKRouteHop this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	RouteHop_set_cltv_expiry_delta(&this_ptr_conv, val);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_RouteHop_1new(JNIEnv *env, jclass clz, int8_tArray pubkey_arg, int64_t node_features_arg, int64_t short_channel_id_arg, int64_t channel_features_arg, int64_t fee_msat_arg, int32_t cltv_expiry_delta_arg) {
	LDKPublicKey pubkey_arg_ref;
	CHECK((*env)->GetArrayLength(env, pubkey_arg) == 33);
	(*env)->GetByteArrayRegion(env, pubkey_arg, 0, 33, pubkey_arg_ref.compressed_form);
	LDKNodeFeatures node_features_arg_conv;
	node_features_arg_conv.inner = (void*)(node_features_arg & (~1));
	node_features_arg_conv.is_owned = (node_features_arg & 1) || (node_features_arg == 0);
	node_features_arg_conv = NodeFeatures_clone(&node_features_arg_conv);
	LDKChannelFeatures channel_features_arg_conv;
	channel_features_arg_conv.inner = (void*)(channel_features_arg & (~1));
	channel_features_arg_conv.is_owned = (channel_features_arg & 1) || (channel_features_arg == 0);
	channel_features_arg_conv = ChannelFeatures_clone(&channel_features_arg_conv);
	LDKRouteHop ret_var = RouteHop_new(pubkey_arg_ref, node_features_arg_conv, short_channel_id_arg, channel_features_arg_conv, fee_msat_arg, cltv_expiry_delta_arg);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_RouteHop_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKRouteHop orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKRouteHop ret_var = RouteHop_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_RouteHop_1hash(JNIEnv *env, jclass clz, int64_t o) {
	LDKRouteHop o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = false;
	int64_t ret_val = RouteHop_hash(&o_conv);
	return ret_val;
}

JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_RouteHop_1eq(JNIEnv *env, jclass clz, int64_t a, int64_t b) {
	LDKRouteHop a_conv;
	a_conv.inner = (void*)(a & (~1));
	a_conv.is_owned = false;
	LDKRouteHop b_conv;
	b_conv.inner = (void*)(b & (~1));
	b_conv.is_owned = false;
	jboolean ret_val = RouteHop_eq(&a_conv, &b_conv);
	return ret_val;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_RouteHop_1write(JNIEnv *env, jclass clz, int64_t obj) {
	LDKRouteHop obj_conv;
	obj_conv.inner = (void*)(obj & (~1));
	obj_conv.is_owned = false;
	LDKCVec_u8Z ret_var = RouteHop_write(&obj_conv);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	CVec_u8Z_free(ret_var);
	return ret_arr;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_RouteHop_1read(JNIEnv *env, jclass clz, int8_tArray ser) {
	LDKu8slice ser_ref;
	ser_ref.datalen = (*env)->GetArrayLength(env, ser);
	ser_ref.data = (*env)->GetByteArrayElements (env, ser, NULL);
	LDKCResult_RouteHopDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_RouteHopDecodeErrorZ), "LDKCResult_RouteHopDecodeErrorZ");
	*ret_conv = RouteHop_read(ser_ref);
	(*env)->ReleaseByteArrayElements(env, ser, (int8_t*)ser_ref.data, 0);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_Route_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKRoute this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	Route_free(this_obj_conv);
}

JNIEXPORT jobjectArray JNICALL Java_org_ldk_impl_bindings_Route_1get_1paths(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKRoute this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKCVec_CVec_RouteHopZZ ret_var = Route_get_paths(&this_ptr_conv);
	jobjectArray ret_arr = NULL;
	ret_arr = (*env)->NewObjectArray(env, ret_var.datalen, arr_of_J_clz, NULL);
	;
	for (size_t m = 0; m < ret_var.datalen; m++) {
		LDKCVec_RouteHopZ ret_conv_12_var = ret_var.data[m];
		int64_tArray ret_conv_12_arr = NULL;
		ret_conv_12_arr = (*env)->NewLongArray(env, ret_conv_12_var.datalen);
		int64_t *ret_conv_12_arr_ptr = (*env)->GetPrimitiveArrayCritical(env, ret_conv_12_arr, NULL);
		for (size_t k = 0; k < ret_conv_12_var.datalen; k++) {
			LDKRouteHop ret_conv_12_conv_10_var = ret_conv_12_var.data[k];
			uint64_t ret_conv_12_conv_10_ref = 0;
			CHECK((((uint64_t)ret_conv_12_conv_10_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
			CHECK((((uint64_t)&ret_conv_12_conv_10_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
			ret_conv_12_conv_10_ref = (uint64_t)ret_conv_12_conv_10_var.inner;
			if (ret_conv_12_conv_10_var.is_owned) {
				ret_conv_12_conv_10_ref |= 1;
			}
			ret_conv_12_arr_ptr[k] = ret_conv_12_conv_10_ref;
		}
		(*env)->ReleasePrimitiveArrayCritical(env, ret_conv_12_arr, ret_conv_12_arr_ptr, 0);
		FREE(ret_conv_12_var.data);
		(*env)->SetObjectArrayElement(env, ret_arr, m, ret_conv_12_arr);
	}
	
	FREE(ret_var.data);
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_Route_1set_1paths(JNIEnv *env, jclass clz, int64_t this_ptr, jobjectArray val) {
	LDKRoute this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKCVec_CVec_RouteHopZZ val_constr;
	val_constr.datalen = (*env)->GetArrayLength(env, val);
	if (val_constr.datalen > 0)
		val_constr.data = MALLOC(val_constr.datalen * sizeof(LDKCVec_RouteHopZ), "LDKCVec_CVec_RouteHopZZ Elements");
	else
		val_constr.data = NULL;
	for (size_t m = 0; m < val_constr.datalen; m++) {
		int64_tArray val_conv_12 = (*env)->GetObjectArrayElement(env, val, m);
		LDKCVec_RouteHopZ val_conv_12_constr;
		val_conv_12_constr.datalen = (*env)->GetArrayLength(env, val_conv_12);
		if (val_conv_12_constr.datalen > 0)
			val_conv_12_constr.data = MALLOC(val_conv_12_constr.datalen * sizeof(LDKRouteHop), "LDKCVec_RouteHopZ Elements");
		else
			val_conv_12_constr.data = NULL;
		int64_t* val_conv_12_vals = (*env)->GetLongArrayElements (env, val_conv_12, NULL);
		for (size_t k = 0; k < val_conv_12_constr.datalen; k++) {
			int64_t val_conv_12_conv_10 = val_conv_12_vals[k];
			LDKRouteHop val_conv_12_conv_10_conv;
			val_conv_12_conv_10_conv.inner = (void*)(val_conv_12_conv_10 & (~1));
			val_conv_12_conv_10_conv.is_owned = (val_conv_12_conv_10 & 1) || (val_conv_12_conv_10 == 0);
			val_conv_12_conv_10_conv = RouteHop_clone(&val_conv_12_conv_10_conv);
			val_conv_12_constr.data[k] = val_conv_12_conv_10_conv;
		}
		(*env)->ReleaseLongArrayElements(env, val_conv_12, val_conv_12_vals, 0);
		val_constr.data[m] = val_conv_12_constr;
	}
	Route_set_paths(&this_ptr_conv, val_constr);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_Route_1get_1payee(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKRoute this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKPayee ret_var = Route_get_payee(&this_ptr_conv);
	uint64_t ret_ref = 0;
	if ((uint64_t)ret_var.inner > 4096) {
		CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
		CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
		ret_ref = (uint64_t)ret_var.inner;
		if (ret_var.is_owned) {
			ret_ref |= 1;
		}
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_Route_1set_1payee(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKRoute this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKPayee val_conv;
	val_conv.inner = (void*)(val & (~1));
	val_conv.is_owned = (val & 1) || (val == 0);
	val_conv = Payee_clone(&val_conv);
	Route_set_payee(&this_ptr_conv, val_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_Route_1new(JNIEnv *env, jclass clz, jobjectArray paths_arg, int64_t payee_arg) {
	LDKCVec_CVec_RouteHopZZ paths_arg_constr;
	paths_arg_constr.datalen = (*env)->GetArrayLength(env, paths_arg);
	if (paths_arg_constr.datalen > 0)
		paths_arg_constr.data = MALLOC(paths_arg_constr.datalen * sizeof(LDKCVec_RouteHopZ), "LDKCVec_CVec_RouteHopZZ Elements");
	else
		paths_arg_constr.data = NULL;
	for (size_t m = 0; m < paths_arg_constr.datalen; m++) {
		int64_tArray paths_arg_conv_12 = (*env)->GetObjectArrayElement(env, paths_arg, m);
		LDKCVec_RouteHopZ paths_arg_conv_12_constr;
		paths_arg_conv_12_constr.datalen = (*env)->GetArrayLength(env, paths_arg_conv_12);
		if (paths_arg_conv_12_constr.datalen > 0)
			paths_arg_conv_12_constr.data = MALLOC(paths_arg_conv_12_constr.datalen * sizeof(LDKRouteHop), "LDKCVec_RouteHopZ Elements");
		else
			paths_arg_conv_12_constr.data = NULL;
		int64_t* paths_arg_conv_12_vals = (*env)->GetLongArrayElements (env, paths_arg_conv_12, NULL);
		for (size_t k = 0; k < paths_arg_conv_12_constr.datalen; k++) {
			int64_t paths_arg_conv_12_conv_10 = paths_arg_conv_12_vals[k];
			LDKRouteHop paths_arg_conv_12_conv_10_conv;
			paths_arg_conv_12_conv_10_conv.inner = (void*)(paths_arg_conv_12_conv_10 & (~1));
			paths_arg_conv_12_conv_10_conv.is_owned = (paths_arg_conv_12_conv_10 & 1) || (paths_arg_conv_12_conv_10 == 0);
			paths_arg_conv_12_conv_10_conv = RouteHop_clone(&paths_arg_conv_12_conv_10_conv);
			paths_arg_conv_12_constr.data[k] = paths_arg_conv_12_conv_10_conv;
		}
		(*env)->ReleaseLongArrayElements(env, paths_arg_conv_12, paths_arg_conv_12_vals, 0);
		paths_arg_constr.data[m] = paths_arg_conv_12_constr;
	}
	LDKPayee payee_arg_conv;
	payee_arg_conv.inner = (void*)(payee_arg & (~1));
	payee_arg_conv.is_owned = (payee_arg & 1) || (payee_arg == 0);
	payee_arg_conv = Payee_clone(&payee_arg_conv);
	LDKRoute ret_var = Route_new(paths_arg_constr, payee_arg_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_Route_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKRoute orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKRoute ret_var = Route_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_Route_1hash(JNIEnv *env, jclass clz, int64_t o) {
	LDKRoute o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = false;
	int64_t ret_val = Route_hash(&o_conv);
	return ret_val;
}

JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_Route_1eq(JNIEnv *env, jclass clz, int64_t a, int64_t b) {
	LDKRoute a_conv;
	a_conv.inner = (void*)(a & (~1));
	a_conv.is_owned = false;
	LDKRoute b_conv;
	b_conv.inner = (void*)(b & (~1));
	b_conv.is_owned = false;
	jboolean ret_val = Route_eq(&a_conv, &b_conv);
	return ret_val;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_Route_1get_1total_1fees(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKRoute this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	int64_t ret_val = Route_get_total_fees(&this_arg_conv);
	return ret_val;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_Route_1get_1total_1amount(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKRoute this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	int64_t ret_val = Route_get_total_amount(&this_arg_conv);
	return ret_val;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_Route_1write(JNIEnv *env, jclass clz, int64_t obj) {
	LDKRoute obj_conv;
	obj_conv.inner = (void*)(obj & (~1));
	obj_conv.is_owned = false;
	LDKCVec_u8Z ret_var = Route_write(&obj_conv);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	CVec_u8Z_free(ret_var);
	return ret_arr;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_Route_1read(JNIEnv *env, jclass clz, int8_tArray ser) {
	LDKu8slice ser_ref;
	ser_ref.datalen = (*env)->GetArrayLength(env, ser);
	ser_ref.data = (*env)->GetByteArrayElements (env, ser, NULL);
	LDKCResult_RouteDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_RouteDecodeErrorZ), "LDKCResult_RouteDecodeErrorZ");
	*ret_conv = Route_read(ser_ref);
	(*env)->ReleaseByteArrayElements(env, ser, (int8_t*)ser_ref.data, 0);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_RouteParameters_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKRouteParameters this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	RouteParameters_free(this_obj_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_RouteParameters_1get_1payee(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKRouteParameters this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKPayee ret_var = RouteParameters_get_payee(&this_ptr_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_RouteParameters_1set_1payee(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKRouteParameters this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKPayee val_conv;
	val_conv.inner = (void*)(val & (~1));
	val_conv.is_owned = (val & 1) || (val == 0);
	val_conv = Payee_clone(&val_conv);
	RouteParameters_set_payee(&this_ptr_conv, val_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_RouteParameters_1get_1final_1value_1msat(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKRouteParameters this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int64_t ret_val = RouteParameters_get_final_value_msat(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_RouteParameters_1set_1final_1value_1msat(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKRouteParameters this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	RouteParameters_set_final_value_msat(&this_ptr_conv, val);
}

JNIEXPORT int32_t JNICALL Java_org_ldk_impl_bindings_RouteParameters_1get_1final_1cltv_1expiry_1delta(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKRouteParameters this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int32_t ret_val = RouteParameters_get_final_cltv_expiry_delta(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_RouteParameters_1set_1final_1cltv_1expiry_1delta(JNIEnv *env, jclass clz, int64_t this_ptr, int32_t val) {
	LDKRouteParameters this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	RouteParameters_set_final_cltv_expiry_delta(&this_ptr_conv, val);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_RouteParameters_1new(JNIEnv *env, jclass clz, int64_t payee_arg, int64_t final_value_msat_arg, int32_t final_cltv_expiry_delta_arg) {
	LDKPayee payee_arg_conv;
	payee_arg_conv.inner = (void*)(payee_arg & (~1));
	payee_arg_conv.is_owned = (payee_arg & 1) || (payee_arg == 0);
	payee_arg_conv = Payee_clone(&payee_arg_conv);
	LDKRouteParameters ret_var = RouteParameters_new(payee_arg_conv, final_value_msat_arg, final_cltv_expiry_delta_arg);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_RouteParameters_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKRouteParameters orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKRouteParameters ret_var = RouteParameters_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_RouteParameters_1write(JNIEnv *env, jclass clz, int64_t obj) {
	LDKRouteParameters obj_conv;
	obj_conv.inner = (void*)(obj & (~1));
	obj_conv.is_owned = false;
	LDKCVec_u8Z ret_var = RouteParameters_write(&obj_conv);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	CVec_u8Z_free(ret_var);
	return ret_arr;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_RouteParameters_1read(JNIEnv *env, jclass clz, int8_tArray ser) {
	LDKu8slice ser_ref;
	ser_ref.datalen = (*env)->GetArrayLength(env, ser);
	ser_ref.data = (*env)->GetByteArrayElements (env, ser, NULL);
	LDKCResult_RouteParametersDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_RouteParametersDecodeErrorZ), "LDKCResult_RouteParametersDecodeErrorZ");
	*ret_conv = RouteParameters_read(ser_ref);
	(*env)->ReleaseByteArrayElements(env, ser, (int8_t*)ser_ref.data, 0);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_Payee_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKPayee this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	Payee_free(this_obj_conv);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_Payee_1get_1pubkey(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKPayee this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 33);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 33, Payee_get_pubkey(&this_ptr_conv).compressed_form);
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_Payee_1set_1pubkey(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKPayee this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKPublicKey val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 33);
	(*env)->GetByteArrayRegion(env, val, 0, 33, val_ref.compressed_form);
	Payee_set_pubkey(&this_ptr_conv, val_ref);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_Payee_1get_1features(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKPayee this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKInvoiceFeatures ret_var = Payee_get_features(&this_ptr_conv);
	uint64_t ret_ref = 0;
	if ((uint64_t)ret_var.inner > 4096) {
		CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
		CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
		ret_ref = (uint64_t)ret_var.inner;
		if (ret_var.is_owned) {
			ret_ref |= 1;
		}
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_Payee_1set_1features(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKPayee this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKInvoiceFeatures val_conv;
	val_conv.inner = (void*)(val & (~1));
	val_conv.is_owned = (val & 1) || (val == 0);
	val_conv = InvoiceFeatures_clone(&val_conv);
	Payee_set_features(&this_ptr_conv, val_conv);
}

JNIEXPORT int64_tArray JNICALL Java_org_ldk_impl_bindings_Payee_1get_1route_1hints(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKPayee this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKCVec_RouteHintZ ret_var = Payee_get_route_hints(&this_ptr_conv);
	int64_tArray ret_arr = NULL;
	ret_arr = (*env)->NewLongArray(env, ret_var.datalen);
	int64_t *ret_arr_ptr = (*env)->GetPrimitiveArrayCritical(env, ret_arr, NULL);
	for (size_t l = 0; l < ret_var.datalen; l++) {
		LDKRouteHint ret_conv_11_var = ret_var.data[l];
		uint64_t ret_conv_11_ref = 0;
		CHECK((((uint64_t)ret_conv_11_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
		CHECK((((uint64_t)&ret_conv_11_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
		ret_conv_11_ref = (uint64_t)ret_conv_11_var.inner;
		if (ret_conv_11_var.is_owned) {
			ret_conv_11_ref |= 1;
		}
		ret_arr_ptr[l] = ret_conv_11_ref;
	}
	(*env)->ReleasePrimitiveArrayCritical(env, ret_arr, ret_arr_ptr, 0);
	FREE(ret_var.data);
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_Payee_1set_1route_1hints(JNIEnv *env, jclass clz, int64_t this_ptr, int64_tArray val) {
	LDKPayee this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKCVec_RouteHintZ val_constr;
	val_constr.datalen = (*env)->GetArrayLength(env, val);
	if (val_constr.datalen > 0)
		val_constr.data = MALLOC(val_constr.datalen * sizeof(LDKRouteHint), "LDKCVec_RouteHintZ Elements");
	else
		val_constr.data = NULL;
	int64_t* val_vals = (*env)->GetLongArrayElements (env, val, NULL);
	for (size_t l = 0; l < val_constr.datalen; l++) {
		int64_t val_conv_11 = val_vals[l];
		LDKRouteHint val_conv_11_conv;
		val_conv_11_conv.inner = (void*)(val_conv_11 & (~1));
		val_conv_11_conv.is_owned = (val_conv_11 & 1) || (val_conv_11 == 0);
		val_conv_11_conv = RouteHint_clone(&val_conv_11_conv);
		val_constr.data[l] = val_conv_11_conv;
	}
	(*env)->ReleaseLongArrayElements(env, val, val_vals, 0);
	Payee_set_route_hints(&this_ptr_conv, val_constr);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_Payee_1get_1expiry_1time(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKPayee this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKCOption_u64Z *ret_copy = MALLOC(sizeof(LDKCOption_u64Z), "LDKCOption_u64Z");
	*ret_copy = Payee_get_expiry_time(&this_ptr_conv);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_Payee_1set_1expiry_1time(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKPayee this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	void* val_ptr = (void*)(((uint64_t)val) & ~1);
	CHECK_ACCESS(val_ptr);
	LDKCOption_u64Z val_conv = *(LDKCOption_u64Z*)(val_ptr);
	val_conv = COption_u64Z_clone((LDKCOption_u64Z*)(((uint64_t)val) & ~1));
	Payee_set_expiry_time(&this_ptr_conv, val_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_Payee_1new(JNIEnv *env, jclass clz, int8_tArray pubkey_arg, int64_t features_arg, int64_tArray route_hints_arg, int64_t expiry_time_arg) {
	LDKPublicKey pubkey_arg_ref;
	CHECK((*env)->GetArrayLength(env, pubkey_arg) == 33);
	(*env)->GetByteArrayRegion(env, pubkey_arg, 0, 33, pubkey_arg_ref.compressed_form);
	LDKInvoiceFeatures features_arg_conv;
	features_arg_conv.inner = (void*)(features_arg & (~1));
	features_arg_conv.is_owned = (features_arg & 1) || (features_arg == 0);
	features_arg_conv = InvoiceFeatures_clone(&features_arg_conv);
	LDKCVec_RouteHintZ route_hints_arg_constr;
	route_hints_arg_constr.datalen = (*env)->GetArrayLength(env, route_hints_arg);
	if (route_hints_arg_constr.datalen > 0)
		route_hints_arg_constr.data = MALLOC(route_hints_arg_constr.datalen * sizeof(LDKRouteHint), "LDKCVec_RouteHintZ Elements");
	else
		route_hints_arg_constr.data = NULL;
	int64_t* route_hints_arg_vals = (*env)->GetLongArrayElements (env, route_hints_arg, NULL);
	for (size_t l = 0; l < route_hints_arg_constr.datalen; l++) {
		int64_t route_hints_arg_conv_11 = route_hints_arg_vals[l];
		LDKRouteHint route_hints_arg_conv_11_conv;
		route_hints_arg_conv_11_conv.inner = (void*)(route_hints_arg_conv_11 & (~1));
		route_hints_arg_conv_11_conv.is_owned = (route_hints_arg_conv_11 & 1) || (route_hints_arg_conv_11 == 0);
		route_hints_arg_conv_11_conv = RouteHint_clone(&route_hints_arg_conv_11_conv);
		route_hints_arg_constr.data[l] = route_hints_arg_conv_11_conv;
	}
	(*env)->ReleaseLongArrayElements(env, route_hints_arg, route_hints_arg_vals, 0);
	void* expiry_time_arg_ptr = (void*)(((uint64_t)expiry_time_arg) & ~1);
	CHECK_ACCESS(expiry_time_arg_ptr);
	LDKCOption_u64Z expiry_time_arg_conv = *(LDKCOption_u64Z*)(expiry_time_arg_ptr);
	expiry_time_arg_conv = COption_u64Z_clone((LDKCOption_u64Z*)(((uint64_t)expiry_time_arg) & ~1));
	LDKPayee ret_var = Payee_new(pubkey_arg_ref, features_arg_conv, route_hints_arg_constr, expiry_time_arg_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_Payee_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKPayee orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKPayee ret_var = Payee_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_Payee_1hash(JNIEnv *env, jclass clz, int64_t o) {
	LDKPayee o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = false;
	int64_t ret_val = Payee_hash(&o_conv);
	return ret_val;
}

JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_Payee_1eq(JNIEnv *env, jclass clz, int64_t a, int64_t b) {
	LDKPayee a_conv;
	a_conv.inner = (void*)(a & (~1));
	a_conv.is_owned = false;
	LDKPayee b_conv;
	b_conv.inner = (void*)(b & (~1));
	b_conv.is_owned = false;
	jboolean ret_val = Payee_eq(&a_conv, &b_conv);
	return ret_val;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_Payee_1write(JNIEnv *env, jclass clz, int64_t obj) {
	LDKPayee obj_conv;
	obj_conv.inner = (void*)(obj & (~1));
	obj_conv.is_owned = false;
	LDKCVec_u8Z ret_var = Payee_write(&obj_conv);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	CVec_u8Z_free(ret_var);
	return ret_arr;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_Payee_1read(JNIEnv *env, jclass clz, int8_tArray ser) {
	LDKu8slice ser_ref;
	ser_ref.datalen = (*env)->GetArrayLength(env, ser);
	ser_ref.data = (*env)->GetByteArrayElements (env, ser, NULL);
	LDKCResult_PayeeDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_PayeeDecodeErrorZ), "LDKCResult_PayeeDecodeErrorZ");
	*ret_conv = Payee_read(ser_ref);
	(*env)->ReleaseByteArrayElements(env, ser, (int8_t*)ser_ref.data, 0);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_Payee_1from_1node_1id(JNIEnv *env, jclass clz, int8_tArray pubkey) {
	LDKPublicKey pubkey_ref;
	CHECK((*env)->GetArrayLength(env, pubkey) == 33);
	(*env)->GetByteArrayRegion(env, pubkey, 0, 33, pubkey_ref.compressed_form);
	LDKPayee ret_var = Payee_from_node_id(pubkey_ref);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_Payee_1for_1keysend(JNIEnv *env, jclass clz, int8_tArray pubkey) {
	LDKPublicKey pubkey_ref;
	CHECK((*env)->GetArrayLength(env, pubkey) == 33);
	(*env)->GetByteArrayRegion(env, pubkey, 0, 33, pubkey_ref.compressed_form);
	LDKPayee ret_var = Payee_for_keysend(pubkey_ref);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_RouteHint_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKRouteHint this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	RouteHint_free(this_obj_conv);
}

JNIEXPORT int64_tArray JNICALL Java_org_ldk_impl_bindings_RouteHint_1get_1a(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKRouteHint this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKCVec_RouteHintHopZ ret_var = RouteHint_get_a(&this_ptr_conv);
	int64_tArray ret_arr = NULL;
	ret_arr = (*env)->NewLongArray(env, ret_var.datalen);
	int64_t *ret_arr_ptr = (*env)->GetPrimitiveArrayCritical(env, ret_arr, NULL);
	for (size_t o = 0; o < ret_var.datalen; o++) {
		LDKRouteHintHop ret_conv_14_var = ret_var.data[o];
		uint64_t ret_conv_14_ref = 0;
		CHECK((((uint64_t)ret_conv_14_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
		CHECK((((uint64_t)&ret_conv_14_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
		ret_conv_14_ref = (uint64_t)ret_conv_14_var.inner;
		if (ret_conv_14_var.is_owned) {
			ret_conv_14_ref |= 1;
		}
		ret_arr_ptr[o] = ret_conv_14_ref;
	}
	(*env)->ReleasePrimitiveArrayCritical(env, ret_arr, ret_arr_ptr, 0);
	FREE(ret_var.data);
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_RouteHint_1set_1a(JNIEnv *env, jclass clz, int64_t this_ptr, int64_tArray val) {
	LDKRouteHint this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKCVec_RouteHintHopZ val_constr;
	val_constr.datalen = (*env)->GetArrayLength(env, val);
	if (val_constr.datalen > 0)
		val_constr.data = MALLOC(val_constr.datalen * sizeof(LDKRouteHintHop), "LDKCVec_RouteHintHopZ Elements");
	else
		val_constr.data = NULL;
	int64_t* val_vals = (*env)->GetLongArrayElements (env, val, NULL);
	for (size_t o = 0; o < val_constr.datalen; o++) {
		int64_t val_conv_14 = val_vals[o];
		LDKRouteHintHop val_conv_14_conv;
		val_conv_14_conv.inner = (void*)(val_conv_14 & (~1));
		val_conv_14_conv.is_owned = (val_conv_14 & 1) || (val_conv_14 == 0);
		val_conv_14_conv = RouteHintHop_clone(&val_conv_14_conv);
		val_constr.data[o] = val_conv_14_conv;
	}
	(*env)->ReleaseLongArrayElements(env, val, val_vals, 0);
	RouteHint_set_a(&this_ptr_conv, val_constr);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_RouteHint_1new(JNIEnv *env, jclass clz, int64_tArray a_arg) {
	LDKCVec_RouteHintHopZ a_arg_constr;
	a_arg_constr.datalen = (*env)->GetArrayLength(env, a_arg);
	if (a_arg_constr.datalen > 0)
		a_arg_constr.data = MALLOC(a_arg_constr.datalen * sizeof(LDKRouteHintHop), "LDKCVec_RouteHintHopZ Elements");
	else
		a_arg_constr.data = NULL;
	int64_t* a_arg_vals = (*env)->GetLongArrayElements (env, a_arg, NULL);
	for (size_t o = 0; o < a_arg_constr.datalen; o++) {
		int64_t a_arg_conv_14 = a_arg_vals[o];
		LDKRouteHintHop a_arg_conv_14_conv;
		a_arg_conv_14_conv.inner = (void*)(a_arg_conv_14 & (~1));
		a_arg_conv_14_conv.is_owned = (a_arg_conv_14 & 1) || (a_arg_conv_14 == 0);
		a_arg_conv_14_conv = RouteHintHop_clone(&a_arg_conv_14_conv);
		a_arg_constr.data[o] = a_arg_conv_14_conv;
	}
	(*env)->ReleaseLongArrayElements(env, a_arg, a_arg_vals, 0);
	LDKRouteHint ret_var = RouteHint_new(a_arg_constr);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_RouteHint_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKRouteHint orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKRouteHint ret_var = RouteHint_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_RouteHint_1hash(JNIEnv *env, jclass clz, int64_t o) {
	LDKRouteHint o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = false;
	int64_t ret_val = RouteHint_hash(&o_conv);
	return ret_val;
}

JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_RouteHint_1eq(JNIEnv *env, jclass clz, int64_t a, int64_t b) {
	LDKRouteHint a_conv;
	a_conv.inner = (void*)(a & (~1));
	a_conv.is_owned = false;
	LDKRouteHint b_conv;
	b_conv.inner = (void*)(b & (~1));
	b_conv.is_owned = false;
	jboolean ret_val = RouteHint_eq(&a_conv, &b_conv);
	return ret_val;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_RouteHint_1write(JNIEnv *env, jclass clz, int64_t obj) {
	LDKRouteHint obj_conv;
	obj_conv.inner = (void*)(obj & (~1));
	obj_conv.is_owned = false;
	LDKCVec_u8Z ret_var = RouteHint_write(&obj_conv);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	CVec_u8Z_free(ret_var);
	return ret_arr;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_RouteHint_1read(JNIEnv *env, jclass clz, int8_tArray ser) {
	LDKu8slice ser_ref;
	ser_ref.datalen = (*env)->GetArrayLength(env, ser);
	ser_ref.data = (*env)->GetByteArrayElements (env, ser, NULL);
	LDKCResult_RouteHintDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_RouteHintDecodeErrorZ), "LDKCResult_RouteHintDecodeErrorZ");
	*ret_conv = RouteHint_read(ser_ref);
	(*env)->ReleaseByteArrayElements(env, ser, (int8_t*)ser_ref.data, 0);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_RouteHintHop_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKRouteHintHop this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	RouteHintHop_free(this_obj_conv);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_RouteHintHop_1get_1src_1node_1id(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKRouteHintHop this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 33);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 33, RouteHintHop_get_src_node_id(&this_ptr_conv).compressed_form);
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_RouteHintHop_1set_1src_1node_1id(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKRouteHintHop this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKPublicKey val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 33);
	(*env)->GetByteArrayRegion(env, val, 0, 33, val_ref.compressed_form);
	RouteHintHop_set_src_node_id(&this_ptr_conv, val_ref);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_RouteHintHop_1get_1short_1channel_1id(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKRouteHintHop this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int64_t ret_val = RouteHintHop_get_short_channel_id(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_RouteHintHop_1set_1short_1channel_1id(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKRouteHintHop this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	RouteHintHop_set_short_channel_id(&this_ptr_conv, val);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_RouteHintHop_1get_1fees(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKRouteHintHop this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKRoutingFees ret_var = RouteHintHop_get_fees(&this_ptr_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_RouteHintHop_1set_1fees(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKRouteHintHop this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKRoutingFees val_conv;
	val_conv.inner = (void*)(val & (~1));
	val_conv.is_owned = (val & 1) || (val == 0);
	val_conv = RoutingFees_clone(&val_conv);
	RouteHintHop_set_fees(&this_ptr_conv, val_conv);
}

JNIEXPORT int16_t JNICALL Java_org_ldk_impl_bindings_RouteHintHop_1get_1cltv_1expiry_1delta(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKRouteHintHop this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int16_t ret_val = RouteHintHop_get_cltv_expiry_delta(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_RouteHintHop_1set_1cltv_1expiry_1delta(JNIEnv *env, jclass clz, int64_t this_ptr, int16_t val) {
	LDKRouteHintHop this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	RouteHintHop_set_cltv_expiry_delta(&this_ptr_conv, val);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_RouteHintHop_1get_1htlc_1minimum_1msat(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKRouteHintHop this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKCOption_u64Z *ret_copy = MALLOC(sizeof(LDKCOption_u64Z), "LDKCOption_u64Z");
	*ret_copy = RouteHintHop_get_htlc_minimum_msat(&this_ptr_conv);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_RouteHintHop_1set_1htlc_1minimum_1msat(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKRouteHintHop this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	void* val_ptr = (void*)(((uint64_t)val) & ~1);
	CHECK_ACCESS(val_ptr);
	LDKCOption_u64Z val_conv = *(LDKCOption_u64Z*)(val_ptr);
	val_conv = COption_u64Z_clone((LDKCOption_u64Z*)(((uint64_t)val) & ~1));
	RouteHintHop_set_htlc_minimum_msat(&this_ptr_conv, val_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_RouteHintHop_1get_1htlc_1maximum_1msat(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKRouteHintHop this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKCOption_u64Z *ret_copy = MALLOC(sizeof(LDKCOption_u64Z), "LDKCOption_u64Z");
	*ret_copy = RouteHintHop_get_htlc_maximum_msat(&this_ptr_conv);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_RouteHintHop_1set_1htlc_1maximum_1msat(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKRouteHintHop this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	void* val_ptr = (void*)(((uint64_t)val) & ~1);
	CHECK_ACCESS(val_ptr);
	LDKCOption_u64Z val_conv = *(LDKCOption_u64Z*)(val_ptr);
	val_conv = COption_u64Z_clone((LDKCOption_u64Z*)(((uint64_t)val) & ~1));
	RouteHintHop_set_htlc_maximum_msat(&this_ptr_conv, val_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_RouteHintHop_1new(JNIEnv *env, jclass clz, int8_tArray src_node_id_arg, int64_t short_channel_id_arg, int64_t fees_arg, int16_t cltv_expiry_delta_arg, int64_t htlc_minimum_msat_arg, int64_t htlc_maximum_msat_arg) {
	LDKPublicKey src_node_id_arg_ref;
	CHECK((*env)->GetArrayLength(env, src_node_id_arg) == 33);
	(*env)->GetByteArrayRegion(env, src_node_id_arg, 0, 33, src_node_id_arg_ref.compressed_form);
	LDKRoutingFees fees_arg_conv;
	fees_arg_conv.inner = (void*)(fees_arg & (~1));
	fees_arg_conv.is_owned = (fees_arg & 1) || (fees_arg == 0);
	fees_arg_conv = RoutingFees_clone(&fees_arg_conv);
	void* htlc_minimum_msat_arg_ptr = (void*)(((uint64_t)htlc_minimum_msat_arg) & ~1);
	CHECK_ACCESS(htlc_minimum_msat_arg_ptr);
	LDKCOption_u64Z htlc_minimum_msat_arg_conv = *(LDKCOption_u64Z*)(htlc_minimum_msat_arg_ptr);
	htlc_minimum_msat_arg_conv = COption_u64Z_clone((LDKCOption_u64Z*)(((uint64_t)htlc_minimum_msat_arg) & ~1));
	void* htlc_maximum_msat_arg_ptr = (void*)(((uint64_t)htlc_maximum_msat_arg) & ~1);
	CHECK_ACCESS(htlc_maximum_msat_arg_ptr);
	LDKCOption_u64Z htlc_maximum_msat_arg_conv = *(LDKCOption_u64Z*)(htlc_maximum_msat_arg_ptr);
	htlc_maximum_msat_arg_conv = COption_u64Z_clone((LDKCOption_u64Z*)(((uint64_t)htlc_maximum_msat_arg) & ~1));
	LDKRouteHintHop ret_var = RouteHintHop_new(src_node_id_arg_ref, short_channel_id_arg, fees_arg_conv, cltv_expiry_delta_arg, htlc_minimum_msat_arg_conv, htlc_maximum_msat_arg_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_RouteHintHop_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKRouteHintHop orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKRouteHintHop ret_var = RouteHintHop_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_RouteHintHop_1hash(JNIEnv *env, jclass clz, int64_t o) {
	LDKRouteHintHop o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = false;
	int64_t ret_val = RouteHintHop_hash(&o_conv);
	return ret_val;
}

JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_RouteHintHop_1eq(JNIEnv *env, jclass clz, int64_t a, int64_t b) {
	LDKRouteHintHop a_conv;
	a_conv.inner = (void*)(a & (~1));
	a_conv.is_owned = false;
	LDKRouteHintHop b_conv;
	b_conv.inner = (void*)(b & (~1));
	b_conv.is_owned = false;
	jboolean ret_val = RouteHintHop_eq(&a_conv, &b_conv);
	return ret_val;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_RouteHintHop_1write(JNIEnv *env, jclass clz, int64_t obj) {
	LDKRouteHintHop obj_conv;
	obj_conv.inner = (void*)(obj & (~1));
	obj_conv.is_owned = false;
	LDKCVec_u8Z ret_var = RouteHintHop_write(&obj_conv);
	int8_tArray ret_arr = (*env)->NewByteArray(env, ret_var.datalen);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, ret_var.datalen, ret_var.data);
	CVec_u8Z_free(ret_var);
	return ret_arr;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_RouteHintHop_1read(JNIEnv *env, jclass clz, int8_tArray ser) {
	LDKu8slice ser_ref;
	ser_ref.datalen = (*env)->GetArrayLength(env, ser);
	ser_ref.data = (*env)->GetByteArrayElements (env, ser, NULL);
	LDKCResult_RouteHintHopDecodeErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_RouteHintHopDecodeErrorZ), "LDKCResult_RouteHintHopDecodeErrorZ");
	*ret_conv = RouteHintHop_read(ser_ref);
	(*env)->ReleaseByteArrayElements(env, ser, (int8_t*)ser_ref.data, 0);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_find_1route(JNIEnv *env, jclass clz, int8_tArray our_node_pubkey, int64_t params, int64_t network, int64_tArray first_hops, int64_t logger, int64_t scorer) {
	LDKPublicKey our_node_pubkey_ref;
	CHECK((*env)->GetArrayLength(env, our_node_pubkey) == 33);
	(*env)->GetByteArrayRegion(env, our_node_pubkey, 0, 33, our_node_pubkey_ref.compressed_form);
	LDKRouteParameters params_conv;
	params_conv.inner = (void*)(params & (~1));
	params_conv.is_owned = false;
	LDKNetworkGraph network_conv;
	network_conv.inner = (void*)(network & (~1));
	network_conv.is_owned = false;
	LDKCVec_ChannelDetailsZ first_hops_constr;
	LDKCVec_ChannelDetailsZ *first_hops_ptr = NULL;
	if (first_hops != NULL) {
		first_hops_constr.datalen = (*env)->GetArrayLength(env, first_hops);
		if (first_hops_constr.datalen > 0)
			first_hops_constr.data = MALLOC(first_hops_constr.datalen * sizeof(LDKChannelDetails), "LDKCVec_ChannelDetailsZ Elements");
		else
			first_hops_constr.data = NULL;
		int64_t* first_hops_vals = (*env)->GetLongArrayElements (env, first_hops, NULL);
		for (size_t q = 0; q < first_hops_constr.datalen; q++) {
			int64_t first_hops_conv_16 = first_hops_vals[q];
			LDKChannelDetails first_hops_conv_16_conv;
			first_hops_conv_16_conv.inner = (void*)(first_hops_conv_16 & (~1));
			first_hops_conv_16_conv.is_owned = (first_hops_conv_16 & 1) || (first_hops_conv_16 == 0);
			first_hops_constr.data[q] = first_hops_conv_16_conv;
		}
		(*env)->ReleaseLongArrayElements(env, first_hops, first_hops_vals, 0);
		first_hops_ptr = &first_hops_constr;
	}
	void* logger_ptr = (void*)(((uint64_t)logger) & ~1);
	CHECK_ACCESS(logger_ptr);
	LDKLogger logger_conv = *(LDKLogger*)(logger_ptr);
	if (logger_conv.free == LDKLogger_JCalls_free) {
		// If this_arg is a JCalls struct, then we need to increment the refcnt in it.
		LDKLogger_JCalls_cloned(&logger_conv);
	}
	void* scorer_ptr = (void*)(((uint64_t)scorer) & ~1);
	if (!(scorer & 1)) { CHECK_ACCESS(scorer_ptr); }
	LDKScore* scorer_conv = (LDKScore*)scorer_ptr;
	LDKCResult_RouteLightningErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_RouteLightningErrorZ), "LDKCResult_RouteLightningErrorZ");
	*ret_conv = find_route(our_node_pubkey_ref, &params_conv, &network_conv, first_hops_ptr, logger_conv, scorer_conv);
	if (first_hops_ptr != NULL) { FREE(first_hops_constr.data); }
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_Scorer_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKScorer this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	Scorer_free(this_obj_conv);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ScoringParameters_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKScoringParameters this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	ScoringParameters_free(this_obj_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ScoringParameters_1get_1base_1penalty_1msat(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKScoringParameters this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int64_t ret_val = ScoringParameters_get_base_penalty_msat(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ScoringParameters_1set_1base_1penalty_1msat(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKScoringParameters this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	ScoringParameters_set_base_penalty_msat(&this_ptr_conv, val);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ScoringParameters_1get_1failure_1penalty_1msat(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKScoringParameters this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int64_t ret_val = ScoringParameters_get_failure_penalty_msat(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ScoringParameters_1set_1failure_1penalty_1msat(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKScoringParameters this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	ScoringParameters_set_failure_penalty_msat(&this_ptr_conv, val);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ScoringParameters_1get_1failure_1penalty_1half_1life(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKScoringParameters this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int64_t ret_val = ScoringParameters_get_failure_penalty_half_life(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ScoringParameters_1set_1failure_1penalty_1half_1life(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKScoringParameters this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	ScoringParameters_set_failure_penalty_half_life(&this_ptr_conv, val);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ScoringParameters_1new(JNIEnv *env, jclass clz, int64_t base_penalty_msat_arg, int64_t failure_penalty_msat_arg, int64_t failure_penalty_half_life_arg) {
	LDKScoringParameters ret_var = ScoringParameters_new(base_penalty_msat_arg, failure_penalty_msat_arg, failure_penalty_half_life_arg);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_Scorer_1new(JNIEnv *env, jclass clz, int64_t params) {
	LDKScoringParameters params_conv;
	params_conv.inner = (void*)(params & (~1));
	params_conv.is_owned = (params & 1) || (params == 0);
	// Warning: we need a move here but no clone is available for LDKScoringParameters
	LDKScorer ret_var = Scorer_new(params_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_Scorer_1default(JNIEnv *env, jclass clz) {
	LDKScorer ret_var = Scorer_default();
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ScoringParameters_1default(JNIEnv *env, jclass clz) {
	LDKScoringParameters ret_var = ScoringParameters_default();
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_Scorer_1as_1Score(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKScorer this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKScore* ret_ret = MALLOC(sizeof(LDKScore), "LDKScore");
	*ret_ret = Scorer_as_Score(&this_arg_conv);
	return (uint64_t)ret_ret;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_FilesystemPersister_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKFilesystemPersister this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	FilesystemPersister_free(this_obj_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_FilesystemPersister_1new(JNIEnv *env, jclass clz, jstring path_to_channel_data) {
	LDKStr path_to_channel_data_conv = java_to_owned_str(env, path_to_channel_data);
	LDKFilesystemPersister ret_var = FilesystemPersister_new(path_to_channel_data_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT jstring JNICALL Java_org_ldk_impl_bindings_FilesystemPersister_1get_1data_1dir(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKFilesystemPersister this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKStr ret_str = FilesystemPersister_get_data_dir(&this_arg_conv);
	jstring ret_conv = str_ref_to_java(env, ret_str.chars, ret_str.len);
	Str_free(ret_str);
	return ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_FilesystemPersister_1persist_1manager(JNIEnv *env, jclass clz, jstring data_dir, int64_t manager) {
	LDKStr data_dir_conv = java_to_owned_str(env, data_dir);
	LDKChannelManager manager_conv;
	manager_conv.inner = (void*)(manager & (~1));
	manager_conv.is_owned = false;
	LDKCResult_NoneErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_NoneErrorZ), "LDKCResult_NoneErrorZ");
	*ret_conv = FilesystemPersister_persist_manager(data_dir_conv, &manager_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_FilesystemPersister_1read_1channelmonitors(JNIEnv *env, jclass clz, int64_t this_arg, int64_t keys_manager) {
	LDKFilesystemPersister this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	void* keys_manager_ptr = (void*)(((uint64_t)keys_manager) & ~1);
	CHECK_ACCESS(keys_manager_ptr);
	LDKKeysInterface keys_manager_conv = *(LDKKeysInterface*)(keys_manager_ptr);
	if (keys_manager_conv.free == LDKKeysInterface_JCalls_free) {
		// If this_arg is a JCalls struct, then we need to increment the refcnt in it.
		LDKKeysInterface_JCalls_cloned(&keys_manager_conv);
	}
	LDKCResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ), "LDKCResult_CVec_C2Tuple_BlockHashChannelMonitorZZErrorZ");
	*ret_conv = FilesystemPersister_read_channelmonitors(&this_arg_conv, keys_manager_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_FilesystemPersister_1as_1Persist(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKFilesystemPersister this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKPersist* ret_ret = MALLOC(sizeof(LDKPersist), "LDKPersist");
	*ret_ret = FilesystemPersister_as_Persist(&this_arg_conv);
	return (uint64_t)ret_ret;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_BackgroundProcessor_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKBackgroundProcessor this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	BackgroundProcessor_free(this_obj_conv);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ChannelManagerPersister_1free(JNIEnv *env, jclass clz, int64_t this_ptr) {
	if ((this_ptr & 1) != 0) return;
	void* this_ptr_ptr = (void*)(((uint64_t)this_ptr) & ~1);
	CHECK_ACCESS(this_ptr_ptr);
	LDKChannelManagerPersister this_ptr_conv = *(LDKChannelManagerPersister*)(this_ptr_ptr);
	FREE((void*)this_ptr);
	ChannelManagerPersister_free(this_ptr_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_BackgroundProcessor_1start(JNIEnv *env, jclass clz, int64_t persister, int64_t event_handler, int64_t chain_monitor, int64_t channel_manager, int64_t net_graph_msg_handler, int64_t peer_manager, int64_t logger) {
	void* persister_ptr = (void*)(((uint64_t)persister) & ~1);
	CHECK_ACCESS(persister_ptr);
	LDKChannelManagerPersister persister_conv = *(LDKChannelManagerPersister*)(persister_ptr);
	if (persister_conv.free == LDKChannelManagerPersister_JCalls_free) {
		// If this_arg is a JCalls struct, then we need to increment the refcnt in it.
		LDKChannelManagerPersister_JCalls_cloned(&persister_conv);
	}
	void* event_handler_ptr = (void*)(((uint64_t)event_handler) & ~1);
	CHECK_ACCESS(event_handler_ptr);
	LDKEventHandler event_handler_conv = *(LDKEventHandler*)(event_handler_ptr);
	if (event_handler_conv.free == LDKEventHandler_JCalls_free) {
		// If this_arg is a JCalls struct, then we need to increment the refcnt in it.
		LDKEventHandler_JCalls_cloned(&event_handler_conv);
	}
	LDKChainMonitor chain_monitor_conv;
	chain_monitor_conv.inner = (void*)(chain_monitor & (~1));
	chain_monitor_conv.is_owned = false;
	LDKChannelManager channel_manager_conv;
	channel_manager_conv.inner = (void*)(channel_manager & (~1));
	channel_manager_conv.is_owned = false;
	LDKNetGraphMsgHandler net_graph_msg_handler_conv;
	net_graph_msg_handler_conv.inner = (void*)(net_graph_msg_handler & (~1));
	net_graph_msg_handler_conv.is_owned = (net_graph_msg_handler & 1) || (net_graph_msg_handler == 0);
	LDKPeerManager peer_manager_conv;
	peer_manager_conv.inner = (void*)(peer_manager & (~1));
	peer_manager_conv.is_owned = false;
	void* logger_ptr = (void*)(((uint64_t)logger) & ~1);
	CHECK_ACCESS(logger_ptr);
	LDKLogger logger_conv = *(LDKLogger*)(logger_ptr);
	if (logger_conv.free == LDKLogger_JCalls_free) {
		// If this_arg is a JCalls struct, then we need to increment the refcnt in it.
		LDKLogger_JCalls_cloned(&logger_conv);
	}
	LDKBackgroundProcessor ret_var = BackgroundProcessor_start(persister_conv, event_handler_conv, &chain_monitor_conv, &channel_manager_conv, net_graph_msg_handler_conv, &peer_manager_conv, logger_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_BackgroundProcessor_1join(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKBackgroundProcessor this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = (this_arg & 1) || (this_arg == 0);
	// Warning: we need a move here but no clone is available for LDKBackgroundProcessor
	LDKCResult_NoneErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_NoneErrorZ), "LDKCResult_NoneErrorZ");
	*ret_conv = BackgroundProcessor_join(this_arg_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_BackgroundProcessor_1stop(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKBackgroundProcessor this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = (this_arg & 1) || (this_arg == 0);
	// Warning: we need a move here but no clone is available for LDKBackgroundProcessor
	LDKCResult_NoneErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_NoneErrorZ), "LDKCResult_NoneErrorZ");
	*ret_conv = BackgroundProcessor_stop(this_arg_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_check_1platform(JNIEnv *env, jclass clz) {
	check_platform();
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_Invoice_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKInvoice this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	Invoice_free(this_obj_conv);
}

JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_Invoice_1eq(JNIEnv *env, jclass clz, int64_t a, int64_t b) {
	LDKInvoice a_conv;
	a_conv.inner = (void*)(a & (~1));
	a_conv.is_owned = false;
	LDKInvoice b_conv;
	b_conv.inner = (void*)(b & (~1));
	b_conv.is_owned = false;
	jboolean ret_val = Invoice_eq(&a_conv, &b_conv);
	return ret_val;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_Invoice_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKInvoice orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKInvoice ret_var = Invoice_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_SignedRawInvoice_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKSignedRawInvoice this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	SignedRawInvoice_free(this_obj_conv);
}

JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_SignedRawInvoice_1eq(JNIEnv *env, jclass clz, int64_t a, int64_t b) {
	LDKSignedRawInvoice a_conv;
	a_conv.inner = (void*)(a & (~1));
	a_conv.is_owned = false;
	LDKSignedRawInvoice b_conv;
	b_conv.inner = (void*)(b & (~1));
	b_conv.is_owned = false;
	jboolean ret_val = SignedRawInvoice_eq(&a_conv, &b_conv);
	return ret_val;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_SignedRawInvoice_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKSignedRawInvoice orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKSignedRawInvoice ret_var = SignedRawInvoice_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_RawInvoice_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKRawInvoice this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	RawInvoice_free(this_obj_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_RawInvoice_1get_1data(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKRawInvoice this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKRawDataPart ret_var = RawInvoice_get_data(&this_ptr_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_RawInvoice_1set_1data(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKRawInvoice this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKRawDataPart val_conv;
	val_conv.inner = (void*)(val & (~1));
	val_conv.is_owned = (val & 1) || (val == 0);
	val_conv = RawDataPart_clone(&val_conv);
	RawInvoice_set_data(&this_ptr_conv, val_conv);
}

JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_RawInvoice_1eq(JNIEnv *env, jclass clz, int64_t a, int64_t b) {
	LDKRawInvoice a_conv;
	a_conv.inner = (void*)(a & (~1));
	a_conv.is_owned = false;
	LDKRawInvoice b_conv;
	b_conv.inner = (void*)(b & (~1));
	b_conv.is_owned = false;
	jboolean ret_val = RawInvoice_eq(&a_conv, &b_conv);
	return ret_val;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_RawInvoice_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKRawInvoice orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKRawInvoice ret_var = RawInvoice_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_RawDataPart_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKRawDataPart this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	RawDataPart_free(this_obj_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_RawDataPart_1get_1timestamp(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKRawDataPart this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKPositiveTimestamp ret_var = RawDataPart_get_timestamp(&this_ptr_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_RawDataPart_1set_1timestamp(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKRawDataPart this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKPositiveTimestamp val_conv;
	val_conv.inner = (void*)(val & (~1));
	val_conv.is_owned = (val & 1) || (val == 0);
	val_conv = PositiveTimestamp_clone(&val_conv);
	RawDataPart_set_timestamp(&this_ptr_conv, val_conv);
}

JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_RawDataPart_1eq(JNIEnv *env, jclass clz, int64_t a, int64_t b) {
	LDKRawDataPart a_conv;
	a_conv.inner = (void*)(a & (~1));
	a_conv.is_owned = false;
	LDKRawDataPart b_conv;
	b_conv.inner = (void*)(b & (~1));
	b_conv.is_owned = false;
	jboolean ret_val = RawDataPart_eq(&a_conv, &b_conv);
	return ret_val;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_RawDataPart_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKRawDataPart orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKRawDataPart ret_var = RawDataPart_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_PositiveTimestamp_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKPositiveTimestamp this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	PositiveTimestamp_free(this_obj_conv);
}

JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_PositiveTimestamp_1eq(JNIEnv *env, jclass clz, int64_t a, int64_t b) {
	LDKPositiveTimestamp a_conv;
	a_conv.inner = (void*)(a & (~1));
	a_conv.is_owned = false;
	LDKPositiveTimestamp b_conv;
	b_conv.inner = (void*)(b & (~1));
	b_conv.is_owned = false;
	jboolean ret_val = PositiveTimestamp_eq(&a_conv, &b_conv);
	return ret_val;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_PositiveTimestamp_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKPositiveTimestamp orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKPositiveTimestamp ret_var = PositiveTimestamp_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT jclass JNICALL Java_org_ldk_impl_bindings_SiPrefix_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKSiPrefix* orig_conv = (LDKSiPrefix*)(orig & ~1);
	jclass ret_conv = LDKSiPrefix_to_java(env, SiPrefix_clone(orig_conv));
	return ret_conv;
}

JNIEXPORT jclass JNICALL Java_org_ldk_impl_bindings_SiPrefix_1milli(JNIEnv *env, jclass clz) {
	jclass ret_conv = LDKSiPrefix_to_java(env, SiPrefix_milli());
	return ret_conv;
}

JNIEXPORT jclass JNICALL Java_org_ldk_impl_bindings_SiPrefix_1micro(JNIEnv *env, jclass clz) {
	jclass ret_conv = LDKSiPrefix_to_java(env, SiPrefix_micro());
	return ret_conv;
}

JNIEXPORT jclass JNICALL Java_org_ldk_impl_bindings_SiPrefix_1nano(JNIEnv *env, jclass clz) {
	jclass ret_conv = LDKSiPrefix_to_java(env, SiPrefix_nano());
	return ret_conv;
}

JNIEXPORT jclass JNICALL Java_org_ldk_impl_bindings_SiPrefix_1pico(JNIEnv *env, jclass clz) {
	jclass ret_conv = LDKSiPrefix_to_java(env, SiPrefix_pico());
	return ret_conv;
}

JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_SiPrefix_1eq(JNIEnv *env, jclass clz, int64_t a, int64_t b) {
	LDKSiPrefix* a_conv = (LDKSiPrefix*)(a & ~1);
	LDKSiPrefix* b_conv = (LDKSiPrefix*)(b & ~1);
	jboolean ret_val = SiPrefix_eq(a_conv, b_conv);
	return ret_val;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_SiPrefix_1multiplier(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKSiPrefix* this_arg_conv = (LDKSiPrefix*)(this_arg & ~1);
	int64_t ret_val = SiPrefix_multiplier(this_arg_conv);
	return ret_val;
}

JNIEXPORT jclass JNICALL Java_org_ldk_impl_bindings_Currency_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCurrency* orig_conv = (LDKCurrency*)(orig & ~1);
	jclass ret_conv = LDKCurrency_to_java(env, Currency_clone(orig_conv));
	return ret_conv;
}

JNIEXPORT jclass JNICALL Java_org_ldk_impl_bindings_Currency_1bitcoin(JNIEnv *env, jclass clz) {
	jclass ret_conv = LDKCurrency_to_java(env, Currency_bitcoin());
	return ret_conv;
}

JNIEXPORT jclass JNICALL Java_org_ldk_impl_bindings_Currency_1bitcoin_1testnet(JNIEnv *env, jclass clz) {
	jclass ret_conv = LDKCurrency_to_java(env, Currency_bitcoin_testnet());
	return ret_conv;
}

JNIEXPORT jclass JNICALL Java_org_ldk_impl_bindings_Currency_1regtest(JNIEnv *env, jclass clz) {
	jclass ret_conv = LDKCurrency_to_java(env, Currency_regtest());
	return ret_conv;
}

JNIEXPORT jclass JNICALL Java_org_ldk_impl_bindings_Currency_1simnet(JNIEnv *env, jclass clz) {
	jclass ret_conv = LDKCurrency_to_java(env, Currency_simnet());
	return ret_conv;
}

JNIEXPORT jclass JNICALL Java_org_ldk_impl_bindings_Currency_1signet(JNIEnv *env, jclass clz) {
	jclass ret_conv = LDKCurrency_to_java(env, Currency_signet());
	return ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_Currency_1hash(JNIEnv *env, jclass clz, int64_t o) {
	LDKCurrency* o_conv = (LDKCurrency*)(o & ~1);
	int64_t ret_val = Currency_hash(o_conv);
	return ret_val;
}

JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_Currency_1eq(JNIEnv *env, jclass clz, int64_t a, int64_t b) {
	LDKCurrency* a_conv = (LDKCurrency*)(a & ~1);
	LDKCurrency* b_conv = (LDKCurrency*)(b & ~1);
	jboolean ret_val = Currency_eq(a_conv, b_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_Sha256_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKSha256 this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	Sha256_free(this_obj_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_Sha256_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKSha256 orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKSha256 ret_var = Sha256_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_Sha256_1hash(JNIEnv *env, jclass clz, int64_t o) {
	LDKSha256 o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = false;
	int64_t ret_val = Sha256_hash(&o_conv);
	return ret_val;
}

JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_Sha256_1eq(JNIEnv *env, jclass clz, int64_t a, int64_t b) {
	LDKSha256 a_conv;
	a_conv.inner = (void*)(a & (~1));
	a_conv.is_owned = false;
	LDKSha256 b_conv;
	b_conv.inner = (void*)(b & (~1));
	b_conv.is_owned = false;
	jboolean ret_val = Sha256_eq(&a_conv, &b_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_Description_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKDescription this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	Description_free(this_obj_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_Description_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKDescription orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKDescription ret_var = Description_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_Description_1hash(JNIEnv *env, jclass clz, int64_t o) {
	LDKDescription o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = false;
	int64_t ret_val = Description_hash(&o_conv);
	return ret_val;
}

JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_Description_1eq(JNIEnv *env, jclass clz, int64_t a, int64_t b) {
	LDKDescription a_conv;
	a_conv.inner = (void*)(a & (~1));
	a_conv.is_owned = false;
	LDKDescription b_conv;
	b_conv.inner = (void*)(b & (~1));
	b_conv.is_owned = false;
	jboolean ret_val = Description_eq(&a_conv, &b_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_PayeePubKey_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKPayeePubKey this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	PayeePubKey_free(this_obj_conv);
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_PayeePubKey_1get_1a(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKPayeePubKey this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 33);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 33, PayeePubKey_get_a(&this_ptr_conv).compressed_form);
	return ret_arr;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_PayeePubKey_1set_1a(JNIEnv *env, jclass clz, int64_t this_ptr, int8_tArray val) {
	LDKPayeePubKey this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	LDKPublicKey val_ref;
	CHECK((*env)->GetArrayLength(env, val) == 33);
	(*env)->GetByteArrayRegion(env, val, 0, 33, val_ref.compressed_form);
	PayeePubKey_set_a(&this_ptr_conv, val_ref);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_PayeePubKey_1new(JNIEnv *env, jclass clz, int8_tArray a_arg) {
	LDKPublicKey a_arg_ref;
	CHECK((*env)->GetArrayLength(env, a_arg) == 33);
	(*env)->GetByteArrayRegion(env, a_arg, 0, 33, a_arg_ref.compressed_form);
	LDKPayeePubKey ret_var = PayeePubKey_new(a_arg_ref);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_PayeePubKey_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKPayeePubKey orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKPayeePubKey ret_var = PayeePubKey_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_PayeePubKey_1hash(JNIEnv *env, jclass clz, int64_t o) {
	LDKPayeePubKey o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = false;
	int64_t ret_val = PayeePubKey_hash(&o_conv);
	return ret_val;
}

JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_PayeePubKey_1eq(JNIEnv *env, jclass clz, int64_t a, int64_t b) {
	LDKPayeePubKey a_conv;
	a_conv.inner = (void*)(a & (~1));
	a_conv.is_owned = false;
	LDKPayeePubKey b_conv;
	b_conv.inner = (void*)(b & (~1));
	b_conv.is_owned = false;
	jboolean ret_val = PayeePubKey_eq(&a_conv, &b_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_ExpiryTime_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKExpiryTime this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	ExpiryTime_free(this_obj_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ExpiryTime_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKExpiryTime orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKExpiryTime ret_var = ExpiryTime_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ExpiryTime_1hash(JNIEnv *env, jclass clz, int64_t o) {
	LDKExpiryTime o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = false;
	int64_t ret_val = ExpiryTime_hash(&o_conv);
	return ret_val;
}

JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_ExpiryTime_1eq(JNIEnv *env, jclass clz, int64_t a, int64_t b) {
	LDKExpiryTime a_conv;
	a_conv.inner = (void*)(a & (~1));
	a_conv.is_owned = false;
	LDKExpiryTime b_conv;
	b_conv.inner = (void*)(b & (~1));
	b_conv.is_owned = false;
	jboolean ret_val = ExpiryTime_eq(&a_conv, &b_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_MinFinalCltvExpiry_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKMinFinalCltvExpiry this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	MinFinalCltvExpiry_free(this_obj_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_MinFinalCltvExpiry_1get_1a(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKMinFinalCltvExpiry this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int64_t ret_val = MinFinalCltvExpiry_get_a(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_MinFinalCltvExpiry_1set_1a(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKMinFinalCltvExpiry this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	MinFinalCltvExpiry_set_a(&this_ptr_conv, val);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_MinFinalCltvExpiry_1new(JNIEnv *env, jclass clz, int64_t a_arg) {
	LDKMinFinalCltvExpiry ret_var = MinFinalCltvExpiry_new(a_arg);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_MinFinalCltvExpiry_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKMinFinalCltvExpiry orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKMinFinalCltvExpiry ret_var = MinFinalCltvExpiry_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_MinFinalCltvExpiry_1hash(JNIEnv *env, jclass clz, int64_t o) {
	LDKMinFinalCltvExpiry o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = false;
	int64_t ret_val = MinFinalCltvExpiry_hash(&o_conv);
	return ret_val;
}

JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_MinFinalCltvExpiry_1eq(JNIEnv *env, jclass clz, int64_t a, int64_t b) {
	LDKMinFinalCltvExpiry a_conv;
	a_conv.inner = (void*)(a & (~1));
	a_conv.is_owned = false;
	LDKMinFinalCltvExpiry b_conv;
	b_conv.inner = (void*)(b & (~1));
	b_conv.is_owned = false;
	jboolean ret_val = MinFinalCltvExpiry_eq(&a_conv, &b_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_Fallback_1free(JNIEnv *env, jclass clz, int64_t this_ptr) {
	if ((this_ptr & 1) != 0) return;
	void* this_ptr_ptr = (void*)(((uint64_t)this_ptr) & ~1);
	CHECK_ACCESS(this_ptr_ptr);
	LDKFallback this_ptr_conv = *(LDKFallback*)(this_ptr_ptr);
	FREE((void*)this_ptr);
	Fallback_free(this_ptr_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_Fallback_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKFallback* orig_conv = (LDKFallback*)orig;
	LDKFallback *ret_copy = MALLOC(sizeof(LDKFallback), "LDKFallback");
	*ret_copy = Fallback_clone(orig_conv);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_Fallback_1seg_1wit_1program(JNIEnv *env, jclass clz, int8_t version, int8_tArray program) {
	
	LDKCVec_u8Z program_ref;
	program_ref.datalen = (*env)->GetArrayLength(env, program);
	program_ref.data = MALLOC(program_ref.datalen, "LDKCVec_u8Z Bytes");
	(*env)->GetByteArrayRegion(env, program, 0, program_ref.datalen, program_ref.data);
	LDKFallback *ret_copy = MALLOC(sizeof(LDKFallback), "LDKFallback");
	*ret_copy = Fallback_seg_wit_program((LDKu5){ ._0 = version }, program_ref);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_Fallback_1pub_1key_1hash(JNIEnv *env, jclass clz, int8_tArray a) {
	LDKTwentyBytes a_ref;
	CHECK((*env)->GetArrayLength(env, a) == 20);
	(*env)->GetByteArrayRegion(env, a, 0, 20, a_ref.data);
	LDKFallback *ret_copy = MALLOC(sizeof(LDKFallback), "LDKFallback");
	*ret_copy = Fallback_pub_key_hash(a_ref);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_Fallback_1script_1hash(JNIEnv *env, jclass clz, int8_tArray a) {
	LDKTwentyBytes a_ref;
	CHECK((*env)->GetArrayLength(env, a) == 20);
	(*env)->GetByteArrayRegion(env, a, 0, 20, a_ref.data);
	LDKFallback *ret_copy = MALLOC(sizeof(LDKFallback), "LDKFallback");
	*ret_copy = Fallback_script_hash(a_ref);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_Fallback_1hash(JNIEnv *env, jclass clz, int64_t o) {
	LDKFallback* o_conv = (LDKFallback*)o;
	int64_t ret_val = Fallback_hash(o_conv);
	return ret_val;
}

JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_Fallback_1eq(JNIEnv *env, jclass clz, int64_t a, int64_t b) {
	LDKFallback* a_conv = (LDKFallback*)a;
	LDKFallback* b_conv = (LDKFallback*)b;
	jboolean ret_val = Fallback_eq(a_conv, b_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_InvoiceSignature_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKInvoiceSignature this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	InvoiceSignature_free(this_obj_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_InvoiceSignature_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKInvoiceSignature orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKInvoiceSignature ret_var = InvoiceSignature_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_InvoiceSignature_1eq(JNIEnv *env, jclass clz, int64_t a, int64_t b) {
	LDKInvoiceSignature a_conv;
	a_conv.inner = (void*)(a & (~1));
	a_conv.is_owned = false;
	LDKInvoiceSignature b_conv;
	b_conv.inner = (void*)(b & (~1));
	b_conv.is_owned = false;
	jboolean ret_val = InvoiceSignature_eq(&a_conv, &b_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_PrivateRoute_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKPrivateRoute this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	PrivateRoute_free(this_obj_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_PrivateRoute_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKPrivateRoute orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKPrivateRoute ret_var = PrivateRoute_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_PrivateRoute_1hash(JNIEnv *env, jclass clz, int64_t o) {
	LDKPrivateRoute o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = false;
	int64_t ret_val = PrivateRoute_hash(&o_conv);
	return ret_val;
}

JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_PrivateRoute_1eq(JNIEnv *env, jclass clz, int64_t a, int64_t b) {
	LDKPrivateRoute a_conv;
	a_conv.inner = (void*)(a & (~1));
	a_conv.is_owned = false;
	LDKPrivateRoute b_conv;
	b_conv.inner = (void*)(b & (~1));
	b_conv.is_owned = false;
	jboolean ret_val = PrivateRoute_eq(&a_conv, &b_conv);
	return ret_val;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_SignedRawInvoice_1into_1parts(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKSignedRawInvoice this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = (this_arg & 1) || (this_arg == 0);
	this_arg_conv = SignedRawInvoice_clone(&this_arg_conv);
	LDKC3Tuple_RawInvoice_u832InvoiceSignatureZ* ret_conv = MALLOC(sizeof(LDKC3Tuple_RawInvoice_u832InvoiceSignatureZ), "LDKC3Tuple_RawInvoice_u832InvoiceSignatureZ");
	*ret_conv = SignedRawInvoice_into_parts(this_arg_conv);
	return ((uint64_t)ret_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_SignedRawInvoice_1raw_1invoice(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKSignedRawInvoice this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKRawInvoice ret_var = SignedRawInvoice_raw_invoice(&this_arg_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_SignedRawInvoice_1hash(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKSignedRawInvoice this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 32);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 32, *SignedRawInvoice_hash(&this_arg_conv));
	return ret_arr;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_SignedRawInvoice_1signature(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKSignedRawInvoice this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKInvoiceSignature ret_var = SignedRawInvoice_signature(&this_arg_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_SignedRawInvoice_1recover_1payee_1pub_1key(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKSignedRawInvoice this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKCResult_PayeePubKeyErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_PayeePubKeyErrorZ), "LDKCResult_PayeePubKeyErrorZ");
	*ret_conv = SignedRawInvoice_recover_payee_pub_key(&this_arg_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_SignedRawInvoice_1check_1signature(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKSignedRawInvoice this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	jboolean ret_val = SignedRawInvoice_check_signature(&this_arg_conv);
	return ret_val;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_RawInvoice_1hash(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKRawInvoice this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 32);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 32, RawInvoice_hash(&this_arg_conv).data);
	return ret_arr;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_RawInvoice_1payment_1hash(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKRawInvoice this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKSha256 ret_var = RawInvoice_payment_hash(&this_arg_conv);
	uint64_t ret_ref = 0;
	if ((uint64_t)ret_var.inner > 4096) {
		CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
		CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
		ret_ref = (uint64_t)ret_var.inner;
		if (ret_var.is_owned) {
			ret_ref |= 1;
		}
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_RawInvoice_1description(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKRawInvoice this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKDescription ret_var = RawInvoice_description(&this_arg_conv);
	uint64_t ret_ref = 0;
	if ((uint64_t)ret_var.inner > 4096) {
		CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
		CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
		ret_ref = (uint64_t)ret_var.inner;
		if (ret_var.is_owned) {
			ret_ref |= 1;
		}
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_RawInvoice_1payee_1pub_1key(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKRawInvoice this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKPayeePubKey ret_var = RawInvoice_payee_pub_key(&this_arg_conv);
	uint64_t ret_ref = 0;
	if ((uint64_t)ret_var.inner > 4096) {
		CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
		CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
		ret_ref = (uint64_t)ret_var.inner;
		if (ret_var.is_owned) {
			ret_ref |= 1;
		}
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_RawInvoice_1description_1hash(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKRawInvoice this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKSha256 ret_var = RawInvoice_description_hash(&this_arg_conv);
	uint64_t ret_ref = 0;
	if ((uint64_t)ret_var.inner > 4096) {
		CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
		CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
		ret_ref = (uint64_t)ret_var.inner;
		if (ret_var.is_owned) {
			ret_ref |= 1;
		}
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_RawInvoice_1expiry_1time(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKRawInvoice this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKExpiryTime ret_var = RawInvoice_expiry_time(&this_arg_conv);
	uint64_t ret_ref = 0;
	if ((uint64_t)ret_var.inner > 4096) {
		CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
		CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
		ret_ref = (uint64_t)ret_var.inner;
		if (ret_var.is_owned) {
			ret_ref |= 1;
		}
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_RawInvoice_1min_1final_1cltv_1expiry(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKRawInvoice this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKMinFinalCltvExpiry ret_var = RawInvoice_min_final_cltv_expiry(&this_arg_conv);
	uint64_t ret_ref = 0;
	if ((uint64_t)ret_var.inner > 4096) {
		CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
		CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
		ret_ref = (uint64_t)ret_var.inner;
		if (ret_var.is_owned) {
			ret_ref |= 1;
		}
	}
	return ret_ref;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_RawInvoice_1payment_1secret(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKRawInvoice this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 32);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 32, RawInvoice_payment_secret(&this_arg_conv).data);
	return ret_arr;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_RawInvoice_1features(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKRawInvoice this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKInvoiceFeatures ret_var = RawInvoice_features(&this_arg_conv);
	uint64_t ret_ref = 0;
	if ((uint64_t)ret_var.inner > 4096) {
		CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
		CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
		ret_ref = (uint64_t)ret_var.inner;
		if (ret_var.is_owned) {
			ret_ref |= 1;
		}
	}
	return ret_ref;
}

JNIEXPORT int64_tArray JNICALL Java_org_ldk_impl_bindings_RawInvoice_1private_1routes(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKRawInvoice this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKCVec_PrivateRouteZ ret_var = RawInvoice_private_routes(&this_arg_conv);
	int64_tArray ret_arr = NULL;
	ret_arr = (*env)->NewLongArray(env, ret_var.datalen);
	int64_t *ret_arr_ptr = (*env)->GetPrimitiveArrayCritical(env, ret_arr, NULL);
	for (size_t o = 0; o < ret_var.datalen; o++) {
		LDKPrivateRoute ret_conv_14_var = ret_var.data[o];
		uint64_t ret_conv_14_ref = 0;
		CHECK((((uint64_t)ret_conv_14_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
		CHECK((((uint64_t)&ret_conv_14_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
		ret_conv_14_ref = (uint64_t)ret_conv_14_var.inner;
		if (ret_conv_14_var.is_owned) {
			ret_conv_14_ref |= 1;
		}
		ret_arr_ptr[o] = ret_conv_14_ref;
	}
	(*env)->ReleasePrimitiveArrayCritical(env, ret_arr, ret_arr_ptr, 0);
	FREE(ret_var.data);
	return ret_arr;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_RawInvoice_1amount_1pico_1btc(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKRawInvoice this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKCOption_u64Z *ret_copy = MALLOC(sizeof(LDKCOption_u64Z), "LDKCOption_u64Z");
	*ret_copy = RawInvoice_amount_pico_btc(&this_arg_conv);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT jclass JNICALL Java_org_ldk_impl_bindings_RawInvoice_1currency(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKRawInvoice this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	jclass ret_conv = LDKCurrency_to_java(env, RawInvoice_currency(&this_arg_conv));
	return ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_PositiveTimestamp_1from_1unix_1timestamp(JNIEnv *env, jclass clz, int64_t unix_seconds) {
	LDKCResult_PositiveTimestampCreationErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_PositiveTimestampCreationErrorZ), "LDKCResult_PositiveTimestampCreationErrorZ");
	*ret_conv = PositiveTimestamp_from_unix_timestamp(unix_seconds);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_PositiveTimestamp_1from_1system_1time(JNIEnv *env, jclass clz, int64_t time) {
	LDKCResult_PositiveTimestampCreationErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_PositiveTimestampCreationErrorZ), "LDKCResult_PositiveTimestampCreationErrorZ");
	*ret_conv = PositiveTimestamp_from_system_time(time);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_PositiveTimestamp_1as_1unix_1timestamp(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKPositiveTimestamp this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	int64_t ret_val = PositiveTimestamp_as_unix_timestamp(&this_arg_conv);
	return ret_val;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_PositiveTimestamp_1as_1time(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKPositiveTimestamp this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	int64_t ret_val = PositiveTimestamp_as_time(&this_arg_conv);
	return ret_val;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_Invoice_1into_1signed_1raw(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKInvoice this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = (this_arg & 1) || (this_arg == 0);
	this_arg_conv = Invoice_clone(&this_arg_conv);
	LDKSignedRawInvoice ret_var = Invoice_into_signed_raw(this_arg_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_Invoice_1check_1signature(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKInvoice this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKCResult_NoneSemanticErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_NoneSemanticErrorZ), "LDKCResult_NoneSemanticErrorZ");
	*ret_conv = Invoice_check_signature(&this_arg_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_Invoice_1from_1signed(JNIEnv *env, jclass clz, int64_t signed_invoice) {
	LDKSignedRawInvoice signed_invoice_conv;
	signed_invoice_conv.inner = (void*)(signed_invoice & (~1));
	signed_invoice_conv.is_owned = (signed_invoice & 1) || (signed_invoice == 0);
	signed_invoice_conv = SignedRawInvoice_clone(&signed_invoice_conv);
	LDKCResult_InvoiceSemanticErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_InvoiceSemanticErrorZ), "LDKCResult_InvoiceSemanticErrorZ");
	*ret_conv = Invoice_from_signed(signed_invoice_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_Invoice_1timestamp(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKInvoice this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	int64_t ret_val = Invoice_timestamp(&this_arg_conv);
	return ret_val;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_Invoice_1payment_1hash(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKInvoice this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 32);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 32, *Invoice_payment_hash(&this_arg_conv));
	return ret_arr;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_Invoice_1payee_1pub_1key(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKInvoice this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 33);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 33, Invoice_payee_pub_key(&this_arg_conv).compressed_form);
	return ret_arr;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_Invoice_1payment_1secret(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKInvoice this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 32);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 32, *Invoice_payment_secret(&this_arg_conv));
	return ret_arr;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_Invoice_1features(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKInvoice this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKInvoiceFeatures ret_var = Invoice_features(&this_arg_conv);
	uint64_t ret_ref = 0;
	if ((uint64_t)ret_var.inner > 4096) {
		CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
		CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
		ret_ref = (uint64_t)ret_var.inner;
		if (ret_var.is_owned) {
			ret_ref |= 1;
		}
	}
	return ret_ref;
}

JNIEXPORT int8_tArray JNICALL Java_org_ldk_impl_bindings_Invoice_1recover_1payee_1pub_1key(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKInvoice this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	int8_tArray ret_arr = (*env)->NewByteArray(env, 33);
	(*env)->SetByteArrayRegion(env, ret_arr, 0, 33, Invoice_recover_payee_pub_key(&this_arg_conv).compressed_form);
	return ret_arr;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_Invoice_1expiry_1time(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKInvoice this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	int64_t ret_val = Invoice_expiry_time(&this_arg_conv);
	return ret_val;
}

JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_Invoice_1is_1expired(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKInvoice this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	jboolean ret_val = Invoice_is_expired(&this_arg_conv);
	return ret_val;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_Invoice_1min_1final_1cltv_1expiry(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKInvoice this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	int64_t ret_val = Invoice_min_final_cltv_expiry(&this_arg_conv);
	return ret_val;
}

JNIEXPORT int64_tArray JNICALL Java_org_ldk_impl_bindings_Invoice_1private_1routes(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKInvoice this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKCVec_PrivateRouteZ ret_var = Invoice_private_routes(&this_arg_conv);
	int64_tArray ret_arr = NULL;
	ret_arr = (*env)->NewLongArray(env, ret_var.datalen);
	int64_t *ret_arr_ptr = (*env)->GetPrimitiveArrayCritical(env, ret_arr, NULL);
	for (size_t o = 0; o < ret_var.datalen; o++) {
		LDKPrivateRoute ret_conv_14_var = ret_var.data[o];
		uint64_t ret_conv_14_ref = 0;
		CHECK((((uint64_t)ret_conv_14_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
		CHECK((((uint64_t)&ret_conv_14_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
		ret_conv_14_ref = (uint64_t)ret_conv_14_var.inner;
		if (ret_conv_14_var.is_owned) {
			ret_conv_14_ref |= 1;
		}
		ret_arr_ptr[o] = ret_conv_14_ref;
	}
	(*env)->ReleasePrimitiveArrayCritical(env, ret_arr, ret_arr_ptr, 0);
	FREE(ret_var.data);
	return ret_arr;
}

JNIEXPORT int64_tArray JNICALL Java_org_ldk_impl_bindings_Invoice_1route_1hints(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKInvoice this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKCVec_RouteHintZ ret_var = Invoice_route_hints(&this_arg_conv);
	int64_tArray ret_arr = NULL;
	ret_arr = (*env)->NewLongArray(env, ret_var.datalen);
	int64_t *ret_arr_ptr = (*env)->GetPrimitiveArrayCritical(env, ret_arr, NULL);
	for (size_t l = 0; l < ret_var.datalen; l++) {
		LDKRouteHint ret_conv_11_var = ret_var.data[l];
		uint64_t ret_conv_11_ref = 0;
		CHECK((((uint64_t)ret_conv_11_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
		CHECK((((uint64_t)&ret_conv_11_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
		ret_conv_11_ref = (uint64_t)ret_conv_11_var.inner;
		if (ret_conv_11_var.is_owned) {
			ret_conv_11_ref |= 1;
		}
		ret_arr_ptr[l] = ret_conv_11_ref;
	}
	(*env)->ReleasePrimitiveArrayCritical(env, ret_arr, ret_arr_ptr, 0);
	FREE(ret_var.data);
	return ret_arr;
}

JNIEXPORT jclass JNICALL Java_org_ldk_impl_bindings_Invoice_1currency(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKInvoice this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	jclass ret_conv = LDKCurrency_to_java(env, Invoice_currency(&this_arg_conv));
	return ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_Invoice_1amount_1milli_1satoshis(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKInvoice this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKCOption_u64Z *ret_copy = MALLOC(sizeof(LDKCOption_u64Z), "LDKCOption_u64Z");
	*ret_copy = Invoice_amount_milli_satoshis(&this_arg_conv);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_Description_1new(JNIEnv *env, jclass clz, jstring description) {
	LDKStr description_conv = java_to_owned_str(env, description);
	LDKCResult_DescriptionCreationErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_DescriptionCreationErrorZ), "LDKCResult_DescriptionCreationErrorZ");
	*ret_conv = Description_new(description_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT jstring JNICALL Java_org_ldk_impl_bindings_Description_1into_1inner(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKDescription this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = (this_arg & 1) || (this_arg == 0);
	this_arg_conv = Description_clone(&this_arg_conv);
	LDKStr ret_str = Description_into_inner(this_arg_conv);
	jstring ret_conv = str_ref_to_java(env, ret_str.chars, ret_str.len);
	Str_free(ret_str);
	return ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ExpiryTime_1from_1seconds(JNIEnv *env, jclass clz, int64_t seconds) {
	LDKCResult_ExpiryTimeCreationErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_ExpiryTimeCreationErrorZ), "LDKCResult_ExpiryTimeCreationErrorZ");
	*ret_conv = ExpiryTime_from_seconds(seconds);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ExpiryTime_1from_1duration(JNIEnv *env, jclass clz, int64_t duration) {
	LDKCResult_ExpiryTimeCreationErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_ExpiryTimeCreationErrorZ), "LDKCResult_ExpiryTimeCreationErrorZ");
	*ret_conv = ExpiryTime_from_duration(duration);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ExpiryTime_1as_1seconds(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKExpiryTime this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	int64_t ret_val = ExpiryTime_as_seconds(&this_arg_conv);
	return ret_val;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ExpiryTime_1as_1duration(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKExpiryTime this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	int64_t ret_val = ExpiryTime_as_duration(&this_arg_conv);
	return ret_val;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_PrivateRoute_1new(JNIEnv *env, jclass clz, int64_t hops) {
	LDKRouteHint hops_conv;
	hops_conv.inner = (void*)(hops & (~1));
	hops_conv.is_owned = (hops & 1) || (hops == 0);
	hops_conv = RouteHint_clone(&hops_conv);
	LDKCResult_PrivateRouteCreationErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_PrivateRouteCreationErrorZ), "LDKCResult_PrivateRouteCreationErrorZ");
	*ret_conv = PrivateRoute_new(hops_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_PrivateRoute_1into_1inner(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKPrivateRoute this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = (this_arg & 1) || (this_arg == 0);
	this_arg_conv = PrivateRoute_clone(&this_arg_conv);
	LDKRouteHint ret_var = PrivateRoute_into_inner(this_arg_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT jclass JNICALL Java_org_ldk_impl_bindings_CreationError_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKCreationError* orig_conv = (LDKCreationError*)(orig & ~1);
	jclass ret_conv = LDKCreationError_to_java(env, CreationError_clone(orig_conv));
	return ret_conv;
}

JNIEXPORT jclass JNICALL Java_org_ldk_impl_bindings_CreationError_1description_1too_1long(JNIEnv *env, jclass clz) {
	jclass ret_conv = LDKCreationError_to_java(env, CreationError_description_too_long());
	return ret_conv;
}

JNIEXPORT jclass JNICALL Java_org_ldk_impl_bindings_CreationError_1route_1too_1long(JNIEnv *env, jclass clz) {
	jclass ret_conv = LDKCreationError_to_java(env, CreationError_route_too_long());
	return ret_conv;
}

JNIEXPORT jclass JNICALL Java_org_ldk_impl_bindings_CreationError_1timestamp_1out_1of_1bounds(JNIEnv *env, jclass clz) {
	jclass ret_conv = LDKCreationError_to_java(env, CreationError_timestamp_out_of_bounds());
	return ret_conv;
}

JNIEXPORT jclass JNICALL Java_org_ldk_impl_bindings_CreationError_1expiry_1time_1out_1of_1bounds(JNIEnv *env, jclass clz) {
	jclass ret_conv = LDKCreationError_to_java(env, CreationError_expiry_time_out_of_bounds());
	return ret_conv;
}

JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_CreationError_1eq(JNIEnv *env, jclass clz, int64_t a, int64_t b) {
	LDKCreationError* a_conv = (LDKCreationError*)(a & ~1);
	LDKCreationError* b_conv = (LDKCreationError*)(b & ~1);
	jboolean ret_val = CreationError_eq(a_conv, b_conv);
	return ret_val;
}

JNIEXPORT jstring JNICALL Java_org_ldk_impl_bindings_CreationError_1to_1str(JNIEnv *env, jclass clz, int64_t o) {
	LDKCreationError* o_conv = (LDKCreationError*)(o & ~1);
	LDKStr ret_str = CreationError_to_str(o_conv);
	jstring ret_conv = str_ref_to_java(env, ret_str.chars, ret_str.len);
	Str_free(ret_str);
	return ret_conv;
}

JNIEXPORT jclass JNICALL Java_org_ldk_impl_bindings_SemanticError_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKSemanticError* orig_conv = (LDKSemanticError*)(orig & ~1);
	jclass ret_conv = LDKSemanticError_to_java(env, SemanticError_clone(orig_conv));
	return ret_conv;
}

JNIEXPORT jclass JNICALL Java_org_ldk_impl_bindings_SemanticError_1no_1payment_1hash(JNIEnv *env, jclass clz) {
	jclass ret_conv = LDKSemanticError_to_java(env, SemanticError_no_payment_hash());
	return ret_conv;
}

JNIEXPORT jclass JNICALL Java_org_ldk_impl_bindings_SemanticError_1multiple_1payment_1hashes(JNIEnv *env, jclass clz) {
	jclass ret_conv = LDKSemanticError_to_java(env, SemanticError_multiple_payment_hashes());
	return ret_conv;
}

JNIEXPORT jclass JNICALL Java_org_ldk_impl_bindings_SemanticError_1no_1description(JNIEnv *env, jclass clz) {
	jclass ret_conv = LDKSemanticError_to_java(env, SemanticError_no_description());
	return ret_conv;
}

JNIEXPORT jclass JNICALL Java_org_ldk_impl_bindings_SemanticError_1multiple_1descriptions(JNIEnv *env, jclass clz) {
	jclass ret_conv = LDKSemanticError_to_java(env, SemanticError_multiple_descriptions());
	return ret_conv;
}

JNIEXPORT jclass JNICALL Java_org_ldk_impl_bindings_SemanticError_1no_1payment_1secret(JNIEnv *env, jclass clz) {
	jclass ret_conv = LDKSemanticError_to_java(env, SemanticError_no_payment_secret());
	return ret_conv;
}

JNIEXPORT jclass JNICALL Java_org_ldk_impl_bindings_SemanticError_1multiple_1payment_1secrets(JNIEnv *env, jclass clz) {
	jclass ret_conv = LDKSemanticError_to_java(env, SemanticError_multiple_payment_secrets());
	return ret_conv;
}

JNIEXPORT jclass JNICALL Java_org_ldk_impl_bindings_SemanticError_1invalid_1features(JNIEnv *env, jclass clz) {
	jclass ret_conv = LDKSemanticError_to_java(env, SemanticError_invalid_features());
	return ret_conv;
}

JNIEXPORT jclass JNICALL Java_org_ldk_impl_bindings_SemanticError_1invalid_1recovery_1id(JNIEnv *env, jclass clz) {
	jclass ret_conv = LDKSemanticError_to_java(env, SemanticError_invalid_recovery_id());
	return ret_conv;
}

JNIEXPORT jclass JNICALL Java_org_ldk_impl_bindings_SemanticError_1invalid_1signature(JNIEnv *env, jclass clz) {
	jclass ret_conv = LDKSemanticError_to_java(env, SemanticError_invalid_signature());
	return ret_conv;
}

JNIEXPORT jclass JNICALL Java_org_ldk_impl_bindings_SemanticError_1imprecise_1amount(JNIEnv *env, jclass clz) {
	jclass ret_conv = LDKSemanticError_to_java(env, SemanticError_imprecise_amount());
	return ret_conv;
}

JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_SemanticError_1eq(JNIEnv *env, jclass clz, int64_t a, int64_t b) {
	LDKSemanticError* a_conv = (LDKSemanticError*)(a & ~1);
	LDKSemanticError* b_conv = (LDKSemanticError*)(b & ~1);
	jboolean ret_val = SemanticError_eq(a_conv, b_conv);
	return ret_val;
}

JNIEXPORT jstring JNICALL Java_org_ldk_impl_bindings_SemanticError_1to_1str(JNIEnv *env, jclass clz, int64_t o) {
	LDKSemanticError* o_conv = (LDKSemanticError*)(o & ~1);
	LDKStr ret_str = SemanticError_to_str(o_conv);
	jstring ret_conv = str_ref_to_java(env, ret_str.chars, ret_str.len);
	Str_free(ret_str);
	return ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_SignOrCreationError_1free(JNIEnv *env, jclass clz, int64_t this_ptr) {
	if ((this_ptr & 1) != 0) return;
	void* this_ptr_ptr = (void*)(((uint64_t)this_ptr) & ~1);
	CHECK_ACCESS(this_ptr_ptr);
	LDKSignOrCreationError this_ptr_conv = *(LDKSignOrCreationError*)(this_ptr_ptr);
	FREE((void*)this_ptr);
	SignOrCreationError_free(this_ptr_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_SignOrCreationError_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKSignOrCreationError* orig_conv = (LDKSignOrCreationError*)orig;
	LDKSignOrCreationError *ret_copy = MALLOC(sizeof(LDKSignOrCreationError), "LDKSignOrCreationError");
	*ret_copy = SignOrCreationError_clone(orig_conv);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_SignOrCreationError_1sign_1error(JNIEnv *env, jclass clz) {
	LDKSignOrCreationError *ret_copy = MALLOC(sizeof(LDKSignOrCreationError), "LDKSignOrCreationError");
	*ret_copy = SignOrCreationError_sign_error();
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_SignOrCreationError_1creation_1error(JNIEnv *env, jclass clz, jclass a) {
	LDKCreationError a_conv = LDKCreationError_from_java(env, a);
	LDKSignOrCreationError *ret_copy = MALLOC(sizeof(LDKSignOrCreationError), "LDKSignOrCreationError");
	*ret_copy = SignOrCreationError_creation_error(a_conv);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_SignOrCreationError_1eq(JNIEnv *env, jclass clz, int64_t a, int64_t b) {
	LDKSignOrCreationError* a_conv = (LDKSignOrCreationError*)a;
	LDKSignOrCreationError* b_conv = (LDKSignOrCreationError*)b;
	jboolean ret_val = SignOrCreationError_eq(a_conv, b_conv);
	return ret_val;
}

JNIEXPORT jstring JNICALL Java_org_ldk_impl_bindings_SignOrCreationError_1to_1str(JNIEnv *env, jclass clz, int64_t o) {
	LDKSignOrCreationError* o_conv = (LDKSignOrCreationError*)o;
	LDKStr ret_str = SignOrCreationError_to_str(o_conv);
	jstring ret_conv = str_ref_to_java(env, ret_str.chars, ret_str.len);
	Str_free(ret_str);
	return ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_InvoicePayer_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKInvoicePayer this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	InvoicePayer_free(this_obj_conv);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_Payer_1free(JNIEnv *env, jclass clz, int64_t this_ptr) {
	if ((this_ptr & 1) != 0) return;
	void* this_ptr_ptr = (void*)(((uint64_t)this_ptr) & ~1);
	CHECK_ACCESS(this_ptr_ptr);
	LDKPayer this_ptr_conv = *(LDKPayer*)(this_ptr_ptr);
	FREE((void*)this_ptr);
	Payer_free(this_ptr_conv);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_Router_1free(JNIEnv *env, jclass clz, int64_t this_ptr) {
	if ((this_ptr & 1) != 0) return;
	void* this_ptr_ptr = (void*)(((uint64_t)this_ptr) & ~1);
	CHECK_ACCESS(this_ptr_ptr);
	LDKRouter this_ptr_conv = *(LDKRouter*)(this_ptr_ptr);
	FREE((void*)this_ptr);
	Router_free(this_ptr_conv);
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_RetryAttempts_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKRetryAttempts this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	RetryAttempts_free(this_obj_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_RetryAttempts_1get_1a(JNIEnv *env, jclass clz, int64_t this_ptr) {
	LDKRetryAttempts this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	int64_t ret_val = RetryAttempts_get_a(&this_ptr_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_RetryAttempts_1set_1a(JNIEnv *env, jclass clz, int64_t this_ptr, int64_t val) {
	LDKRetryAttempts this_ptr_conv;
	this_ptr_conv.inner = (void*)(this_ptr & (~1));
	this_ptr_conv.is_owned = false;
	RetryAttempts_set_a(&this_ptr_conv, val);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_RetryAttempts_1new(JNIEnv *env, jclass clz, int64_t a_arg) {
	LDKRetryAttempts ret_var = RetryAttempts_new(a_arg);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_RetryAttempts_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKRetryAttempts orig_conv;
	orig_conv.inner = (void*)(orig & (~1));
	orig_conv.is_owned = false;
	LDKRetryAttempts ret_var = RetryAttempts_clone(&orig_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT jboolean JNICALL Java_org_ldk_impl_bindings_RetryAttempts_1eq(JNIEnv *env, jclass clz, int64_t a, int64_t b) {
	LDKRetryAttempts a_conv;
	a_conv.inner = (void*)(a & (~1));
	a_conv.is_owned = false;
	LDKRetryAttempts b_conv;
	b_conv.inner = (void*)(b & (~1));
	b_conv.is_owned = false;
	jboolean ret_val = RetryAttempts_eq(&a_conv, &b_conv);
	return ret_val;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_RetryAttempts_1hash(JNIEnv *env, jclass clz, int64_t o) {
	LDKRetryAttempts o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = false;
	int64_t ret_val = RetryAttempts_hash(&o_conv);
	return ret_val;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_PaymentError_1free(JNIEnv *env, jclass clz, int64_t this_ptr) {
	if ((this_ptr & 1) != 0) return;
	void* this_ptr_ptr = (void*)(((uint64_t)this_ptr) & ~1);
	CHECK_ACCESS(this_ptr_ptr);
	LDKPaymentError this_ptr_conv = *(LDKPaymentError*)(this_ptr_ptr);
	FREE((void*)this_ptr);
	PaymentError_free(this_ptr_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_PaymentError_1clone(JNIEnv *env, jclass clz, int64_t orig) {
	LDKPaymentError* orig_conv = (LDKPaymentError*)orig;
	LDKPaymentError *ret_copy = MALLOC(sizeof(LDKPaymentError), "LDKPaymentError");
	*ret_copy = PaymentError_clone(orig_conv);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_PaymentError_1invoice(JNIEnv *env, jclass clz, jstring a) {
	LDKStr a_conv = java_to_owned_str(env, a);
	LDKPaymentError *ret_copy = MALLOC(sizeof(LDKPaymentError), "LDKPaymentError");
	*ret_copy = PaymentError_invoice(a_conv);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_PaymentError_1routing(JNIEnv *env, jclass clz, int64_t a) {
	LDKLightningError a_conv;
	a_conv.inner = (void*)(a & (~1));
	a_conv.is_owned = (a & 1) || (a == 0);
	a_conv = LightningError_clone(&a_conv);
	LDKPaymentError *ret_copy = MALLOC(sizeof(LDKPaymentError), "LDKPaymentError");
	*ret_copy = PaymentError_routing(a_conv);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_PaymentError_1sending(JNIEnv *env, jclass clz, int64_t a) {
	void* a_ptr = (void*)(((uint64_t)a) & ~1);
	CHECK_ACCESS(a_ptr);
	LDKPaymentSendFailure a_conv = *(LDKPaymentSendFailure*)(a_ptr);
	a_conv = PaymentSendFailure_clone((LDKPaymentSendFailure*)(((uint64_t)a) & ~1));
	LDKPaymentError *ret_copy = MALLOC(sizeof(LDKPaymentError), "LDKPaymentError");
	*ret_copy = PaymentError_sending(a_conv);
	uint64_t ret_ref = (uint64_t)ret_copy;
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_InvoicePayer_1new(JNIEnv *env, jclass clz, int64_t payer, int64_t router, int64_t scorer, int64_t logger, int64_t event_handler, int64_t retry_attempts) {
	void* payer_ptr = (void*)(((uint64_t)payer) & ~1);
	CHECK_ACCESS(payer_ptr);
	LDKPayer payer_conv = *(LDKPayer*)(payer_ptr);
	if (payer_conv.free == LDKPayer_JCalls_free) {
		// If this_arg is a JCalls struct, then we need to increment the refcnt in it.
		LDKPayer_JCalls_cloned(&payer_conv);
	}
	void* router_ptr = (void*)(((uint64_t)router) & ~1);
	CHECK_ACCESS(router_ptr);
	LDKRouter router_conv = *(LDKRouter*)(router_ptr);
	if (router_conv.free == LDKRouter_JCalls_free) {
		// If this_arg is a JCalls struct, then we need to increment the refcnt in it.
		LDKRouter_JCalls_cloned(&router_conv);
	}
	LDKLockableScore scorer_conv;
	scorer_conv.inner = (void*)(scorer & (~1));
	scorer_conv.is_owned = false;
	void* logger_ptr = (void*)(((uint64_t)logger) & ~1);
	CHECK_ACCESS(logger_ptr);
	LDKLogger logger_conv = *(LDKLogger*)(logger_ptr);
	if (logger_conv.free == LDKLogger_JCalls_free) {
		// If this_arg is a JCalls struct, then we need to increment the refcnt in it.
		LDKLogger_JCalls_cloned(&logger_conv);
	}
	void* event_handler_ptr = (void*)(((uint64_t)event_handler) & ~1);
	CHECK_ACCESS(event_handler_ptr);
	LDKEventHandler event_handler_conv = *(LDKEventHandler*)(event_handler_ptr);
	if (event_handler_conv.free == LDKEventHandler_JCalls_free) {
		// If this_arg is a JCalls struct, then we need to increment the refcnt in it.
		LDKEventHandler_JCalls_cloned(&event_handler_conv);
	}
	LDKRetryAttempts retry_attempts_conv;
	retry_attempts_conv.inner = (void*)(retry_attempts & (~1));
	retry_attempts_conv.is_owned = (retry_attempts & 1) || (retry_attempts == 0);
	retry_attempts_conv = RetryAttempts_clone(&retry_attempts_conv);
	LDKInvoicePayer ret_var = InvoicePayer_new(payer_conv, router_conv, &scorer_conv, logger_conv, event_handler_conv, retry_attempts_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_InvoicePayer_1pay_1invoice(JNIEnv *env, jclass clz, int64_t this_arg, int64_t invoice) {
	LDKInvoicePayer this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKInvoice invoice_conv;
	invoice_conv.inner = (void*)(invoice & (~1));
	invoice_conv.is_owned = false;
	LDKCResult_PaymentIdPaymentErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_PaymentIdPaymentErrorZ), "LDKCResult_PaymentIdPaymentErrorZ");
	*ret_conv = InvoicePayer_pay_invoice(&this_arg_conv, &invoice_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_InvoicePayer_1pay_1zero_1value_1invoice(JNIEnv *env, jclass clz, int64_t this_arg, int64_t invoice, int64_t amount_msats) {
	LDKInvoicePayer this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKInvoice invoice_conv;
	invoice_conv.inner = (void*)(invoice & (~1));
	invoice_conv.is_owned = false;
	LDKCResult_PaymentIdPaymentErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_PaymentIdPaymentErrorZ), "LDKCResult_PaymentIdPaymentErrorZ");
	*ret_conv = InvoicePayer_pay_zero_value_invoice(&this_arg_conv, &invoice_conv, amount_msats);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_InvoicePayer_1remove_1cached_1payment(JNIEnv *env, jclass clz, int64_t this_arg, int8_tArray payment_hash) {
	LDKInvoicePayer this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	unsigned char payment_hash_arr[32];
	CHECK((*env)->GetArrayLength(env, payment_hash) == 32);
	(*env)->GetByteArrayRegion(env, payment_hash, 0, 32, payment_hash_arr);
	unsigned char (*payment_hash_ref)[32] = &payment_hash_arr;
	InvoicePayer_remove_cached_payment(&this_arg_conv, payment_hash_ref);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_InvoicePayer_1as_1EventHandler(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKInvoicePayer this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKEventHandler* ret_ret = MALLOC(sizeof(LDKEventHandler), "LDKEventHandler");
	*ret_ret = InvoicePayer_as_EventHandler(&this_arg_conv);
	return (uint64_t)ret_ret;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_create_1invoice_1from_1channelmanager(JNIEnv *env, jclass clz, int64_t channelmanager, int64_t keys_manager, jclass network, int64_t amt_msat, jstring description) {
	LDKChannelManager channelmanager_conv;
	channelmanager_conv.inner = (void*)(channelmanager & (~1));
	channelmanager_conv.is_owned = false;
	void* keys_manager_ptr = (void*)(((uint64_t)keys_manager) & ~1);
	CHECK_ACCESS(keys_manager_ptr);
	LDKKeysInterface keys_manager_conv = *(LDKKeysInterface*)(keys_manager_ptr);
	if (keys_manager_conv.free == LDKKeysInterface_JCalls_free) {
		// If this_arg is a JCalls struct, then we need to increment the refcnt in it.
		LDKKeysInterface_JCalls_cloned(&keys_manager_conv);
	}
	LDKCurrency network_conv = LDKCurrency_from_java(env, network);
	void* amt_msat_ptr = (void*)(((uint64_t)amt_msat) & ~1);
	CHECK_ACCESS(amt_msat_ptr);
	LDKCOption_u64Z amt_msat_conv = *(LDKCOption_u64Z*)(amt_msat_ptr);
	amt_msat_conv = COption_u64Z_clone((LDKCOption_u64Z*)(((uint64_t)amt_msat) & ~1));
	LDKStr description_conv = java_to_owned_str(env, description);
	LDKCResult_InvoiceSignOrCreationErrorZ* ret_conv = MALLOC(sizeof(LDKCResult_InvoiceSignOrCreationErrorZ), "LDKCResult_InvoiceSignOrCreationErrorZ");
	*ret_conv = create_invoice_from_channelmanager(&channelmanager_conv, keys_manager_conv, network_conv, amt_msat_conv, description_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT void JNICALL Java_org_ldk_impl_bindings_DefaultRouter_1free(JNIEnv *env, jclass clz, int64_t this_obj) {
	LDKDefaultRouter this_obj_conv;
	this_obj_conv.inner = (void*)(this_obj & (~1));
	this_obj_conv.is_owned = (this_obj & 1) || (this_obj == 0);
	DefaultRouter_free(this_obj_conv);
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_DefaultRouter_1new(JNIEnv *env, jclass clz, int64_t network_graph, int64_t logger) {
	LDKNetworkGraph network_graph_conv;
	network_graph_conv.inner = (void*)(network_graph & (~1));
	network_graph_conv.is_owned = false;
	void* logger_ptr = (void*)(((uint64_t)logger) & ~1);
	CHECK_ACCESS(logger_ptr);
	LDKLogger logger_conv = *(LDKLogger*)(logger_ptr);
	if (logger_conv.free == LDKLogger_JCalls_free) {
		// If this_arg is a JCalls struct, then we need to increment the refcnt in it.
		LDKLogger_JCalls_cloned(&logger_conv);
	}
	LDKDefaultRouter ret_var = DefaultRouter_new(&network_graph_conv, logger_conv);
	uint64_t ret_ref = 0;
	CHECK((((uint64_t)ret_var.inner) & 1) == 0); // We rely on a free low bit, malloc guarantees this.
	CHECK((((uint64_t)&ret_var) & 1) == 0); // We rely on a free low bit, pointer alignment guarantees this.
	ret_ref = (uint64_t)ret_var.inner;
	if (ret_var.is_owned) {
		ret_ref |= 1;
	}
	return ret_ref;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_DefaultRouter_1as_1Router(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKDefaultRouter this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKRouter* ret_ret = MALLOC(sizeof(LDKRouter), "LDKRouter");
	*ret_ret = DefaultRouter_as_Router(&this_arg_conv);
	return (uint64_t)ret_ret;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_ChannelManager_1as_1Payer(JNIEnv *env, jclass clz, int64_t this_arg) {
	LDKChannelManager this_arg_conv;
	this_arg_conv.inner = (void*)(this_arg & (~1));
	this_arg_conv.is_owned = false;
	LDKPayer* ret_ret = MALLOC(sizeof(LDKPayer), "LDKPayer");
	*ret_ret = ChannelManager_as_Payer(&this_arg_conv);
	return (uint64_t)ret_ret;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_SiPrefix_1from_1str(JNIEnv *env, jclass clz, jstring s) {
	LDKStr s_conv = java_to_owned_str(env, s);
	LDKCResult_SiPrefixNoneZ* ret_conv = MALLOC(sizeof(LDKCResult_SiPrefixNoneZ), "LDKCResult_SiPrefixNoneZ");
	*ret_conv = SiPrefix_from_str(s_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_Invoice_1from_1str(JNIEnv *env, jclass clz, jstring s) {
	LDKStr s_conv = java_to_owned_str(env, s);
	LDKCResult_InvoiceNoneZ* ret_conv = MALLOC(sizeof(LDKCResult_InvoiceNoneZ), "LDKCResult_InvoiceNoneZ");
	*ret_conv = Invoice_from_str(s_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT int64_t JNICALL Java_org_ldk_impl_bindings_SignedRawInvoice_1from_1str(JNIEnv *env, jclass clz, jstring s) {
	LDKStr s_conv = java_to_owned_str(env, s);
	LDKCResult_SignedRawInvoiceNoneZ* ret_conv = MALLOC(sizeof(LDKCResult_SignedRawInvoiceNoneZ), "LDKCResult_SignedRawInvoiceNoneZ");
	*ret_conv = SignedRawInvoice_from_str(s_conv);
	return (uint64_t)ret_conv;
}

JNIEXPORT jstring JNICALL Java_org_ldk_impl_bindings_Invoice_1to_1str(JNIEnv *env, jclass clz, int64_t o) {
	LDKInvoice o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = false;
	LDKStr ret_str = Invoice_to_str(&o_conv);
	jstring ret_conv = str_ref_to_java(env, ret_str.chars, ret_str.len);
	Str_free(ret_str);
	return ret_conv;
}

JNIEXPORT jstring JNICALL Java_org_ldk_impl_bindings_SignedRawInvoice_1to_1str(JNIEnv *env, jclass clz, int64_t o) {
	LDKSignedRawInvoice o_conv;
	o_conv.inner = (void*)(o & (~1));
	o_conv.is_owned = false;
	LDKStr ret_str = SignedRawInvoice_to_str(&o_conv);
	jstring ret_conv = str_ref_to_java(env, ret_str.chars, ret_str.len);
	Str_free(ret_str);
	return ret_conv;
}

JNIEXPORT jstring JNICALL Java_org_ldk_impl_bindings_Currency_1to_1str(JNIEnv *env, jclass clz, int64_t o) {
	LDKCurrency* o_conv = (LDKCurrency*)(o & ~1);
	LDKStr ret_str = Currency_to_str(o_conv);
	jstring ret_conv = str_ref_to_java(env, ret_str.chars, ret_str.len);
	Str_free(ret_str);
	return ret_conv;
}

JNIEXPORT jstring JNICALL Java_org_ldk_impl_bindings_SiPrefix_1to_1str(JNIEnv *env, jclass clz, int64_t o) {
	LDKSiPrefix* o_conv = (LDKSiPrefix*)(o & ~1);
	LDKStr ret_str = SiPrefix_to_str(o_conv);
	jstring ret_conv = str_ref_to_java(env, ret_str.chars, ret_str.len);
	Str_free(ret_str);
	return ret_conv;
}

