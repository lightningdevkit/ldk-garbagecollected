package org.ldk.structs;

import org.ldk.impl.bindings;
import org.ldk.enums.*;
import org.ldk.util.*;
import java.util.Arrays;
import javax.annotation.Nullable;


/**
 * Simple KeysInterface implementor that takes a 32-byte seed for use as a BIP 32 extended key
 * and derives keys from that.
 * 
 * Your node_id is seed/0'
 * ChannelMonitor closes may use seed/1'
 * Cooperative closes may use seed/2'
 * The two close keys may be needed to claim on-chain funds!
 */
@SuppressWarnings("unchecked") // We correctly assign various generic arrays
public class KeysManager extends CommonBase {
	KeysManager(Object _dummy, long ptr) { super(ptr); }
	@Override @SuppressWarnings("deprecation")
	protected void finalize() throws Throwable {
		super.finalize();
		if (ptr != 0) { bindings.KeysManager_free(ptr); }
	}

	/**
	 * Constructs a KeysManager from a 32-byte seed. If the seed is in some way biased (eg your
	 * CSRNG is busted) this may panic (but more importantly, you will possibly lose funds).
	 * starting_time isn't strictly required to actually be a time, but it must absolutely,
	 * without a doubt, be unique to this instance. ie if you start multiple times with the same
	 * seed, starting_time must be unique to each run. Thus, the easiest way to achieve this is to
	 * simply use the current time (with very high precision).
	 * 
	 * The seed MUST be backed up safely prior to use so that the keys can be re-created, however,
	 * obviously, starting_time should be unique every time you reload the library - it is only
	 * used to generate new ephemeral key data (which will be stored by the individual channel if
	 * necessary).
	 * 
	 * Note that the seed is required to recover certain on-chain funds independent of
	 * ChannelMonitor data, though a current copy of ChannelMonitor data is also required for any
	 * channel, and some on-chain during-closing funds.
	 * 
	 * Note that until the 0.1 release there is no guarantee of backward compatibility between
	 * versions. Once the library is more fully supported, the docs will be updated to include a
	 * detailed description of the guarantee.
	 */
	public static KeysManager of(byte[] seed, long starting_time_secs, int starting_time_nanos) {
		long ret = bindings.KeysManager_new(seed, starting_time_secs, starting_time_nanos);
		if (ret >= 0 && ret <= 4096) { return null; }
		KeysManager ret_hu_conv = null; if (ret < 0 || ret > 4096) { ret_hu_conv = new KeysManager(null, ret); }
		ret_hu_conv.ptrs_to.add(ret_hu_conv);
		return ret_hu_conv;
	}

	/**
	 * Derive an old Sign containing per-channel secrets based on a key derivation parameters.
	 * 
	 * Key derivation parameters are accessible through a per-channel secrets
	 * Sign::channel_keys_id and is provided inside DynamicOuputP2WSH in case of
	 * onchain output detection for which a corresponding delayed_payment_key must be derived.
	 */
	public InMemorySigner derive_channel_keys(long channel_value_satoshis, byte[] params) {
		long ret = bindings.KeysManager_derive_channel_keys(this.ptr, channel_value_satoshis, params);
		if (ret >= 0 && ret <= 4096) { return null; }
		InMemorySigner ret_hu_conv = null; if (ret < 0 || ret > 4096) { ret_hu_conv = new InMemorySigner(null, ret); }
		ret_hu_conv.ptrs_to.add(this);
		return ret_hu_conv;
	}

	/**
	 * Creates a Transaction which spends the given descriptors to the given outputs, plus an
	 * output to the given change destination (if sufficient change value remains). The
	 * transaction will have a feerate, at least, of the given value.
	 * 
	 * Returns `Err(())` if the output value is greater than the input value minus required fee or
	 * if a descriptor was duplicated.
	 * 
	 * We do not enforce that outputs meet the dust limit or that any output scripts are standard.
	 * 
	 * May panic if the `SpendableOutputDescriptor`s were not generated by Channels which used
	 * this KeysManager or one of the `InMemorySigner` created by this KeysManager.
	 */
	public Result_TransactionNoneZ spend_spendable_outputs(SpendableOutputDescriptor[] descriptors, TxOut[] outputs, byte[] change_destination_script, int feerate_sat_per_1000_weight) {
		long ret = bindings.KeysManager_spend_spendable_outputs(this.ptr, descriptors != null ? Arrays.stream(descriptors).mapToLong(descriptors_conv_27 -> descriptors_conv_27.ptr).toArray() : null, outputs != null ? Arrays.stream(outputs).mapToLong(outputs_conv_7 -> outputs_conv_7.ptr).toArray() : null, change_destination_script, feerate_sat_per_1000_weight);
		if (ret >= 0 && ret <= 4096) { return null; }
		Result_TransactionNoneZ ret_hu_conv = Result_TransactionNoneZ.constr_from_ptr(ret);
		return ret_hu_conv;
	}

	/**
	 * Constructs a new KeysInterface which calls the relevant methods on this_arg.
	 * This copies the `inner` pointer in this_arg and thus the returned KeysInterface must be freed before this_arg is
	 */
	public KeysInterface as_KeysInterface() {
		long ret = bindings.KeysManager_as_KeysInterface(this.ptr);
		if (ret >= 0 && ret <= 4096) { return null; }
		KeysInterface ret_hu_conv = new KeysInterface(null, ret);
		ret_hu_conv.ptrs_to.add(this);
		return ret_hu_conv;
	}

}
